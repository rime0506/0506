// åŠ¨æ€ç”Ÿæˆ Manifest ä»¥æ”¯æŒå•æ–‡ä»¶ PWA
const manifest = {
    "name": "Insé£æ¡Œé¢",
    "short_name": "Insæ¡Œé¢",
    "start_url": ".",
    "display": "standalone",
    "background_color": "#ffffff",
    "theme_color": "#ffffff",
    "orientation": "portrait",
    "icons": [
        {
            "src": "https://img.heliar.top/file/1769158422909_æ— æ ‡é¢˜281_20251207015501_20260123165317.png",
            "sizes": "192x192",
            "type": "image/png"
        },
        {
            "src": "https://img.heliar.top/file/1769158422909_æ— æ ‡é¢˜281_20251207015501_20260123165317.png",
            "sizes": "512x512",
            "type": "image/png"
        }
    ]
};
const stringManifest = JSON.stringify(manifest);
const blob = new Blob([stringManifest], {type: 'application/manifest+json'});
const manifestURL = URL.createObjectURL(blob);
// ç­‰å¾… DOM åŠ è½½å®Œæˆåå†è®¾ç½® manifest
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', function() {
        const manifestLink = document.querySelector('#manifest-link');
        if (manifestLink) {
            manifestLink.setAttribute('href', manifestURL);
        }
    });
} else {
    const manifestLink = document.querySelector('#manifest-link');
    if (manifestLink) {
        manifestLink.setAttribute('href', manifestURL);
    }
}

// iOS 100vh ä¿®å¤ï¼šåŠ¨æ€è®¡ç®—è§†å£é«˜åº¦
function setVh() {
    // è·å–è§†å£é«˜åº¦ï¼Œä¸åŒ…å«æµè§ˆå™¨ UIï¼ˆå¦‚ Safari åº•éƒ¨æ ï¼‰
    let vh = window.innerHeight + 'px';
    document.documentElement.style.setProperty('--vh', vh);
}
// åˆå§‹åŒ–å¹¶ç›‘å¬ resize
setVh();
window.addEventListener('resize', setVh);

// åˆå§‹åŒ–DEXieæ•°æ®åº“
const db = new Dexie('DesktopDB');
// ç‰ˆæœ¬å‡çº§ï¼šå¢åŠ  lorebooks è¡¨
db.version(1).stores({
    dexiData: 'key, value'
});
db.version(2).stores({
    dexiData: 'key, value',
    lorebooks: '++id, name' // æ–°å¢ä¸–ç•Œä¹¦è¡¨ï¼šidè‡ªå¢ï¼Œnameç´¢å¼•
});
db.version(3).stores({
    dexiData: 'key, value',
    lorebooks: '++id, name',
    characters: '++id, name, type' // æ–°å¢è§’è‰²è¡¨ï¼štype ç”¨äºåŒºåˆ† Char/NPC/User
});
db.version(4).stores({
    dexiData: 'key, value',
    lorebooks: '++id, name',
    characters: '++id, name, type',
    sticker_categories: '++id, name'
});
db.version(5).stores({
    dexiData: 'key, value',
    lorebooks: '++id, name',
    characters: '++id, name, type',
    sticker_categories: '++id, name',
    moments: '++id, userId, time, ownerUserId' // æ–°å¢æœ‹å‹åœˆè¡¨ (ownerUserId ç”¨äºè´¦å·éš”ç¦»)
});
db.version(6).stores({
    dexiData: 'key, value',
    lorebooks: '++id, name',
    characters: '++id, name, type',
    sticker_categories: '++id, name',
    moments: '++id, userId, time, ownerUserId',
    friend_requests: '++id, fromCharId, toAccountId, status, time' // æ–°å¢å¥½å‹ç”³è¯·è¡¨
});
// ç‰ˆæœ¬71ï¼šå…¼å®¹å·²å­˜åœ¨çš„é«˜ç‰ˆæœ¬æ•°æ®åº“
db.version(71).stores({
    dexiData: 'key, value',
    lorebooks: '++id, name',
    characters: '++id, name, type',
    sticker_categories: '++id, name',
    moments: '++id, userId, time, ownerUserId',
    friend_requests: '++id, fromCharId, toAccountId, status, time'
});
// ç‰ˆæœ¬72ï¼šæ·»åŠ ç¾¤èŠè¡¨
db.version(72).stores({
    dexiData: 'key, value',
    lorebooks: '++id, name',
    characters: '++id, name, type',
    sticker_categories: '++id, name',
    moments: '++id, userId, time, ownerUserId',
    friend_requests: '++id, fromCharId, toAccountId, status, time',
    group_chats: '++id, name, ownerAccountId, created_at' // ç¾¤èŠè¡¨ï¼šidè‡ªå¢ï¼Œåç§°ï¼Œåˆ›å»ºè€…è´¦å·IDï¼Œåˆ›å»ºæ—¶é—´
});
// ç‰ˆæœ¬73ï¼šæ·»åŠ ç”µè¯è®°å½•å’ŒçŸ­ä¿¡è®°å½•è¡¨ï¼ˆä»localStorageè¿ç§»åˆ°IndexedDBï¼‰
db.version(73).stores({
    dexiData: 'key, value',
    lorebooks: '++id, name',
    characters: '++id, name, type',
    sticker_categories: '++id, name',
    moments: '++id, userId, time, ownerUserId',
    friend_requests: '++id, fromCharId, toAccountId, status, time',
    group_chats: '++id, name, ownerAccountId, created_at',
    phone_recents: '++id, accountId, charId, time, type', // ç”µè¯è®°å½•ï¼šaccountIdè´¦å·éš”ç¦»ï¼ŒcharIdè§’è‰²IDï¼Œtimeæ—¶é—´ï¼Œtypeç±»å‹(missed/incoming/outgoing)
    sms_messages: '++id, accountId, charId, time, read'   // çŸ­ä¿¡è®°å½•ï¼šaccountIdè´¦å·éš”ç¦»ï¼ŒcharIdè§’è‰²IDï¼Œtimeæ—¶é—´ï¼Œreadæ˜¯å¦å·²è¯»
});
// ç‰ˆæœ¬74ï¼šæ·»åŠ èŠå¤©æ€»ç»“è¡¨ï¼ˆç”¨äºAIè‡ªåŠ¨æ€»ç»“åŠŸèƒ½ï¼‰
db.version(74).stores({
    dexiData: 'key, value',
    lorebooks: '++id, name',
    characters: '++id, name, type',
    sticker_categories: '++id, name',
    moments: '++id, userId, time, ownerUserId',
    friend_requests: '++id, fromCharId, toAccountId, status, time',
    group_chats: '++id, name, ownerAccountId, created_at',
    phone_recents: '++id, accountId, charId, time, type',
    sms_messages: '++id, accountId, charId, time, read',
    chat_summaries: '++id, accountId, chatType, chatId, time' // èŠå¤©æ€»ç»“è¡¨ï¼šaccountIdè´¦å·éš”ç¦»ï¼ŒchatType(private/group)ï¼ŒchatIdè§’è‰²/ç¾¤èŠIDï¼Œtimeæ€»ç»“æ—¶é—´
});

// ğŸ“¦ æ•°æ®è¿ç§»ï¼šå°† localStorage ä¸­çš„ç”µè¯å’ŒçŸ­ä¿¡è®°å½•è¿ç§»åˆ° IndexedDB
async function migratePhoneAndSmsToIndexedDB() {
    const migrationKey = 'phone_sms_migrated_to_indexeddb';
    if (localStorage.getItem(migrationKey) === 'true') {
        return; // å·²ç»è¿ç§»è¿‡
    }
    
    console.log('[Migration] å¼€å§‹è¿ç§»ç”µè¯å’ŒçŸ­ä¿¡è®°å½•åˆ° IndexedDB...');
    
    // è·å–é»˜è®¤è´¦å·ID
    const currentAccountId = localStorage.getItem('current_my_char_id') || '1';
    
    // è¿ç§»ç”µè¯è®°å½•
    try {
        const phoneRecents = JSON.parse(localStorage.getItem('phone_recents') || '[]');
        if (phoneRecents.length > 0) {
            console.log(`[Migration] è¿ç§» ${phoneRecents.length} æ¡ç”µè¯è®°å½•...`);
            for (const record of phoneRecents) {
                await db.phone_recents.add({
                    accountId: currentAccountId,
                    charId: null, // æ—§æ•°æ®æ²¡æœ‰ charId
                    name: record.name,
                    number: record.number,
                    time: record.time || Date.now(),
                    type: record.type || 'missed',
                    isBlocked: record.isBlocked || false
                });
            }
            // æ¸…ç†æ—§æ•°æ®
            localStorage.removeItem('phone_recents');
            console.log('[Migration] âœ… ç”µè¯è®°å½•è¿ç§»å®Œæˆ');
        }
    } catch (e) {
        console.error('[Migration] âŒ ç”µè¯è®°å½•è¿ç§»å¤±è´¥:', e);
    }
    
    // è¿ç§»çŸ­ä¿¡è®°å½•
    try {
        const smsMessages = JSON.parse(localStorage.getItem('sms_messages') || '[]');
        if (smsMessages.length > 0) {
            console.log(`[Migration] è¿ç§» ${smsMessages.length} æ¡çŸ­ä¿¡è®°å½•...`);
            for (const msg of smsMessages) {
                await db.sms_messages.add({
                    accountId: currentAccountId,
                    charId: null, // æ—§æ•°æ®æ²¡æœ‰ charId
                    sender: msg.sender,
                    number: msg.number,
                    content: msg.content || msg.message,
                    time: msg.time || msg.timestamp || Date.now(),
                    read: msg.read !== false,
                    type: msg.type || 'received',
                    isBlocked: msg.isBlocked || false,
                    receiverName: msg.receiverName,
                    receiverId: msg.receiverId
                });
            }
            // æ¸…ç†æ—§æ•°æ®
            localStorage.removeItem('sms_messages');
            console.log('[Migration] âœ… çŸ­ä¿¡è®°å½•è¿ç§»å®Œæˆ');
        }
    } catch (e) {
        console.error('[Migration] âŒ çŸ­ä¿¡è®°å½•è¿ç§»å¤±è´¥:', e);
    }
    
    // æ ‡è®°è¿ç§»å®Œæˆ
    localStorage.setItem(migrationKey, 'true');
    console.log('[Migration] ğŸ‰ ç”µè¯å’ŒçŸ­ä¿¡æ•°æ®è¿ç§»å®Œæˆ');
}

        let currentSelectIcon = '';
        let currentCharacterType = 'char'; // é»˜è®¤ä¸º char
        let editingCharId = null; // å½“å‰ç¼–è¾‘çš„è§’è‰²ID
        let currentChatCharId = null; // å½“å‰èŠå¤©å¯¹è±¡ID
        let currentChatUserId = null; // å½“å‰èŠå¤©ä½¿ç”¨çš„ User ID (ä¸´æ—¶ç¼“å­˜)
        let currentMyCharId = localStorage.getItem('current_my_char_id'); // å½“å‰ç™»å½•çš„â€œæˆ‘â€çš„è§’è‰²ID

        // æ¨¡æ‹Ÿç”¨æˆ·IDï¼Œå®é™…é¡¹ç›®ä¸­å¯èƒ½æ¥è‡ªç™»å½•
        let currentUserId = localStorage.getItem('user_id');
        if (!currentUserId) {
            currentUserId = 'user_' + Math.random().toString(36).substr(2, 9);
            localStorage.setItem('user_id', currentUserId);
        }
        
        // å…¨å±€å®šæ—¶å™¨å˜é‡
        let notifTimer = null;
        let autoChatTimer = null; // ä¸»åŠ¨èŠå¤©å®šæ—¶å™¨
        const autoChatLocks = new Set(); // å­˜å‚¨æ­£åœ¨è¿›è¡Œä¸»åŠ¨èŠå¤©çš„ charIdï¼Œé˜²æ­¢å¹¶å‘è§¦å‘
        // è®°å½•å·²çŸ¥çš„é€šçŸ¥IDï¼Œç”¨äºåˆ¤æ–­æ–°æ¶ˆæ¯
        let knownNotifIds = new Set();
        let isFirstLoad = true;
        // ç¼“å­˜æœ€æ–°ä¸€æ¡é€šçŸ¥ï¼Œç”¨äºå®šæ—¶å¼¹çª—æ–‡æ¡ˆ
        let latestNotification = null;

        // --- èŠå¤©äº¤äº’å…¨å±€å˜é‡ ---
        let longPressTimer = null;
        let isLongPress = false;
        let activeMsgIndex = -1; // å½“å‰æ“ä½œçš„æ¶ˆæ¯ç´¢å¼•
        let isSelectionMode = false;
        let selectedIndices = new Set(); // é€‰ä¸­çš„æ¶ˆæ¯ç´¢å¼•é›†åˆ

        // å…¨å±€å˜é‡ï¼šè¡¨æƒ…åŒ…ç®¡ç†
        let currentStickerCategoryId = null;

        // æ‰‹åŠ¨è§¦å‘æ¨é€è®¢é˜…ï¼ˆæ–°å¢å‡½æ•°ï¼‰
        async function manualSubscribePush() {
            console.log('[Manual] æ‰‹åŠ¨è§¦å‘æ¨é€è®¢é˜…...');
            showDebugToast('æ­£åœ¨æ³¨å†Œæ¨é€...', true);
            
            try {
                await registerServiceWorkerAndSubscribe();
                alert('âœ… æ¨é€è®¢é˜…æˆåŠŸï¼è¯·æŸ¥çœ‹è¯Šæ–­é¢æ¿ç¡®è®¤çŠ¶æ€ã€‚');
            } catch (err) {
                console.error('[Manual] è®¢é˜…å¤±è´¥:', err);
                alert('âŒ è®¢é˜…å¤±è´¥: ' + err.message);
            }
        }

        // é¡µé¢åŠ è½½åˆå§‹åŒ–
        window.onload = async function() {
            await restoreDesktopOrder(); // ä¼˜å…ˆæ¢å¤æ¡Œé¢å›¾æ ‡é¡ºåº
            await restoreSetting(); // å¼‚æ­¥æ¢å¤DEXieæ•°æ®
            await migrateAccountData(); // è¿ç§»è´¦å·éš”ç¦»æ•°æ®
            await migratePhoneAndSmsToIndexedDB(); // è¿ç§»ç”µè¯å’ŒçŸ­ä¿¡è®°å½•åˆ°IndexedDB
            await loadWardrobeCharacter(); // åŠ è½½è¡£æŸœäººç‰©å½¢è±¡
            initDesktopDrag(); // åˆå§‹åŒ–æ¡Œé¢æ‹–æ‹½
            syncPreview();
            
            // è¯·æ±‚é€šçŸ¥æƒé™ï¼ˆå°±åƒä½ ä¹‹å‰çš„ç‰ˆæœ¬ï¼‰
            if ('Notification' in window && Notification.permission === 'default') {
                console.log('[é€šçŸ¥] è¯·æ±‚é€šçŸ¥æƒé™...');
                Notification.requestPermission().then(permission => {
                    console.log('[é€šçŸ¥] æƒé™ç»“æœ:', permission);
                    if (permission === 'granted') {
                        showDebugToast('âœ“ é€šçŸ¥æƒé™å·²æˆäºˆ', true);
                    }
                });
            }
            
            // åˆå§‹åŒ–é€šçŸ¥è®¾ç½®
            const notifEnabled = localStorage.getItem('notification_enabled') === 'true';
            document.getElementById('notif-switch').checked = notifEnabled;
            
            // åˆå§‹åŒ–è°ƒè¯•æ¨¡å¼è®¾ç½®
            const debugEnabled = localStorage.getItem('debug_mode_enabled') === 'true';
            document.getElementById('debug-switch').checked = debugEnabled;
            
            // åˆå§‹åŒ–å¼ºåŠ›ä¿æ´»è®¾ç½®
            const keepaliveEnabled = localStorage.getItem('keepalive_enabled') === 'true';
            document.getElementById('keepalive-switch').checked = keepaliveEnabled;
            
            // å¦‚æœä¿æ´»å·²å¼€å¯ï¼Œç­‰å¾…ç”¨æˆ·äº¤äº’åå¯åŠ¨
            if (keepaliveEnabled) {
                console.log('[Init] ä¿æ´»å·²å¯ç”¨ï¼Œç­‰å¾…ç”¨æˆ·äº¤äº’...');
                document.addEventListener('click', function initKeepAlive() {
                    startKeepAlive();
                    document.removeEventListener('click', initKeepAlive);
                }, { once: true });
            }
            
            // åˆå§‹åŒ–é€šçŸ¥è½®è¯¢ (15ç§’æ£€æŸ¥ï¼Œæ›´å¿«å“åº”åç«¯è§¦å‘)
            if (notifEnabled) {
                startNotificationLoop(15);
            }
            
            // âœ… ä¿®å¤ï¼šé¡µé¢åŠ è½½æ—¶ç«‹å³æ³¨å†Œ Service Worker å’Œè®¢é˜…æ¨é€
            // ä¸å†ç­‰å¾… startAutoChatLoopï¼Œè€Œæ˜¯ç«‹å³æ‰§è¡Œ
            if (location.protocol === 'https:' || location.hostname === 'localhost') {
                console.log('[Init] ç«‹å³æ³¨å†Œ Service Worker å’Œè®¢é˜…æ¨é€...');
                await registerServiceWorkerAndSubscribe();
            } else {
                console.warn('[Init] å½“å‰ç¯å¢ƒä¸æ”¯æŒ Service Worker (éœ€è¦ HTTPS æˆ– localhost)');
            }
            
            // å¯åŠ¨ä¸»åŠ¨èŠå¤©æ£€æµ‹ (æ¯åˆ†é’Ÿä¸€æ¬¡)
            startAutoChatLoop();
            
            // âœ… è‡ªåŠ¨åˆå§‹åŒ–è”æœºç³»ç»Ÿï¼ˆä¸éœ€è¦æ‰‹åŠ¨æ‰“å¼€è®¾ç½®ï¼‰
            initOnlineSystem();
        }

        // --- çº¯å‰ç«¯æ¨¡å¼ï¼šæ‰€æœ‰æ•°æ®å­˜å‚¨åœ¨æœ¬åœ° ---
        // å·²ç§»é™¤åç«¯ä¾èµ–ï¼Œé€šçŸ¥ã€è§’è‰²ã€èŠå¤©è®°å½•å…¨éƒ¨ä½¿ç”¨ IndexedDB å­˜å‚¨
        console.log('[Config] çº¯å‰ç«¯æ¨¡å¼ï¼šæ— éœ€åç«¯æœåŠ¡');
        console.log('[Config] æ‰€æœ‰æ•°æ®å­˜å‚¨åœ¨æœ¬åœ° IndexedDB');

        // å¯åŠ¨è½®è¯¢
        function startNotificationLoop(seconds) {
            if (notifTimer) clearInterval(notifTimer);

            const loopTask = () => {
                fetchNotifications();
            };
            
            console.log(`[Notification] Polling started, checking every ${seconds}s`);
            showDebugToast(`é€šçŸ¥è½®è¯¢: æ¯${seconds}ç§’æ£€æŸ¥`, true);
            
            loopTask(); // ç«‹å³æ‰§è¡Œä¸€æ¬¡
            notifTimer = setInterval(loopTask, seconds * 1000);
        }

        // åˆ‡æ¢é€šçŸ¥æƒé™
        function toggleNotification(checkbox) {
            const enabled = checkbox.checked;
            localStorage.setItem('notification_enabled', enabled);
            if (enabled) {
                // è¯·æ±‚æµè§ˆå™¨ç³»ç»Ÿé€šçŸ¥æƒé™
                if ("Notification" in window) {
                    Notification.requestPermission().then(permission => {
                        if (permission === "granted") {
                            new Notification("ç³»ç»Ÿé€šçŸ¥å·²å¼€å¯", { body: "å³ä½¿åœ¨åå°ï¼Œæ‚¨ä¹Ÿèƒ½æ”¶åˆ°æ–°æ¶ˆæ¯æé†’äº†~" });
                        } else {
                            alert("è¯·åœ¨æµè§ˆå™¨å¼¹çª—ä¸­ç‚¹å‡»ã€å…è®¸ã€‘ï¼Œå¦åˆ™æ— æ³•æ”¶åˆ°ç³»ç»Ÿé€šçŸ¥å“¦ï¼");
                        }
                    });
                }
                startNotificationLoop(15); // 15ç§’æ£€æŸ¥
            } else {
                if (notifTimer) clearInterval(notifTimer);
                document.getElementById('notif-badge').style.display = 'none';
            }
        }

        // æµ‹è¯•é€šçŸ¥åŠŸèƒ½
        function testNotification() {
            console.log('[Test] Testing notification system...');
            console.log('[Test] Browser supports Notification:', "Notification" in window);
            console.log('[Test] Current permission:', Notification.permission);
            console.log('[Test] Page visibility:', document.visibilityState);
            console.log('[Test] Page hidden:', document.hidden);
            
            if (!("Notification" in window)) {
                alert("ä½ çš„æµè§ˆå™¨ä¸æ”¯æŒç³»ç»Ÿé€šçŸ¥åŠŸèƒ½");
                return;
            }
            
            if (Notification.permission === "denied") {
                alert("é€šçŸ¥æƒé™å·²è¢«æ‹’ç»ï¼Œè¯·åœ¨æµè§ˆå™¨è®¾ç½®ä¸­å…è®¸é€šçŸ¥æƒé™ååˆ·æ–°é¡µé¢");
                return;
            }
            
            if (Notification.permission === "granted") {
                // ç«‹å³å‘é€ç¬¬ä¸€æ¡é€šçŸ¥
                new Notification("æµ‹è¯•é€šçŸ¥", {
                    body: "å¦‚æœä½ èƒ½çœ‹åˆ°è¿™æ¡é€šçŸ¥ï¼Œè¯´æ˜ç³»ç»Ÿé€šçŸ¥åŠŸèƒ½æ­£å¸¸ï¼",
                    icon: 'https://img.heliar.top/file/1769158422909_æ— æ ‡é¢˜281_20251207015501_20260123165317.png'
                });
                showDebugToast("âœ“ ç«‹å³å‘é€é€šçŸ¥ï¼5ç§’åå†å‘ä¸€æ¡", true);
                
                // 5ç§’åå‘é€ç¬¬äºŒæ¡é€šçŸ¥
                setTimeout(() => {
                    new Notification("å»¶è¿Ÿæµ‹è¯•é€šçŸ¥", {
                        body: "è¿™æ˜¯5ç§’åå‘é€çš„é€šçŸ¥ï¼Œå¦‚æœåœ¨åå°ä¹Ÿèƒ½æ”¶åˆ°ï¼Œè¯´æ˜åå°æ¨é€æ­£å¸¸ï¼",
                        icon: 'https://img.heliar.top/file/1769158422909_æ— æ ‡é¢˜281_20251207015501_20260123165317.png',
                        tag: 'delayed-test'
                    });
                    showDebugToast("âœ“ 5ç§’å»¶è¿Ÿé€šçŸ¥å·²å‘é€ï¼", true);
                    console.log('[Test] 5ç§’å»¶è¿Ÿé€šçŸ¥å·²å‘é€');
                }, 5000);
                
            } else {
                Notification.requestPermission().then(permission => {
                    console.log('[Test] Permission request result:', permission);
                    if (permission === "granted") {
                        new Notification("æµ‹è¯•é€šçŸ¥", {
                            body: "æƒé™å·²æˆäºˆï¼ç³»ç»Ÿé€šçŸ¥åŠŸèƒ½æ­£å¸¸å·¥ä½œ",
                            icon: 'https://img.heliar.top/file/1769158422909_æ— æ ‡é¢˜281_20251207015501_20260123165317.png'
                        });
                        showDebugToast("âœ“ æƒé™å·²æˆäºˆï¼é€šçŸ¥å·²å‘é€", true);
                    } else {
                        alert("é€šçŸ¥æƒé™è¢«æ‹’ç»ï¼Œæ— æ³•å‘é€é€šçŸ¥");
                    }
                });
            }
        }

        // åˆ‡æ¢è°ƒè¯•æ¨¡å¼
        function toggleDebugMode(checkbox) {
            const enabled = checkbox.checked;
            localStorage.setItem('debug_mode_enabled', enabled);
            if (enabled) {
                showDebugToast('è°ƒè¯•æ¨¡å¼å·²å¼€å¯');
            }
        }

        // --- å¼ºåŠ›ä¿æ´»åŠŸèƒ½ ---
        let keepAliveAudio = null;

        // åˆ‡æ¢ä¿æ´»åŠŸèƒ½
        function toggleKeepAlive(checkbox) {
            const enabled = checkbox.checked;
            localStorage.setItem('keepalive_enabled', enabled);
            
            if (enabled) {
                startKeepAlive();
            } else {
                stopKeepAlive();
            }
        }

        // å¯åŠ¨ä¿æ´»
        async function startKeepAlive() {
            if (!keepAliveAudio) {
                keepAliveAudio = document.getElementById('keepalive-audio');
            }
            
            try {
                // è®¾ç½®éŸ³é‡ä¸º0ï¼ˆé™éŸ³ï¼‰
                keepAliveAudio.volume = 0;
                
                // å°è¯•æ’­æ”¾
                await keepAliveAudio.play();
                console.log('[KeepAlive] âœ“ ä¿æ´»éŸ³é¢‘å·²å¯åŠ¨');
                showDebugToast('âœ“ å¼ºåŠ›ä¿æ´»å·²å¯åŠ¨', true);
                addLog('success', 'å¼ºåŠ›ä¿æ´»å·²å¯åŠ¨');
                
                // ç›‘å¬æ’­æ”¾é”™è¯¯
                keepAliveAudio.onerror = (e) => {
                    console.error('[KeepAlive] éŸ³é¢‘æ’­æ”¾é”™è¯¯:', e);
                    showDebugToast('âœ— ä¿æ´»éŸ³é¢‘åŠ è½½å¤±è´¥');
                    addLog('error', 'ä¿æ´»éŸ³é¢‘åŠ è½½å¤±è´¥', e);
                };
                
            } catch (err) {
                console.error('[KeepAlive] å¯åŠ¨å¤±è´¥:', err);
                showDebugToast('âš ï¸ éœ€è¦ç”¨æˆ·äº¤äº’æ‰èƒ½å¯åŠ¨');
                addLog('warning', 'ä¿æ´»å¯åŠ¨å¤±è´¥ï¼Œéœ€è¦ç”¨æˆ·äº¤äº’', err);
                
                // ç­‰å¾…ç”¨æˆ·ç‚¹å‡»åé‡è¯•
                document.addEventListener('click', function retryKeepAlive() {
                    startKeepAlive();
                    document.removeEventListener('click', retryKeepAlive);
                }, { once: true });
            }
        }

        // åœæ­¢ä¿æ´»
        function stopKeepAlive() {
            if (keepAliveAudio) {
                keepAliveAudio.pause();
                keepAliveAudio.currentTime = 0;
                console.log('[KeepAlive] âœ“ ä¿æ´»å·²åœæ­¢');
                showDebugToast('âœ“ ä¿æ´»å·²åœæ­¢');
                addLog('info', 'å¼ºåŠ›ä¿æ´»å·²åœæ­¢');
            }
        }

        // æ˜¾ç¤ºè°ƒè¯•Toastï¼ˆåœ¨æ‰‹æœºä¸Šå¯è§ï¼‰
        let toastTimer = null;
        function showDebugToast(message, forceShow = false) {
            // æ£€æŸ¥æ˜¯å¦å¼€å¯è°ƒè¯•æ¨¡å¼ï¼ˆæµ‹è¯•é€šçŸ¥æ—¶å¼ºåˆ¶æ˜¾ç¤ºï¼‰
            const debugEnabled = localStorage.getItem('debug_mode_enabled') === 'true';
            if (!debugEnabled && !forceShow) {
                return;
            }
            
            // åˆ›å»ºæˆ–è·å–toastå…ƒç´ 
            let toast = document.getElementById('debug-toast');
            if (!toast) {
                toast = document.createElement('div');
                toast.id = 'debug-toast';
                toast.className = 'debug-toast';
                document.body.appendChild(toast);
            }
            
            // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
            if (toastTimer) clearTimeout(toastTimer);
            
            // æ˜¾ç¤ºæ¶ˆæ¯
            toast.innerText = message;
            toast.classList.add('show');
            
            // 3ç§’åéšè—
            toastTimer = setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        // API é”™è¯¯æç¤ºå¼¹çª—
        let apiErrorTimer = null;
        function showApiErrorToast(errorMessage) {
            // åˆ›å»ºæˆ–è·å–å¼¹çª—å…ƒç´ 
            let toast = document.getElementById('api-error-toast');
            if (!toast) {
                toast = document.createElement('div');
                toast.id = 'api-error-toast';
                toast.className = 'api-error-toast';
                document.body.appendChild(toast);
            }
            
            // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
            if (apiErrorTimer) clearTimeout(apiErrorTimer);
            
            // æ„å»ºé”™è¯¯æç¤ºå†…å®¹
            toast.innerHTML = `
                <div class="error-icon">âš ï¸</div>
                <div class="error-title">è¯·æ±‚å¤±è´¥</div>
                <div class="error-msg">${errorMessage}</div>
            `;
            toast.classList.add('show');
            
            // 4ç§’åè‡ªåŠ¨éšè—
            apiErrorTimer = setTimeout(() => {
                toast.classList.remove('show');
            }, 4000);
            
            // ç‚¹å‡»å…³é—­
            toast.style.pointerEvents = 'auto';
            toast.onclick = () => {
                toast.classList.remove('show');
                if (apiErrorTimer) clearTimeout(apiErrorTimer);
            };
        }

        // å…¨å±€æ—¥å¿—ç³»ç»Ÿ
        const systemLogs = [];
        const MAX_LOGS = 100;
        
        function addLog(type, message, data = null) {
            const log = {
                time: new Date().toLocaleTimeString(),
                type: type, // 'info', 'success', 'warning', 'error'
                message: message,
                data: data
            };
            systemLogs.unshift(log);
            if (systemLogs.length > MAX_LOGS) systemLogs.pop();
            
            // å¦‚æœè¯Šæ–­é¢æ¿æ‰“å¼€ï¼Œå®æ—¶æ›´æ–°
            const logContainer = document.getElementById('diagnostic-logs');
            if (logContainer) {
                renderLogs();
            }
        }
        
        function renderLogs() {
            const container = document.getElementById('diagnostic-logs');
            if (!container) return;
            
            container.innerHTML = systemLogs.map(log => {
                const colors = {
                    info: '#007aff',
                    success: '#34c759',
                    warning: '#ff9500',
                    error: '#ff3b30'
                };
                const icons = {
                    info: 'â„¹ï¸',
                    success: 'âœ…',
                    warning: 'âš ï¸',
                    error: 'âŒ'
                };
                
                return `
                    <div style="padding:8px; border-bottom:1px solid #eee; font-size:12px;">
                        <div style="display:flex; justify-content:space-between; margin-bottom:4px;">
                            <span style="color:${colors[log.type]}; font-weight:bold;">${icons[log.type]} ${log.type.toUpperCase()}</span>
                            <span style="color:#999;">${log.time}</span>
                        </div>
                        <div style="color:#333;">${log.message}</div>
                        ${log.data ? `<pre style="background:#f5f5f5; padding:4px; border-radius:4px; margin-top:4px; font-size:10px; overflow-x:auto;">${JSON.stringify(log.data, null, 2)}</pre>` : ''}
                    </div>
                `;
            }).join('');
        }
        
        // æ˜¾ç¤ºè¯Šæ–­é¢æ¿
        async function showDiagnosticPanel() {
            const panel = document.createElement('div');
            panel.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.8);
                z-index: 9999;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 20px;
            `;
            
            const content = document.createElement('div');
            content.style.cssText = `
                background: white;
                border-radius: 12px;
                padding: 20px;
                max-width: 500px;
                width: 100%;
                max-height: 80vh;
                overflow-y: auto;
            `;
            
            // è·å–è¯Šæ–­ä¿¡æ¯
            let diagnosticInfo = `<h2 style="margin-top:0; color:#333;">ğŸ” è¯Šæ–­ä¿¡æ¯</h2>`;
            
            // 1. User ID
            diagnosticInfo += `<div style="margin-bottom:20px; padding:10px; background:#f5f5f5; border-radius:8px;">
                <strong style="color:#007aff;">User ID:</strong><br>
                <code style="background:#fff; padding:5px; border-radius:4px; display:block; margin-top:5px; word-break:break-all;">${currentUserId}</code>
            </div>`;
            
            // 2. æ£€æŸ¥ Service Worker
            let swStatus = 'âŒ æœªæ³¨å†Œ';
            if ('serviceWorker' in navigator) {
                const registration = await navigator.serviceWorker.getRegistration();
                if (registration) {
                    swStatus = 'âœ… å·²æ³¨å†Œ';
                    if (registration.active) {
                        swStatus += ' (æ¿€æ´»)';
                    }
                }
            }
            diagnosticInfo += `<div style="margin-bottom:20px; padding:10px; background:#f5f5f5; border-radius:8px;">
                <strong style="color:#007aff;">Service Worker:</strong><br>
                <span style="margin-top:5px; display:block;">${swStatus}</span>
            </div>`;
            
            // 3. æ¨é€è®¢é˜…çŠ¶æ€
            let subStatus = 'âŒ æœªè®¢é˜…';
            let subEndpoint = 'æ— ';
            if ('serviceWorker' in navigator && 'PushManager' in window) {
                const registration = await navigator.serviceWorker.getRegistration();
                if (registration) {
                    const subscription = await registration.pushManager.getSubscription();
                    if (subscription) {
                        subStatus = 'âœ… å·²è®¢é˜…';
                        subEndpoint = subscription.endpoint.substring(0, 50) + '...';
                    }
                }
            }
            diagnosticInfo += `<div style="margin-bottom:20px; padding:10px; background:#f5f5f5; border-radius:8px;">
                <strong style="color:#007aff;">æ¨é€è®¢é˜…:</strong><br>
                <span style="margin-top:5px; display:block;">${subStatus}</span>
                <code style="background:#fff; padding:5px; border-radius:4px; display:block; margin-top:5px; font-size:10px; word-break:break-all;">${subEndpoint}</code>
            </div>`;
            
            // 4. é€šçŸ¥æƒé™
            const notifPerm = Notification.permission;
            const permIcon = notifPerm === 'granted' ? 'âœ…' : notifPerm === 'denied' ? 'âŒ' : 'âš ï¸';
            diagnosticInfo += `<div style="margin-bottom:20px; padding:10px; background:#f5f5f5; border-radius:8px;">
                <strong style="color:#007aff;">é€šçŸ¥æƒé™:</strong><br>
                <span style="margin-top:5px; display:block;">${permIcon} ${notifPerm}</span>
            </div>`;
            
            // 5. ç¯å¢ƒä¿¡æ¯
            diagnosticInfo += `<div style="margin-bottom:20px; padding:10px; background:#f5f5f5; border-radius:8px;">
                <strong style="color:#007aff;">ç¯å¢ƒä¿¡æ¯:</strong><br>
                <span style="margin-top:5px; display:block;">åè®®: ${location.protocol}</span>
                <span style="display:block;">åŸŸå: ${location.hostname}</span>
                <span style="display:block;">æ¨¡å¼: çº¯å‰ç«¯ï¼ˆæ— éœ€åç«¯ï¼‰</span>
            </div>`;
            
            // 6. å¼€å¯ä¸»åŠ¨èŠå¤©çš„è§’è‰²
            const autoChars = await db.characters
                .filter(c => c.auto_reply_enabled === true && c.auto_reply_interval > 0)
                .toArray();
            diagnosticInfo += `<div style="margin-bottom:20px; padding:10px; background:#f5f5f5; border-radius:8px;">
                <strong style="color:#007aff;">ä¸»åŠ¨èŠå¤©è§’è‰²:</strong><br>
                <span style="margin-top:5px; display:block;">${autoChars.length} ä¸ªè§’è‰²å·²å¯ç”¨</span>
                ${autoChars.map(c => `<div style="margin-top:5px; padding:5px; background:#fff; border-radius:4px;">
                    ${c.name} (${c.auto_reply_interval}åˆ†é’Ÿ)
                </div>`).join('')}
            </div>`;
            
            // 7. å®æ—¶æ—¥å¿—åŒºåŸŸ
            diagnosticInfo += `<div style="margin-bottom:20px;">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                    <strong style="color:#007aff;">ğŸ“‹ å®æ—¶æ—¥å¿— (æœ€è¿‘${systemLogs.length}æ¡)</strong>
                    <button onclick="systemLogs.length=0; renderLogs();" style="padding:4px 8px; background:#ff3b30; color:#fff; border:none; border-radius:4px; font-size:11px;">æ¸…ç©º</button>
                </div>
                <div id="diagnostic-logs" style="max-height:300px; overflow-y:auto; background:#f9f9f9; border-radius:8px; padding:10px;">
                    ${systemLogs.length === 0 ? '<div style="text-align:center; color:#999; padding:20px;">æš‚æ— æ—¥å¿—</div>' : ''}
                </div>
            </div>`;
            
            content.innerHTML = diagnosticInfo;
            
            // æ¸²æŸ“æ—¥å¿—
            renderLogs();
            
            // å…³é—­æŒ‰é’®
            const closeBtn = document.createElement('button');
            closeBtn.innerText = 'å…³é—­';
            closeBtn.style.cssText = `
                width: 100%;
                padding: 12px;
                background: var(--ins-pink);
                color: white;
                border: none;
                border-radius: 8px;
                font-size: 16px;
                cursor: pointer;
                margin-top: 10px;
            `;
            closeBtn.onclick = () => document.body.removeChild(panel);
            content.appendChild(closeBtn);
            
            panel.appendChild(content);
            document.body.appendChild(panel);
            
            // ç‚¹å‡»èƒŒæ™¯å…³é—­
            panel.onclick = (e) => {
                if (e.target === panel) {
                    document.body.removeChild(panel);
                }
            };
        }

        // æ˜¾ç¤ºè®¾ç½®é¡µé¢
        function showSettingPage() {
            document.getElementById('setting-page').style.display = 'flex';
        }
        function hideSettingPage() {
            document.getElementById('setting-page').style.display = 'none';
        }

        // ===== æ•°æ®å¯¼å…¥å¯¼å‡ºåŠŸèƒ½ =====
        
        // æ˜¾ç¤ºå¯¼å‡ºé€‰é¡¹å¼¹çª—
        function showExportOptions() {
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.5);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 100000;
            `;
            
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white;
                border-radius: 12px;
                padding: 24px;
                max-width: 400px;
                width: 90%;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            `;
            
            dialog.innerHTML = `
                <h3 style="margin: 0 0 16px 0; font-size: 18px;">å¯¼å‡ºæ•°æ®é€‰é¡¹</h3>
                <p style="margin: 0 0 20px 0; font-size: 14px; color: #666;">
                    é€‰æ‹©è¦å¯¼å‡ºçš„æ•°æ®ç±»å‹ï¼š
                </p>
                <div style="margin-bottom: 20px;">
                    <label style="display: flex; align-items: center; margin-bottom: 12px; cursor: pointer;">
                        <input type="checkbox" id="export-local-data" checked style="margin-right: 8px; width: 18px; height: 18px;">
                        <div>
                            <div style="font-weight: 500;">æœ¬åœ°æ•°æ®</div>
                            <div style="font-size: 12px; color: #999;">
                                åŒ…æ‹¬ï¼šè§’è‰²ã€èŠå¤©è®°å½•ã€ä¸–ç•Œä¹¦ã€è¡¨æƒ…åŒ…ã€æœ‹å‹åœˆã€ç¾¤èŠã€ç”µè¯/çŸ­ä¿¡è®°å½•ç­‰
                            </div>
                        </div>
                    </label>
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" id="export-online-data" checked style="margin-right: 8px; width: 18px; height: 18px;">
                        <div>
                            <div style="font-weight: 500;">è”æœºè´¦å·æ•°æ®</div>
                            <div style="font-size: 12px; color: #999;">
                                åŒ…æ‹¬ï¼šè”æœºæœåŠ¡å™¨åœ°å€ã€ç™»å½•Tokenã€ç”¨æˆ·ä¿¡æ¯
                            </div>
                        </div>
                    </label>
                </div>
                <div style="display: flex; gap: 12px; justify-content: flex-end;">
                    <button id="export-cancel-btn" style="padding: 8px 16px; border: 1px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">
                        å–æ¶ˆ
                    </button>
                    <button id="export-confirm-btn" style="padding: 8px 16px; border: none; background: #07c160; color: white; border-radius: 6px; cursor: pointer;">
                        ç¡®å®šå¯¼å‡º
                    </button>
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            // ç»‘å®šäº‹ä»¶
            document.getElementById('export-cancel-btn').onclick = () => {
                document.body.removeChild(overlay);
            };
            
            document.getElementById('export-confirm-btn').onclick = async () => {
                const includeLocal = document.getElementById('export-local-data').checked;
                const includeOnline = document.getElementById('export-online-data').checked;
                
                if (!includeLocal && !includeOnline) {
                    alert('è¯·è‡³å°‘é€‰æ‹©ä¸€ç§æ•°æ®ç±»å‹');
                    return;
                }
                
                document.body.removeChild(overlay);
                await exportAllDataWithOptions(includeLocal, includeOnline);
            };
            
            // ç‚¹å‡»èƒŒæ™¯å…³é—­
            overlay.onclick = (e) => {
                if (e.target === overlay) {
                    document.body.removeChild(overlay);
                }
            };
        }
        
        // å¯¼å‡ºæ‰€æœ‰æ•°æ®ï¼ˆå¸¦é€‰é¡¹ï¼‰
        async function exportAllDataWithOptions(includeLocal = true, includeOnline = true) {
            try {
                const exportData = {
                    version: '2.0', // ç‰ˆæœ¬å‡çº§åˆ°2.0
                    exportTime: new Date().toISOString(),
                    dataTypes: {
                        local: includeLocal,
                        online: includeOnline
                    },
                    data: {}
                };
                
                if (includeLocal) {
                    // å¯¼å‡ºæ‰€æœ‰æ•°æ®åº“è¡¨
                    exportData.data.dexiData = await db.dexiData.toArray();
                    exportData.data.lorebooks = await db.lorebooks.toArray();
                    exportData.data.characters = await db.characters.toArray();
                    exportData.data.sticker_categories = await db.sticker_categories.toArray();
                    exportData.data.moments = await db.moments.toArray();
                    exportData.data.friend_requests = await db.friend_requests.toArray();
                    
                    // æ–°å¢ï¼šå¯¼å‡ºç¾¤èŠæ•°æ®
                    exportData.data.group_chats = await db.group_chats.toArray();
                    
                    // æ–°å¢ï¼šå¯¼å‡ºç”µè¯å’ŒçŸ­ä¿¡è®°å½•
                    exportData.data.phone_recents = await db.phone_recents.toArray();
                    exportData.data.sms_messages = await db.sms_messages.toArray();
                    
                    // æ–°å¢ï¼šå¯¼å‡ºèŠå¤©æ€»ç»“
                    exportData.data.chat_summaries = await db.chat_summaries.toArray();
                    
                    // å¯¼å‡ºæœ¬åœ° localStorage æ•°æ®
                    exportData.localStorage = {
                        user_id: localStorage.getItem('user_id'),
                        current_my_char_id: localStorage.getItem('current_my_char_id'),
                        notification_enabled: localStorage.getItem('notification_enabled'),
                        debug_mode: localStorage.getItem('debug_mode'),
                        keepalive_enabled: localStorage.getItem('keepalive_enabled')
                    };
                }
                
                if (includeOnline) {
                    // å¯¼å‡ºè”æœºç›¸å…³æ•°æ®
                    exportData.onlineData = {
                        server_url: localStorage.getItem('online_server_url'),
                        token: localStorage.getItem('online_token'),
                        user_data: localStorage.getItem('online_user_data')
                    };
                }
                
                // è½¬æ¢ä¸ºJSONå­—ç¬¦ä¸²
                const jsonString = JSON.stringify(exportData, null, 2);
                
                // åˆ›å»ºä¸‹è½½é“¾æ¥
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                
                // æ ¹æ®å¯¼å‡ºçš„æ•°æ®ç±»å‹è®¾ç½®æ–‡ä»¶å
                let filename = 'wechat_backup_';
                if (includeLocal && includeOnline) {
                    filename += 'full_';
                } else if (includeLocal) {
                    filename += 'local_';
                } else if (includeOnline) {
                    filename += 'online_';
                }
                filename += new Date().getTime() + '.json';
                
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                // æ˜¾ç¤ºå¯¼å‡ºçš„æ•°æ®ç»Ÿè®¡
                let stats = [];
                if (includeLocal) {
                    const charCount = exportData.data.characters?.length || 0;
                    const groupCount = exportData.data.group_chats?.length || 0;
                    const momentCount = exportData.data.moments?.length || 0;
                    stats.push(`è§’è‰²: ${charCount}ä¸ª`);
                    stats.push(`ç¾¤èŠ: ${groupCount}ä¸ª`);
                    stats.push(`æœ‹å‹åœˆ: ${momentCount}æ¡`);
                }
                if (includeOnline) {
                    stats.push('è”æœºè´¦å·ä¿¡æ¯å·²åŒ…å«');
                }
                
                alert('æ•°æ®å¯¼å‡ºæˆåŠŸï¼\n\n' + stats.join('\n'));
            } catch (error) {
                console.error('å¯¼å‡ºæ•°æ®å¤±è´¥:', error);
                alert('å¯¼å‡ºæ•°æ®å¤±è´¥: ' + error.message);
            }
        }
        
        // å…¼å®¹æ—§ç‰ˆæœ¬ï¼šç›´æ¥è°ƒç”¨æ—¶æ˜¾ç¤ºé€‰é¡¹
        async function exportAllData() {
            showExportOptions();
        }
        
        // å¯¼å…¥æ‰€æœ‰æ•°æ®
        async function importAllData(input) {
            const file = input.files[0];
            if (!file) return;
            
            try {
                const text = await file.text();
                const importData = JSON.parse(text);
                
                // éªŒè¯æ•°æ®æ ¼å¼
                if (!importData.version || !importData.data) {
                    throw new Error('æ•°æ®æ ¼å¼ä¸æ­£ç¡®');
                }
                
                // æ£€æµ‹æ•°æ®ç±»å‹
                const hasLocalData = importData.dataTypes?.local !== false;
                const hasOnlineData = importData.onlineData || (importData.dataTypes?.online === true);
                
                // æ˜¾ç¤ºå¯¼å…¥å†…å®¹é¢„è§ˆ
                let previewMsg = 'å³å°†å¯¼å…¥ä»¥ä¸‹æ•°æ®ï¼š\n\n';
                if (hasLocalData) {
                    const charCount = importData.data.characters?.length || 0;
                    const groupCount = importData.data.group_chats?.length || 0;
                    const momentCount = importData.data.moments?.length || 0;
                    previewMsg += `ğŸ“± æœ¬åœ°æ•°æ®ï¼š\n`;
                    previewMsg += `  - è§’è‰²: ${charCount}ä¸ª\n`;
                    previewMsg += `  - ç¾¤èŠ: ${groupCount}ä¸ª\n`;
                    previewMsg += `  - æœ‹å‹åœˆ: ${momentCount}æ¡\n`;
                    previewMsg += `  - ä»¥åŠä¸–ç•Œä¹¦ã€è¡¨æƒ…åŒ…ã€ç”µè¯/çŸ­ä¿¡è®°å½•ç­‰\n\n`;
                }
                if (hasOnlineData) {
                    const userData = importData.onlineData?.user_data;
                    if (userData) {
                        try {
                            const userObj = JSON.parse(userData);
                            previewMsg += `ğŸŒ è”æœºè´¦å·ï¼š${userObj.username || 'æœªçŸ¥'}\n\n`;
                        } catch {
                            previewMsg += `ğŸŒ è”æœºè´¦å·æ•°æ®\n\n`;
                        }
                    } else {
                        previewMsg += `ğŸŒ è”æœºè´¦å·æ•°æ®\n\n`;
                    }
                }
                
                previewMsg += 'âš ï¸ å¯¼å…¥å°†è¦†ç›–ç°æœ‰æ•°æ®ï¼\nå»ºè®®å…ˆå¯¼å‡ºå½“å‰æ•°æ®ä½œä¸ºå¤‡ä»½ã€‚\n\næ˜¯å¦ç»§ç»­ï¼Ÿ';
                
                // ç¡®è®¤å¯¹è¯æ¡†
                if (!confirm(previewMsg)) {
                    input.value = ''; // æ¸…ç©ºæ–‡ä»¶é€‰æ‹©
                    return;
                }
                
                // æ¸…ç©ºç°æœ‰æ•°æ®
                if (hasLocalData) {
                    await db.dexiData.clear();
                    await db.lorebooks.clear();
                    await db.characters.clear();
                    await db.sticker_categories.clear();
                    await db.moments.clear();
                    await db.friend_requests.clear();
                    
                    // æ¸…ç©ºæ–°å¢çš„è¡¨
                    if (db.group_chats) await db.group_chats.clear();
                    if (db.phone_recents) await db.phone_recents.clear();
                    if (db.sms_messages) await db.sms_messages.clear();
                    if (db.chat_summaries) await db.chat_summaries.clear();
                }
                
                // å¯¼å…¥æ•°æ®åº“è¡¨æ•°æ®
                if (hasLocalData && importData.data) {
                    if (importData.data.dexiData) {
                        await db.dexiData.bulkAdd(importData.data.dexiData);
                    }
                    if (importData.data.lorebooks) {
                        await db.lorebooks.bulkAdd(importData.data.lorebooks);
                    }
                    if (importData.data.characters) {
                        await db.characters.bulkAdd(importData.data.characters);
                    }
                    if (importData.data.sticker_categories) {
                        await db.sticker_categories.bulkAdd(importData.data.sticker_categories);
                    }
                    if (importData.data.moments) {
                        await db.moments.bulkAdd(importData.data.moments);
                    }
                    if (importData.data.friend_requests) {
                        await db.friend_requests.bulkAdd(importData.data.friend_requests);
                    }
                    
                    // å¯¼å…¥æ–°å¢çš„è¡¨
                    if (importData.data.group_chats && db.group_chats) {
                        await db.group_chats.bulkAdd(importData.data.group_chats);
                    }
                    if (importData.data.phone_recents && db.phone_recents) {
                        await db.phone_recents.bulkAdd(importData.data.phone_recents);
                    }
                    if (importData.data.sms_messages && db.sms_messages) {
                        await db.sms_messages.bulkAdd(importData.data.sms_messages);
                    }
                    if (importData.data.chat_summaries && db.chat_summaries) {
                        await db.chat_summaries.bulkAdd(importData.data.chat_summaries);
                    }
                    
                    // å¯¼å…¥ localStorage æ•°æ®
                    if (importData.localStorage) {
                        Object.keys(importData.localStorage).forEach(key => {
                            const value = importData.localStorage[key];
                            if (value !== null && value !== undefined) {
                                localStorage.setItem(key, value);
                            }
                        });
                    }
                }
                
                // å¯¼å…¥è”æœºæ•°æ®
                if (hasOnlineData && importData.onlineData) {
                    if (importData.onlineData.server_url) {
                        localStorage.setItem('online_server_url', importData.onlineData.server_url);
                    }
                    if (importData.onlineData.token) {
                        localStorage.setItem('online_token', importData.onlineData.token);
                    }
                    if (importData.onlineData.user_data) {
                        localStorage.setItem('online_user_data', importData.onlineData.user_data);
                    }
                }
                
                input.value = ''; // æ¸…ç©ºæ–‡ä»¶é€‰æ‹©
                
                let successMsg = 'æ•°æ®å¯¼å…¥æˆåŠŸï¼\n\n';
                if (hasLocalData) successMsg += 'âœ… æœ¬åœ°æ•°æ®å·²å¯¼å…¥\n';
                if (hasOnlineData) successMsg += 'âœ… è”æœºè´¦å·å·²å¯¼å…¥\n';
                successMsg += '\né¡µé¢å³å°†åˆ·æ–°...';
                
                alert(successMsg);
                
                // åˆ·æ–°é¡µé¢ä»¥åº”ç”¨å¯¼å…¥çš„æ•°æ®
                setTimeout(() => {
                    window.location.reload();
                }, 500);
                
            } catch (error) {
                console.error('å¯¼å…¥æ•°æ®å¤±è´¥:', error);
                alert('å¯¼å…¥æ•°æ®å¤±è´¥: ' + error.message);
                input.value = '';
            }
        }
        
        // æ¸…ç©ºæ‰€æœ‰æ•°æ®
        async function clearAllDataConfirm() {
            const confirm1 = confirm('âš ï¸ è­¦å‘Šï¼šæ­¤æ“ä½œå°†åˆ é™¤æ‰€æœ‰æ•°æ®ï¼\n\nåŒ…æ‹¬ï¼š\n- æ‰€æœ‰è§’è‰²å’ŒèŠå¤©è®°å½•\n- æ‰€æœ‰ä¸–ç•Œä¹¦\n- æ‰€æœ‰è¡¨æƒ…åŒ…\n- æ‰€æœ‰æœ‹å‹åœˆ\n- æ‰€æœ‰ç¾¤èŠ\n- ç”µè¯å’ŒçŸ­ä¿¡è®°å½•\n- è”æœºè´¦å·ä¿¡æ¯\n- APIè®¾ç½®\n\næ­¤æ“ä½œä¸å¯æ¢å¤ï¼Œç¡®å®šè¦ç»§ç»­å—ï¼Ÿ');
            if (!confirm1) return;
            
            const confirm2 = prompt('è¯·è¾“å…¥"ç¡®è®¤åˆ é™¤"ä»¥ç»§ç»­ï¼š');
            if (confirm2 !== 'ç¡®è®¤åˆ é™¤') {
                alert('å·²å–æ¶ˆæ“ä½œ');
                return;
            }
            
            try {
                // æ¸…ç©ºæ‰€æœ‰æ•°æ®åº“è¡¨
                await db.dexiData.clear();
                await db.lorebooks.clear();
                await db.characters.clear();
                await db.sticker_categories.clear();
                await db.moments.clear();
                await db.friend_requests.clear();
                
                // æ¸…ç©ºæ–°å¢çš„è¡¨
                if (db.group_chats) await db.group_chats.clear();
                if (db.phone_recents) await db.phone_recents.clear();
                if (db.sms_messages) await db.sms_messages.clear();
                if (db.chat_summaries) await db.chat_summaries.clear();
                
                // æ¸…ç©º localStorage
                localStorage.clear();
                
                alert('æ‰€æœ‰æ•°æ®å·²æ¸…ç©ºï¼é¡µé¢å³å°†åˆ·æ–°...');
                
                setTimeout(() => {
                    window.location.reload();
                }, 500);
                
            } catch (error) {
                console.error('æ¸…ç©ºæ•°æ®å¤±è´¥:', error);
                alert('æ¸…ç©ºæ•°æ®å¤±è´¥: ' + error.message);
            }
        }

        // æ˜¾ç¤ºé€šçŸ¥ä¸­å¿ƒ
        function showNotificationCenter() {
            const enabled = localStorage.getItem('notification_enabled') === 'true';
            if (!enabled) return; // æœªå¼€å¯ä¸æ˜¾ç¤º

            document.getElementById('notification-center').style.display = 'block';
            fetchNotifications(); // æ‰“å¼€æ—¶åˆ·æ–°ä¸€ä¸‹
        }
        function hideNotificationCenter() {
            document.getElementById('notification-center').style.display = 'none';
        }

        // è·å–é€šçŸ¥ï¼ˆçº¯å‰ç«¯ï¼šä»æœ¬åœ° IndexedDB è¯»å–ï¼‰
        async function fetchNotifications() {
            const enabled = localStorage.getItem('notification_enabled') === 'true';
            if (!enabled) return;

            try {
                // ä»æœ¬åœ°å­˜å‚¨è¯»å–é€šçŸ¥
                const notificationsJson = localStorage.getItem(`notifications_${currentUserId}`);
                const list = notificationsJson ? JSON.parse(notificationsJson) : [];
                renderNotifications(list);
            } catch (err) {
                console.error('è·å–é€šçŸ¥å¤±è´¥:', err);
            }
        }
        
        // æ·»åŠ æœ¬åœ°é€šçŸ¥ï¼ˆçº¯å‰ç«¯ç‰ˆæœ¬ï¼‰
        function addLocalNotification(title, content, type = 'single') {
            try {
                const notificationsJson = localStorage.getItem(`notifications_${currentUserId}`);
                const list = notificationsJson ? JSON.parse(notificationsJson) : [];
                
                const newNotif = {
                    id: Date.now(),
                    title: title,
                    content: content,
                    type: type,
                    timestamp: Date.now() / 1000,
                    is_read: false
                };
                
                list.unshift(newNotif);
                
                // æœ€å¤šä¿ç•™100æ¡é€šçŸ¥
                if (list.length > 100) list.pop();
                
                localStorage.setItem(`notifications_${currentUserId}`, JSON.stringify(list));
                return newNotif;
            } catch (err) {
                console.error('æ·»åŠ é€šçŸ¥å¤±è´¥:', err);
                return null;
            }
        }

        // æ¸²æŸ“é€šçŸ¥åˆ—è¡¨
        function renderNotifications(list) {
            const container = document.getElementById('notif-list');
            container.innerHTML = '';
            
            let unreadCount = 0;

            if (list.length === 0) {
                container.innerHTML = '<div class="empty-tip">æš‚æ— æ–°é€šçŸ¥</div>';
                latestNotification = null;
            } else {
                // ç¡®ä¿åˆ—è¡¨æ˜¯æŒ‰æ—¶é—´å€’åºçš„
                list.sort((a, b) => b.timestamp - a.timestamp);
                
                // æ›´æ–°æœ€æ–°çš„ä¸€æ¡é€šçŸ¥ç¼“å­˜
                latestNotification = list[0];

                list.forEach(item => {
                    // 1. ç»Ÿè®¡æœªè¯»
                    if (!item.is_read) unreadCount++;

                    // 2. æ£€æŸ¥æ˜¯å¦æœ‰æ–°æ¶ˆæ¯ (ä¸åœ¨å·²çŸ¥åˆ—è¡¨ä¸­ï¼Œä¸”éé¦–æ¬¡åŠ è½½)
                    if (!knownNotifIds.has(item.id)) {
                        knownNotifIds.add(item.id);
                        
                        // ä»…å½“éé¦–æ¬¡åŠ è½½æ—¶å¼¹çª—ï¼Œé¿å…åˆ·æ–°é¡µé¢æ—¶ç‹‚å¼¹
                        if (!isFirstLoad) {
                            sendSystemNotification(item.title, item.content);
                        }
                    }

                    // 3. æ¸²æŸ“DOM
                    const div = document.createElement('div');
                    div.className = `notif-item ${!item.is_read ? 'unread' : ''}`;
                    // æ ¼å¼åŒ–æ—¶é—´æˆ³
                    const date = new Date(item.timestamp * 1000);
                    const timeStr = `${date.getMonth()+1}-${date.getDate()} ${date.getHours()}:${date.getMinutes().toString().padStart(2, '0')}`;
                    
                    div.innerHTML = `
                        <div class="notif-time">${timeStr}</div>
                        <div class="notif-content-title">${item.title}</div>
                        <div class="notif-desc">${item.content}</div>
                    `;
                    div.onclick = () => markRead(item.id, item.is_read);
                    container.appendChild(div);
                });
            }
            
            // é¦–æ¬¡åŠ è½½æ ‡è®°ç½®ä¸ºfalse
            isFirstLoad = false;

            // æ›´æ–°çº¢ç‚¹
            const badge = document.getElementById('notif-badge');
            badge.style.display = unreadCount > 0 ? 'block' : 'none';
        }

        // å‘é€ç³»ç»Ÿé€šçŸ¥
        function sendSystemNotification(title, body) {
            console.log(`[Notification] ========================================`);
            console.log(`[Notification] ğŸ”” å°è¯•å‘é€é€šçŸ¥: "${title}" - "${body}"`);
            addLog('info', `å°è¯•å‘é€é€šçŸ¥: ${title}`, { body, caller: new Error().stack.split('\n')[2] });
            
            // æ£€æŸ¥æµè§ˆå™¨æ˜¯å¦æ”¯æŒé€šçŸ¥
            if (!("Notification" in window)) {
                console.error('[Notification] âœ— æµè§ˆå™¨ä¸æ”¯æŒé€šçŸ¥');
                addLog('error', 'æµè§ˆå™¨ä¸æ”¯æŒé€šçŸ¥');
                showDebugToast('æµè§ˆå™¨ä¸æ”¯æŒé€šçŸ¥');
                return;
            }
            
            // æ£€æŸ¥æƒé™çŠ¶æ€
            const permission = Notification.permission;
            console.log(`[Notification] æƒé™çŠ¶æ€: ${permission}`);
            addLog('info', `é€šçŸ¥æƒé™çŠ¶æ€: ${permission}`);
            
            if (permission === "granted") {
                try {
                    console.log(`[Notification] âœ“ æƒé™å·²æˆäºˆï¼Œç«‹å³å‘é€é€šçŸ¥...`);
                    const notification = new Notification(title, { 
                        body: body,
                        icon: 'https://img.heliar.top/file/1769158422909_æ— æ ‡é¢˜281_20251207015501_20260123165317.png',
                        badge: 'https://img.heliar.top/file/1769158422909_æ— æ ‡é¢˜281_20251207015501_20260123165317.png',
                        tag: 'chat-message-' + Date.now(), // æ¯æ¬¡éƒ½ç”¨æ–°tagï¼Œé¿å…è¢«æ›¿æ¢
                        requireInteraction: false,
                        silent: false
                    });
                    
                    notification.onclick = function() {
                        window.focus();
                        this.close();
                    };
                    
                    console.log('[Notification] âœ“âœ“âœ“ é€šçŸ¥å·²æˆåŠŸå‘é€ï¼');
                    showDebugToast(`âœ“ é€šçŸ¥: ${title}`);
                } catch (error) {
                    console.error('[Notification] âœ—âœ—âœ— å‘é€å¤±è´¥:', error);
                    showDebugToast(`âœ— é€šçŸ¥å¤±è´¥: ${error.message}`);
                }
            } else if (permission === "default") {
                console.log('[Notification] æƒé™æœªè®¾ç½®ï¼Œè¯·æ±‚æƒé™...');
                Notification.requestPermission().then(permission => {
                    console.log(`[Notification] æƒé™è¯·æ±‚ç»“æœ: ${permission}`);
                    if (permission === "granted") {
                        try {
                            new Notification(title, { 
                                body: body,
                                icon: 'https://img.heliar.top/file/1769158422909_æ— æ ‡é¢˜281_20251207015501_20260123165317.png'
                            });
                            console.log('[Notification] âœ“ é€šçŸ¥å·²å‘é€ï¼ˆæƒé™æˆäºˆåï¼‰');
                        } catch (error) {
                            console.error('[Notification] âœ— å‘é€å¤±è´¥:', error);
                        }
                    } else {
                        console.warn('[Notification] âœ— æƒé™è¢«æ‹’ç»');
                    }
                });
            } else {
                console.error('[Notification] âœ—âœ—âœ— æƒé™å·²è¢«æ‹’ç»ï¼Œæ— æ³•å‘é€é€šçŸ¥');
                console.error('[Notification] è¯·åœ¨æµè§ˆå™¨è®¾ç½®ä¸­å…è®¸é€šçŸ¥æƒé™');
                showDebugToast('âœ— é€šçŸ¥æƒé™è¢«æ‹’ç»ï¼Œè¯·åœ¨è®¾ç½®ä¸­å…è®¸');
            }
            
            console.log(`[Notification] ========================================`);
        }

        // æ ‡è®°å·²è¯»ï¼ˆçº¯å‰ç«¯ï¼šæ›´æ–°æœ¬åœ°å­˜å‚¨ï¼‰
        async function markRead(id, isRead) {
            if (isRead) return; // å·²ç»æ˜¯å·²è¯»

            try {
                const notificationsJson = localStorage.getItem(`notifications_${currentUserId}`);
                const list = notificationsJson ? JSON.parse(notificationsJson) : [];
                
                const notif = list.find(n => n.id === id);
                if (notif) {
                    notif.is_read = true;
                    localStorage.setItem(`notifications_${currentUserId}`, JSON.stringify(list));
                }
                
                // é‡æ–°è·å–åˆ·æ–°åˆ—è¡¨
                fetchNotifications();
            } catch (err) {
                console.error('æ ‡è®°å·²è¯»å¤±è´¥:', err);
            }
        }

        // æ ¸å¿ƒï¼šæŠ˜å å±•å¼€åˆ‡æ¢
        function toggleExpand(id) {
            const expand = document.getElementById(id);
            const arrow = document.getElementById(`arrow${id.replace('expand','')}`);
            if (expand.style.display === 'flex') {
                expand.style.display = 'none';
                arrow.classList.remove('active');
                // arrow.innerText = 'â†’'; // SVGæ—‹è½¬
            } else {
                expand.style.display = 'flex';
                arrow.classList.add('active');
                // arrow.innerText = 'â†‘'; // SVGæ—‹è½¬
            }
        }

        // å…¨å±€å­—ä½“è®¾ç½®ç›¸å…³å‡½æ•°
        let customFontStyleElement = null;
        
        // é¢„è§ˆè‡ªå®šä¹‰å­—ä½“
        function previewCustomFont() {
            const fontUrl = document.getElementById('custom-font-input').value.trim();
            const fontName = document.getElementById('custom-font-name-input').value.trim();
            
            if (!fontUrl || !fontName) {
                alert('è¯·å¡«å†™å­—ä½“é“¾æ¥å’Œå­—ä½“åç§°');
                return;
            }
            
            // åŠ¨æ€åŠ è½½å­—ä½“æ ·å¼
            loadCustomFont(fontUrl, fontName, true);
        }
        
        // åŠ è½½å¹¶åº”ç”¨è‡ªå®šä¹‰å­—ä½“
        function loadCustomFont(fontUrl, fontName, previewOnly = false) {
            // ç§»é™¤æ—§çš„å­—ä½“æ ·å¼
            const oldLink = document.getElementById('custom-font-link');
            if (oldLink) oldLink.remove();
            
            // åˆ›å»ºæ–°çš„ link æ ‡ç­¾åŠ è½½å­—ä½“
            const link = document.createElement('link');
            link.id = 'custom-font-link';
            link.rel = 'stylesheet';
            link.href = fontUrl;
            document.head.appendChild(link);
            
            // ç­‰å¾…å­—ä½“åŠ è½½å®Œæˆååº”ç”¨
            link.onload = function() {
                if (previewOnly) {
                    // ä»…é¢„è§ˆï¼šåªåº”ç”¨åˆ°é¢„è§ˆåŒºåŸŸ
                    const previewText = document.getElementById('font-preview-text');
                    previewText.style.fontFamily = `"${fontName}", sans-serif`;
                    previewText.innerText = `è¿™æ˜¯å­—ä½“é¢„è§ˆæ•ˆæœ ABC 123\n${fontName}`;
                } else {
                    // å…¨å±€åº”ç”¨
                    applyFontGlobal(fontName);
                }
            };
            
            link.onerror = function() {
                alert('å­—ä½“åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥é“¾æ¥æ˜¯å¦æ­£ç¡®');
            };
        }
        
        // åº”ç”¨å­—ä½“åˆ°å…¨å±€
        function applyFontGlobal(fontName) {
            // ç§»é™¤æ—§çš„å…¨å±€å­—ä½“æ ·å¼
            if (customFontStyleElement) {
                customFontStyleElement.remove();
            }
            
            // åˆ›å»ºæ–°çš„æ ·å¼å…ƒç´ 
            customFontStyleElement = document.createElement('style');
            customFontStyleElement.id = 'custom-font-global';
            customFontStyleElement.textContent = `
                * {
                    font-family: "${fontName}", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif !important;
                }
            `;
            document.head.appendChild(customFontStyleElement);
        }
        
        // æ¸…é™¤è‡ªå®šä¹‰å­—ä½“ï¼Œæ¢å¤é»˜è®¤
        function clearCustomFont() {
            // æ¸…é™¤è¾“å…¥æ¡†
            document.getElementById('custom-font-input').value = '';
            document.getElementById('custom-font-name-input').value = '';
            
            // ç§»é™¤å­—ä½“é“¾æ¥å’Œå…¨å±€æ ·å¼
            const fontLink = document.getElementById('custom-font-link');
            if (fontLink) fontLink.remove();
            
            if (customFontStyleElement) {
                customFontStyleElement.remove();
                customFontStyleElement = null;
            }
            
            // é‡ç½®é¢„è§ˆåŒºåŸŸ
            const previewText = document.getElementById('font-preview-text');
            previewText.style.fontFamily = '';
            previewText.innerText = 'è¿™æ˜¯å­—ä½“é¢„è§ˆæ•ˆæœ ABC 123';
            
            alert('å·²æ¢å¤é»˜è®¤å­—ä½“');
        }

        // åŒæ­¥é¢„è§ˆåŒºå’Œè¾“å…¥æ¡†
        function syncPreview() {
            // å£çº¸é¢„è§ˆ
            const bg = document.getElementById('desktop-body').style.backgroundImage;
            if (bg) {
                document.getElementById('wallpaper-preview').style.backgroundImage = bg;
                document.getElementById('wallpaper-preview').innerText = '';
            }
            // å°ç»„ä»¶
            document.getElementById('widget-icon-preview').style.backgroundImage = document.getElementById('widget-icon').style.backgroundImage;
            document.getElementById('widget-title-input').value = document.getElementById('widget-title').innerText.replace(/\{|\}/g, '').trim();
            document.getElementById('widget-subtext-input').value = document.getElementById('widget-subtext').innerText.trim();
            // æ‹ç«‹å¾—
            document.getElementById('photo-left-preview').style.backgroundImage = document.getElementById('img-left').style.backgroundImage;
            document.getElementById('photo-right-preview').style.backgroundImage = document.getElementById('img-right').style.backgroundImage;
            // å¤´åƒ
            document.getElementById('avatar1-preview').style.backgroundImage = document.getElementById('avatar-img-1').style.backgroundImage;
            document.getElementById('avatar2-preview').style.backgroundImage = document.getElementById('avatar-img-2').style.backgroundImage;
            document.getElementById('avatar1-bubble-input').value = document.getElementById('avatar-bubble1').innerText.trim();
            document.getElementById('avatar1-name-input').value = document.getElementById('avatar-name1').innerText.trim();
            document.getElementById('avatar2-bubble-input').value = document.getElementById('avatar-bubble2').innerText.trim();
            document.getElementById('avatar2-name-input').value = document.getElementById('avatar-name2').innerText.trim();
            // å€’æ•°æ—¥
            document.getElementById('days-input').value = document.getElementById('days-text').innerText.trim();
            // æ¤­åœ†å½¢é¢œè‰²
            const capsuleColor = getComputedStyle(document.documentElement).getPropertyValue('--capsule-bg').trim() || '#FFF7FA';
            const bubbleColor = getComputedStyle(document.documentElement).getPropertyValue('--bubble-bg').trim() || '#FFF7FA';
            document.getElementById('capsule-color-input').value = capsuleColor;
            document.getElementById('bubble-color-input').value = bubbleColor;
            // å­—ä½“é¢„è§ˆåŒæ­¥
            const fontName = document.getElementById('custom-font-name-input').value.trim();
            const previewText = document.getElementById('font-preview-text');
            if (fontName && previewText) {
                previewText.style.fontFamily = `"${fontName}", sans-serif`;
                previewText.innerText = `è¿™æ˜¯å­—ä½“é¢„è§ˆæ•ˆæœ ABC 123\n${fontName}`;
            }
        }

        // é¡µé¢åˆ‡æ¢
        function showCustomPage() {
            document.getElementById('home-page').style.display = 'none';
            document.getElementById('custom-main-page').style.display = 'flex';
            syncPreview();
        }
        function backHomePage() {
            document.getElementById('custom-main-page').style.display = 'none';
            document.getElementById('home-page').style.display = 'block';
        }

        // å„é¡¹è‡ªå®šä¹‰æ–¹æ³•
        function setWallpaper(input) {
            const file = input.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = e => {
                    document.getElementById('desktop-body').style.backgroundImage = `url(${e.target.result})`;
                    document.getElementById('wallpaper-preview').style.backgroundImage = `url(${e.target.result})`;
                    document.getElementById('wallpaper-preview').innerText = '';
                };
                reader.readAsDataURL(file);
            }
            input.value = '';
        }
        function selectIcon(iconId) {
            currentSelectIcon = iconId;
            document.getElementById('custom-icon-input').click();
        }
        function setCustomIcon(input) {
            const file = input.files[0];
            if (file && currentSelectIcon) {
                const reader = new FileReader();
                reader.onload = e => {
                    let iconDom = document.getElementById(`icon-${currentSelectIcon}`)?.querySelector('.icon') || document.getElementById(`dock-${currentSelectIcon}`)?.querySelector('.icon');
                    if (iconDom) iconDom.style.backgroundImage = `url(${e.target.result})`;
                };
                reader.readAsDataURL(file);
            }
            input.value = '';
        }
        function setWidgetIcon(input) {
            const file = input.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = e => {
                    document.getElementById('widget-icon').style.backgroundImage = `url(${e.target.result})`;
                    document.getElementById('widget-icon-preview').style.backgroundImage = `url(${e.target.result})`;
                };
                reader.readAsDataURL(file);
            }
            input.value = '';
        }
        function setPhoto(pos, input) {
            const file = input.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = e => {
                    document.getElementById(`img-${pos}`).style.backgroundImage = `url(${e.target.result})`;
                    document.getElementById(`photo-${pos}-preview`).style.backgroundImage = `url(${e.target.result})`;
                };
                reader.readAsDataURL(file);
            }
            input.value = '';
        }
        function setAvatar(id, input) {
            const file = input.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = e => {
                    const img = document.getElementById(`avatar-img-${id}`);
                    img.style.backgroundImage = `url(${e.target.result})`;
                    img.classList.add('has-image');
                    document.getElementById(`avatar${id}-preview`).style.backgroundImage = `url(${e.target.result})`;
                };
                reader.readAsDataURL(file);
            }
            input.value = '';
        }

        // --- API è®¾ç½®é€»è¾‘ (æŠ˜å ç‰ˆ) ---
        function toggleApiSetting() {
            const body = document.getElementById('api-setting-body');
            const arrow = document.getElementById('api-setting-arrow');
            if (body.style.display === 'block') {
                body.style.display = 'none';
                arrow.classList.remove('expanded');
            } else {
                body.style.display = 'block';
                arrow.classList.add('expanded');
                loadAiConfig(); // å±•å¼€æ—¶åŠ è½½
            }
        }

        function toggleKeyVis() {
            const input = document.getElementById('ai-key-input');
            // æ‰¾åˆ°å¯¹åº”çš„eye-iconï¼ˆåœ¨åŒä¸€ä¸ªapi-input-groupä¸­ï¼‰
            const inputGroup = input.closest('.api-input-group');
            const icon = inputGroup ? inputGroup.querySelector('.eye-icon') : null;
            if (input && icon) {
                if (input.type === 'password') {
                    input.type = 'text';
                    icon.textContent = 'éšè—';
                } else {
                    input.type = 'password';
                    icon.textContent = 'æ˜¾ç¤º';
                }
            }
        }

        function updateTempDisplay(val) {
            document.getElementById('temp-val-display').innerText = val;
        }
        
        // åŠ è½½ API é…ç½®
        async function loadAiConfig() {
            try {
                const urlItem = await db.dexiData.get('aiBaseUrl');
                const keyItem = await db.dexiData.get('aiApiKey');
                const modelItem = await db.dexiData.get('aiCurrentModel');
                const listItem = await db.dexiData.get('aiModelList');
                const tempItem = await db.dexiData.get('aiTemperature');

                if (urlItem) document.getElementById('ai-url-input').value = urlItem.value;
                if (keyItem) document.getElementById('ai-key-input').value = keyItem.value;
                if (tempItem) {
                    document.getElementById('ai-temp-slider').value = tempItem.value;
                    updateTempDisplay(tempItem.value);
                }
                
                // æ¢å¤ä¸‹æ‹‰æ¡†
                const select = document.getElementById('ai-model-select');
                if (listItem && listItem.value) {
                    const models = JSON.parse(listItem.value);
                    select.innerHTML = '<option value="" disabled>è¯·é€‰æ‹©æ¨¡å‹</option>';
                    models.forEach(m => {
                        const opt = document.createElement('option');
                        opt.value = m.id;
                        opt.text = m.id;
                        select.appendChild(opt);
                    });
                }
                
                if (modelItem) {
                    select.value = modelItem.value;
                }
                
                // åŠ è½½é¢„è®¾åˆ—è¡¨
                await loadApiPresetList();
            } catch (e) {
                console.error("åŠ è½½ API é…ç½®å¤±è´¥", e);
            }
        }
        
        // è‡ªåŠ¨ä¿å­˜ API é…ç½® (æ¯æ¬¡è¾“å…¥å˜æ›´æ—¶)
        async function autoSaveApi() {
            const url = document.getElementById('ai-url-input').value.trim();
            const key = document.getElementById('ai-key-input').value.trim();
            const model = document.getElementById('ai-model-select').value;
            const temp = document.getElementById('ai-temp-slider').value;
            
            await db.dexiData.put({ key: 'aiBaseUrl', value: url });
            await db.dexiData.put({ key: 'aiApiKey', value: key });
            await db.dexiData.put({ key: 'aiCurrentModel', value: model });
            await db.dexiData.put({ key: 'aiTemperature', value: temp });
        }
        
        // ========== API é¢„è®¾ç®¡ç† ==========
        
        // åŠ è½½é¢„è®¾åˆ—è¡¨åˆ°ä¸‹æ‹‰æ¡†
        async function loadApiPresetList() {
            const select = document.getElementById('api-preset-select');
            if (!select) return;
            
            try {
                const presetsData = await db.dexiData.get('apiPresets');
                const presets = presetsData?.value ? JSON.parse(presetsData.value) : [];
                const currentPresetData = await db.dexiData.get('currentApiPreset');
                const currentPresetName = currentPresetData?.value || '';
                
                select.innerHTML = '<option value="">-- é€‰æ‹©é¢„è®¾ --</option>';
                presets.forEach(preset => {
                    const opt = document.createElement('option');
                    opt.value = preset.name;
                    opt.textContent = preset.name;
                    if (preset.name === currentPresetName) {
                        opt.selected = true;
                    }
                    select.appendChild(opt);
                });
            } catch (e) {
                console.error('åŠ è½½APIé¢„è®¾åˆ—è¡¨å¤±è´¥:', e);
            }
        }
        
        // ä¿å­˜å½“å‰é…ç½®ä¸ºé¢„è®¾
        async function saveApiPreset() {
            const name = prompt('è¯·è¾“å…¥é¢„è®¾åç§°ï¼š');
            if (!name || !name.trim()) return;
            
            const presetName = name.trim();
            const url = document.getElementById('ai-url-input').value.trim();
            const key = document.getElementById('ai-key-input').value.trim();
            const model = document.getElementById('ai-model-select').value;
            const temp = document.getElementById('ai-temp-slider').value;
            const modelListData = await db.dexiData.get('aiModelList');
            const modelList = modelListData?.value || '[]';
            
            const newPreset = {
                name: presetName,
                url: url,
                key: key,
                model: model,
                temperature: temp,
                modelList: modelList
            };
            
            try {
                const presetsData = await db.dexiData.get('apiPresets');
                let presets = presetsData?.value ? JSON.parse(presetsData.value) : [];
                
                // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨åŒåé¢„è®¾
                const existingIndex = presets.findIndex(p => p.name === presetName);
                if (existingIndex >= 0) {
                    if (!confirm(`é¢„è®¾"${presetName}"å·²å­˜åœ¨ï¼Œæ˜¯å¦è¦†ç›–ï¼Ÿ`)) return;
                    presets[existingIndex] = newPreset;
                } else {
                    presets.push(newPreset);
                }
                
                await db.dexiData.put({ key: 'apiPresets', value: JSON.stringify(presets) });
                await db.dexiData.put({ key: 'currentApiPreset', value: presetName });
                
                await loadApiPresetList();
                alert(`é¢„è®¾"${presetName}"å·²ä¿å­˜ï¼`);
            } catch (e) {
                console.error('ä¿å­˜APIé¢„è®¾å¤±è´¥:', e);
                alert('ä¿å­˜é¢„è®¾å¤±è´¥ï¼š' + e.message);
            }
        }
        
        // åŠ è½½é€‰ä¸­çš„é¢„è®¾
        async function loadApiPreset(presetName) {
            if (!presetName) return;
            
            try {
                const presetsData = await db.dexiData.get('apiPresets');
                const presets = presetsData?.value ? JSON.parse(presetsData.value) : [];
                const preset = presets.find(p => p.name === presetName);
                
                if (!preset) {
                    alert('é¢„è®¾ä¸å­˜åœ¨');
                    return;
                }
                
                // åº”ç”¨é¢„è®¾åˆ°è¾“å…¥æ¡†
                document.getElementById('ai-url-input').value = preset.url || '';
                document.getElementById('ai-key-input').value = preset.key || '';
                document.getElementById('ai-temp-slider').value = preset.temperature || '0.7';
                updateTempDisplay(preset.temperature || '0.7');
                
                // æ¢å¤æ¨¡å‹åˆ—è¡¨å’Œé€‰æ‹©
                const select = document.getElementById('ai-model-select');
                if (preset.modelList) {
                    try {
                        const models = JSON.parse(preset.modelList);
                        select.innerHTML = '<option value="" disabled>è¯·é€‰æ‹©æ¨¡å‹</option>';
                        models.forEach(m => {
                            const opt = document.createElement('option');
                            opt.value = m.id;
                            opt.text = m.id;
                            select.appendChild(opt);
                        });
                    } catch (e) {
                        select.innerHTML = '<option value="" disabled>è¯·æ‹‰å–</option>';
                    }
                }
                if (preset.model) {
                    select.value = preset.model;
                }
                
                // ä¿å­˜åˆ°æ•°æ®åº“
                await db.dexiData.put({ key: 'aiBaseUrl', value: preset.url || '' });
                await db.dexiData.put({ key: 'aiApiKey', value: preset.key || '' });
                await db.dexiData.put({ key: 'aiCurrentModel', value: preset.model || '' });
                await db.dexiData.put({ key: 'aiTemperature', value: preset.temperature || '0.7' });
                await db.dexiData.put({ key: 'aiModelList', value: preset.modelList || '[]' });
                await db.dexiData.put({ key: 'currentApiPreset', value: presetName });
                
            } catch (e) {
                console.error('åŠ è½½APIé¢„è®¾å¤±è´¥:', e);
                alert('åŠ è½½é¢„è®¾å¤±è´¥ï¼š' + e.message);
            }
        }
        
        // åˆ é™¤å½“å‰é€‰ä¸­çš„é¢„è®¾
        async function deleteApiPreset() {
            const select = document.getElementById('api-preset-select');
            const presetName = select.value;
            
            if (!presetName) {
                alert('è¯·å…ˆé€‰æ‹©è¦åˆ é™¤çš„é¢„è®¾');
                return;
            }
            
            if (!confirm(`ç¡®å®šè¦åˆ é™¤é¢„è®¾"${presetName}"å—ï¼Ÿ`)) return;
            
            try {
                const presetsData = await db.dexiData.get('apiPresets');
                let presets = presetsData?.value ? JSON.parse(presetsData.value) : [];
                
                presets = presets.filter(p => p.name !== presetName);
                await db.dexiData.put({ key: 'apiPresets', value: JSON.stringify(presets) });
                
                // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰é¢„è®¾ï¼Œæ¸…ç©ºå½“å‰é¢„è®¾æ ‡è®°
                const currentPresetData = await db.dexiData.get('currentApiPreset');
                if (currentPresetData?.value === presetName) {
                    await db.dexiData.put({ key: 'currentApiPreset', value: '' });
                }
                
                await loadApiPresetList();
                alert(`é¢„è®¾"${presetName}"å·²åˆ é™¤`);
            } catch (e) {
                console.error('åˆ é™¤APIé¢„è®¾å¤±è´¥:', e);
                alert('åˆ é™¤é¢„è®¾å¤±è´¥ï¼š' + e.message);
            }
        }

        // NovelAI è®¾ç½®ç›¸å…³å‡½æ•°
        function toggleNovelAISettings() {
            const body = document.getElementById('novelai-setting-body');
            const arrow = document.getElementById('novelai-setting-arrow');
            if (body.style.display === 'none') {
                body.style.display = 'block';
                arrow.textContent = 'â–²';
                loadNovelAIConfig(); // å±•å¼€æ—¶åŠ è½½
            } else {
                body.style.display = 'none';
                arrow.textContent = 'â–¼';
            }
        }

        // åˆ‡æ¢NovelAIå¯†é’¥æ˜¾ç¤º
        function toggleNovelAIKeyVis() {
            const input = document.getElementById('novelai-api-key');
            const inputGroup = input.closest('.api-input-group');
            const icon = inputGroup ? inputGroup.querySelector('.eye-icon') : null;
            if (input && icon) {
                if (input.type === 'password') {
                    input.type = 'text';
                    icon.textContent = 'éšè—';
                } else {
                    input.type = 'password';
                    icon.textContent = 'æ˜¾ç¤º';
                }
            }
        }

        // æ›´æ–°NovelAIé‡‡æ ·æ­¥æ•°æ˜¾ç¤º
        function updateNovelAIStepsDisplay(val) {
            const display = document.getElementById('novelai-steps-value');
            if (display) display.textContent = val;
        }

        // æ›´æ–°NovelAIå¼•å¯¼å¼ºåº¦æ˜¾ç¤º
        function updateNovelAIScaleDisplay(val) {
            const display = document.getElementById('novelai-scale-value');
            if (display) display.textContent = val;
        }

        // åŠ è½½ NovelAI é…ç½®
        async function loadNovelAIConfig() {
            try {
                const apiKeyItem = await db.dexiData.get('novelaiApiKey');
                const proxyUrlItem = await db.dexiData.get('novelaiProxyUrl');
                const modelItem = await db.dexiData.get('novelaiModel');
                const stepsItem = await db.dexiData.get('novelaiSteps');
                const scaleItem = await db.dexiData.get('novelaiScale');
                const samplerItem = await db.dexiData.get('novelaiSampler');
                const sizeItem = await db.dexiData.get('novelaiSize');
                const systemPromptItem = await db.dexiData.get('novelaiSystemPrompt');
                const negativePromptItem = await db.dexiData.get('novelaiNegativePrompt');

                if (apiKeyItem) document.getElementById('novelai-api-key').value = apiKeyItem.value;
                if (proxyUrlItem) document.getElementById('novelai-proxy-url').value = proxyUrlItem.value;
                if (modelItem) document.getElementById('novelai-model').value = modelItem.value;
                if (stepsItem) {
                    document.getElementById('novelai-steps').value = stepsItem.value;
                    updateNovelAIStepsDisplay(stepsItem.value);
                }
                if (scaleItem) {
                    document.getElementById('novelai-scale').value = scaleItem.value;
                    updateNovelAIScaleDisplay(scaleItem.value);
                }
                if (samplerItem) document.getElementById('novelai-sampler').value = samplerItem.value;
                if (sizeItem) document.getElementById('novelai-size').value = sizeItem.value;
                if (systemPromptItem) document.getElementById('novelai-system-prompt').value = systemPromptItem.value;
                if (negativePromptItem) document.getElementById('novelai-negative-prompt').value = negativePromptItem.value;
            } catch (e) {
                console.error("åŠ è½½ NovelAI é…ç½®å¤±è´¥", e);
            }
        }

        // è‡ªåŠ¨ä¿å­˜ NovelAI é…ç½®
        async function autoSaveNovelAI() {
            const apiKey = document.getElementById('novelai-api-key').value.trim();
            const proxyUrl = document.getElementById('novelai-proxy-url').value.trim();
            const model = document.getElementById('novelai-model').value;
            const steps = document.getElementById('novelai-steps').value;
            const scale = document.getElementById('novelai-scale').value;
            const sampler = document.getElementById('novelai-sampler').value;
            const size = document.getElementById('novelai-size').value;
            const systemPrompt = document.getElementById('novelai-system-prompt').value.trim();
            const negativePrompt = document.getElementById('novelai-negative-prompt').value.trim();

            await db.dexiData.put({ key: 'novelaiApiKey', value: apiKey });
            await db.dexiData.put({ key: 'novelaiProxyUrl', value: proxyUrl });
            await db.dexiData.put({ key: 'novelaiModel', value: model });
            await db.dexiData.put({ key: 'novelaiSteps', value: steps });
            await db.dexiData.put({ key: 'novelaiScale', value: scale });
            await db.dexiData.put({ key: 'novelaiSampler', value: sampler });
            await db.dexiData.put({ key: 'novelaiSize', value: size });
            await db.dexiData.put({ key: 'novelaiSystemPrompt', value: systemPrompt });
            await db.dexiData.put({ key: 'novelaiNegativePrompt', value: negativePrompt });
        }

        // æµ‹è¯• NovelAI è¿æ¥
        async function testNovelAIConnection() {
            const apiKey = document.getElementById('novelai-api-key').value.trim();
            const proxyUrl = document.getElementById('novelai-proxy-url').value.trim();
            const resultDiv = document.getElementById('novelai-test-result');
            const btnText = document.getElementById('test-novelai-btn-text');

            if (!apiKey) {
                resultDiv.textContent = 'âŒ è¯·å…ˆè¾“å…¥ NovelAI API Key';
                resultDiv.style.color = '#ff3b30';
                return;
            }

            btnText.textContent = 'æµ‹è¯•ä¸­...';
            resultDiv.textContent = 'â³ æ­£åœ¨æµ‹è¯•è¿æ¥...';
            resultDiv.style.color = '#999';

            try {
                const testUrl = proxyUrl || 'https://image.novelai.net/ai/generate-image';
                
                // æ„é€ æµ‹è¯•è¯·æ±‚ï¼ˆä½¿ç”¨æœ€å°å‚æ•°ï¼‰
                const testPayload = {
                    input: 'test',
                    model: 'nai-diffusion-3',
                    action: 'generate',
                    parameters: {
                        width: 512,
                        height: 512,
                        scale: 7,
                        sampler: 'k_euler_ancestral',
                        steps: 1,
                        n_samples: 1,
                        seed: 0
                    }
                };

                const response = await fetch(testUrl, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(testPayload)
                });

                if (response.ok) {
                    resultDiv.textContent = 'âœ… NovelAI è¿æ¥æˆåŠŸï¼';
                    resultDiv.style.color = '#34C759';
                } else {
                    const errorText = await response.text();
                    resultDiv.textContent = `âŒ è¿æ¥å¤±è´¥ (${response.status}): ${errorText.substring(0, 100)}`;
                    resultDiv.style.color = '#ff3b30';
                }
            } catch (err) {
                resultDiv.textContent = `âŒ è¿æ¥é”™è¯¯: ${err.message}`;
                resultDiv.style.color = '#ff3b30';
            } finally {
                btnText.textContent = 'æµ‹è¯• NovelAI è¿æ¥';
            }
        }

        // æ„é€ æ™ºèƒ½ URL (è‡ªåŠ¨è¡¥å…¨ /v1)
        function getSmartUrl(baseUrl, endpoint) {
            let url = baseUrl;
            if (url.endsWith('/')) url = url.slice(0, -1);
            // å¦‚æœç”¨æˆ·æ²¡æœ‰å†™ /v1ï¼Œä¸”ä¸æ˜¯ç›´æ¥è¯·æ±‚å®Œæ•´è·¯å¾„ï¼Œè‡ªåŠ¨è¡¥å…¨ /v1
            if (!url.includes('/v1')) {
                url += '/v1';
            }
            return url + endpoint;
        }

        // æ‹‰å–æ¨¡å‹åˆ—è¡¨
        async function fetchModels() {
            const url = document.getElementById('ai-url-input').value.trim();
            const key = document.getElementById('ai-key-input').value.trim();
            
            if (!url) {
                alert("è¯·å…ˆå¡«å†™åä»£åœ°å€");
                return;
            }

            const spinner = document.getElementById('fetch-spinner');
            const btnText = document.getElementById('fetch-text');
            spinner.style.display = 'inline-block';
            btnText.style.display = 'none';
            
            // æ„é€ è¯·æ±‚ URL: è‡ªåŠ¨è¡¥å…¨ /v1/models
            const requestUrl = getSmartUrl(url, '/models');

            try {
                const res = await fetch(requestUrl, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${key}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!res.ok) {
                    throw new Error(`HTTP Error ${res.status}`);
                }
                
                const data = await res.json();
                let models = [];
                if (Array.isArray(data)) {
                    models = data;
                } else if (data.data && Array.isArray(data.data)) {
                    models = data.data;
                }
                
                const select = document.getElementById('ai-model-select');
                select.innerHTML = '<option value="" disabled selected>è¯·é€‰æ‹©æ¨¡å‹</option>';
                models.forEach(m => {
                    const opt = document.createElement('option');
                    opt.value = m.id;
                    opt.text = m.id;
                    select.appendChild(opt);
                });
                
                await db.dexiData.put({ key: 'aiModelList', value: JSON.stringify(models) });
                alert(`æˆåŠŸè·å– ${models.length} ä¸ªæ¨¡å‹ï¼`);
                
            } catch (err) {
                console.error(err);
                alert(`æ‹‰å–å¤±è´¥: ${err.message}\nå°è¯•è¯·æ±‚: ${requestUrl}`);
            } finally {
                spinner.style.display = 'none';
                btnText.style.display = 'inline';
            }
        }

        // æµ‹è¯•è¿æ¥
        async function testConnection() {
            const url = document.getElementById('ai-url-input').value.trim();
            const key = document.getElementById('ai-key-input').value.trim();
            const model = document.getElementById('ai-model-select').value;
            
            if (!url || !model) {
                alert("è¯·å…ˆå®Œå–„é…ç½®å¹¶é€‰æ‹©æ¨¡å‹");
                return;
            }

            const btn = document.querySelector('.test-btn');
            const originalText = document.getElementById('test-btn-text').innerText;
            document.getElementById('test-btn-text').innerText = "æµ‹è¯•ä¸­...";
            btn.style.opacity = "0.7";

            // æ„é€ ç®€å•çš„ Chat è¯·æ±‚
            const requestUrl = getSmartUrl(url, '/chat/completions');
            
            try {
                const res = await fetch(requestUrl, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${key}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: model,
                        messages: [{ role: "user", content: "Hi" }],
                        max_tokens: 5
                    })
                });

                if (res.ok) {
                    alert("âœ… è¿æ¥æˆåŠŸï¼API é…ç½®æœ‰æ•ˆã€‚");
                } else {
                    const errText = await res.text();
                    alert(`âŒ è¿æ¥å¤±è´¥ (${res.status}):\n${errText}`);
                }
            } catch (e) {
                alert(`âŒ ç½‘ç»œé”™è¯¯: ${e.message}`);
            } finally {
                document.getElementById('test-btn-text').innerText = originalText;
                btn.style.opacity = "1";
            }
        }

        // æ ¸å¿ƒï¼šä¿å­˜æ‰€æœ‰è®¾ç½®åˆ°DEXie (ä¿ç•™åŸæœ‰é€»è¾‘ï¼Œä»…æ’é™¤ AI ç›¸å…³ key é˜²æ­¢è¦†ç›–)
        async function saveAllSetting() {
            // ... (AIé…ç½®ç‹¬ç«‹ä¿å­˜ï¼Œè¿™é‡Œåªè´Ÿè´£ä¸ªæ€§åŒ–è®¾ç½®)
            // æ•´ç†æ‰€æœ‰è¦å­˜å‚¨çš„æ•°æ®
            const saveData = {
                wallpaper: document.getElementById('desktop-body').style.backgroundImage.replace(/url\(|\)|"/g, ''),
                widgetIcon: document.getElementById('widget-icon').style.backgroundImage.replace(/url\(|\)|"/g, ''),
                widgetTitle: document.getElementById('widget-title-input').value.trim() || '{`{ lovely Day Â¸.*ãƒ»~ â˜…`}',
                widgetSubtext: document.getElementById('widget-subtext-input').value.trim() || 'ä¸–ç•Œç ´ç ´çƒ‚çƒ‚å°çŒ«ç¼ç¼è¡¥è¡¥ ğŸ¾',
                photoLeft: document.getElementById('img-left').style.backgroundImage.replace(/url\(|\)|"/g, ''),
                photoRight: document.getElementById('img-right').style.backgroundImage.replace(/url\(|\)|"/g, ''),
                avatar1: document.getElementById('avatar-img-1').style.backgroundImage.replace(/url\(|\)|"/g, ''),
                avatar2: document.getElementById('avatar-img-2').style.backgroundImage.replace(/url\(|\)|"/g, ''),
                avatar1Bubble: document.getElementById('avatar1-bubble-input').value.trim() || '> .. <',
                avatar1Name: document.getElementById('avatar1-name-input').value.trim() || '> .. <',
                avatar2Bubble: document.getElementById('avatar2-bubble-input').value.trim() || 'gw..â™¡',
                avatar2Name: document.getElementById('avatar2-name-input').value.trim() || 'gw..â™¡',
                daysText: document.getElementById('days-input').value.trim() || '446 days'
            };
            
            // ... (åç»­é€»è¾‘ä¸å˜ï¼Œä½†æ³¨æ„ clear() ä¼šæ¸…é™¤ AI é…ç½®ï¼Œéœ€è¦ä¿®æ”¹)
            
            // â˜… ä¿®æ”¹ç‚¹ï¼šä¸èƒ½ç›´æ¥ db.dexiData.clear()ï¼Œå› ä¸ºä¼šåˆ æ‰ AI é…ç½®
            // æ–¹æ¡ˆï¼šåª put æ›´æ–°è¿™äº› UI ç›¸å…³çš„ keyï¼Œä¸ä½¿ç”¨ clear
            
            // å­˜å‚¨åº”ç”¨å›¾æ ‡
            const iconIds = ['setting','notes','remind','facetime','photo','camera'];
            iconIds.forEach(id => {
                saveData[`icon${id.charAt(0).toUpperCase() + id.slice(1)}`] = document.getElementById(`icon-${id}`).querySelector('.icon').style.backgroundImage.replace(/url\(|\)|"/g, '');
            });
            // å­˜å‚¨Dockå›¾æ ‡
            const dockIds = ['setting','custom','message','music'];
            dockIds.forEach(id => {
                saveData[`dock${id.charAt(0).toUpperCase() + id.slice(1)}`] = document.getElementById(`dock-${id}`).querySelector('.icon').style.backgroundImage.replace(/url\(|\)|"/g, '');
            });

            // ä¿å­˜æ¤­åœ†å½¢é¢œè‰²
            const capsuleColor = document.getElementById('capsule-color-input').value;
            const bubbleColor = document.getElementById('bubble-color-input').value;
            saveData.capsuleColor = capsuleColor;
            saveData.bubbleColor = bubbleColor;

            // ä¿å­˜è‡ªå®šä¹‰å­—ä½“
            const customFontUrl = document.getElementById('custom-font-input').value.trim();
            const customFontName = document.getElementById('custom-font-name-input').value.trim();
            saveData.customFontUrl = customFontUrl;
            saveData.customFontName = customFontName;

            // å¾ªç¯ä¿å­˜
            for (const [key, value] of Object.entries(saveData)) {
                await db.dexiData.put({ key, value });
            }

            // å®æ—¶æ›´æ–°é¡µé¢æ˜¾ç¤º
            document.getElementById('widget-title').innerText = saveData.widgetTitle;
            document.getElementById('widget-subtext').innerText = saveData.widgetSubtext;
            document.getElementById('avatar-bubble1').innerText = saveData.avatar1Bubble;
            document.getElementById('avatar-name1').innerText = saveData.avatar1Name;
            document.getElementById('avatar-bubble2').innerText = saveData.avatar2Bubble;
            document.getElementById('avatar-name2').innerText = saveData.avatar2Name;
            document.getElementById('days-text').innerText = saveData.daysText;
            
            // åº”ç”¨æ¤­åœ†å½¢é¢œè‰²
            document.documentElement.style.setProperty('--capsule-bg', capsuleColor);
            document.documentElement.style.setProperty('--bubble-bg', bubbleColor);

            // åº”ç”¨è‡ªå®šä¹‰å­—ä½“åˆ°å…¨å±€
            if (customFontUrl && customFontName) {
                loadCustomFont(customFontUrl, customFontName, false);
            }

            // ä¿å­˜æç¤º
            const tip = document.getElementById('save-tip');
            tip.style.display = 'block';
            setTimeout(() => tip.style.display = 'none', 1500);
        }

// --- æ—¥å†æ—¶é—´è®¾å®šé€»è¾‘ (Premium Pink Pro) ---

const calendar = {
    date: new Date(),        // å½“å‰æµè§ˆçš„æ—¥æœŸï¼ˆç”¨äºç¿»é¡µï¼‰
    selectedDate: new Date(), // ç”¨æˆ·é€‰ä¸­çš„æ—¥æœŸ
    isSelectorOpen: false,   // çŠ¶æ€æ ‡è¯†
    isInitialized: false,    // æ˜¯å¦å·²åˆå§‹åŒ–

    elements: {},

    months: ["1æœˆ Â· January", "2æœˆ Â· February", "3æœˆ Â· March", "4æœˆ Â· April", "5æœˆ Â· May", "6æœˆ Â· June", "7æœˆ Â· July", "8æœˆ Â· August", "9æœˆ Â· September", "10æœˆ Â· October", "11æœˆ Â· November", "12æœˆ Â· December"],
    monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],

    init() {
        if (this.isInitialized) return;
        
        this.elements = {
            // Containers
            calendarLayer: document.getElementById('cal-calendarLayer'),
            selectorLayer: document.getElementById('cal-selectorLayer'),
            
            // Display/Inputs
            headerBtn: document.getElementById('cal-headerTitleBtn'),
            headerText: document.getElementById('cal-monthYearText'),
            daysContainer: document.getElementById('cal-daysContainer'),
            monthGrid: document.getElementById('cal-monthGrid'),
            yearList: document.getElementById('cal-yearList'),
            
            // Buttons
            prevBtn: document.getElementById('cal-prevBtn'),
            nextBtn: document.getElementById('cal-nextBtn'),
            
            // Time
            hourInput: document.getElementById('cal-hourInput'),
            minuteInput: document.getElementById('cal-minuteInput'),
            confirmBtn: document.getElementById('cal-confirmBtn')
        };

        this.bindEvents();
        this.renderSelectorItems();
        this.isInitialized = true;
    },

    // æ¸²æŸ“æ—¥å†ç½‘æ ¼
    render() {
        // è®¾ç½®æ ‡é¢˜
        this.elements.headerText.innerHTML = `${this.months[this.date.getMonth()].split(' Â· ')[0]} <span style="font-weight:300; opacity:0.6; font-size:0.9em">${this.date.getFullYear()}</span>`;

        this.date.setDate(1);
        const lastDay = new Date(this.date.getFullYear(), this.date.getMonth() + 1, 0).getDate();
        const firstDayIndex = this.date.getDay(); // 0 is Sunday
        
        let daysHTML = "";

        // ç©ºç™½å ä½
        for (let x = 0; x < firstDayIndex; x++) {
            daysHTML += `<div class="day fade"></div>`;
        }

        // æ—¥æœŸ
        for (let i = 1; i <= lastDay; i++) {
            const isToday = i === new Date().getDate() && 
                          this.date.getMonth() === new Date().getMonth() && 
                          this.date.getFullYear() === new Date().getFullYear();
            
            const isSelected = i === this.selectedDate.getDate() &&
                             this.date.getMonth() === this.selectedDate.getMonth() &&
                             this.date.getFullYear() === this.selectedDate.getFullYear();

            let classes = "day";
            if (isToday) classes += " today";
            if (isSelected) classes += " selected";

            // ä½¿ç”¨ onclick å­—ç¬¦ä¸²ç»‘å®šå¯èƒ½ä¼šæœ‰é—®é¢˜ï¼Œè¿™é‡Œæ”¹ç”¨äº‹ä»¶å§”æ‰˜æˆ–ç›´æ¥ç”ŸæˆHTMLåç»‘å®š
            // ä¸ºäº†ç®€å•ï¼Œæˆ‘ä»¬ä½¿ç”¨å…¨å±€å‡½æ•° calendarSelectDay
            daysHTML += `<div class="${classes}" onclick="calendarSelectDay(${i})">${i}</div>`;
        }

        this.elements.daysContainer.innerHTML = daysHTML;
        
        // æ›´æ–°é€‰æ‹©å™¨çš„é«˜äº®çŠ¶æ€
        this.updateSelectorHighlights();
    },

    // æ¸²æŸ“é€‰æ‹©å™¨çš„å†…å®¹ï¼ˆæœˆä»½å’Œå¹´ä»½åˆ—è¡¨ï¼‰
    renderSelectorItems() {
        // 1. æ¸²æŸ“æœˆä»½
        let mHtml = '';
        this.months.forEach((m, index) => {
            const ch = m.split(' Â· ')[0];
            const en = this.monthsShort[index];
            mHtml += `<div class="sel-month-item" onclick="calendarSetMonth(${index})">
                <span style="font-weight:700">${ch}</span> 
                <span style="font-size:0.8em; opacity:0.7">${en}</span>
            </div>`;
        });
        this.elements.monthGrid.innerHTML = mHtml;

        // 2. æ¸²æŸ“å¹´ä»½ (å‰å50å¹´)
        const currentYear = new Date().getFullYear();
        let yHtml = '';
        for(let y = currentYear - 50; y <= currentYear + 50; y++) {
            yHtml += `<div class="sel-year-item" id="year-${y}" onclick="calendarSetYear(${y})">${y}</div>`;
        }
        this.elements.yearList.innerHTML = yHtml;
    },

    updateSelectorHighlights() {
        // é«˜äº®æœˆä»½
        const monthItems = this.elements.monthGrid.children;
        for(let item of monthItems) item.classList.remove('selected');
        if(monthItems[this.date.getMonth()]) monthItems[this.date.getMonth()].classList.add('selected');

        // é«˜äº®å¹´ä»½å¹¶æ»šåŠ¨
        const yearItems = this.elements.yearList.children;
        for(let item of yearItems) item.classList.remove('selected');
        
        const activeYearEl = document.getElementById(`year-${this.date.getFullYear()}`);
        if(activeYearEl) {
            activeYearEl.classList.add('selected');
            // å¦‚æœé¢æ¿å¼€ç€ï¼Œæ‰æ»šåŠ¨ï¼Œå¦åˆ™ä¼šåœ¨åå°ä¹±æ»š
            if(this.isSelectorOpen) {
                activeYearEl.scrollIntoView({block: "center", behavior: "smooth"});
            }
        }
    },

    toggleSelector() {
        this.isSelectorOpen = !this.isSelectorOpen;
        
        if(this.isSelectorOpen) {
            this.elements.calendarLayer.classList.remove('active');
            this.elements.selectorLayer.classList.add('active');
            this.elements.headerBtn.classList.add('active');
            
            this.elements.prevBtn.style.opacity = '0';
            this.elements.prevBtn.style.pointerEvents = 'none';
            this.elements.nextBtn.style.opacity = '0';
            this.elements.nextBtn.style.pointerEvents = 'none';

            setTimeout(() => {
                const activeYear = document.getElementById(`year-${this.date.getFullYear()}`);
                if(activeYear) activeYear.scrollIntoView({block: "center"});
            }, 100);

        } else {
            this.elements.selectorLayer.classList.remove('active');
            this.elements.calendarLayer.classList.add('active');
            this.elements.headerBtn.classList.remove('active');

            this.elements.prevBtn.style.opacity = '1';
            this.elements.prevBtn.style.pointerEvents = 'auto';
            this.elements.nextBtn.style.opacity = '1';
            this.elements.nextBtn.style.pointerEvents = 'auto';
        }
    },

    setMonth(index) {
        this.date.setMonth(index);
        this.render();
    },

    setYear(year) {
        this.date.setFullYear(year);
        this.render();
    },
    
    selectDay(day) {
        this.selectedDate = new Date(this.date.getFullYear(), this.date.getMonth(), day);
        // ä¿ç•™å½“å‰çš„å°æ—¶åˆ†é’Ÿ
        const h = parseInt(this.elements.hourInput.value) || 0;
        const m = parseInt(this.elements.minuteInput.value) || 0;
        this.selectedDate.setHours(h);
        this.selectedDate.setMinutes(m);
        
        this.render();
    },

    updateTimeInputs() {
        const h = this.selectedDate.getHours().toString().padStart(2, '0');
        const m = this.selectedDate.getMinutes().toString().padStart(2, '0');
        this.elements.hourInput.value = h;
        this.elements.minuteInput.value = m;
    },

    bindEvents() {
        // å¤´éƒ¨ç‚¹å‡» -> æ‰“å¼€é€‰æ‹©å™¨
        this.elements.headerBtn.addEventListener('click', () => this.toggleSelector());

        // å·¦å³å¯¼èˆª
        this.elements.prevBtn.addEventListener('click', () => {
            this.date.setMonth(this.date.getMonth() - 1);
            this.render();
        });
        this.elements.nextBtn.addEventListener('click', () => {
            this.date.setMonth(this.date.getMonth() + 1);
            this.render();
        });

        // æ—¶é—´è¾“å…¥åŠç¡®è®¤
        const formatTime = (e) => {
            let val = parseInt(e.target.value);
            const max = e.target.id === 'cal-hourInput' ? 23 : 59;
            if(isNaN(val) || val < 0) val = 0; if(val > max) val = max;
            e.target.value = val.toString().padStart(2, '0');
            
            // æ›´æ–° selectedDate
            if (e.target.id === 'cal-hourInput') this.selectedDate.setHours(val);
            else this.selectedDate.setMinutes(val);
        };

        this.elements.hourInput.addEventListener('change', formatTime);
        this.elements.minuteInput.addEventListener('change', formatTime);
        
        // ç¡®è®¤æŒ‰é’®é€»è¾‘
        this.elements.confirmBtn.addEventListener('click', () => {
            if (this.isSelectorOpen) {
                this.toggleSelector(); // å…³é—­é€‰æ‹©å™¨ï¼Œå›åˆ°æ—¥å†è§†å›¾
            } else {
                saveCalendarTime(); // è°ƒç”¨å…¨å±€ä¿å­˜å‡½æ•°
            }
        });
    }
};

// å…¨å±€è¾…åŠ©å‡½æ•°ä¾› onclick è°ƒç”¨
function calendarSelectDay(day) {
    calendar.selectDay(day);
}
function calendarSetMonth(index) {
    calendar.setMonth(index);
}
function calendarSetYear(year) {
    calendar.setYear(year);
}

// ä¸»å…¥å£
// æ˜¾ç¤ºè¡£æŸœé¡µé¢
function showWardrobePage() {
    closeChatPanel();
    const wardrobePage = document.getElementById('wardrobe-page');
    if (wardrobePage) {
        wardrobePage.style.display = 'flex';
        // åŠ è½½ä¿å­˜çš„äººç‰©å½¢è±¡
        loadWardrobeCharacter();
    }
}

// éšè—è¡£æŸœé¡µé¢
function hideWardrobePage() {
    const wardrobePage = document.getElementById('wardrobe-page');
    if (wardrobePage) {
        wardrobePage.style.display = 'none';
    }
}

// è¡£æŸœç”Ÿæˆå›¾ç‰‡ç›¸å…³å‡½æ•°
let wardrobeGenerateType = 'character';
let wardrobeGender = 'female'; // é»˜è®¤å¥³ç”Ÿ

function openWardrobeGenerateModal() {
    const modal = document.getElementById('wardrobe-generate-modal');
    if (modal) {
        modal.style.display = 'flex';
        wardrobeGenerateType = 'character';
        wardrobeGender = 'female';
        selectWardrobeGenerateType('character', document.getElementById('wardrobe-btn-character'));
        selectWardrobeGender('female', document.getElementById('wardrobe-gender-female'));
        document.getElementById('wardrobe-generate-prompt').value = '';
    }
}

function closeWardrobeGenerateModal() {
    const modal = document.getElementById('wardrobe-generate-modal');
    if (modal) {
        modal.style.display = 'none';
        document.getElementById('wardrobe-generate-loading').style.display = 'none';
    }
}

function selectWardrobeGenerateType(type, element) {
    wardrobeGenerateType = type;
    // æ›´æ–°æŒ‰é’®æ ·å¼
    const allBtns = document.querySelectorAll('#wardrobe-btn-character, #wardrobe-btn-clothes');
    allBtns.forEach(btn => {
        btn.style.border = '2px solid #eee';
        btn.style.background = '#fff';
        btn.style.color = '#666';
    });
    element.style.border = '2px solid var(--ins-pink)';
    element.style.background = '#fff0f5';
    element.style.color = 'var(--ins-pink)';
    
    // æ§åˆ¶æ€§åˆ«é€‰æ‹©çš„æ˜¾ç¤ºï¼ˆåªåœ¨äººç‰©å½¢è±¡æ—¶æ˜¾ç¤ºï¼‰
    const genderSelect = document.getElementById('wardrobe-gender-select');
    if (genderSelect) {
        genderSelect.style.display = type === 'character' ? 'block' : 'none';
    }
}

// æ€§åˆ«é€‰æ‹©å‡½æ•°
function selectWardrobeGender(gender, element) {
    wardrobeGender = gender;
    // æ›´æ–°æŒ‰é’®æ ·å¼
    const allBtns = document.querySelectorAll('.wardrobe-gender-btn');
    allBtns.forEach(btn => {
        btn.style.border = '2px solid #eee';
        btn.style.background = '#fff';
        btn.style.color = '#666';
    });
    
    if (gender === 'female') {
        element.style.border = '2px solid #ff69b4';
        element.style.background = '#fff0f5';
        element.style.color = '#ff69b4';
    } else {
        element.style.border = '2px solid #4a90e2';
        element.style.background = '#f0f7ff';
        element.style.color = '#4a90e2';
    }
}

async function generateWardrobeImage() {
    const prompt = document.getElementById('wardrobe-generate-prompt').value.trim();
    if (!prompt) {
        alert('è¯·è¾“å…¥ç”Ÿæˆè¦æ±‚');
        return;
    }

    // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
    const loadingDiv = document.getElementById('wardrobe-generate-loading');
    const confirmBtn = document.querySelector('.generate-confirm-btn');
    loadingDiv.style.display = 'block';
    confirmBtn.disabled = true;
    confirmBtn.textContent = 'ç”Ÿæˆä¸­...';

    try {
        // è·å–NovelAIé…ç½®
        const apiKeyItem = await db.dexiData.get('novelaiApiKey');
        const proxyUrlItem = await db.dexiData.get('novelaiProxyUrl');
        const modelItem = await db.dexiData.get('novelaiModel');
        const stepsItem = await db.dexiData.get('novelaiSteps');
        const scaleItem = await db.dexiData.get('novelaiScale');
        const samplerItem = await db.dexiData.get('novelaiSampler');
        const sizeItem = await db.dexiData.get('novelaiSize');

        if (!apiKeyItem || !apiKeyItem.value) {
            throw new Error('è¯·å…ˆåœ¨è®¾ç½®ä¸­é…ç½® NovelAI API Key');
        }

        const apiKey = apiKeyItem.value;
        const proxyUrl = proxyUrlItem ? proxyUrlItem.value : 'https://image.novelai.net/ai/generate-image';
        const model = modelItem ? modelItem.value : 'nai-diffusion-4-5-full';
        const steps = stepsItem ? parseInt(stepsItem.value) : 28;
        const scale = scaleItem ? parseFloat(scaleItem.value) : 11;
        const sampler = samplerItem ? samplerItem.value : 'k_euler_ancestral';
        const size = sizeItem ? sizeItem.value : '832x1216';
        // è§£æå°ºå¯¸
        const [width, height] = size.split('x').map(Number);

        // è·å–å‚è€ƒå›¾ï¼ˆç”¨äºå›¾ç”Ÿå›¾ï¼‰
        let referenceImageBase64 = null;
        let cleanImage = null; // å»é™¤å‰ç¼€åçš„çº¯ base64 æ•°æ®
        
        if (wardrobeGenerateType === 'clothes') {
            // ç”Ÿæˆè¡£æœæ—¶ï¼Œè·å–å½“å‰äººç‰©å½¢è±¡ä½œä¸ºå‚è€ƒå›¾
            const charImg = document.getElementById('wardrobe-char-base');
            if (charImg && charImg.src && !charImg.src.includes('character.png')) {
                try {
                    // å°†å›¾ç‰‡è½¬æ¢ä¸º base64
                    referenceImageBase64 = await imageToBase64(charImg.src);
                    // å…³é”®ä¿®å¤ï¼šå»é™¤ base64 çš„å¤´ (data:image/png;base64,)
                    cleanImage = referenceImageBase64.replace(/^data:image\/\w+;base64,/, "");
                    console.log('å·²è·å–å‚è€ƒå›¾ï¼Œå‡†å¤‡è¿›è¡Œå›¾ç”Ÿå›¾ï¼Œçº¯ base64 é•¿åº¦:', cleanImage.length);
                } catch (e) {
                    console.warn('è·å–å‚è€ƒå›¾å¤±è´¥ï¼Œå°†ä½¿ç”¨çº¯æ–‡ç”Ÿå›¾:', e);
                }
            }
            
            // å¦‚æœæ²¡æœ‰å‚è€ƒå›¾ï¼Œæç¤ºç”¨æˆ·
            if (!cleanImage) {
                alert('è¯·å…ˆç”Ÿæˆäººç‰©å½¢è±¡åå†æ¢è£…');
                loadingDiv.style.display = 'none';
                confirmBtn.disabled = false;
                confirmBtn.textContent = 'ç”Ÿæˆ';
                return;
            }
        }
        
        // æ„å»ºå®Œæ•´çš„prompt
        let fullPrompt = '';
        let wardrobeNegativePrompt = '';
        
        if (wardrobeGenerateType === 'character') {
            // äººç‰©å½¢è±¡ï¼šæ ¹æ®é€‰æ‹©çš„æ€§åˆ«æ·»åŠ å¯¹åº”æ ‡ç­¾
            if (wardrobeGender === 'male') {
                // ç”·ç”Ÿï¼šå°† prompt (ä½ çš„è¾“å…¥) æ”¾åœ¨æœ€æœ€å‰é¢ï¼
                fullPrompt = prompt + ', 1boy, male, full body, standing, solo, masterpiece, best quality, highly detailed';
                wardrobeNegativePrompt = 'girl, female, woman, 1girl, feminine, worst quality, low quality, blurry, watermark, signature, cropped, cut off, half body, upper body, close-up, portrait, multiple views, background scenery, complex background, landscape, text, logo';
            } else {
                // å¥³ç”Ÿï¼šå°† prompt (ä½ çš„è¾“å…¥) æ”¾åœ¨æœ€æœ€å‰é¢ï¼
                fullPrompt = prompt + ', 1girl, female, full body, standing, solo, masterpiece, best quality, highly detailed';
                wardrobeNegativePrompt = 'boy, male, man, 1boy, masculine, worst quality, low quality, blurry, watermark, signature, cropped, cut off, half body, upper body, close-up, portrait, multiple views, background scenery, complex background, landscape, text, logo';
            }
        } else {
            // æ¢è£…æ¨¡å¼ï¼šå¿…é¡»å¸¦ä¸Šæ€§åˆ«å’ŒåŸºç¡€è´¨é‡è¯ï¼ŒæŠŠç”¨æˆ·çš„è¡£æœæè¿°(prompt)æ”¾åœ¨æœ€å‰é¢
            const genderTags = wardrobeGender === 'male' ? '1boy, male' : '1girl, female';
            fullPrompt = prompt + ', ' + genderTags + ', full body, standing, solo, masterpiece, best quality, highly detailed';
            wardrobeNegativePrompt = 'worst quality, low quality, blurry, watermark, text, logo, nsfw';
        }

        // åˆ¤æ–­æ¨¡å‹ç‰ˆæœ¬
        const isV4 = model.includes('nai-diffusion-4');
        
        // æ ¹æ®æ¨¡å‹ç‰ˆæœ¬é€‰æ‹©æ­£ç¡®çš„ç«¯ç‚¹
        const isCustomProxy = proxyUrl && proxyUrl !== 'https://image.novelai.net/ai/generate-image' && proxyUrl !== 'https://image.novelai.net/ai/generate-image-stream';
        let apiUrl;
        if (isCustomProxy) {
            apiUrl = proxyUrl;
        } else {
            apiUrl = isV4 ? 'https://image.novelai.net/ai/generate-image-stream' : 'https://image.novelai.net/ai/generate-image';
        }

        // æ„å»ºè¯·æ±‚ä½“
        let requestBody;
        if (isV4) {
            // V4/V4.5 ä½¿ç”¨æ–°æ ¼å¼
            requestBody = {
                input: fullPrompt, // V4 éœ€è¦ input å­—æ®µ
                model: model,
                action: 'generate',
                parameters: {
                    width: width,
                    height: height,
                    scale: scale,
                    sampler: sampler,
                    steps: steps,
                    seed: Math.floor(Math.random() * 9999999999),
                    n_samples: 1,
                    ucPreset: 0,
                    qualityToggle: true,
                    sm: false,
                    sm_dyn: false,
                    dynamic_thresholding: false,
                    controlnet_strength: 1,
                    legacy: false,
                    add_original_image: false,
                    cfg_rescale: 0,
                    noise_schedule: 'native',
                    negative_prompt: wardrobeNegativePrompt
                }
            };
            
            // å¦‚æœæ˜¯æ¢è£…æ¨¡å¼ï¼Œæ·»åŠ å›¾ç”Ÿå›¾å‚æ•°
            if (cleanImage) {
                console.log('å¯ç”¨å›¾ç”Ÿå›¾æ¨¡å¼ (V4 img2img)');
                // æ˜ç¡®å‘Šè¯‰ API è¿™æ˜¯å›¾ç”Ÿå›¾
                requestBody.action = 'img2img';
                // ä½¿ç”¨å»é™¤äº†å‰ç¼€çš„å›¾ç‰‡æ•°æ®
                requestBody.parameters.image = cleanImage;
                // é‡ç»˜å¹…åº¦ï¼š0.7 å·¦å³èƒ½åœ¨ä¿æŒå§¿åŠ¿çš„åŒæ—¶æ¢è¡£æœ
                requestBody.parameters.strength = 0.7;
                // ç¨å¾®åŠ ä¸€ç‚¹å™ªç‚¹å¢åŠ ç»†èŠ‚
                requestBody.parameters.noise = 0.1;
                requestBody.parameters.extra_noise_seed = requestBody.parameters.seed;
                
                console.log('å‚è€ƒå›¾ base64 é•¿åº¦:', cleanImage.length);
            }
        } else {
            // V3 ä½¿ç”¨æ—§æ ¼å¼
            requestBody = {
                input: fullPrompt,
                model: model,
                action: 'generate',
                parameters: {
                    width: width,
                    height: height,
                    scale: scale,
                    sampler: sampler,
                    steps: steps,
                    seed: Math.floor(Math.random() * 9999999999),
                    n_samples: 1,
                    ucPreset: 0,
                    qualityToggle: true,
                    negative_prompt: wardrobeNegativePrompt
                }
            };
            
            // å¦‚æœæ˜¯æ¢è£…æ¨¡å¼ï¼Œæ·»åŠ å›¾ç”Ÿå›¾å‚æ•°ï¼ˆV3ï¼‰
            if (cleanImage) {
                console.log('å¯ç”¨å›¾ç”Ÿå›¾æ¨¡å¼ (V3 img2img)');
                requestBody.action = 'img2img';
                requestBody.parameters.image = cleanImage;
                requestBody.parameters.strength = 0.7;
                requestBody.parameters.noise = 0.1;
                requestBody.parameters.extra_noise_seed = requestBody.parameters.seed;
                
                console.log('å‚è€ƒå›¾ base64 é•¿åº¦:', cleanImage.length);
            }
        }

        // å‘é€è¯·æ±‚
        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${apiKey}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`ç”Ÿæˆå¤±è´¥: ${response.status} ${errorText.substring(0, 200)}`);
        }

        // å¤„ç†å“åº”
        const contentType = response.headers.get('content-type');
        let imageUrl;
        
        if (contentType && contentType.includes('text/event-stream')) {
            // SSE æµå¼å“åº”ï¼ˆV4ï¼‰
            const text = await response.text();
            console.log('SSE å“åº”å‰ 500 å­—ç¬¦:', text.substring(0, 500));
            const lines = text.trim().split('\n');
            let base64Data = null;
            
            // ä»åå¾€å‰æŸ¥æ‰¾æœ€åä¸€ä¸ªåŒ…å«å›¾ç‰‡æ•°æ®çš„è¡Œ
            for (let i = lines.length - 1; i >= 0; i--) {
                const line = lines[i].trim();
                if (line.startsWith('data: ') && line !== 'data: [DONE]') {
                    const dataContent = line.substring(6);
                    try {
                        const jsonData = JSON.parse(dataContent);
                        console.log('è§£æåˆ° JSON æ•°æ®:', jsonData);
                        
                        // æ£€æŸ¥æ˜¯å¦æ˜¯é”™è¯¯äº‹ä»¶
                        if (jsonData.event_type === 'error' || jsonData.event === 'error') {
                            const errorMsg = jsonData.message || jsonData.error || 'NovelAI ç”Ÿæˆå¤±è´¥';
                            console.error('NovelAI é”™è¯¯:', jsonData);
                            throw new Error(`NovelAI API é”™è¯¯: ${errorMsg}`);
                        }
                        
                        // å°è¯•å„ç§å¯èƒ½çš„å­—æ®µ
                        if (jsonData.event_type === 'final' && jsonData.image) {
                            base64Data = jsonData.image;
                            console.log('æ‰¾åˆ°å›¾ç‰‡æ•°æ® (final.image)');
                            break;
                        }
                        if (jsonData.final && jsonData.final.image) {
                            base64Data = jsonData.final.image;
                            console.log('æ‰¾åˆ°å›¾ç‰‡æ•°æ® (final.image nested)');
                            break;
                        }
                        if (jsonData.data && typeof jsonData.data === 'string') {
                            base64Data = jsonData.data;
                            console.log('æ‰¾åˆ°å›¾ç‰‡æ•°æ® (data)');
                            break;
                        }
                        if (jsonData.image) {
                            base64Data = jsonData.image;
                            console.log('æ‰¾åˆ°å›¾ç‰‡æ•°æ® (image)');
                            break;
                        }
                        // NovelAI V4.5 å¯èƒ½ç›´æ¥è¿”å› base64
                        if (typeof jsonData === 'string' && jsonData.length > 100) {
                            base64Data = jsonData;
                            console.log('æ‰¾åˆ°å›¾ç‰‡æ•°æ® (ç›´æ¥å­—ç¬¦ä¸²)');
                            break;
                        }
                    } catch (e) {
                        // å¦‚æœä¸æ˜¯ JSONï¼Œå¯èƒ½ç›´æ¥æ˜¯ base64
                        if (dataContent.length > 100) {
                            base64Data = dataContent;
                            console.log('æ‰¾åˆ°å›¾ç‰‡æ•°æ® (é JSON å­—ç¬¦ä¸²)');
                            break;
                        }
                    }
                }
            }
            
            if (!base64Data) {
                console.error('æ— æ³•æå–å›¾ç‰‡æ•°æ®ï¼Œå“åº”å†…å®¹:', text.substring(0, 1000));
                throw new Error('æ— æ³•ä» SSE å“åº”ä¸­æå–å›¾ç‰‡æ•°æ®ã€‚è¯·æ£€æŸ¥æ§åˆ¶å°æ—¥å¿—ã€‚');
            }
            
            console.log('æå–åˆ°çš„ base64 æ•°æ®é•¿åº¦:', base64Data.length);
            
            // æ£€æŸ¥æ˜¯å¦ä¸ºå›¾ç‰‡çš„base64
            const isPNG = base64Data.startsWith('iVBORw0KGgo');
            const isJPEG = base64Data.startsWith('/9j/');
            
            if (isPNG || isJPEG) {
                imageUrl = `data:${isPNG ? 'image/png' : 'image/jpeg'};base64,${base64Data}`;
            } else {
                // å¯èƒ½æ˜¯ZIPçš„base64ï¼Œéœ€è¦è§£å‹
                const binaryString = atob(base64Data);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                const zipBlob = new Blob([bytes]);
                imageUrl = await extractImageFromZip(zipBlob);
            }
        } else {
            // ZIP æ–‡ä»¶å“åº”ï¼ˆV3ï¼‰
            const zipBlob = await response.blob();
            imageUrl = await extractImageFromZip(zipBlob);
        }

        if (!imageUrl) {
            throw new Error('æ— æ³•è§£æå›¾åƒæ•°æ®');
        }

        // æ˜¾ç¤ºç”Ÿæˆçš„å›¾ç‰‡
        if (wardrobeGenerateType === 'character') {
            // ç”Ÿæˆäººç‰©å½¢è±¡ï¼šç›´æ¥æ›´æ–°
            const charImg = document.getElementById('wardrobe-char-base');
            if (charImg) {
                charImg.src = imageUrl;
                // ä¿å­˜åˆ° Dexie
                await saveWardrobeCharacter(imageUrl);
            }
        } else {
            // ç”Ÿæˆè¡£æœ - å›¾ç”Ÿå›¾æ¢è£…
            // å›¾ç”Ÿå›¾æ¨¡å¼ï¼šæ›´æ–°å½“å‰äººç‰©å½¢è±¡ï¼ˆæ¢è£…æ•ˆæœï¼‰
            const charImg = document.getElementById('wardrobe-char-base');
            if (charImg) {
                charImg.src = imageUrl;
                // ä¿å­˜æ›´æ–°åçš„äººç‰©å½¢è±¡åˆ° Dexie
                await saveWardrobeCharacter(imageUrl);
            }
            alert('æ¢è£…æˆåŠŸï¼äººç‰©è¡£æœå·²æ›´æ–°');
        }

        // æ˜¾ç¤ºæˆåŠŸæç¤ºï¼ˆå›¾ç”Ÿå›¾æ¨¡å¼å·²ç»æœ‰ä¸“é—¨æç¤ºï¼Œè¿™é‡Œåªæç¤ºå…¶ä»–æƒ…å†µï¼‰
        if (wardrobeGenerateType === 'character' || !referenceImageBase64) {
            alert('å›¾ç‰‡ç”ŸæˆæˆåŠŸï¼');
        }
        closeWardrobeGenerateModal();

    } catch (error) {
        console.error('ç”Ÿæˆå›¾ç‰‡å¤±è´¥:', error);
        alert('ç”Ÿæˆå¤±è´¥: ' + error.message);
    } finally {
        loadingDiv.style.display = 'none';
        confirmBtn.disabled = false;
        confirmBtn.textContent = 'ç”Ÿæˆ';
    }
}

// è¡£æŸœTabåˆ‡æ¢å‡½æ•°
function switchWardrobeTab(category, element) {
    // æ›´æ–°Tabæ ·å¼
    document.querySelectorAll('.wardrobe-tab-item').forEach(tab => {
        tab.classList.remove('active');
        tab.style.color = '#999';
        tab.style.fontWeight = 'normal';
        const span = tab.querySelector('span');
        if (span) span.remove();
    });
    element.classList.add('active');
    element.style.color = '#333';
    element.style.fontWeight = 'bold';
    const indicator = document.createElement('span');
    indicator.style.cssText = 'position:absolute; bottom:0; left:50%; transform:translateX(-50%); width:20px; height:3px; background:#d4a5ff; border-radius:3px;';
    element.appendChild(indicator);

    // æ›´æ–°åˆ—è¡¨æ˜¾ç¤º
    document.querySelectorAll('.wardrobe-list').forEach(list => {
        list.style.display = 'none';
    });
    const targetList = document.getElementById('wardrobe-list-' + category);
    if (targetList) {
        targetList.style.display = 'flex';
    }
}

// å°†å›¾ç‰‡URLè½¬æ¢ä¸ºbase64
async function imageToBase64(imageUrl) {
    return new Promise((resolve, reject) => {
        // å¦‚æœå·²ç»æ˜¯ base64ï¼Œç›´æ¥è¿”å›
        if (imageUrl.startsWith('data:')) {
            resolve(imageUrl);
            return;
        }
        
        // å¦‚æœæ˜¯ blob URLï¼Œéœ€è¦å…ˆè½¬æ¢
        if (imageUrl.startsWith('blob:')) {
            fetch(imageUrl)
                .then(response => response.blob())
                .then(blob => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                })
                .catch(reject);
            return;
        }
        
        // æ™®é€š URLï¼Œä½¿ç”¨ canvas è½¬æ¢
        const img = new Image();
        img.crossOrigin = 'anonymous'; // è§£å†³è·¨åŸŸé—®é¢˜
        img.onload = () => {
            try {
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                const base64 = canvas.toDataURL('image/png');
                resolve(base64);
            } catch (e) {
                reject(e);
            }
        };
        img.onerror = reject;
        img.src = imageUrl;
    });
}

// ä¿å­˜è¡£æŸœäººç‰©å½¢è±¡åˆ° Dexie
async function saveWardrobeCharacter(imageUrl) {
    try {
        await db.dexiData.put({ key: 'wardrobeCharacter', value: imageUrl });
        // åŒæ—¶ä¿å­˜å½“å‰é€‰æ‹©çš„æ€§åˆ«ï¼Œæ¢è£…æ—¶éœ€è¦ç”¨åˆ°
        await db.dexiData.put({ key: 'wardrobeCharacterGender', value: wardrobeGender });
        console.log('äººç‰©å½¢è±¡å·²ä¿å­˜ï¼Œæ€§åˆ«:', wardrobeGender);
    } catch (error) {
        console.error('ä¿å­˜äººç‰©å½¢è±¡å¤±è´¥:', error);
    }
}

// åŠ è½½è¡£æŸœäººç‰©å½¢è±¡
async function loadWardrobeCharacter() {
    try {
        const item = await db.dexiData.get('wardrobeCharacter');
        const genderItem = await db.dexiData.get('wardrobeCharacterGender');
        
        if (item && item.value) {
            const charImg = document.getElementById('wardrobe-char-base');
            if (charImg) {
                charImg.src = item.value;
                console.log('äººç‰©å½¢è±¡å·²åŠ è½½');
            }
        }
        
        // æ¢å¤æ€§åˆ«è®¾ç½®
        if (genderItem && genderItem.value) {
            wardrobeGender = genderItem.value;
            console.log('äººç‰©æ€§åˆ«å·²æ¢å¤:', wardrobeGender);
        }
    } catch (error) {
        console.error('åŠ è½½äººç‰©å½¢è±¡å¤±è´¥:', error);
    }
}

// ä»ZIPæ–‡ä»¶ä¸­æå–å›¾ç‰‡
async function extractImageFromZip(zipBlob) {
    // æ£€æŸ¥æ˜¯å¦æœ‰JSZipåº“
    if (typeof JSZip === 'undefined') {
        // å¦‚æœæ²¡æœ‰JSZipï¼Œå°è¯•ç›´æ¥è¯»å–ä¸ºå›¾ç‰‡
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(zipBlob);
        });
    }
    
    try {
        const zip = await JSZip.loadAsync(zipBlob);
        let imageFile = null;
        
        // æŸ¥æ‰¾ç¬¬ä¸€ä¸ªå›¾ç‰‡æ–‡ä»¶
        for (const filename in zip.files) {
            if (filename.match(/\.(png|jpg|jpeg|webp)$/i)) {
                imageFile = zip.files[filename];
                break;
            }
        }
        
        if (!imageFile) {
            throw new Error('ZIPæ–‡ä»¶ä¸­æœªæ‰¾åˆ°å›¾ç‰‡');
        }
        
        const imageBlob = await imageFile.async('blob');
        
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(imageBlob);
        });
    } catch (error) {
        console.error('è§£å‹ZIPå¤±è´¥:', error);
        // é™çº§å¤„ç†ï¼šç›´æ¥ä½œä¸ºå›¾ç‰‡è¯»å–
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(zipBlob);
        });
    }
}

// æ·»åŠ è¡£æœé¡¹åˆ°åˆ—è¡¨
function addWardrobeClothesItem(category, imageUrl, name) {
    const listId = 'wardrobe-list-' + category;
    const list = document.getElementById(listId);
    if (!list) return;

    const item = document.createElement('div');
    item.className = 'wardrobe-clothes-item';
    item.style.cssText = 'display:inline-block; flex-shrink:0; width:90px; height:110px; border:1px solid #f0f0f0; border-radius:12px; margin-right:12px; background:#fff; cursor:pointer; text-align:center; padding:6px; transition:all 0.2s;';
    item.innerHTML = `
        <img src="${imageUrl}" alt="${name}" style="width:100%; height:75px; object-fit:contain; margin-bottom:5px;">
        <div class="wardrobe-clothes-name" style="font-size:11px; color:#888; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${name.substring(0, 10)}${name.length > 10 ? '...' : ''}</div>
    `;
    item.onmouseenter = function() {
        this.style.borderColor = '#e0b0ff';
        this.style.background = '#faf4ff';
        this.style.transform = 'translateY(-2px)';
    };
    item.onmouseleave = function() {
        this.style.borderColor = '#f0f0f0';
        this.style.background = '#fff';
        this.style.transform = 'translateY(0)';
    };
    list.appendChild(item);
}

async function showCalendarPage() {
    if (!currentChatCharId) {
        alert("è¯·å…ˆé€‰æ‹©ä¸€ä¸ªèŠå¤©å¯¹è±¡");
        return;
    }
    
    closeChatPanel();
    document.getElementById('calendar-page').style.display = 'flex';
    
    // åˆå§‹åŒ–æ—¥å† DOM ç»‘å®š
    calendar.init();
    
    // è·å–è§’è‰²æ—¶é—´
    const char = await db.characters.get(currentChatCharId);
    const now = Date.now();
    const offset = char.timeOffset || 0;
    const virtualTime = new Date(now + offset);
    
    // è®¾ç½®æ—¥å†åˆå§‹çŠ¶æ€
    calendar.selectedDate = new Date(virtualTime); // å¤åˆ¶ä¸€ä»½
    calendar.date = new Date(virtualTime); // æµè§ˆè§†å›¾ä¹Ÿè®¾ä¸ºå½“å‰æ—¶é—´
    
    calendar.updateTimeInputs(); // æ›´æ–°è¾“å…¥æ¡†
    calendar.render(); // æ¸²æŸ“æ—¥å†
}

function hideCalendarPage() {
    document.getElementById('calendar-page').style.display = 'none';
}

async function saveCalendarTime() {
    if (!currentChatCharId) return;
    
    // ä» calendar å¯¹è±¡è·å–æœ€ç»ˆæ—¶é—´
    const targetTime = calendar.selectedDate.getTime();
    const now = Date.now();
    const offset = targetTime - now;
    
    const char = await db.characters.get(currentChatCharId);
    char.timeOffset = offset;
    
    await db.characters.put(char);
    
    hideCalendarPage();
    alert("æ—¶é—´è®¾å®šå·²æ›´æ–°");
}

// è¾…åŠ©å‡½æ•°ï¼šè·å–æ ¼å¼åŒ–çš„è™šæ‹Ÿæ—¶é—´å­—ç¬¦ä¸²
function getFormattedVirtualTime(offset) {
    const now = Date.now();
    const virtualNow = new Date(now + (offset || 0));
    
    const year = virtualNow.getFullYear();
    const month = virtualNow.getMonth() + 1;
    const day = virtualNow.getDate();
    const hours = virtualNow.getHours().toString().padStart(2, '0');
    const mins = virtualNow.getMinutes().toString().padStart(2, '0');
    const weekDays = ['å‘¨æ—¥', 'å‘¨ä¸€', 'å‘¨äºŒ', 'å‘¨ä¸‰', 'å‘¨å››', 'å‘¨äº”', 'å‘¨å…­'];
    const week = weekDays[virtualNow.getDay()];
    
    return `${year}å¹´${month}æœˆ${day}æ—¥ ${hours}:${mins} (${week})`;
}

// --- App Store é€»è¾‘ ---
// åº”ç”¨å®‰è£…çŠ¶æ€ç®¡ç†
const installedAppsDb = new Dexie('InstalledAppsDB');
installedAppsDb.version(1).stores({
    apps: 'appId, installed, installDate'
});

// æ£€æŸ¥åº”ç”¨æ˜¯å¦å·²å®‰è£…
async function isAppInstalled(appId) {
    try {
        const app = await installedAppsDb.apps.get(appId);
        return app ? app.installed : false;
    } catch (error) {
        console.error('æ£€æŸ¥åº”ç”¨å®‰è£…çŠ¶æ€å¤±è´¥:', error);
        return false;
    }
}

// å®‰è£…åº”ç”¨
async function installApp(appId, desktopIconId, showFunction) {
    try {
        await installedAppsDb.apps.put({
            appId: appId,
            installed: true,
            installDate: new Date()
        });
        
        // æ˜¾ç¤ºæ¡Œé¢å›¾æ ‡
        if (desktopIconId) {
            const icon = document.getElementById(desktopIconId);
            if (icon) {
                icon.style.display = 'flex';
            }
        }
        
        // ä¿å­˜åˆ° localStorage ä½œä¸ºå¤‡ä»½
        const installedApps = JSON.parse(localStorage.getItem('installedApps') || '{}');
        installedApps[appId] = {
            installed: true,
            installDate: new Date().toISOString(),
            desktopIconId: desktopIconId,
            showFunction: showFunction
        };
        localStorage.setItem('installedApps', JSON.stringify(installedApps));
        
        return true;
    } catch (error) {
        console.error('å®‰è£…åº”ç”¨å¤±è´¥:', error);
        return false;
    }
}

// å¸è½½åº”ç”¨
async function uninstallApp(appId, desktopIconId) {
    try {
        await installedAppsDb.apps.delete(appId);
        
        // éšè—æ¡Œé¢å›¾æ ‡
        if (desktopIconId) {
            const icon = document.getElementById(desktopIconId);
            if (icon) {
                icon.style.display = 'none';
            }
        }
        
        // ä» localStorage åˆ é™¤
        const installedApps = JSON.parse(localStorage.getItem('installedApps') || '{}');
        delete installedApps[appId];
        localStorage.setItem('installedApps', JSON.stringify(installedApps));
        
        return true;
    } catch (error) {
        console.error('å¸è½½åº”ç”¨å¤±è´¥:', error);
        return false;
    }
}

// åˆå§‹åŒ–å·²å®‰è£…åº”ç”¨çš„æ¡Œé¢å›¾æ ‡æ˜¾ç¤º
async function initInstalledApps() {
    try {
        // ä» IndexedDB åŠ è½½
        const installedApps = await installedAppsDb.apps.toArray();
        installedApps.forEach(app => {
            if (app.installed) {
                // ä»åº”ç”¨å•†åº—æ•°æ®ä¸­æ‰¾åˆ°å¯¹åº”çš„åº”ç”¨
                const allApps = [...appStoreData.today, ...appStoreData.games, ...appStoreData.apps, ...appStoreData.updates];
                const appData = allApps.find(a => a.appId === app.appId);
                if (appData && appData.desktopIconId) {
                    const icon = document.getElementById(appData.desktopIconId);
                    if (icon) {
                        icon.style.display = 'flex';
                    }
                }
            }
        });
        
        // ä» localStorage æ¢å¤ï¼ˆå…¼å®¹æ—§æ•°æ®ï¼‰
        const localApps = JSON.parse(localStorage.getItem('installedApps') || '{}');
        Object.keys(localApps).forEach(appId => {
            const appInfo = localApps[appId];
            if (appInfo.installed && appInfo.desktopIconId) {
                const icon = document.getElementById(appInfo.desktopIconId);
                if (icon) {
                    icon.style.display = 'flex';
                }
                // åŒæ­¥åˆ° IndexedDB
                installedAppsDb.apps.put({
                    appId: appId,
                    installed: true,
                    installDate: appInfo.installDate ? new Date(appInfo.installDate) : new Date()
                });
            }
        });
    } catch (error) {
        console.error('åˆå§‹åŒ–å·²å®‰è£…åº”ç”¨å¤±è´¥:', error);
    }
}

// ä¸‹è½½/å®‰è£…åº”ç”¨
async function downloadApp(appId) {
    const allApps = [...appStoreData.today, ...appStoreData.games, ...appStoreData.apps, ...appStoreData.updates];
    const app = allApps.find(a => a.appId === appId);
    
    if (!app) {
        alert('åº”ç”¨ä¸å­˜åœ¨');
        return;
    }
    
    // æ£€æŸ¥æ˜¯å¦å·²å®‰è£…
    const isInstalled = await isAppInstalled(appId);
    if (isInstalled) {
        // å¦‚æœå·²å®‰è£…ï¼Œç›´æ¥æ‰“å¼€åº”ç”¨
        if (app.showFunction && typeof window[app.showFunction] === 'function') {
            window[app.showFunction]();
            hideAppStorePage();
        }
        return;
    }
    
    // æ˜¾ç¤ºä¸‹è½½è¿›åº¦
    showToast('æ­£åœ¨ä¸‹è½½ ' + app.name + '...', 2000);
    
    // æ¨¡æ‹Ÿä¸‹è½½è¿‡ç¨‹
    setTimeout(async () => {
        const success = await installApp(appId, app.desktopIconId, app.showFunction);
        if (success) {
            showToast(app.name + ' å·²å®‰è£…', 2000);
            // åˆ·æ–°åº”ç”¨å•†åº—æ˜¾ç¤º
            const activeTab = document.querySelector('.appstore-tab.active');
            if (activeTab) {
                switchAppStoreTab(activeTab.dataset.tab);
            }
        } else {
            showToast('å®‰è£…å¤±è´¥ï¼Œè¯·é‡è¯•', 2000);
        }
    }, 1500);
}

function showAppStorePage() {
    document.getElementById('appstore-page').style.display = 'flex';
    switchAppStoreTab('today');
}

function hideAppStorePage() {
    const page = document.getElementById('appstore-page');
    if (page) {
        page.style.display = 'none';
    }
}

function showMusicAppPage() {
    document.getElementById('musicAppPage').classList.add('active');
}

function closeMusicApp() {
    document.getElementById('musicAppPage').classList.remove('active');
}

// ç½‘æ˜“äº‘éŸ³ä¹æ’­æ”¾å™¨åŠŸèƒ½
// ============================================

// åˆå§‹åŒ–éŸ³ä¹æ’­æ”¾å™¨Dexieæ•°æ®åº“
const wyyDb = new Dexie('WYYMusicPlayerDB');
wyyDb.version(1).stores({
    userSettings: 'id',
    playlistCards: 'id',
    songs: '++id, name, singer, dateAdded',
    songFiles: '++id, songId, type, data',
    lyrics: '++id, songId, data'
});
wyyDb.version(2).stores({
    userSettings: 'id',
    playlistCards: 'id',
    songs: '++id, name, singer, dateAdded, playlistId',
    songFiles: '++id, songId, type, data',
    lyrics: '++id, songId, data',
    playlists: '++id, name, desc, cover, dateCreated'
});

// éŸ³ä¹æ’­æ”¾å™¨å…ƒç´ 
const wyyPlayBtn = document.getElementById('wyyPlayBtn');
const wyyPlayerPlayBtn = document.getElementById('wyyPlayerPlayBtn');
const wyyRecordCover = document.getElementById('wyyRecordCover');
const wyyCurrentRecordContainer = document.getElementById('wyyCurrentRecordContainer');
const wyyAlbumArtLarge = document.getElementById('wyyAlbumArtLarge');
const wyyCurrentSongName = document.getElementById('wyyCurrentSongName');
const wyyCurrentSingerName = document.getElementById('wyyCurrentSingerName');
const wyyPlayerSongName = document.getElementById('wyyPlayerSongName');
const wyyPlayerSingerName = document.getElementById('wyyPlayerSingerName');
const wyyPlaylistBtn = document.getElementById('wyyPlaylistBtn');
const wyyPlaylistModal = document.getElementById('wyyPlaylistModal');
const wyySongsList = document.getElementById('wyySongsList');
const wyyEmptyPlaylist = document.getElementById('wyyEmptyPlaylist');
const wyyAddSongBtn = document.getElementById('wyyAddSongBtn');
const wyyClearAllBtn = document.getElementById('wyyClearAllBtn');
const wyyProgressBar = document.getElementById('wyyProgressBar');
const wyyProgress = document.getElementById('wyyProgress');
const wyyCurrentTime = document.getElementById('wyyCurrentTime');
const wyyTotalTime = document.getElementById('wyyTotalTime');
const wyyPrevBtn = document.getElementById('wyyPrevBtn');
const wyyNextBtn = document.getElementById('wyyNextBtn');
const wyyPlayBar = document.getElementById('wyyPlayBar');
const wyyBackBtn = document.getElementById('wyyBackBtn');
const wyyMainPage = document.getElementById('wyyMainPage');
const wyyPlayerPage = document.getElementById('wyyPlayerPage');

// æ­Œæ›²è¾“å…¥å…ƒç´ 
const wyySongNameInput = document.getElementById('wyySongNameInput');
const wyySingerNameInput = document.getElementById('wyySingerNameInput');
const wyySongUrlInput = document.getElementById('wyySongUrlInput');
const wyyLyricUrlInput = document.getElementById('wyyLyricUrlInput');

// ä¸Šä¼ é€‰é¡¹æŒ‰é’®
const wyyUrlOptionBtn = document.getElementById('wyyUrlOptionBtn');
const wyyFileOptionBtn = document.getElementById('wyyFileOptionBtn');
const wyyUrlUploadSection = document.getElementById('wyyUrlUploadSection');
const wyyFileUploadSection = document.getElementById('wyyFileUploadSection');

const wyyLyricUrlOptionBtn = document.getElementById('wyyLyricUrlOptionBtn');
const wyyLyricFileOptionBtn = document.getElementById('wyyLyricFileOptionBtn');
const wyyLyricUrlUploadSection = document.getElementById('wyyLyricUrlUploadSection');
const wyyLyricFileUploadSection = document.getElementById('wyyLyricFileUploadSection');

// æ–‡ä»¶ä¸Šä¼ æŒ‰é’®
const wyyUploadCoverBtn = document.getElementById('wyyUploadCoverBtn');
const wyyCoverFileInput = document.getElementById('wyyCoverFileInput');
const wyySongCoverPreview = document.getElementById('wyySongCoverPreview');
const wyyUploadSongFileBtn = document.getElementById('wyyUploadSongFileBtn');
const wyySongFileInput = document.getElementById('wyySongFileInput');
const wyyUploadLyricFileBtn = document.getElementById('wyyUploadLyricFileBtn');
const wyyLyricFileInput = document.getElementById('wyyLyricFileInput');

let wyyAudio = null;
let wyyProgressUpdateInterval = null;

// æ’­æ”¾åˆ—è¡¨æ•°æ®
let wyyPlaylist = [];
let wyyCurrentSongIndex = 0;
let wyyCurrentPlaylistId = null; // å½“å‰é€‰ä¸­çš„æ­Œå•ID

// æ’­æ”¾æ¨¡å¼ï¼š'order' é¡ºåºæ’­æ”¾, 'single' å•æ›²å¾ªç¯
let wyyPlayMode = 'order';

// æ­Œè¯æ˜¾ç¤ºçŠ¶æ€ï¼šfalse æ˜¾ç¤ºå°é¢, true æ˜¾ç¤ºæ­Œè¯
let wyyShowLyrics = false;

// å½“å‰æ­Œè¯æ•°æ®
let wyyCurrentLyrics = [];

// ä¸´æ—¶å­˜å‚¨ä¸Šä¼ çš„æ–‡ä»¶
let wyyTempSongCover = null;
let wyyTempSongFile = null;
let wyyTempLyricFile = null;

// é¡µé¢åˆ‡æ¢åŠŸèƒ½
if (wyyPlayBar) {
    wyyPlayBar.addEventListener('click', (e) => {
        if (!e.target.closest('.wyy-play-controls')) {
            wyyMainPage.classList.remove('active');
            wyyPlayerPage.classList.add('active');
            wyyUpdatePlayerPage();
        }
    });
}

if (wyyBackBtn) {
    wyyBackBtn.addEventListener('click', () => {
        wyyPlayerPage.classList.remove('active');
        wyyMainPage.classList.add('active');
    });
}

// åˆå§‹åŒ–æ’­æ”¾åˆ—è¡¨
async function wyyInitPlaylist() {
    try {
        let songs;
        if (wyyCurrentPlaylistId) {
            // åŠ è½½æŒ‡å®šæ­Œå•çš„æ­Œæ›²
            songs = await wyyDb.songs.where('playlistId').equals(wyyCurrentPlaylistId).toArray();
            // åœ¨å†…å­˜ä¸­æŒ‰æ—¥æœŸæ’åº
            songs.sort((a, b) => {
                const dateA = a.dateAdded ? new Date(a.dateAdded).getTime() : 0;
                const dateB = b.dateAdded ? new Date(b.dateAdded).getTime() : 0;
                return dateA - dateB;
            });
        } else {
            // å¦‚æœæ²¡æœ‰é€‰ä¸­æ­Œå•ï¼ŒåŠ è½½æ‰€æœ‰æ­Œæ›²ï¼ˆå…¼å®¹æ—§æ•°æ®ï¼‰
            songs = await wyyDb.songs.orderBy('dateAdded').toArray();
        }
        
        if (songs.length > 0) {
            wyyPlaylist = songs;
            
            // åŠ è½½æ¯é¦–æ­Œæ›²çš„æ–‡ä»¶æ•°æ®
            for (let i = 0; i < wyyPlaylist.length; i++) {
                const song = wyyPlaylist[i];
                
                // åŠ è½½æ­Œæ›²æ–‡ä»¶
                const songFile = await wyyDb.songFiles.where({ songId: song.id }).first();
                if (songFile) {
                    song.hasLocalFile = true;
                    song.localFileData = songFile.data;
                    song.fileType = songFile.type;
                }
                
                // åŠ è½½æ­Œè¯æ–‡ä»¶
                const lyric = await wyyDb.lyrics.where({ songId: song.id }).first();
                if (lyric) {
                    song.hasLocalLyric = true;
                    song.localLyricData = lyric.data;
                }
            }
            
            wyyUpdatePlaylistDisplay();
        } else {
            // ç©ºæ­Œå•
            wyyPlaylist = [];
            wyyUpdatePlaylistDisplay();
        }
        
        // è®¾ç½®å½“å‰æ’­æ”¾çš„æ­Œæ›²
        if (wyyPlaylist.length > 0) {
            await wyyLoadSong(wyyCurrentSongIndex);
        }
    } catch (error) {
        console.error('åˆå§‹åŒ–æ’­æ”¾åˆ—è¡¨å¤±è´¥:', error);
    }
}

// æ›´æ–°æ’­æ”¾åˆ—è¡¨æ˜¾ç¤º
function wyyUpdatePlaylistDisplay() {
    if (!wyySongsList) return;
    
    if (wyyPlaylist.length === 0) {
        if (wyyEmptyPlaylist) wyyEmptyPlaylist.style.display = 'block';
        wyySongsList.innerHTML = '<div class="wyy-empty-playlist">æš‚æ— æ­Œæ›²ï¼Œè¯·æ·»åŠ æ­Œæ›²</div>';
        return;
    }
    
    if (wyyEmptyPlaylist) wyyEmptyPlaylist.style.display = 'none';
    
    let songsHTML = '';
    wyyPlaylist.forEach((song, index) => {
        const isActive = index === wyyCurrentSongIndex;
        const hasCover = song.cover && song.cover !== '';
        songsHTML += `
            <div class="wyy-song-item ${isActive ? 'active' : ''}" data-index="${index}">
                <div class="wyy-song-item-icon ${!hasCover ? 'default' : ''}" style="${hasCover ? `background-image: url(${song.cover})` : ''}">
                    ${!hasCover ? (isActive ? '<i class="fa fa-play"></i>' : (index + 1)) : ''}
                </div>
                <div class="wyy-song-item-info">
                    <div class="wyy-song-item-name">${song.name}</div>
                    <div class="wyy-song-item-singer">${song.singer}</div>
                </div>
                <div class="wyy-song-item-actions" style="display: flex; gap: 5px; align-items: center;">
                    <button class="wyy-song-item-add" data-song-id="${song.id}" title="æ·»åŠ åˆ°æ­Œå•">
                        <i class="fa fa-plus"></i>
                    </button>
                    <button class="wyy-song-item-remove" data-index="${index}">
                        <i class="fa fa-times"></i>
                    </button>
                </div>
            </div>
        `;
    });
    
    wyySongsList.innerHTML = songsHTML;
    
    // æ·»åŠ æ­Œæ›²ç‚¹å‡»äº‹ä»¶
    document.querySelectorAll('.wyy-song-item').forEach(item => {
        item.addEventListener('click', function(e) {
            if (!e.target.closest('.wyy-song-item-remove') && !e.target.closest('.wyy-song-item-add') && !e.target.closest('.wyy-song-item-actions')) {
                const index = parseInt(this.getAttribute('data-index'));
                wyyPlaySong(index);
                if (wyyPlaylistModal) wyyPlaylistModal.style.display = 'none';
            }
        });
    });
    
    // æ·»åŠ "æ·»åŠ åˆ°æ­Œå•"æŒ‰é’®ç‚¹å‡»äº‹ä»¶
    document.querySelectorAll('.wyy-song-item-add').forEach(btn => {
        btn.addEventListener('click', function(e) {
            e.stopPropagation();
            const songId = parseInt(this.getAttribute('data-song-id'));
            wyyShowAddToPlaylistModal(songId);
        });
    });
    
    // æ·»åŠ åˆ é™¤æŒ‰é’®ç‚¹å‡»äº‹ä»¶
    document.querySelectorAll('.wyy-song-item-remove').forEach(btn => {
        btn.addEventListener('click', function(e) {
            e.stopPropagation();
            const index = parseInt(this.getAttribute('data-index'));
            wyyRemoveSong(index);
        });
    });
}

// æ›´æ–°æ’­æ”¾å™¨é¡µé¢
function wyyUpdatePlayerPage() {
    if (wyyPlaylist.length === 0 || wyyCurrentSongIndex >= wyyPlaylist.length) return;
    
    const song = wyyPlaylist[wyyCurrentSongIndex];
    if (wyyPlayerSongName) wyyPlayerSongName.textContent = song.name;
    if (wyyPlayerSingerName) wyyPlayerSingerName.textContent = song.singer;
    
    if (wyyAlbumArtLarge) {
        if (song.cover && song.cover !== '') {
            wyyAlbumArtLarge.style.backgroundImage = `url(${song.cover})`;
        } else {
            wyyAlbumArtLarge.style.backgroundImage = '';
            wyyAlbumArtLarge.style.backgroundColor = '#f5f5f5';
        }
    }
    
    if (wyyAudio) {
        if (wyyTotalTime) wyyTotalTime.textContent = wyyFormatTime(wyyAudio.duration || 299);
        wyyStartProgressUpdate();
    }
    
    // æ›´æ–°æ­Œè¯æ˜¾ç¤ºçŠ¶æ€
    const wyyLyricsContainer = document.getElementById('wyyLyricsContainer');
    if (wyyShowLyrics) {
        if (wyyAlbumArtLarge) wyyAlbumArtLarge.classList.add('hidden');
        if (wyyLyricsContainer) wyyLyricsContainer.classList.add('active');
        wyyUpdateLyricsDisplay();
    } else {
        if (wyyAlbumArtLarge) wyyAlbumArtLarge.classList.remove('hidden');
        if (wyyLyricsContainer) wyyLyricsContainer.classList.remove('active');
    }
}

// æ’­æ”¾æŒ‡å®šç´¢å¼•çš„æ­Œæ›²
async function wyyPlaySong(index) {
    if (index >= 0 && index < wyyPlaylist.length) {
        wyyCurrentSongIndex = index;
        await wyyLoadSong(index);
        wyyPlayCurrentSong();
        wyyUpdatePlaylistDisplay();
        wyyUpdatePlayerPage();
    }
}

// åŠ è½½æ­Œæ›²
async function wyyLoadSong(index) {
    const song = wyyPlaylist[index];
    
    // åœæ­¢å½“å‰æ’­æ”¾
    if (wyyAudio) {
        wyyAudio.pause();
        wyyStopProgressUpdate();
        if (wyyRecordCover) wyyRecordCover.classList.remove('playing');
        if (wyyPlayBtn) wyyPlayBtn.innerHTML = '<i class="fa fa-play"></i>';
        if (wyyPlayerPlayBtn) wyyPlayerPlayBtn.innerHTML = '<i class="fa fa-play"></i>';
        
        // é‡Šæ”¾ä¹‹å‰çš„å¯¹è±¡URL
        if (wyyAudio.src && wyyAudio.src.startsWith('blob:')) {
            URL.revokeObjectURL(wyyAudio.src);
        }
    }
    
    // åˆ›å»ºæ–°çš„éŸ³é¢‘å¯¹è±¡
    try {
        if (song.hasLocalFile && song.localFileData) {
            // å°†Base64è½¬æ¢ä¸ºBlobå¹¶åˆ›å»ºå¯¹è±¡URL
            const audioData = wyyBase64ToBlob(song.localFileData, song.fileType || 'audio/mpeg');
            const audioUrl = URL.createObjectURL(audioData);
            wyyAudio = new Audio(audioUrl);
        } else if (song.url) {
            // å¤„ç†ç½‘æ˜“äº‘éŸ³ä¹URLï¼ˆå¯èƒ½éœ€è¦ç‰¹æ®Šå¤„ç†ï¼‰
            let audioUrl = song.url;
            // å¦‚æœæ˜¯ç½‘æ˜“äº‘çš„å¤–é“¾ï¼Œå°è¯•æ·»åŠ å‚æ•°
            if (audioUrl.includes('music.163.com')) {
                // ç½‘æ˜“äº‘å¤–é“¾å¯èƒ½éœ€è¦ç‰¹æ®Šå¤„ç†
                console.log('æ£€æµ‹åˆ°ç½‘æ˜“äº‘éŸ³ä¹URLï¼Œå¯èƒ½éœ€è¦ç‰¹æ®Šå¤„ç†');
            }
            
            wyyAudio = new Audio(audioUrl);
            // æ·»åŠ è·¨åŸŸæ”¯æŒ
            wyyAudio.crossOrigin = 'anonymous';
            // è®¾ç½®åŠ è½½ç­–ç•¥
            wyyAudio.load();
        } else {
            console.error('æ²¡æœ‰æœ‰æ•ˆçš„æ­Œæ›²æ–‡ä»¶');
            alert('æ— æ³•åŠ è½½æ­Œæ›²æ–‡ä»¶ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼');
            return;
        }
        
        wyyAudio.loop = false;
        wyyAudio.preload = 'auto';
        
        // é”™è¯¯å¤„ç†
        wyyAudio.addEventListener('error', (e) => {
            console.error('éŸ³é¢‘åŠ è½½é”™è¯¯:', e);
            const error = wyyAudio.error;
            let errorMsg = 'éŸ³é¢‘åŠ è½½å¤±è´¥';
            if (error) {
                switch(error.code) {
                    case error.MEDIA_ERR_ABORTED:
                        errorMsg = 'éŸ³é¢‘åŠ è½½è¢«ä¸­æ­¢';
                        break;
                    case error.MEDIA_ERR_NETWORK:
                        errorMsg = 'ç½‘ç»œé”™è¯¯ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥';
                        break;
                    case error.MEDIA_ERR_DECODE:
                        errorMsg = 'éŸ³é¢‘è§£ç å¤±è´¥ï¼Œå¯èƒ½æ ¼å¼ä¸æ”¯æŒ';
                        break;
                    case error.MEDIA_ERR_SRC_NOT_SUPPORTED:
                        errorMsg = 'éŸ³é¢‘æ ¼å¼ä¸æ”¯æŒï¼Œè¯·å°è¯•å…¶ä»–æ ¼å¼';
                        break;
                }
            }
            console.error(errorMsg);
        });
        
        // æ›´æ–°éŸ³é¢‘äº‹ä»¶ç›‘å¬
        wyyAudio.addEventListener('ended', wyyHandleSongEnded);
        wyyAudio.addEventListener('loadedmetadata', () => {
            if (wyyAudio.duration && !isNaN(wyyAudio.duration) && isFinite(wyyAudio.duration)) {
                if (wyyTotalTime) wyyTotalTime.textContent = wyyFormatTime(wyyAudio.duration);
                console.log('éŸ³é¢‘æ—¶é•¿:', wyyAudio.duration, 'ç§’');
            } else {
                console.warn('æ— æ³•è·å–éŸ³é¢‘æ—¶é•¿');
            }
            wyyUpdateProgress();
        });
        wyyAudio.addEventListener('canplay', () => {
            console.log('éŸ³é¢‘å¯ä»¥å¼€å§‹æ’­æ”¾');
        });
        wyyAudio.addEventListener('canplaythrough', () => {
            console.log('éŸ³é¢‘å®Œå…¨åŠ è½½ï¼Œå¯ä»¥æµç•…æ’­æ”¾');
        });
        wyyAudio.addEventListener('loadeddata', () => {
            console.log('éŸ³é¢‘æ•°æ®åŠ è½½å®Œæˆ');
        });
        wyyAudio.addEventListener('progress', () => {
            if (wyyAudio.buffered.length > 0) {
                const bufferedEnd = wyyAudio.buffered.end(wyyAudio.buffered.length - 1);
                const duration = wyyAudio.duration;
                if (duration > 0) {
                    const bufferedPercent = (bufferedEnd / duration) * 100;
                    console.log('éŸ³é¢‘ç¼“å†²è¿›åº¦:', bufferedPercent.toFixed(1) + '%');
                }
            }
        });
        wyyAudio.addEventListener('stalled', () => {
            console.warn('éŸ³é¢‘åŠ è½½åœæ»');
        });
        wyyAudio.addEventListener('suspend', () => {
            console.warn('éŸ³é¢‘åŠ è½½æš‚åœ');
        });
        wyyAudio.addEventListener('timeupdate', () => {
            wyyUpdateProgress();
            if (wyyShowLyrics) {
                wyyUpdateLyricsDisplay();
            }
        });
        
        // æ›´æ–°æ˜¾ç¤º
        if (wyyCurrentSongName) wyyCurrentSongName.textContent = song.name;
        if (wyyCurrentSingerName) wyyCurrentSingerName.textContent = song.singer;
        
        // æ›´æ–°å”±ç‰‡å°é¢
        if (wyyCurrentRecordContainer) {
            if (song.cover && song.cover !== '') {
                wyyCurrentRecordContainer.style.backgroundImage = `url(${song.cover})`;
            } else {
                wyyCurrentRecordContainer.style.backgroundImage = '';
                wyyCurrentRecordContainer.style.backgroundColor = '#cccccc';
            }
        }
        
        // åŠ è½½æ­Œè¯
        if (song.hasLocalLyric && song.localLyricData) {
            wyyLoadLyricsFromText(song.localLyricData);
        } else if (song.lyricUrl) {
            wyyLoadLyricsFromUrl(song.lyricUrl);
        } else if (song.lyricText) {
            wyyLoadLyricsFromText(song.lyricText);
        }
    } catch (error) {
        console.error('åŠ è½½æ­Œæ›²å¤±è´¥:', error);
        alert('åŠ è½½æ­Œæ›²å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶');
    }
}

// Base64è½¬Blob
function wyyBase64ToBlob(base64, contentType = '') {
    const byteCharacters = atob(base64.split(',')[1]);
    const byteNumbers = new Array(byteCharacters.length);
    for (let i = 0; i < byteCharacters.length; i++) {
        byteNumbers[i] = byteCharacters.charCodeAt(i);
    }
    const byteArray = new Uint8Array(byteNumbers);
    return new Blob([byteArray], { type: contentType });
}

// æ’­æ”¾å½“å‰æ­Œæ›²
async function wyyPlayCurrentSong() {
    if (!wyyAudio) return;
    
    try {
        // ç­‰å¾…éŸ³é¢‘å¯ä»¥æ’­æ”¾
        if (wyyAudio.readyState < 2) {
            await new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    reject(new Error('éŸ³é¢‘åŠ è½½è¶…æ—¶'));
                }, 10000);
                
                const checkReady = () => {
                    if (wyyAudio.readyState >= 2) {
                        clearTimeout(timeout);
                        resolve();
                    } else {
                        setTimeout(checkReady, 100);
                    }
                };
                
                wyyAudio.addEventListener('canplay', () => {
                    clearTimeout(timeout);
                    resolve();
                }, { once: true });
                
                checkReady();
            });
        }
        
        await wyyAudio.play();
        if (wyyPlayBtn) wyyPlayBtn.innerHTML = '<i class="fa fa-pause"></i>';
        if (wyyPlayerPlayBtn) wyyPlayerPlayBtn.innerHTML = '<i class="fa fa-pause"></i>';
        if (wyyRecordCover) wyyRecordCover.classList.add('playing');
        wyyStartProgressUpdate();
        console.log('æ’­æ”¾æˆåŠŸ');
    } catch (err) {
        console.error('æ’­æ”¾å¤±è´¥:', err);
        let errorMsg = 'æ’­æ”¾å¤±è´¥';
        if (err.name === 'NotAllowedError') {
            errorMsg = 'æµè§ˆå™¨é˜»æ­¢äº†è‡ªåŠ¨æ’­æ”¾ï¼Œè¯·æ‰‹åŠ¨ç‚¹å‡»æ’­æ”¾æŒ‰é’®';
        } else if (err.name === 'NotSupportedError') {
            errorMsg = 'éŸ³é¢‘æ ¼å¼ä¸æ”¯æŒï¼Œè¯·å°è¯•å…¶ä»–æ ¼å¼';
        } else if (err.message === 'éŸ³é¢‘åŠ è½½è¶…æ—¶') {
            errorMsg = 'éŸ³é¢‘åŠ è½½è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–æ–‡ä»¶';
        } else {
            errorMsg = 'æ’­æ”¾å¤±è´¥ï¼š' + err.message;
        }
        alert(errorMsg);
    }
}

// å¤„ç†æ­Œæ›²ç»“æŸ
function wyyHandleSongEnded() {
    if (wyyPlaylist.length > 0) {
        if (wyyPlayMode === 'single') {
            // å•æ›²å¾ªç¯ï¼šé‡æ–°æ’­æ”¾å½“å‰æ­Œæ›²
            wyyAudio.currentTime = 0;
            wyyPlayCurrentSong();
        } else {
            // é¡ºåºæ’­æ”¾ï¼šæ’­æ”¾ä¸‹ä¸€é¦–
            wyyCurrentSongIndex = (wyyCurrentSongIndex + 1) % wyyPlaylist.length;
            wyyLoadSong(wyyCurrentSongIndex);
            wyyPlayCurrentSong();
            wyyUpdatePlaylistDisplay();
            wyyUpdatePlayerPage();
        }
    } else {
        if (wyyPlayBtn) wyyPlayBtn.innerHTML = '<i class="fa fa-play"></i>';
        if (wyyPlayerPlayBtn) wyyPlayerPlayBtn.innerHTML = '<i class="fa fa-play"></i>';
        if (wyyRecordCover) wyyRecordCover.classList.remove('playing');
        wyyStopProgressUpdate();
    }
}

// æ·»åŠ ä¸Šä¼ æ­Œæ›²
async function wyyAddSong() {
    if (!wyySongNameInput || !wyySingerNameInput) return;
    
    const name = wyySongNameInput.value.trim();
    const singer = wyySingerNameInput.value.trim();
    const url = wyySongUrlInput ? wyySongUrlInput.value.trim() : '';
    const lyricUrl = wyyLyricUrlInput ? wyyLyricUrlInput.value.trim() : '';
    
    if (!name || !singer) {
        alert('è¯·å¡«å†™æ­Œæ›²åç§°å’Œæ­Œæ‰‹');
        return;
    }
    
    // æ£€æŸ¥æ˜¯å¦æœ‰æ­Œæ›²æ–‡ä»¶
    if (!wyyTempSongFile && !url) {
        alert('è¯·ä¸Šä¼ æ­Œæ›²æ–‡ä»¶æˆ–è¾“å…¥æ­Œæ›²URL');
        return;
    }
    
    // æ£€æŸ¥æ˜¯å¦é€‰ä¸­äº†æ­Œå•
    if (!wyyCurrentPlaylistId) {
        alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ­Œå•æˆ–åˆ›å»ºæ–°æ­Œå•');
        return;
    }
    
    try {
        const songData = {
            name,
            singer,
            cover: wyyTempSongCover || '',
            lyricUrl: '',
            playlistId: wyyCurrentPlaylistId,
            hasLocalFile: false,
            hasLocalLyric: false,
            dateAdded: new Date()
        };
        
        // ä¿å­˜æ­Œæ›²åŸºæœ¬ä¿¡æ¯
        const songId = await wyyDb.songs.add(songData);
        
        // å¤„ç†æ­Œæ›²æ–‡ä»¶
        if (wyyTempSongFile) {
            await wyyDb.songFiles.add({
                songId: songId,
                type: wyyTempSongFile.type,
                data: wyyTempSongFile.data
            });
            
            songData.hasLocalFile = true;
            songData.localFileData = wyyTempSongFile.data;
            songData.fileType = wyyTempSongFile.type;
        } else if (url) {
            if (!url.startsWith('http://') && !url.startsWith('https://')) {
                alert('è¯·æä¾›æœ‰æ•ˆçš„æ­Œæ›²URLï¼ˆä»¥http://æˆ–https://å¼€å¤´ï¼‰');
                return;
            }
            songData.url = url;
            await wyyDb.songs.update(songId, { url: url });
        }
        
        // å¤„ç†æ­Œè¯æ–‡ä»¶
        if (wyyTempLyricFile) {
            await wyyDb.lyrics.add({
                songId: songId,
                data: wyyTempLyricFile.data
            });
            
            songData.hasLocalLyric = true;
            songData.localLyricData = wyyTempLyricFile.data;
        } else if (lyricUrl) {
            songData.lyricUrl = lyricUrl;
            await wyyDb.songs.update(songId, { lyricUrl: lyricUrl });
        }
        
        // å¤„ç†å°é¢
        if (wyyTempSongCover) {
            await wyyDb.songs.update(songId, { cover: wyyTempSongCover });
        }
        
        songData.id = songId;
        wyyPlaylist.push(songData);
        
        // æ¸…ç©ºè¾“å…¥æ¡†å’Œä¸´æ—¶æ•°æ®
        wyySongNameInput.value = '';
        wyySingerNameInput.value = '';
        if (wyySongUrlInput) wyySongUrlInput.value = '';
        if (wyyLyricUrlInput) wyyLyricUrlInput.value = '';
        if (wyySongCoverPreview) wyySongCoverPreview.style.backgroundImage = '';
        wyyTempSongCover = null;
        wyyTempSongFile = null;
        wyyTempLyricFile = null;
        
        wyyUpdatePlaylistDisplay();
        
        // å¦‚æœæ˜¯ç¬¬ä¸€é¦–æ­Œæ›²ï¼Œè®¾ç½®ä¸ºå½“å‰æ’­æ”¾
        if (wyyPlaylist.length === 1) {
            wyyCurrentSongIndex = 0;
            await wyyLoadSong(0);
        }
        
        alert('æ­Œæ›²æ·»åŠ æˆåŠŸï¼');
    } catch (error) {
        console.error('æ·»åŠ æ­Œæ›²å¤±è´¥:', error);
        alert('æ·»åŠ æ­Œæ›²å¤±è´¥ï¼Œè¯·é‡è¯•');
    }
}

// åˆ é™¤æ­Œæ›²
async function wyyRemoveSong(index) {
    if (index >= 0 && index < wyyPlaylist.length) {
        const song = wyyPlaylist[index];
        
        try {
            // ä»æ•°æ®åº“ä¸­åˆ é™¤
            await wyyDb.songs.delete(song.id);
            await wyyDb.songFiles.where({ songId: song.id }).delete();
            await wyyDb.lyrics.where({ songId: song.id }).delete();
            
            // é‡Šæ”¾å¯¹è±¡URL
            if (song.hasLocalFile && wyyAudio && wyyAudio.src && wyyAudio.src.startsWith('blob:')) {
                URL.revokeObjectURL(wyyAudio.src);
            }
            
            wyyPlaylist.splice(index, 1);
            
            // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰æ’­æ”¾çš„æ­Œæ›²
            if (index === wyyCurrentSongIndex) {
                if (wyyPlaylist.length > 0) {
                    wyyCurrentSongIndex = Math.min(wyyCurrentSongIndex, wyyPlaylist.length - 1);
                    await wyyLoadSong(wyyCurrentSongIndex);
                    if (wyyAudio && !wyyAudio.paused) {
                        wyyPlayCurrentSong();
                    }
                } else {
                    if (wyyAudio) {
                        wyyAudio.pause();
                    }
                    if (wyyCurrentSongName) wyyCurrentSongName.textContent = 'æš‚æ— æ­Œæ›²';
                    if (wyyCurrentSingerName) wyyCurrentSingerName.textContent = '';
                    if (wyyPlayerSongName) wyyPlayerSongName.textContent = 'æš‚æ— æ­Œæ›²';
                    if (wyyPlayerSingerName) wyyPlayerSingerName.textContent = '';
                    if (wyyCurrentRecordContainer) {
                        wyyCurrentRecordContainer.style.backgroundImage = '';
                        wyyCurrentRecordContainer.style.backgroundColor = '#cccccc';
                    }
                    if (wyyAlbumArtLarge) {
                        wyyAlbumArtLarge.style.backgroundImage = '';
                        wyyAlbumArtLarge.style.backgroundColor = '#f5f5f5';
                    }
                    if (wyyPlayBtn) wyyPlayBtn.innerHTML = '<i class="fa fa-play"></i>';
                    if (wyyPlayerPlayBtn) wyyPlayerPlayBtn.innerHTML = '<i class="fa fa-play"></i>';
                    if (wyyRecordCover) wyyRecordCover.classList.remove('playing');
                    wyyStopProgressUpdate();
                }
            } else if (index < wyyCurrentSongIndex) {
                wyyCurrentSongIndex--;
            }
            
            wyyUpdatePlaylistDisplay();
            wyyUpdatePlayerPage();
        } catch (error) {
            console.error('åˆ é™¤æ­Œæ›²å¤±è´¥:', error);
        }
    }
}

// æ¸…ç©ºåˆ—è¡¨
async function wyyClearAllSongs() {
    if (wyyPlaylist.length > 0 && confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰æ­Œæ›²å—ï¼Ÿ')) {
        try {
            // é‡Šæ”¾æ‰€æœ‰å¯¹è±¡URL
            wyyPlaylist.forEach(song => {
                if (song.hasLocalFile && wyyAudio && wyyAudio.src && wyyAudio.src.startsWith('blob:')) {
                    URL.revokeObjectURL(wyyAudio.src);
                }
            });
            
            // æ¸…ç©ºæ•°æ®åº“
            await wyyDb.songs.clear();
            await wyyDb.songFiles.clear();
            await wyyDb.lyrics.clear();
            
            wyyPlaylist = [];
            if (wyyAudio) {
                wyyAudio.pause();
            }
            if (wyyCurrentSongName) wyyCurrentSongName.textContent = 'æš‚æ— æ­Œæ›²';
            if (wyyCurrentSingerName) wyyCurrentSingerName.textContent = '';
            if (wyyPlayerSongName) wyyPlayerSongName.textContent = 'æš‚æ— æ­Œæ›²';
            if (wyyPlayerSingerName) wyyPlayerSingerName.textContent = '';
            if (wyyCurrentRecordContainer) {
                wyyCurrentRecordContainer.style.backgroundImage = '';
                wyyCurrentRecordContainer.style.backgroundColor = '#cccccc';
            }
            if (wyyAlbumArtLarge) {
                wyyAlbumArtLarge.style.backgroundImage = '';
                wyyAlbumArtLarge.style.backgroundColor = '#f5f5f5';
            }
            if (wyyPlayBtn) wyyPlayBtn.innerHTML = '<i class="fa fa-play"></i>';
            if (wyyPlayerPlayBtn) wyyPlayerPlayBtn.innerHTML = '<i class="fa fa-play"></i>';
            if (wyyRecordCover) wyyRecordCover.classList.remove('playing');
            wyyStopProgressUpdate();
            
            wyyUpdatePlaylistDisplay();
            wyyUpdatePlayerPage();
        } catch (error) {
            console.error('æ¸…ç©ºåˆ—è¡¨å¤±è´¥:', error);
        }
    }
}

// åŠ è½½æ­Œè¯
function wyyLoadLyricsFromUrl(url) {
    if (!url) {
        wyyCurrentLyrics = [];
        wyyUpdateLyricsDisplay();
        return;
    }
    
    fetch(url)
        .then(response => response.text())
        .then(text => {
            wyyLoadLyricsFromText(text);
        })
        .catch(error => {
            console.log('æ­Œè¯åŠ è½½å¤±è´¥:', error);
            wyyCurrentLyrics = [];
            wyyUpdateLyricsDisplay();
        });
}

// è§£æLRCæ­Œè¯
function wyyParseLyrics(text) {
    if (!text) return [];
    
    const lines = text.split('\n');
    const lyrics = [];
    
    for (let line of lines) {
        line = line.trim();
        if (!line) continue;
        
        // åŒ¹é…æ—¶é—´æ ‡ç­¾ [mm:ss.xx] æˆ– [mm:ss]
        const timeRegex = /\[(\d{2}):(\d{2})(?:\.(\d{2,3}))?\]/g;
        const matches = [...line.matchAll(timeRegex)];
        
        if (matches.length > 0) {
            const lyricText = line.replace(timeRegex, '').trim();
            if (!lyricText) continue;
            
            for (let match of matches) {
                const minutes = parseInt(match[1]);
                const seconds = parseInt(match[2]);
                const milliseconds = match[3] ? parseInt(match[3].padEnd(3, '0')) : 0;
                const time = minutes * 60 + seconds + milliseconds / 1000;
                
                lyrics.push({
                    time: time,
                    text: lyricText
                });
            }
        }
    }
    
    // æŒ‰æ—¶é—´æ’åº
    lyrics.sort((a, b) => a.time - b.time);
    return lyrics;
}

function wyyLoadLyricsFromText(text) {
    if (!text) {
        wyyCurrentLyrics = [];
        wyyUpdateLyricsDisplay();
        return;
    }
    
    // å¦‚æœæ˜¯Base64ç¼–ç ï¼Œå…ˆè§£ç 
    let lyricText = text;
    if (text.startsWith('data:text/plain;base64,')) {
        try {
            const base64Data = text.split(',')[1];
            lyricText = atob(base64Data);
        } catch (e) {
            console.error('æ­Œè¯è§£ç å¤±è´¥:', e);
        }
    }
    
    wyyCurrentLyrics = wyyParseLyrics(lyricText);
    wyyUpdateLyricsDisplay();
}

// æ›´æ–°æ­Œè¯æ˜¾ç¤º
function wyyUpdateLyricsDisplay() {
    const lyricsContent = document.getElementById('wyyLyricsContent');
    if (!lyricsContent) return;
    
    if (wyyCurrentLyrics.length === 0) {
        lyricsContent.innerHTML = '<div style="opacity: 0.6;">æš‚æ— æ­Œè¯</div>';
        return;
    }
    
    // å¦‚æœæ­£åœ¨æ’­æ”¾ï¼Œé«˜äº®å½“å‰æ­Œè¯
    if (wyyAudio && !wyyAudio.paused) {
        const currentTime = wyyAudio.currentTime;
        let activeIndex = -1;
        
        for (let i = wyyCurrentLyrics.length - 1; i >= 0; i--) {
            if (currentTime >= wyyCurrentLyrics[i].time) {
                activeIndex = i;
                break;
            }
        }
        
        let html = '';
        wyyCurrentLyrics.forEach((lyric, index) => {
            const isActive = index === activeIndex;
            html += `<div style="margin: 10px 0; ${isActive ? 'color: #fff; font-weight: bold; font-size: 18px;' : 'opacity: 0.6;'}">${lyric.text}</div>`;
        });
        
        lyricsContent.innerHTML = html;
        
        // æ»šåŠ¨åˆ°å½“å‰æ­Œè¯
        if (activeIndex >= 0) {
            const activeElement = lyricsContent.children[activeIndex];
            if (activeElement) {
                activeElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }
    } else {
        // æœªæ’­æ”¾æ—¶æ˜¾ç¤ºæ‰€æœ‰æ­Œè¯
        let html = '';
        wyyCurrentLyrics.forEach(lyric => {
            html += `<div style="margin: 10px 0; opacity: 0.6;">${lyric.text}</div>`;
        });
        lyricsContent.innerHTML = html;
    }
}

// æ’­æ”¾æŒ‰é’®äº‹ä»¶
if (wyyPlayBtn) {
    wyyPlayBtn.addEventListener('click', async () => {
        if (wyyPlaylist.length === 0) {
            alert('è¯·å…ˆæ·»åŠ æ­Œæ›²');
            return;
        }
        
        if (!wyyAudio) {
            await wyyLoadSong(wyyCurrentSongIndex);
        }
        
        if (wyyAudio && wyyAudio.paused) {
            await wyyPlayCurrentSong();
        } else if (wyyAudio) {
            wyyAudio.pause();
            wyyPlayBtn.innerHTML = '<i class="fa fa-play"></i>';
            if (wyyPlayerPlayBtn) wyyPlayerPlayBtn.innerHTML = '<i class="fa fa-play"></i>';
            if (wyyRecordCover) wyyRecordCover.classList.remove('playing');
            wyyStopProgressUpdate();
        }
    });
}

if (wyyPlayerPlayBtn) {
    wyyPlayerPlayBtn.addEventListener('click', async () => {
        if (wyyPlaylist.length === 0) {
            alert('è¯·å…ˆæ·»åŠ æ­Œæ›²');
            return;
        }
        
        if (!wyyAudio) {
            await wyyLoadSong(wyyCurrentSongIndex);
        }
        
        if (wyyAudio && wyyAudio.paused) {
            await wyyPlayCurrentSong();
        } else if (wyyAudio) {
            wyyAudio.pause();
            if (wyyPlayBtn) wyyPlayBtn.innerHTML = '<i class="fa fa-play"></i>';
            wyyPlayerPlayBtn.innerHTML = '<i class="fa fa-play"></i>';
            if (wyyRecordCover) wyyRecordCover.classList.remove('playing');
            wyyStopProgressUpdate();
        }
    });
}

// ä¸Šä¸€é¦–/ä¸‹ä¸€é¦–
if (wyyPrevBtn) {
    wyyPrevBtn.addEventListener('click', () => {
        if (wyyPlaylist.length === 0) return;
        
        wyyCurrentSongIndex = (wyyCurrentSongIndex - 1 + wyyPlaylist.length) % wyyPlaylist.length;
        wyyPlaySong(wyyCurrentSongIndex);
    });
}

if (wyyNextBtn) {
    wyyNextBtn.addEventListener('click', () => {
        if (wyyPlaylist.length === 0) return;
        
        wyyCurrentSongIndex = (wyyCurrentSongIndex + 1) % wyyPlaylist.length;
        wyyPlaySong(wyyCurrentSongIndex);
    });
}

// å¾ªç¯æ¨¡å¼åˆ‡æ¢
const wyyLoopModeBtn = document.getElementById('wyyLoopModeBtn');
const wyyLoopIcon = document.getElementById('wyyLoopIcon');

if (wyyLoopModeBtn && wyyLoopIcon) {
    wyyLoopModeBtn.addEventListener('click', () => {
        if (wyyPlayMode === 'order') {
            // åˆ‡æ¢åˆ°å•æ›²å¾ªç¯
            wyyPlayMode = 'single';
            wyyLoopIcon.className = 'fa fa-repeat';
            wyyLoopModeBtn.classList.add('wyy-loop-mode-single');
            if (wyyAudio) {
                wyyAudio.loop = false; // ä½¿ç”¨è‡ªå®šä¹‰å¾ªç¯é€»è¾‘
            }
        } else {
            // åˆ‡æ¢åˆ°é¡ºåºæ’­æ”¾
            wyyPlayMode = 'order';
            wyyLoopIcon.className = 'fa fa-list';
            wyyLoopModeBtn.classList.remove('wyy-loop-mode-single');
            if (wyyAudio) {
                wyyAudio.loop = false;
            }
        }
    });
}

// æ’­æ”¾åˆ—è¡¨æŒ‰é’®äº‹ä»¶ï¼ˆä¸»é¡µé¢ï¼‰
if (wyyPlaylistBtn) {
    wyyPlaylistBtn.addEventListener('click', () => {
        if (wyyPlaylistModal) wyyPlaylistModal.style.display = 'flex';
    });
}

// æ’­æ”¾å™¨è¯¦æƒ…é¡µé¢çš„æ’­æ”¾åˆ—è¡¨æŒ‰é’®ï¼ˆæ‰“å¼€æ’­æ”¾åˆ—è¡¨ï¼‰
const wyyPlayerPlaylistBtn = document.getElementById('wyyPlayerPlaylistBtn');
const wyyLyricsContainer = document.getElementById('wyyLyricsContainer');

if (wyyPlayerPlaylistBtn) {
    wyyPlayerPlaylistBtn.addEventListener('click', () => {
        if (wyyPlaylistModal) wyyPlaylistModal.style.display = 'flex';
    });
}

// å°é¢ç‚¹å‡»åˆ‡æ¢æ­Œè¯
if (wyyAlbumArtLarge) {
    wyyAlbumArtLarge.addEventListener('click', () => {
        wyyShowLyrics = !wyyShowLyrics;
        
        if (wyyShowLyrics) {
            wyyAlbumArtLarge.classList.add('hidden');
            if (wyyLyricsContainer) wyyLyricsContainer.classList.add('active');
            wyyUpdateLyricsDisplay();
        } else {
            wyyAlbumArtLarge.classList.remove('hidden');
            if (wyyLyricsContainer) wyyLyricsContainer.classList.remove('active');
        }
    });
}

// è¿›åº¦æ¡åŠŸèƒ½
function wyyStartProgressUpdate() {
    wyyStopProgressUpdate();
    wyyProgressUpdateInterval = setInterval(wyyUpdateProgress, 1000);
    wyyUpdateProgress();
}

function wyyStopProgressUpdate() {
    if (wyyProgressUpdateInterval) {
        clearInterval(wyyProgressUpdateInterval);
        wyyProgressUpdateInterval = null;
    }
}

function wyyUpdateProgress() {
    if (!wyyAudio || !wyyAudio.duration) return;
    
    const percent = (wyyAudio.currentTime / wyyAudio.duration) * 100;
    if (wyyProgress) wyyProgress.style.width = percent + '%';
    if (wyyCurrentTime) wyyCurrentTime.textContent = wyyFormatTime(wyyAudio.currentTime);
    if (wyyTotalTime) wyyTotalTime.textContent = wyyFormatTime(wyyAudio.duration);
}

function wyyFormatTime(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
}

if (wyyProgressBar) {
    wyyProgressBar.addEventListener('click', (e) => {
        if (!wyyAudio) return;
        
        const rect = wyyProgressBar.getBoundingClientRect();
        const percent = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
        wyyAudio.currentTime = percent * wyyAudio.duration;
        wyyUpdateProgress();
    });
}

// æ·»åŠ ä¸Šä¼ é€‰é¡¹åˆ‡æ¢åŠŸèƒ½
if (wyyUrlOptionBtn && wyyFileOptionBtn && wyyUrlUploadSection && wyyFileUploadSection) {
    wyyUrlOptionBtn.addEventListener('click', () => {
        wyyUrlOptionBtn.classList.add('active');
        wyyFileOptionBtn.classList.remove('active');
        wyyUrlUploadSection.classList.add('active');
        wyyFileUploadSection.classList.remove('active');
    });

    wyyFileOptionBtn.addEventListener('click', () => {
        wyyFileOptionBtn.classList.add('active');
        wyyUrlOptionBtn.classList.remove('active');
        wyyFileUploadSection.classList.add('active');
        wyyUrlUploadSection.classList.remove('active');
    });
}

if (wyyLyricUrlOptionBtn && wyyLyricFileOptionBtn && wyyLyricUrlUploadSection && wyyLyricFileUploadSection) {
    wyyLyricUrlOptionBtn.addEventListener('click', () => {
        wyyLyricUrlOptionBtn.classList.add('active');
        wyyLyricFileOptionBtn.classList.remove('active');
        wyyLyricUrlUploadSection.classList.add('active');
        wyyLyricFileUploadSection.classList.remove('active');
    });

    wyyLyricFileOptionBtn.addEventListener('click', () => {
        wyyLyricFileOptionBtn.classList.add('active');
        wyyLyricUrlOptionBtn.classList.remove('active');
        wyyLyricFileUploadSection.classList.add('active');
        wyyLyricUrlUploadSection.classList.remove('active');
    });
}

// ä¸Šä¼ å°é¢æŒ‰é’®
if (wyyUploadCoverBtn && wyyCoverFileInput) {
    wyyUploadCoverBtn.addEventListener('click', () => {
        wyyCoverFileInput.click();
    });

    wyyCoverFileInput.addEventListener('change', function(event) {
        const file = event.target.files[0];
        if (file) {
            if (!file.type.match('image.*')) {
                alert('è¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶ï¼');
                return;
            }
            
            if (file.size > 2 * 1024 * 1024) {
                alert('å›¾ç‰‡å¤§å°ä¸èƒ½è¶…è¿‡2MBï¼');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                if (wyySongCoverPreview) wyySongCoverPreview.style.backgroundImage = `url(${e.target.result})`;
                wyyTempSongCover = e.target.result;
            };
            reader.readAsDataURL(file);
        }
    });
}

// ä¸Šä¼ æ­Œæ›²æ–‡ä»¶æŒ‰é’®
if (wyyUploadSongFileBtn && wyySongFileInput) {
    wyyUploadSongFileBtn.addEventListener('click', () => {
        wyySongFileInput.click();
    });

    wyySongFileInput.addEventListener('change', function(event) {
        const file = event.target.files[0];
        if (file) {
            const validAudioTypes = [
                'audio/mpeg', 'audio/mp3', 'audio/wav', 'audio/wave', 'audio/x-wav',
                'audio/ogg', 'audio/oga', 'audio/x-m4a', 'audio/mp4', 'audio/flac',
                'audio/x-flac', 'audio/aac', 'audio/aacp'
            ];
            
            const validExtensions = ['.mp3', '.wav', '.ogg', '.m4a', '.flac', '.aac'];
            const fileName = file.name.toLowerCase();
            const isValidExtension = validExtensions.some(ext => fileName.endsWith(ext));
            
            if (!validAudioTypes.includes(file.type) && !isValidExtension) {
                alert('è¯·é€‰æ‹©æœ‰æ•ˆçš„éŸ³é¢‘æ–‡ä»¶ï¼ˆMP3ã€WAVã€OGGã€M4Aã€FLACã€AACç­‰æ ¼å¼ï¼‰ï¼');
                return;
            }
            
            if (file.size > 50 * 1024 * 1024) {
                alert('éŸ³é¢‘æ–‡ä»¶å¤§å°ä¸èƒ½è¶…è¿‡50MBï¼');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                wyyTempSongFile = {
                    data: e.target.result,
                    type: file.type || 'audio/mpeg',
                    name: file.name
                };
                alert(`å·²é€‰æ‹©æ­Œæ›²æ–‡ä»¶: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`);
            };
            reader.readAsDataURL(file);
        }
    });
}

// ä¸Šä¼ æ­Œè¯æ–‡ä»¶æŒ‰é’®
if (wyyUploadLyricFileBtn && wyyLyricFileInput) {
    wyyUploadLyricFileBtn.addEventListener('click', () => {
        wyyLyricFileInput.click();
    });

    wyyLyricFileInput.addEventListener('change', function(event) {
        const file = event.target.files[0];
        if (file) {
            const validTypes = ['.lrc', '.txt'];
            const fileName = file.name.toLowerCase();
            const isValidType = validTypes.some(type => fileName.endsWith(type));
            
            if (!isValidType) {
                alert('è¯·é€‰æ‹©LRCæˆ–TXTæ ¼å¼çš„æ­Œè¯æ–‡ä»¶ï¼');
                return;
            }
            
            if (file.size > 1 * 1024 * 1024) {
                alert('æ­Œè¯æ–‡ä»¶å¤§å°ä¸èƒ½è¶…è¿‡1MBï¼');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                wyyTempLyricFile = {
                    data: e.target.result,
                    name: file.name
                };
                alert(`å·²é€‰æ‹©æ­Œè¯æ–‡ä»¶: ${file.name}`);
            };
            reader.readAsDataURL(file);
        }
    });
}

// æ·»åŠ æ­Œæ›²æŒ‰é’®äº‹ä»¶
if (wyyAddSongBtn) {
    wyyAddSongBtn.addEventListener('click', wyyAddSong);
}

// æ¸…ç©ºåˆ—è¡¨æŒ‰é’®äº‹ä»¶
if (wyyClearAllBtn) {
    wyyClearAllBtn.addEventListener('click', wyyClearAllSongs);
}

// ç‚¹å‡»æ¨¡æ€æ¡†å¤–éƒ¨å…³é—­
if (wyyPlaylistModal) {
    wyyPlaylistModal.addEventListener('click', (e) => {
        if (e.target === wyyPlaylistModal) {
            wyyPlaylistModal.style.display = 'none';
            wyyTempSongCover = null;
            wyyTempSongFile = null;
            wyyTempLyricFile = null;
            if (wyySongCoverPreview) wyySongCoverPreview.style.backgroundImage = '';
        }
    });
}

// ä¿¡æ¯é¡µé¢æ•°æ®
const messageChats = [
    { 
        id: 'welcome', 
        name: 'æ¬¢è¿å°åŠ©æ‰‹', 
        avatar: 'https://img.icons8.com/color/96/chat.png', 
        time: 'åˆšåˆš', 
        preview: 'æ¬¢è¿ä½¿ç”¨è¿™ä¸ªç½‘é¡µï¼', 
        unread: false, 
        chatTimeLabel: 'åˆšåˆš',
        messages: [
            { 
                type: 'received', 
                text: 'æ¬¢è¿ä½¿ç”¨è¿™ä¸ªç½‘é¡µï¼ğŸ‰\n\nè¿™æ˜¯ä¸€ä¸ªä»¿ iOS é£æ ¼çš„ä¿¡æ¯åº”ç”¨ï¼Œä½ å¯ä»¥åœ¨è¿™é‡Œï¼š\n\nâ€¢ æŸ¥çœ‹å’Œç®¡ç†ä½ çš„ä¿¡æ¯\nâ€¢ ä¸å¥½å‹èŠå¤©\nâ€¢ å‘é€å’Œæ¥æ”¶æ¶ˆæ¯\n\nå¸Œæœ›ä½ èƒ½å–œæ¬¢è¿™ä¸ªè®¾è®¡ï¼å¦‚æœ‰ä»»ä½•é—®é¢˜ï¼Œéšæ—¶å‘Šè¯‰æˆ‘ã€‚' 
            }
        ]
    }
];

// çŸ­ä¿¡ç¼–è¾‘æ¨¡å¼çŠ¶æ€
let isMessageEditMode = false;
let selectedMessageChats = new Set();

// åˆ‡æ¢çŸ­ä¿¡ç¼–è¾‘æ¨¡å¼
async function toggleMessageEditMode() {
    isMessageEditMode = !isMessageEditMode;
    selectedMessageChats.clear();
    
    const editBtn = document.getElementById('message-edit-btn');
    const listContainer = document.getElementById('message-chat-list-container');
    
    if (isMessageEditMode) {
        editBtn.textContent = 'å®Œæˆ';
        if (listContainer) {
            listContainer.classList.add('edit-mode');
        }
        // æ˜¾ç¤ºåˆ‡æ¢è´¦å·å’Œåˆ é™¤æŒ‰é’®
        showMessageEditActions();
    } else {
        editBtn.textContent = 'ç¼–è¾‘';
        if (listContainer) {
            listContainer.classList.remove('edit-mode');
        }
        // éšè—æ“ä½œæŒ‰é’®
        hideMessageEditActions();
    }
    
    // é‡æ–°æ¸²æŸ“åˆ—è¡¨ä»¥æ˜¾ç¤ºé€‰æ‹©æ¡†
    await renderMessageList();
}

// æ˜¾ç¤ºç¼–è¾‘æ¨¡å¼æ“ä½œæŒ‰é’®
function showMessageEditActions() {
    const actionsContainer = document.getElementById('message-edit-actions');
    if (actionsContainer) {
        actionsContainer.style.display = 'block';
    }
    updateMessageDeleteButton();
}

// éšè—ç¼–è¾‘æ¨¡å¼æ“ä½œæŒ‰é’®
function hideMessageEditActions() {
    const actionsContainer = document.getElementById('message-edit-actions');
    if (actionsContainer) {
        actionsContainer.style.display = 'none';
    }
    const deleteBtn = document.getElementById('message-delete-btn');
    if (deleteBtn) {
        deleteBtn.style.display = 'none';
    }
}

// åœ¨ç¼–è¾‘æ¨¡å¼ä¸‹æ˜¾ç¤ºåˆ‡æ¢è´¦å·æŒ‰é’®
async function showMessageSwitchAccount() {
    await showSwitchAccountModal();
}

// åˆ‡æ¢çŸ­ä¿¡èŠå¤©é€‰æ‹©çŠ¶æ€
async function toggleMessageChatSelection(chatId) {
    if (!isMessageEditMode) return;
    
    // ä¸å…è®¸é€‰æ‹©æ¬¢è¿å°åŠ©æ‰‹
    if (chatId === 'welcome') return;
    
    if (selectedMessageChats.has(chatId)) {
        selectedMessageChats.delete(chatId);
    } else {
        selectedMessageChats.add(chatId);
    }
    
    await renderMessageList();
    updateMessageDeleteButton();
}

// æ›´æ–°åˆ é™¤æŒ‰é’®çŠ¶æ€
function updateMessageDeleteButton() {
    const deleteBtn = document.getElementById('message-delete-btn');
    if (deleteBtn) {
        if (selectedMessageChats.size > 0) {
            deleteBtn.style.display = 'flex';
            deleteBtn.textContent = `åˆ é™¤(${selectedMessageChats.size})`;
        } else {
            deleteBtn.style.display = 'none';
        }
    }
}

// åˆ é™¤é€‰ä¸­çš„çŸ­ä¿¡èŠå¤©
async function deleteSelectedMessageChats() {
    if (selectedMessageChats.size === 0) return;
    
    // è¿‡æ»¤æ‰æ¬¢è¿å°åŠ©æ‰‹ï¼ˆä¸å…è®¸åˆ é™¤ï¼‰
    const chatsToDelete = Array.from(selectedMessageChats).filter(id => id !== 'welcome');
    if (chatsToDelete.length === 0) return;
    
    if (!confirm(`ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${chatsToDelete.length} ä¸ªèŠå¤©å—ï¼Ÿ`)) {
        return;
    }
    
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    // ä» Dexie åˆ é™¤é€‰ä¸­èŠå¤©çš„æ‰€æœ‰æ¶ˆæ¯
    const allMessages = await db.sms_messages.where('accountId').equals(accountId).toArray();
    const idsToDelete = allMessages.filter(msg => {
        let chatId;
        if (msg.type === 'sent') {
            chatId = msg.number || msg.receiverId || msg.sender;
        } else {
            chatId = msg.number || msg.sender;
        }
        return chatsToDelete.includes(chatId);
    }).map(msg => msg.id);
    
    await db.sms_messages.bulkDelete(idsToDelete);
    
    // å¦‚æœå½“å‰æ‰“å¼€çš„èŠå¤©è¢«åˆ é™¤äº†ï¼Œå…ˆè¿”å›åˆ—è¡¨é¡µ
    if (currentMessageChatId && selectedMessageChats.has(currentMessageChatId)) {
        goBackMessageList();
    }
    
    // æ¸…ç©ºé€‰æ‹©å¹¶é€€å‡ºç¼–è¾‘æ¨¡å¼
    selectedMessageChats.clear();
    isMessageEditMode = false;
    
    const editBtn = document.getElementById('message-edit-btn');
    if (editBtn) editBtn.textContent = 'ç¼–è¾‘';
    
    const listContainer = document.getElementById('message-chat-list-container');
    if (listContainer) {
        listContainer.classList.remove('edit-mode');
    }
    
    hideMessageEditActions();
    
    // é‡æ–°æ¸²æŸ“åˆ—è¡¨
    await renderMessageList();
}

// æ¸²æŸ“ä¿¡æ¯åˆ—è¡¨
async function renderMessageList() {
    const listContainer = document.getElementById('message-chat-list-container');
    if (!listContainer) return;
    
    // ğŸ¯ ä» Dexie è¯»å–çŸ­ä¿¡è®°å½•ï¼ˆæŒ‰è´¦å·è¿‡æ»¤ï¼‰
    const accountId = getCurrentAccountId();
    let smsMessages = [];
    
    if (accountId) {
        smsMessages = await db.sms_messages.where('accountId').equals(accountId).toArray();
    }
    
    // æŒ‰èŠå¤©IDåˆ†ç»„ï¼ˆä¿®å¤ï¼šå‘é€çš„æ¶ˆæ¯ä½¿ç”¨æ¥æ”¶è€…IDï¼Œæ¥æ”¶çš„æ¶ˆæ¯ä½¿ç”¨å‘é€è€…IDï¼‰
    const groupedChats = {};
    
    // é¢„åŠ è½½è§’è‰²å¤´åƒç¼“å­˜
    const charAvatarCache = {};
    
    for (const msg of smsMessages) {
        // ğŸ¯ ä¿®å¤ï¼šå¯¹äºå‘é€çš„æ¶ˆæ¯ï¼Œä½¿ç”¨numberï¼ˆæ¥æ”¶è€…IDï¼‰åˆ†ç»„
        // å¯¹äºæ¥æ”¶çš„æ¶ˆæ¯ï¼Œä½¿ç”¨numberæˆ–senderï¼ˆå‘é€è€…IDï¼‰åˆ†ç»„
        let chatId;
        if (msg.type === 'sent') {
            // å‘é€çš„æ¶ˆæ¯ï¼šä½¿ç”¨numberå­—æ®µï¼ˆåº”è¯¥æ˜¯æ¥æ”¶è€…çš„IDï¼‰
            chatId = msg.number || msg.receiverId || msg.sender;
        } else {
            // æ¥æ”¶çš„æ¶ˆæ¯ï¼šä½¿ç”¨å‘é€è€…çš„ID
            chatId = msg.number || msg.sender;
        }
        
        if (!groupedChats[chatId]) {
            // ğŸ¯ ä¿®å¤ï¼šæ˜¾ç¤ºæ¥æ”¶è€…çš„åå­—ï¼ˆå¯¹äºå‘é€çš„æ¶ˆæ¯ï¼Œä½¿ç”¨å­˜å‚¨çš„æ¥æ”¶è€…ä¿¡æ¯ï¼‰
            let displayName = msg.sender;
            let displayAvatar = '';
            
            // å¦‚æœæœ‰ charIdï¼Œä»æ•°æ®åº“è·å–è§’è‰²å¤´åƒ
            if (msg.charId && !charAvatarCache[msg.charId]) {
                const char = await db.characters.get(msg.charId);
                if (char) {
                    charAvatarCache[msg.charId] = char.avatar;
                }
            }
            if (msg.charId && charAvatarCache[msg.charId]) {
                displayAvatar = charAvatarCache[msg.charId];
            }
            
            // å¦‚æœæ˜¯å‘é€çš„æ¶ˆæ¯ï¼Œä½¿ç”¨å­˜å‚¨çš„æ¥æ”¶è€…ä¿¡æ¯
            if (msg.type === 'sent' && msg.receiverName) {
                displayName = msg.receiverName;
                // æŸ¥æ‰¾åŒèŠå¤©ä¸­æ¥æ”¶çš„æ¶ˆæ¯ï¼Œè·å–æ¥æ”¶è€…å¤´åƒ
                const receivedMsg = smsMessages.find(m => 
                    (m.number || m.sender) === chatId && m.type !== 'sent'
                );
                if (receivedMsg && receivedMsg.charId) {
                    if (!charAvatarCache[receivedMsg.charId]) {
                        const char = await db.characters.get(receivedMsg.charId);
                        if (char) charAvatarCache[receivedMsg.charId] = char.avatar;
                    }
                    displayAvatar = charAvatarCache[receivedMsg.charId] || displayAvatar;
                }
            }
            
            groupedChats[chatId] = {
                id: chatId,
                name: displayName,
                avatar: displayAvatar,
                number: msg.number,
                messages: [],
                isBlocked: msg.isBlocked || false
            };
        }
        groupedChats[chatId].messages.push(msg);
    }
    
    // è½¬æ¢æˆæ•°ç»„å¹¶æŒ‰æœ€æ–°æ¶ˆæ¯æ—¶é—´æ’åº
    const chats = Object.values(groupedChats).map(chat => {
        const lastMsg = chat.messages[0]; // å› ä¸ºunshiftï¼Œç¬¬ä¸€ä¸ªæ˜¯æœ€æ–°çš„
        return {
            ...chat,
            time: formatMessageTime(lastMsg.time),
            preview: lastMsg.content,
            unread: !lastMsg.read
        };
    }).sort((a, b) => {
        return b.messages[0].time - a.messages[0].time;
    });
    
    // å§‹ç»ˆæ·»åŠ æ¬¢è¿æ¶ˆæ¯ï¼ˆç¡®ä¿å®ƒå§‹ç»ˆæ˜¾ç¤ºåœ¨åˆ—è¡¨ä¸­ï¼‰
    // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨æ¬¢è¿æ¶ˆæ¯ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™æ·»åŠ 
    const hasWelcome = chats.some(chat => chat.id === 'welcome');
    if (!hasWelcome) {
        chats.push({
            id: 'welcome',
            name: 'æ¬¢è¿å°åŠ©æ‰‹',
            avatar: 'https://img.icons8.com/color/96/chat.png',
            time: 'åˆšåˆš',
            preview: 'æ¬¢è¿ä½¿ç”¨è¿™ä¸ªç½‘é¡µï¼',
            unread: false
        });
    }
    
    listContainer.innerHTML = '';
    chats.forEach(chat => {
        const unreadClass = chat.unread ? 'message-unread' : '';
        const unreadDot = chat.unread ? `<div class="message-unread-dot"></div>` : '';
        const isSelected = selectedMessageChats.has(chat.id);
        const selectedClass = isSelected ? 'message-chat-selected' : '';
        
        // æ¬¢è¿å°åŠ©æ‰‹åœ¨ç¼–è¾‘æ¨¡å¼ä¸‹ä¸æ˜¾ç¤ºé€‰æ‹©æ¡†ï¼Œä¹Ÿä¸èƒ½è¢«é€‰æ‹©
        const isWelcome = chat.id === 'welcome';
        const showCheckbox = isMessageEditMode && !isWelcome;
        
        // ç¼–è¾‘æ¨¡å¼ä¸‹æ˜¾ç¤ºé€‰æ‹©æ¡†ï¼Œå¦åˆ™ç›´æ¥æ‰“å¼€èŠå¤©ï¼ˆæ¬¢è¿å°åŠ©æ‰‹å§‹ç»ˆå¯ä»¥æ‰“å¼€ï¼‰
        const onClickAction = showCheckbox
            ? `toggleMessageChatSelection('${chat.id}')`
            : `openMessageChat('${chat.id}')`;
        
        const checkbox = showCheckbox
            ? `<div class="message-chat-checkbox ${isSelected ? 'checked' : ''}">
                <svg viewBox="0 0 24 24" style="width:20px;height:20px;stroke:currentColor;fill:none;stroke-width:3;">
                    ${isSelected ? '<path d="M20 6L9 17l-5-5"></path>' : ''}
                </svg>
               </div>`
            : '';
        
        const defaultAvatarClass = chat.avatar ? '' : 'default-avatar';
        const avatarImg = chat.avatar 
            ? `<img src="${chat.avatar}" style="width:100%;height:100%;object-fit:cover;" onerror="this.style.display='none';this.parentElement.classList.add('default-avatar');">`
            : '';
        
        const html = `
            <div class="message-chat-item ${unreadClass} ${selectedClass}" onclick="${onClickAction}">
                ${checkbox}
                <div class="message-avatar ${defaultAvatarClass}">
                    ${avatarImg}
                </div>
                <div class="message-chat-info">
                    <div class="message-chat-top">
                        <span class="message-chat-name">${chat.name}</span>
                        <div class="message-chat-time">
                            <span>${chat.time}</span>
                        </div>
                    </div>
                    <div class="message-chat-bottom">
                        <div class="message-chat-preview">${chat.preview}</div>
                        ${unreadDot}
                    </div>
                </div>
            </div>
        `;
        listContainer.insertAdjacentHTML('beforeend', html);
    });
    
    // æ›´æ–°åˆ é™¤æŒ‰é’®
    updateMessageDeleteButton();
}

// æ ¼å¼åŒ–æ¶ˆæ¯æ—¶é—´
function formatMessageTime(timestamp) {
    const now = Date.now();
    const diff = now - timestamp;
    const date = new Date(timestamp);
    
    // 1åˆ†é’Ÿå†…
    if (diff < 60000) {
        return 'åˆšåˆš';
    }
    // 1å°æ—¶å†…
    if (diff < 3600000) {
        return Math.floor(diff / 60000) + 'åˆ†é’Ÿå‰';
    }
    // ä»Šå¤©
    const today = new Date();
    if (date.getDate() === today.getDate() && 
        date.getMonth() === today.getMonth() && 
        date.getFullYear() === today.getFullYear()) {
        return date.getHours() + ':' + String(date.getMinutes()).padStart(2, '0');
    }
    // æ˜¨å¤©
    const yesterday = new Date(today);
    yesterday.setDate(yesterday.getDate() - 1);
    if (date.getDate() === yesterday.getDate() && 
        date.getMonth() === yesterday.getMonth() && 
        date.getFullYear() === yesterday.getFullYear()) {
        return 'æ˜¨å¤©';
    }
    // ä¸€å‘¨å†…
    if (diff < 7 * 24 * 3600000) {
        const days = ['å‘¨æ—¥', 'å‘¨ä¸€', 'å‘¨äºŒ', 'å‘¨ä¸‰', 'å‘¨å››', 'å‘¨äº”', 'å‘¨å…­'];
        return days[date.getDay()];
    }
    // æ›´æ—©
    return (date.getMonth() + 1) + '/' + date.getDate();
}

// å½“å‰çŸ­ä¿¡èŠå¤©çš„è”ç³»äººIDï¼ˆå…¨å±€å˜é‡ï¼‰
let currentMessageChatId = null;
let currentMessageChatName = null;

// æ‰“å¼€èŠå¤©è¯¦æƒ…
async function openMessageChat(id) {
    console.log('openMessageChat called with id:', id);
    
    const accountId = getCurrentAccountId();
    
    // ğŸ¯ ä» Dexie è¯»å–çŸ­ä¿¡è®°å½•
    let smsMessages = [];
    if (accountId) {
        smsMessages = await db.sms_messages.where('accountId').equals(accountId).toArray();
    }
    
    // æŸ¥æ‰¾è¯¥è”ç³»äººçš„æ‰€æœ‰æ¶ˆæ¯ï¼ˆä¿®å¤ï¼šæ”¯æŒå‘é€å’Œæ¥æ”¶çš„æ¶ˆæ¯ï¼‰
    const chatMessages = smsMessages.filter(msg => {
        if (msg.type === 'sent') {
            // å‘é€çš„æ¶ˆæ¯ï¼šä½¿ç”¨numberï¼ˆæ¥æ”¶è€…IDï¼‰æˆ–receiverIdåŒ¹é…
            return (msg.number || msg.receiverId) === id;
        } else {
            // æ¥æ”¶çš„æ¶ˆæ¯ï¼šä½¿ç”¨å‘é€è€…çš„IDåŒ¹é…
            return (msg.number || msg.sender) === id;
        }
    });
    
    if (chatMessages.length === 0 && id !== 'welcome') {
        console.error('Chat not found:', id);
        return;
    }
    
    // æ„å»ºèŠå¤©å¯¹è±¡
    let chat;
    if (id === 'welcome') {
        // æ¬¢è¿æ¶ˆæ¯
        chat = {
            id: 'welcome',
            name: 'æ¬¢è¿å°åŠ©æ‰‹',
            avatar: 'https://img.icons8.com/color/96/chat.png',
            chatTimeLabel: 'åˆšåˆš',
            messages: [{
                type: 'received',
                text: 'æ¬¢è¿ä½¿ç”¨è¿™ä¸ªç½‘é¡µï¼ğŸ‰\n\nè¿™æ˜¯ä¸€ä¸ªä»¿ iOS é£æ ¼çš„ä¿¡æ¯åº”ç”¨ï¼Œä½ å¯ä»¥åœ¨è¿™é‡Œï¼š\n\nâ€¢ æŸ¥çœ‹å’Œç®¡ç†ä½ çš„ä¿¡æ¯\nâ€¢ ä¸å¥½å‹èŠå¤©\nâ€¢ å‘é€å’Œæ¥æ”¶æ¶ˆæ¯\n\nå¸Œæœ›ä½ èƒ½å–œæ¬¢è¿™ä¸ªè®¾è®¡ï¼å¦‚æœ‰ä»»ä½•é—®é¢˜ï¼Œéšæ—¶å‘Šè¯‰æˆ‘ã€‚'
            }]
        };
        currentMessageChatId = null;
        currentMessageChatName = null;
    } else {
        // çœŸå®çŸ­ä¿¡
        console.log('[openMessageChat] èŠå¤©æ¶ˆæ¯æ•°é‡:', chatMessages.length);
        console.log('[openMessageChat] ç¬¬ä¸€æ¡æ¶ˆæ¯:', chatMessages[0]);
        
        // ğŸ¯ ä¿®å¤ï¼šæ‰¾åˆ°æ¥æ”¶æ¶ˆæ¯æ¥ç¡®å®šæ¥æ”¶è€…ä¿¡æ¯ï¼ˆå¦‚æœåªæœ‰å‘é€æ¶ˆæ¯ï¼Œä½¿ç”¨å­˜å‚¨çš„æ¥æ”¶è€…ä¿¡æ¯ï¼‰
        const receivedMsg = chatMessages.find(msg => msg.type !== 'sent');
        const firstMsg = receivedMsg || chatMessages[chatMessages.length - 1]; // ä¼˜å…ˆä½¿ç”¨æ¥æ”¶æ¶ˆæ¯ï¼Œå¦åˆ™ç”¨æœ€æ—©çš„æ¶ˆæ¯
        
        console.log('[openMessageChat] ç¬¬ä¸€æ¡æ¶ˆæ¯å†…å®¹:', firstMsg);
        
        // ç¡®å®šæ˜¾ç¤ºçš„åå­—å’Œå¤´åƒï¼ˆä»è§’è‰²æ•°æ®åº“è·å–ï¼‰
        let displayName = firstMsg.sender;
        let displayAvatar = '';
        
        // å¦‚æœæœ‰ charIdï¼Œä»æ•°æ®åº“è·å–è§’è‰²å¤´åƒ
        if (firstMsg.charId) {
            const char = await db.characters.get(firstMsg.charId);
            if (char) {
                displayAvatar = char.avatar || displayAvatar;
            }
        }
        
        // å¦‚æœç¬¬ä¸€æ¡æ¶ˆæ¯æ˜¯å‘é€çš„æ¶ˆæ¯ï¼Œä½¿ç”¨å­˜å‚¨çš„æ¥æ”¶è€…ä¿¡æ¯
        if (firstMsg.type === 'sent' && firstMsg.receiverName) {
            displayName = firstMsg.receiverName;
            // å°è¯•ä»æ¥æ”¶æ¶ˆæ¯ä¸­è·å–å¤´åƒ
            const receivedMsgForAvatar = chatMessages.find(msg => msg.type !== 'sent');
            if (receivedMsgForAvatar && receivedMsgForAvatar.charId) {
                const char = await db.characters.get(receivedMsgForAvatar.charId);
                if (char) {
                    displayAvatar = char.avatar || displayAvatar;
                }
            }
        }
        
        console.log('[openMessageChat] æ˜¾ç¤ºåç§°:', displayName);
        console.log('[openMessageChat] æ˜¾ç¤ºå¤´åƒ:', displayAvatar);
        
        chat = {
            id: id,
            name: displayName,
            avatar: displayAvatar,
            chatTimeLabel: formatMessageTime(firstMsg.time || firstMsg.timestamp || Date.now()),
            messages: chatMessages.reverse().map(msg => {
                const msgText = msg.content || msg.message || '';
                console.log('[openMessageChat] æ˜ å°„æ¶ˆæ¯:', { type: msg.type, text: msgText });
                return {
                    type: msg.type || (msg.sender === displayName ? 'received' : 'sent'),
                    text: msgText
                };
            })
        };
        
        console.log('[openMessageChat] æœ€ç»ˆèŠå¤©å¯¹è±¡:', chat);
        
        // ä¿å­˜å½“å‰èŠå¤©ä¿¡æ¯
        currentMessageChatId = id;
        currentMessageChatName = displayName;
        
        // æ ‡è®°ä¸ºå·²è¯»ï¼ˆä¿®å¤ï¼šæ”¯æŒå‘é€å’Œæ¥æ”¶çš„æ¶ˆæ¯ï¼‰
        const idsToUpdate = chatMessages.map(msg => msg.id);
        for (const msgId of idsToUpdate) {
            await db.sms_messages.update(msgId, { read: true });
        }
    }
    
    // éšè—åˆ—è¡¨é¡µ
    const listPage = document.getElementById('message-list-page');
    if (listPage) {
        listPage.style.display = 'none';
    }
    
    // æ˜¾ç¤ºè¯¦æƒ…é¡µ
    const detailPage = document.getElementById('message-detail-page');
    if (!detailPage) {
        console.error('Detail page not found');
        return;
    }
    
    // å…ˆè®¾ç½® displayï¼Œå†æ·»åŠ  active ç±»è§¦å‘åŠ¨ç”»
    detailPage.style.display = 'flex';
    // ä½¿ç”¨ setTimeout ç¡®ä¿ display è®¾ç½®åå†è§¦å‘åŠ¨ç”»
    setTimeout(() => {
        detailPage.classList.add('active');
    }, 10);
    
    // è®¾ç½®èŠå¤©ä¿¡æ¯
    document.getElementById('message-detail-name').innerText = chat.name;
    const avatarEl = document.getElementById('message-detail-avatar');
    if (avatarEl) {
        const avatarContainer = avatarEl.parentElement;
        if (chat.avatar) {
            avatarEl.src = chat.avatar;
            avatarEl.style.display = '';
            avatarContainer.classList.remove('default-avatar');
            avatarEl.onerror = function() {
                this.style.display = 'none';
                avatarContainer.classList.add('default-avatar');
            };
        } else {
            avatarEl.style.display = 'none';
            avatarContainer.classList.add('default-avatar');
        }
    }
    
    // æ¸²æŸ“æ¶ˆæ¯
    const msgContainer = document.getElementById('message-container');
    if (!msgContainer) {
        console.error('Message container not found');
        return;
    }
    
    let htmlContent = `<div class="message-ts-group"><span class="message-ts-label">iMessage</span><span class="message-ts-time">${chat.chatTimeLabel || 'ä»Šå¤©'}</span></div>`;
    
    chat.messages.forEach((msg, index) => {
        htmlContent += `<div class="message-wrapper"><div class="message-bubble ${msg.type === 'sent' ? 'message-sent' : 'message-received'}">${msg.text.replace(/\n/g, '<br>')}</div></div>`;
        if (msg.type === 'sent' && index === chat.messages.length - 1) {
            htmlContent += `<div class="message-delivery-text" style="opacity:1">å·²é€è¾¾</div>`;
        }
    });
    
    msgContainer.innerHTML = htmlContent;
    
    // æ»šåŠ¨åˆ°åº•éƒ¨
    setTimeout(() => {
        const scrollArea = document.getElementById('message-area-scroll');
        if (scrollArea) {
            scrollArea.scrollTo({ top: scrollArea.scrollHeight, behavior: 'instant' });
        }
    }, 10);
    
    // åˆå§‹åŒ–è¾“å…¥æ¡†çŠ¶æ€ï¼ˆéšè—å‘é€æŒ‰é’®ï¼Œæ˜¾ç¤ºéº¦å…‹é£ï¼‰
    const msgInput = document.getElementById('message-msg-input');
    if (msgInput) {
        msgInput.value = '';
        handleMessageInputChange(msgInput);
    }
}

// ç¡®ä¿å‡½æ•°åœ¨å…¨å±€ä½œç”¨åŸŸ
window.openMessageChat = openMessageChat;
window.sendMessageDetail = sendMessageDetail;
window.handleMessageInputChange = handleMessageInputChange;
window.acceptMessageReply = acceptMessageReply;
window.toggleMessageEditMode = toggleMessageEditMode;
window.toggleMessageChatSelection = toggleMessageChatSelection;
window.deleteSelectedMessageChats = deleteSelectedMessageChats;
window.showMessageSwitchAccount = showMessageSwitchAccount;

function showMessagePage() {
    document.getElementById('message-page').classList.add('active');
    // é»˜è®¤æ˜¾ç¤ºåˆ—è¡¨é¡µ
    document.getElementById('message-list-page').style.display = 'flex';
    // ç¡®ä¿è¯¦æƒ…é¡µå’Œæ–°å»ºé¡µéšè—
    const detailPage = document.getElementById('message-detail-page');
    if (detailPage) {
        detailPage.classList.remove('active');
        detailPage.style.display = 'none';
    }
    const composePage = document.getElementById('message-compose-page');
    if (composePage) {
        composePage.classList.remove('active');
        composePage.style.display = 'none';
    }
    // æ¸²æŸ“åˆ—è¡¨
    renderMessageList();
}

function hideMessagePage() {
    document.getElementById('message-page').classList.remove('active');
    document.getElementById('message-list-page').style.display = 'none';
    document.getElementById('message-detail-page').classList.remove('active');
    document.getElementById('message-compose-page').classList.remove('active');
}

function goBackMessageList() {
    const detailPage = document.getElementById('message-detail-page');
    if (detailPage) {
        detailPage.classList.remove('active');
        // ç­‰å¾…åŠ¨ç”»å®Œæˆåå†éšè—
        setTimeout(() => {
            detailPage.style.display = 'none';
        }, 400);
    }
    
    // æ˜¾ç¤ºåˆ—è¡¨é¡µ
    const listPage = document.getElementById('message-list-page');
    if (listPage) {
        listPage.style.display = 'flex';
    }
}

function openComposeMessage() {
    document.getElementById('message-compose-page').classList.add('active');
}

function closeComposeMessage() {
    document.getElementById('message-compose-page').classList.remove('active');
}

// å‘é€çŸ­ä¿¡è¯¦æƒ…é¡µçš„æ¶ˆæ¯
async function sendMessageDetail() {
    const input = document.getElementById('message-msg-input');
    const text = input.value.trim();
    
    if (!text) return;
    
    // å¦‚æœæ²¡æœ‰å½“å‰èŠå¤©ï¼Œä¸èƒ½å‘é€
    if (!currentMessageChatId || currentMessageChatId === 'welcome') {
        alert('æ— æ³•å‘é€æ¶ˆæ¯');
        return;
    }
    
    // ğŸ¯ æ£€æŸ¥ä½™é¢ï¼ˆæ¯æ¡çŸ­ä¿¡0.1å…ƒï¼‰
    const SMS_COST = 0.1;
    const balance = getPhoneBalance();
    if (balance < SMS_COST) {
        const recharge = confirm(`ä½™é¢ä¸è¶³ï¼ˆå½“å‰ä½™é¢ï¼šÂ¥${balance.toFixed(2)}ï¼‰\n\næ¯æ¡çŸ­ä¿¡éœ€è¦ Â¥${SMS_COST.toFixed(2)}ï¼Œè¯·å…ˆå……å€¼ã€‚\n\næ˜¯å¦å‰å¾€å……å€¼ï¼Ÿ`);
        if (recharge) {
            hideMessagePage();
            setTimeout(() => {
                showPhoneRechargePage();
            }, 300);
        }
        return;
    }
    
    // è·å–å½“å‰ç”¨æˆ·ä¿¡æ¯
    const accountId = getCurrentAccountId();
    if (!accountId) {
        alert('è¯·å…ˆç™»å½•');
        return;
    }
    
    const myChar = await db.characters.get(parseInt(accountId));
    if (!myChar) {
        alert('æ‰¾ä¸åˆ°ç”¨æˆ·ä¿¡æ¯');
        return;
    }
    
    // ğŸ¯ æ‰£è´¹
    if (!deductPhoneBalance(SMS_COST)) {
        alert('æ‰£è´¹å¤±è´¥ï¼Œè¯·é‡è¯•');
        return;
    }
    
    // æ¸…ç©ºè¾“å…¥æ¡†
    input.value = '';
    handleMessageInputChange(input);
    
    // ä¿å­˜å‘é€çš„æ¶ˆæ¯åˆ° Dexie
    const myPhoneNumber = myChar.identity?.phone || generateVirtualPhoneNumber(myChar.id);
    
    // ğŸ¯ å…³é”®ä¿®å¤ï¼šä½¿ç”¨å½“å‰èŠå¤©çš„IDï¼ˆæ¥æ”¶è€…çš„IDï¼‰ä½œä¸ºèŠå¤©æ ‡è¯†
    // è¿™æ ·æ¶ˆæ¯ä¼šå½’å…¥æ­£ç¡®çš„èŠå¤©ï¼Œè€Œä¸æ˜¯åˆ›å»ºæ–°çš„èŠå¤©
    // åŒæ—¶å­˜å‚¨æ¥æ”¶è€…ä¿¡æ¯ï¼Œç¡®ä¿åˆ†ç»„å’Œæ˜¾ç¤ºæ­£ç¡®
    await db.sms_messages.add({
        accountId: accountId,
        charId: null, // å‘é€çš„æ¶ˆæ¯ä¸éœ€è¦ charId
        sender: myChar.nick || myChar.name,
        number: currentMessageChatId, // ä½¿ç”¨æ¥æ”¶è€…çš„IDä½œä¸ºnumberï¼Œç¡®ä¿åˆ†ç»„æ­£ç¡®
        content: text,
        time: Date.now(),
        read: true,
        type: 'sent', // æ ‡è®°ä¸ºå‘é€çš„æ¶ˆæ¯
        receiverName: currentMessageChatName, // å­˜å‚¨æ¥æ”¶è€…åå­—ï¼Œç”¨äºæ˜¾ç¤º
        receiverId: currentMessageChatId // å­˜å‚¨æ¥æ”¶è€…ID
    });
    
    // é‡æ–°æ¸²æŸ“æ¶ˆæ¯åˆ—è¡¨
    renderMessageList();
    
    // åœ¨è¯¦æƒ…é¡µæ˜¾ç¤ºæ–°æ¶ˆæ¯
    const msgContainer = document.getElementById('message-container');
    if (msgContainer) {
        const scrollArea = document.getElementById('message-area-scroll');
        const wasAtBottom = scrollArea.scrollHeight - scrollArea.scrollTop <= scrollArea.clientHeight + 50;
        
        const newMsgHtml = `<div class="message-wrapper"><div class="message-bubble message-sent">${text.replace(/\n/g, '<br>')}</div></div>`;
        msgContainer.innerHTML += newMsgHtml;
        
        // å¦‚æœä¹‹å‰åœ¨åº•éƒ¨ï¼Œæ»šåŠ¨åˆ°åº•éƒ¨
        if (wasAtBottom) {
            setTimeout(() => {
                scrollArea.scrollTo({ top: scrollArea.scrollHeight, behavior: 'smooth' });
            }, 10);
        }
    }
}

// å¤„ç†çŸ­ä¿¡è¾“å…¥æ¡†å˜åŒ–ï¼ˆåˆ‡æ¢éº¦å…‹é£å’Œå‘é€æŒ‰é’®ï¼‰
function handleMessageInputChange(input) {
    const hasText = input.value.trim().length > 0;
    const micIcon = document.getElementById('message-icon-mic');
    const sendBtn = document.getElementById('message-btn-send');
    
    if (hasText) {
        if (micIcon) micIcon.style.display = 'none';
        if (sendBtn) sendBtn.style.display = 'flex';
    } else {
        if (micIcon) micIcon.style.display = 'flex';
        if (sendBtn) sendBtn.style.display = 'none';
    }
}

// çŸ­ä¿¡é¡µé¢æ¥å—å›å¤ï¼ˆè°ƒç”¨APIï¼‰
async function acceptMessageReply() {
    if (!currentMessageChatId || currentMessageChatId === 'welcome') {
        alert('æ— æ³•æ¥å—å›å¤');
        return;
    }
    
    // é€šè¿‡è”ç³»äººåç§°æŸ¥æ‰¾è§’è‰²
    const allChars = await db.characters.toArray();
    const targetChar = allChars.find(char => 
        (char.nick || char.name) === currentMessageChatName
    );
    
    if (!targetChar) {
        alert('æ‰¾ä¸åˆ°å¯¹åº”çš„è§’è‰²');
        return;
    }
    
    const accountId = getCurrentAccountId();
    if (!accountId) {
        alert('è¯·å…ˆç™»å½•');
        return;
    }
    
    const myChar = await db.characters.get(parseInt(accountId));
    if (!myChar) {
        alert('æ‰¾ä¸åˆ°ç”¨æˆ·ä¿¡æ¯');
        return;
    }
    
    console.log('[acceptMessageReply] âš¡ å¼€å§‹æ¥å—çŸ­ä¿¡å›å¤');
    console.log('[acceptMessageReply] è§’è‰²åç§°:', targetChar.name);
    console.log('[acceptMessageReply] è´¦å· ID:', accountId);
    
    try {
        // 1. è·å–å…³è”æ•°æ® (User å’Œ Lorebook) - ä¸ triggerAiReply ä¿æŒä¸€è‡´
        console.log('[acceptMessageReply] ğŸ“– å¼€å§‹åŠ è½½ä¸Šä¸‹æ–‡ä¿¡æ¯...');
        
        let userDesc = "";
        let userName = "ç”¨æˆ·";
        if (targetChar.linked_user_id) {
            console.log('[acceptMessageReply] ğŸ‘¤ æ£€æµ‹åˆ°å…³è”çš„ç”¨æˆ· ID:', targetChar.linked_user_id);
            const user = await db.characters.get(targetChar.linked_user_id);
            if (user) {
                userName = user.name;
                userDesc = `\n\nã€å¯¹è¯å¯¹è±¡(User)ä¿¡æ¯ã€‘\nåå­—ï¼š${user.name}\nè®¾å®šï¼š${user.description || 'æ— '}`;
                console.log('[acceptMessageReply] âœ… ç”¨æˆ·äººè®¾å·²åŠ è½½:', userName);
            } else {
                console.warn('[acceptMessageReply] âš ï¸ æœªæ‰¾åˆ°å…³è”çš„ç”¨æˆ·æ•°æ®');
            }
        } else {
            console.log('[acceptMessageReply] â„¹ï¸ æœªè®¾ç½®å…³è”ç”¨æˆ·');
        }
        
        let loreContext = "";
        const lorebookIds = targetChar.lorebookIds || (targetChar.lorebookId ? [targetChar.lorebookId] : []);
        console.log('[acceptMessageReply] ğŸ“š å…³è”çš„ä¸–ç•Œä¹¦ ID:', lorebookIds);
        
        // è·å–å¾®ä¿¡èŠå¤©å†å²ç”¨äºä¸–ç•Œä¹¦åŒ¹é…
        const wechatHistory = getChatHistory(targetChar, accountId);
        const recentText = wechatHistory.slice(-10).map(m => m.content).join(' ');
        
        if (lorebookIds.length > 0) {
            console.log('[acceptMessageReply] ğŸ” ç”¨äºåŒ¹é…ä¸–ç•Œä¹¦çš„å…³é”®è¯æ–‡æœ¬:', recentText.substring(0, 100));
            loreContext = await getLorebookContext(lorebookIds, `${targetChar.name} ${userName} ${recentText}`);
            if (loreContext) {
                console.log('[acceptMessageReply] âœ… ä¸–ç•Œä¹¦å†…å®¹å·²åŠ è½½ï¼ˆé•¿åº¦ï¼‰:', loreContext.length);
            } else {
                console.log('[acceptMessageReply] â„¹ï¸ æ²¡æœ‰åŒ¹é…åˆ°ä¸–ç•Œä¹¦æ¡ç›®');
            }
        } else {
            console.log('[acceptMessageReply] â„¹ï¸ æœªè®¾ç½®ä¸–ç•Œä¹¦');
        }
        
        // 2. è·å–å¾®ä¿¡èŠå¤©å†å²ï¼ˆç”¨äºä¸Šä¸‹æ–‡ï¼‰
        const fullWechatHistory = getChatHistory(targetChar, accountId);
        console.log('[acceptMessageReply] ğŸ“š å¾®ä¿¡èŠå¤©å†å²æ¡æ•°:', fullWechatHistory.length);
        
        // 3. è·å–çŸ­ä¿¡èŠå¤©å†å²ï¼ˆä» Dexieï¼‰
        let smsMessages = await db.sms_messages.where('accountId').equals(accountId).toArray();
        const chatMessages = smsMessages.filter(msg => (msg.number || msg.sender) === currentMessageChatId);
        console.log('[acceptMessageReply] ğŸ“± çŸ­ä¿¡èŠå¤©å†å²æ¡æ•°:', chatMessages.length);
        
        // 4. è®¡ç®—è™šæ‹Ÿæ—¶é—´
        const virtualTimeStr = getFormattedVirtualTime(targetChar.timeOffset);
        
        // 5. æ„å»ºç³»ç»Ÿæç¤ºï¼ˆä¸ triggerAiReply ä¿æŒä¸€è‡´ï¼‰
        let systemPrompt = `ä½ æ­£åœ¨è¿›è¡Œè§’è‰²æ‰®æ¼”ã€‚
ã€å½“å‰æ—¶é—´ã€‘
${virtualTimeStr}

ã€è§’è‰²(ä½ )ä¿¡æ¯ã€‘
åå­—ï¼š${targetChar.name}
${targetChar.nick ? `æ˜µç§°ï¼š${targetChar.nick}` : ''}
ç±»å‹ï¼š${targetChar.type || 'char'}
è®¾å®šï¼š
${targetChar.description || ''}

${targetChar.identity ? `è™šæ‹Ÿèº«ä»½ä¿¡æ¯ï¼š
${targetChar.identity.account ? `è´¦å·ï¼š${targetChar.identity.account}` : ''}
${targetChar.type !== 'user' && targetChar.identity.password ? `å¯†ç ï¼š${targetChar.identity.password}` : ''}
${targetChar.identity.phone ? `æ‰‹æœºï¼š${targetChar.identity.phone}` : ''}
${targetChar.identity.address ? `ä½å€ï¼š${targetChar.identity.address}` : ''}
${targetChar.identity.id_card ? `èº«ä»½è¯ï¼š${targetChar.identity.id_card}` : ''}
${targetChar.identity.bank_card ? `é“¶è¡Œå¡ï¼š${targetChar.identity.bank_card}` : ''}
${targetChar.type !== 'user' && targetChar.identity.bank_password ? `é“¶è¡Œå¡å¯†ç ï¼š${targetChar.identity.bank_password}` : ''}
${targetChar.identity.balance !== undefined && targetChar.identity.balance !== null ? `ä½™é¢ï¼š${targetChar.identity.balance}` : ''}
` : ''}
${userDesc}
${loreContext}

è¯·å®Œå…¨æ²‰æµ¸åœ¨è§’è‰²ä¸­ï¼Œç”¨ç¬¦åˆè§’è‰²æ€§æ ¼çš„è¯­æ°”å›å¤ã€‚
å›å¤ç®€çŸ­è‡ªç„¶ï¼ŒåƒçœŸå®çŸ­ä¿¡ä¸€æ ·ã€‚
è¯·æ³¨æ„ï¼šä¸è¦é‡å¤è¾“å‡ºåå­—å‰ç¼€ï¼Œç›´æ¥è¾“å‡ºå›å¤å†…å®¹ã€‚

ã€é‡è¦å›å¤è§„åˆ™ - å¿…é¡»ä¸¥æ ¼éµå®ˆã€‘
1. **å¿…é¡»**æ¨¡æ‹ŸçŸ­ä¿¡è¿å‘æ¶ˆæ¯çš„ä¹ æƒ¯ï¼šè¯·ç”Ÿæˆ 1 åˆ° 3 æ¡çŸ­æ¶ˆæ¯ï¼Œä¸èƒ½åªå‘ä¸€æ¡ï¼
2. **å¿…é¡»**ä½¿ç”¨åˆ†éš”ç¬¦ "|||" æ¥éš”å¼€æ¯ä¸€æ¡æ¶ˆæ¯ã€‚
3. **ä¸¥ç¦ä½¿ç”¨é€—å·**ï¼ˆåŒ…æ‹¬ä¸­æ–‡é€—å·å’Œè‹±æ–‡é€—å·ï¼‰ã€‚å¦‚æœæƒ³è¡¨è¾¾åœé¡¿ï¼Œè¯·ç›´æ¥æ‹†åˆ†æˆä¸‹ä¸€æ¡æ¶ˆæ¯ï¼Œæˆ–è€…ç”¨ç©ºæ ¼ä»£æ›¿ã€‚
4. æ¯æ¡æ¶ˆæ¯è¦ç®€çŸ­ï¼Œ5-15ä¸ªå­—æœ€ä½³ï¼ŒåƒçœŸå®çŸ­ä¿¡èŠå¤©ä¸€æ ·åˆ†å¤šæ¡å‘é€ã€‚
5. ä¸¥ç¦åªå‘é€æ ‡ç‚¹ç¬¦å·ã€‚æ¯ä¸€æ¡æ¶ˆæ¯éƒ½å¿…é¡»æœ‰å®é™…æ–‡å­—å†…å®¹ã€‚
6. è¯­æ°”è¦è‡ªç„¶ã€å£è¯­åŒ–ï¼Œç¬¦åˆäººè®¾ã€‚

è¯·ä»¥JSONæ ¼å¼è¿”å›ï¼š
{
  "reply": "ä½ çš„å›å¤å†…å®¹|||ç¬¬äºŒæ¡å†…å®¹|||ç¬¬ä¸‰æ¡å†…å®¹"
}`;
        
        // 6. æ„å»ºå†å²è®°å½•ï¼ˆåˆå¹¶å¾®ä¿¡å’ŒçŸ­ä¿¡å†å²ï¼‰
        // å…ˆå–å¾®ä¿¡å†å²ï¼ˆæœ€è¿‘Næ¡ï¼‰
        const contextCount = targetChar.context_message_count || 20;
        const recentWechatHistory = fullWechatHistory.slice(-contextCount)
            .map(m => {
                let content = m.content || '';
                if (m.imageDescription) {
                    content += `\n(å›¾ç‰‡æè¿°: ${m.imageDescription})`;
                }
                return {
                    role: m.role === 'char' ? 'assistant' : 'user',
                    content: content
                };
            })
            .filter(m => m.content && m.content.trim());
        
        // å†å–çŸ­ä¿¡å†å²ï¼ˆæœ€è¿‘10æ¡ï¼‰
        const recentSmsHistory = chatMessages.slice(-10).map(msg => {
            const isSent = msg.type === 'sent' || msg.sender === (myChar.nick || myChar.name);
            return {
                role: isSent ? 'user' : 'assistant',
                content: msg.content
            };
        }).filter(m => m.content && m.content.trim());
        
        // åˆå¹¶å†å²ï¼šå¾®ä¿¡å†å² + çŸ­ä¿¡å†å²ï¼ˆçŸ­ä¿¡å†å²æ”¾åœ¨æœ€åï¼Œå› ä¸ºæ˜¯æœ€æ–°çš„ï¼‰
        const combinedHistory = [...recentWechatHistory, ...recentSmsHistory].slice(-contextCount);
        
        console.log('[acceptMessageReply] ğŸ“ åˆå¹¶åçš„å†å²æ¶ˆæ¯æ•°:', combinedHistory.length);
        console.log('[acceptMessageReply]   - å¾®ä¿¡å†å²:', recentWechatHistory.length, 'æ¡');
        console.log('[acceptMessageReply]   - çŸ­ä¿¡å†å²:', recentSmsHistory.length, 'æ¡');
        
        // 7. è°ƒç”¨AI
        const messages = [
            { role: 'system', content: systemPrompt },
            ...combinedHistory
        ];
        
        console.log('[acceptMessageReply] ğŸ“¤ å‡†å¤‡å‘é€ç»™ AI');
        const aiResponse = await callAI(messages);
        
        // 8. è§£æå›å¤
        let replyText = '';
        const parsed = extractAndParseJSON(aiResponse);
        if (parsed) {
            replyText = parsed.reply || parsed.content || parsed.message || '';
        }
        
        if (!replyText) {
            replyText = aiResponse.trim() || '...';
        }
        
        // 9. å¤„ç†åˆ†éš”ç¬¦ï¼Œæ‹†åˆ†æˆå¤šæ¡æ¶ˆæ¯
        const replySegments = replyText.split('|||').map(s => s.trim()).filter(s => s.length > 0);
        
        if (replySegments.length === 0) {
            alert('AI è¿”å›ä¸ºç©º');
            return;
        }
        
        // 10. ä¿å­˜å›å¤åˆ°çŸ­ä¿¡è®°å½•ï¼ˆå¦‚æœæœ‰å¤šæ¡ï¼Œé€æ¡å‘é€ï¼‰
        const phoneNumber = targetChar.identity?.phone || generateVirtualPhoneNumber(targetChar.id);
        
        for (let i = 0; i < replySegments.length; i++) {
            const segment = replySegments[i];
            
            // å¦‚æœä¸æ˜¯ç¬¬ä¸€æ¡ï¼Œç¨å¾®å»¶æ—¶
            if (i > 0) {
                await new Promise(r => setTimeout(r, 500));
            }
            
            // ä¿å­˜åˆ° Dexie æ•°æ®åº“
            await db.sms_messages.add({
                accountId: accountId,
                charId: targetChar.id,
                sender: targetChar.nick || targetChar.name,
                number: phoneNumber,
                content: segment,
                time: Date.now() + i * 100, // ç¨å¾®é”™å¼€æ—¶é—´
                read: true,
                type: 'received'
            });
            
            // åœ¨è¯¦æƒ…é¡µæ˜¾ç¤ºæ–°æ¶ˆæ¯
            const msgContainer = document.getElementById('message-container');
            if (msgContainer) {
                const newMsgHtml = `<div class="message-wrapper"><div class="message-bubble message-received">${segment.replace(/\n/g, '<br>')}</div></div>`;
                msgContainer.innerHTML += newMsgHtml;
            }
        }
        
        // é‡æ–°æ¸²æŸ“æ¶ˆæ¯åˆ—è¡¨
        renderMessageList();
        
        // æ»šåŠ¨åˆ°åº•éƒ¨
        setTimeout(() => {
            const scrollArea = document.getElementById('message-area-scroll');
            if (scrollArea) {
                scrollArea.scrollTo({ top: scrollArea.scrollHeight, behavior: 'smooth' });
            }
        }, 100);
        
        console.log('[acceptMessageReply] âœ… å›å¤å®Œæˆï¼Œå…±', replySegments.length, 'æ¡æ¶ˆæ¯');
        
    } catch (error) {
        console.error('[acceptMessageReply] âŒ æ¥å—å›å¤å¤±è´¥:', error);
        alert('æ¥å—å›å¤å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•');
    }
}

function sendNewMessageDetail() {
    // å ä½å‡½æ•°ï¼Œåç»­å¯ä»¥æ·»åŠ å‘é€æ–°æ¶ˆæ¯çš„é€»è¾‘
    console.log('å‘é€æ–°æ¶ˆæ¯');
}

        function hideAppStorePage() {
            const page = document.getElementById('appstore-page');
            page.style.transform = 'scale(0.95)';
            page.style.opacity = '0';
            setTimeout(() => {
                page.style.display = 'none';
                page.style.transform = ''; 
                page.style.opacity = '';
            }, 200);
        }

        // æ¨¡æ‹Ÿåº”ç”¨æ•°æ®
        const appStoreData = {
            today: [
                { name: 'å¾®ä¿¡è¯»ä¹¦', subtitle: 'è®©é˜…è¯»ä¸å†å­¤å•', icon: 'https://img.icons8.com/color/96/book.png', rating: 4.8, downloads: '1000ä¸‡+', appId: 'wechat-read' },
                { name: 'å°çº¢ä¹¦', subtitle: 'æ ‡è®°æˆ‘çš„ç”Ÿæ´»', icon: 'https://img.icons8.com/color/96/instagram-new.png', rating: 4.7, downloads: '5000ä¸‡+', appId: 'xiaohongshu' },
                { name: 'Notion', subtitle: 'ä½ çš„å…¨èƒ½å·¥ä½œç©ºé—´', icon: 'https://img.icons8.com/color/96/notion.png', rating: 4.9, downloads: '500ä¸‡+', appId: 'notion' }
            ],
            games: [
                { name: 'åŸç¥', subtitle: 'å¼€æ”¾ä¸–ç•Œå†’é™©æ¸¸æˆ', icon: 'https://img.icons8.com/color/96/controller.png', rating: 4.6, downloads: '1äº¿+', appId: 'genshin' },
                { name: 'ç‹è€…è£è€€', subtitle: '5v5å…¬å¹³ç«æŠ€', icon: 'https://img.icons8.com/color/96/sword.png', rating: 4.5, downloads: '5äº¿+', appId: 'honor-of-kings' },
                { name: 'è›‹ä»”æ´¾å¯¹', subtitle: 'ä¸€èµ·æ¥ç©å§', icon: 'https://img.icons8.com/color/96/party.png', rating: 4.7, downloads: '2äº¿+', appId: 'eggy-party' }
            ],
            apps: [
                { name: 'ç½‘æ˜“äº‘éŸ³ä¹', subtitle: 'å‘ç°å¥½éŸ³ä¹', icon: 'https://img.icons8.com/color/96/music.png', rating: 4.8, downloads: '5äº¿+', appId: 'netease-music', desktopIconId: 'icon-photo', showFunction: 'showMusicAppPage' },
                { name: 'æ”¯ä»˜å®', subtitle: 'ç”Ÿæ´»å¥½ï¼Œæ”¯ä»˜å®', icon: 'https://img.icons8.com/color/96/alipay.png', rating: 4.8, downloads: '10äº¿+', appId: 'alipay' },
                { name: 'é«˜å¾·åœ°å›¾', subtitle: 'å‡ºè¡Œå¯¼èˆªå¿…å¤‡', icon: 'https://img.icons8.com/color/96/map.png', rating: 4.7, downloads: '5äº¿+', appId: 'amap' },
                { name: 'QQéŸ³ä¹', subtitle: 'å¬æˆ‘æƒ³å¬çš„æ­Œ', icon: 'https://img.icons8.com/color/96/music.png', rating: 4.6, downloads: '3äº¿+', appId: 'qq-music' }
            ],
            updates: [
                { name: 'å¾®ä¿¡', subtitle: 'ç‰ˆæœ¬ 8.0.50 æ›´æ–°', icon: 'https://img.icons8.com/color/96/wechat.png', rating: 4.9, downloads: 'å·²å®‰è£…', appId: 'wechat' },
                { name: 'QQ', subtitle: 'ç‰ˆæœ¬ 9.0.20 æ›´æ–°', icon: 'https://img.icons8.com/color/96/qq.png', rating: 4.7, downloads: 'å·²å®‰è£…', appId: 'qq' }
            ]
        };

        async function switchAppStoreTab(type) {
            // æ›´æ–°æ ‡ç­¾æ ·å¼
            document.querySelectorAll('.appstore-tab').forEach(tab => {
                if (tab.dataset.tab === type) {
                    tab.classList.add('active');
                } else {
                    tab.classList.remove('active');
                }
            });

            // æ¸²æŸ“å†…å®¹
            const container = document.getElementById('appstore-content');
            const apps = appStoreData[type] || [];
            
            if (apps.length === 0) {
                container.innerHTML = '<div style="text-align:center; color:#999; margin-top:60px;">æš‚æ— å†…å®¹</div>';
                return;
            }

            // æ£€æŸ¥æ¯ä¸ªåº”ç”¨çš„å®‰è£…çŠ¶æ€
            const appsWithStatus = await Promise.all(apps.map(async (app) => {
                const installed = await isAppInstalled(app.appId || '');
                return { ...app, installed };
            }));

            container.innerHTML = appsWithStatus.map(app => {
                const buttonText = app.installed ? 'æ‰“å¼€' : 'è·å–';
                const buttonClass = app.installed ? 'app-get-btn installed' : 'app-get-btn';
                return `
                <div class="app-card">
                    <div class="app-icon-large" style="background-image:url(${app.icon})"></div>
                    <div class="app-info">
                        <div>
                            <div class="app-name">${app.name}</div>
                            <div class="app-subtitle">${app.subtitle}</div>
                            <div class="app-rating">
                                <span class="app-stars">â˜…â˜…â˜…â˜…â˜…</span>
                                <span>${app.rating}</span>
                                <span>Â·</span>
                                <span>${app.installed ? 'å·²å®‰è£…' : app.downloads}</span>
                            </div>
                        </div>
                        <button class="${buttonClass}" onclick="downloadApp('${app.appId || ''}')">${buttonText}</button>
                    </div>
                </div>
            `;
            }).join('');
        }

        // åˆå§‹åŒ–å·²å®‰è£…åº”ç”¨
        document.addEventListener('DOMContentLoaded', async function() {
            await initInstalledApps();
        });

        // æœç´¢åŠŸèƒ½
        document.addEventListener('DOMContentLoaded', function() {
            const searchInput = document.getElementById('appstore-search');
            if (searchInput) {
                searchInput.addEventListener('input', function(e) {
                    const keyword = e.target.value.toLowerCase();
                    if (!keyword) {
                        // æ¢å¤å½“å‰æ ‡ç­¾å†…å®¹
                        const activeTab = document.querySelector('.appstore-tab.active');
                        if (activeTab) {
                            switchAppStoreTab(activeTab.dataset.tab);
                        }
                        return;
                    }

                    // æœç´¢æ‰€æœ‰åˆ†ç±»
                    const allApps = [...appStoreData.today, ...appStoreData.games, ...appStoreData.apps, ...appStoreData.updates];
                    const results = allApps.filter(app => 
                        app.name.toLowerCase().includes(keyword) || 
                        app.subtitle.toLowerCase().includes(keyword)
                    );

                    const container = document.getElementById('appstore-content');
                    if (results.length === 0) {
                        container.innerHTML = '<div style="text-align:center; color:#999; margin-top:60px;">æœªæ‰¾åˆ°ç›¸å…³åº”ç”¨</div>';
                    } else {
                        // æ£€æŸ¥æ¯ä¸ªåº”ç”¨çš„å®‰è£…çŠ¶æ€
                        Promise.all(results.map(async (app) => {
                            const installed = await isAppInstalled(app.appId || '');
                            return { ...app, installed };
                        })).then(appsWithStatus => {
                            container.innerHTML = appsWithStatus.map(app => {
                                const buttonText = app.installed ? 'æ‰“å¼€' : 'è·å–';
                                const buttonClass = app.installed ? 'app-get-btn installed' : 'app-get-btn';
                                return `
                                <div class="app-card">
                                    <div class="app-icon-large" style="background-image:url(${app.icon})"></div>
                                    <div class="app-info">
                                        <div>
                                            <div class="app-name">${app.name}</div>
                                            <div class="app-subtitle">${app.subtitle}</div>
                                            <div class="app-rating">
                                                <span class="app-stars">â˜…â˜…â˜…â˜…â˜…</span>
                                                <span>${app.rating}</span>
                                                <span>Â·</span>
                                                <span>${app.installed ? 'å·²å®‰è£…' : app.downloads}</span>
                                            </div>
                                        </div>
                                        <button class="${buttonClass}" onclick="downloadApp('${app.appId || ''}')">${buttonText}</button>
                                    </div>
                                </div>
                            `;
                            }).join('');
                        });
                    }
                });
            }
        });

// --- å¾®ä¿¡åº”ç”¨é€»è¾‘ ---
async function showWechatPage() {
    // ç¡®ä¿èŠå¤©çª—å£è¢«å…³é—­
    const chatWindow = document.getElementById('chat-window');
    if (chatWindow && chatWindow.style.display !== 'none') {
        chatWindow.style.display = 'none';
        currentChatCharId = null;
        console.log('[WechatPage] Closed chat window, cleared currentChatCharId');
    }
    
    // ğŸ¯ æ£€æŸ¥æ˜¯å¦æœ‰å·²æ³¨å†Œçš„User
    const hasRegisteredUser = await checkWechatRegistration();
    
    if (!hasRegisteredUser) {
        // é¦–æ¬¡ä½¿ç”¨ï¼Œæ˜¾ç¤ºæ³¨å†Œé¡µé¢
        console.log('[å¾®ä¿¡] é¦–æ¬¡ä½¿ç”¨ï¼Œæ˜¾ç¤ºæ³¨å†Œé¡µé¢');
        await showWechatRegisterPage();
    } else {
        // å·²æ³¨å†Œï¼Œæ˜¾ç¤ºå¾®ä¿¡ä¸»é¡µ
        console.log('[å¾®ä¿¡] å·²æ³¨å†Œï¼Œæ˜¾ç¤ºä¸»é¡µ');
        document.getElementById('wechat-page').style.display = 'flex';
        // æ‰“å¼€æ—¶è‡ªåŠ¨åˆ‡åˆ°ç¬¬ä¸€ä¸ªæ ‡ç­¾é¡µå¹¶æ¸²æŸ“
        switchWechatTab(0);
    }
}

// æ£€æŸ¥æ˜¯å¦æœ‰å·²æ³¨å†Œçš„User
async function checkWechatRegistration() {
    const users = await db.characters.where('type').equals('user').toArray();
    
    for (const user of users) {
        if (user.identity && user.identity.wechat_registered) {
            return true;
        }
    }
    
    return false;
}

// æ˜¾ç¤ºå¾®ä¿¡æ³¨å†Œé¡µé¢
async function showWechatRegisterPage() {
    const registerPage = document.getElementById('wechat-register-page');
    const userSelect = document.getElementById('register-user-select');
    
    // æ¸…ç©ºä¸‹æ‹‰æ¡†
    userSelect.innerHTML = '<option value="">-- è¯·é€‰æ‹©Useræ¡£æ¡ˆ --</option>';
    
    // åŠ è½½æ‰€æœ‰Useræ¡£æ¡ˆ
    const users = await db.characters.where('type').equals('user').toArray();
    
    if (users.length === 0) {
        showToast('è¯·å…ˆåˆ›å»ºUseræ¡£æ¡ˆ');
        return;
    }
    
    // å¡«å……ä¸‹æ‹‰æ¡†
    users.forEach(user => {
        const option = document.createElement('option');
        option.value = user.id;
        option.textContent = user.name;
        userSelect.appendChild(option);
    });
    
    // æ˜¾ç¤ºæ³¨å†Œé¡µé¢
    registerPage.style.display = 'flex';
}

        function hideWechatPage() {
            const page = document.getElementById('wechat-page');
            page.style.transform = 'scale(0.95)';
            page.style.opacity = '0';
            setTimeout(() => {
                page.style.display = 'none';
                page.style.transform = ''; 
                page.style.opacity = '';
            }, 200);
        }

        async function switchWechatTab(index) {
            const tabs = document.querySelectorAll('.wechat-tab-item');
            tabs.forEach((tab, i) => {
                if (i === index) {
                    tab.classList.add('active');
                } else {
                    tab.classList.remove('active');
                }
            });
            
            const content = document.getElementById('wechat-content');
            const title = document.getElementById('wechat-main-title');

            // æŸ¥å²—æ¨¡å¼ï¼šä½¿ç”¨æŸ¥å²—æ¨¡å¼çš„æ¸²æŸ“å‡½æ•°
            if (isViewingRoleAccount && currentViewingRoleAccountId) {
                const roleChar = await db.characters.get(parseInt(currentViewingRoleAccountId));
                const roleName = roleChar ? roleChar.name : 'è§’è‰²';
                
                if (index === 0) {
                    title.innerText = `${roleName}çš„å¾®ä¿¡`;
                    await renderRoleAccountWechatList(content);
                } else if (index === 1) {
                    title.innerText = `${roleName}çš„é€šè®¯å½•`;
                    await renderRoleAccountContactList(content);
                } else if (index === 2) {
                    title.innerText = `${roleName}çš„å‘ç°`;
                    await renderRoleAccountDiscoverPage(content);
                } else if (index === 3) {
                    title.innerText = `${roleName}çš„ä¿¡æ¯`;
                    await renderRoleAccountMePage(content);
                }
                return;
            }

            if (index === 0) {
                title.innerText = "å¾®ä¿¡";
                await renderWechatList(content);
            } else if (index === 1) {
                title.innerText = "é€šè®¯å½•";
                await renderContactList(content);
            } else if (index === 2) {
                title.innerText = "å‘ç°";
                content.innerHTML = `
                    <div class="wechat-cell-group" style="margin-top:0;">
                        <div class="wechat-cell" onclick="showMomentsPage()">
                            <div class="wechat-cell-icon icon-moments">
                                <svg class="svg-icon" style="stroke:currentColor;" viewBox="0 0 24 24"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path></svg>
                            </div>
                            <div class="wechat-cell-text">æœ‹å‹åœˆ</div>
                            <div class="wechat-cell-arrow">â€º</div>
                        </div>
                    </div>
                `;
            } else if (index === 3) {
                title.innerText = "æˆ‘";
                await renderMePage(content);
            }
        }

        // æ¸²æŸ“â€œæˆ‘â€çš„é¡µé¢
        async function renderMePage(container) {
            container.innerHTML = '';
            
            // è·å–å½“å‰â€œæˆ‘â€çš„è§’è‰²
            let myChar = null;
            if (currentMyCharId) {
                myChar = await db.characters.get(parseInt(currentMyCharId));
            }
            
            // å…œåº•ï¼šå¦‚æœæœªè®¾ç½®ï¼Œå°è¯•æ‰¾ç¬¬ä¸€ä¸ª User è§’è‰²
            if (!myChar) {
                const users = await db.characters.where('type').equals('user').toArray();
                if (users.length > 0) {
                    myChar = users[0];
                    currentMyCharId = myChar.id;
                    localStorage.setItem('current_my_char_id', currentMyCharId);
                }
            }
            
            const avatarUrl = myChar && myChar.avatar ? myChar.avatar : '';
            const name = myChar ? myChar.name : 'æœªç™»å½•';
            // å°è¯•è·å–è™šæ‹Ÿå¾®ä¿¡å·
            const account = myChar && myChar.identity && myChar.identity.account ? myChar.identity.account : (myChar ? `wxid_${myChar.id}` : 'æœªè®¾ç½®');
            
            const profileHtml = `
                <div class="wechat-profile" onclick="openProfileSettings()">
                    <div class="wechat-profile-avatar" style="${avatarUrl ? `background-image:url(${avatarUrl})` : ''}"></div>
                    <div class="wechat-profile-info">
                        <div class="wechat-profile-name">${name}</div>
                        <div class="wechat-profile-id">
                            <span>å¾®ä¿¡å·ï¼š${account}</span>
                            <svg class="svg-icon wechat-qrcode-icon" viewBox="0 0 24 24" style="width:16px;height:16px;"><path d="M3 3h6v6H3zm2 2v2h2V5zm8-2h6v6h-6zm2 2v2h2V5zM3 13h6v6H3zm2 2v2h2v-2zm8-2h2v2h-2zm4 0h2v2h-2zm-4 4h2v2h-2zm2-2h2v2h-2zm2 2h2v2h-2z"/></svg>
                            <svg class="svg-icon" style="width:12px;height:12px;color:#ccc;margin-left:auto;" viewBox="0 0 24 24"><polyline points="9 18 15 12 9 6"></polyline></svg>
                        </div>
                    </div>
                </div>
            `;
            
            const cellsHtml = `
                <div class="wechat-cell-group">
                    <div class="wechat-cell" onclick="showServicePage()">
                        <div class="wechat-cell-icon icon-service">
                            <svg class="svg-icon" style="stroke:currentColor;" viewBox="0 0 24 24"><rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect><line x1="8" y1="21" x2="16" y2="21"></line><line x1="12" y1="17" x2="12" y2="21"></line></svg>
                        </div>
                        <div class="wechat-cell-text">æœåŠ¡</div>
                        <div class="wechat-cell-arrow">â€º</div>
                    </div>
                </div>
                <div class="wechat-cell-group">
                    <div class="wechat-cell" onclick="showFavoritesPage()">
                        <div class="wechat-cell-icon icon-collect">
                            <svg class="svg-icon" style="stroke:currentColor;" viewBox="0 0 24 24"><path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path></svg>
                        </div>
                        <div class="wechat-cell-text">æ”¶è—</div>
                        <div class="wechat-cell-arrow">â€º</div>
                    </div>
                    <div class="wechat-cell" data-action="showStickerPage">
                        <div class="wechat-cell-icon icon-emoji">
                            <svg class="svg-icon" style="stroke:currentColor;" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><path d="M8 14s1.5 2 4 2 4-2 4-2"></path><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line></svg>
                        </div>
                        <div class="wechat-cell-text">è¡¨æƒ…</div>
                        <div class="wechat-cell-arrow">â€º</div>
                    </div>
                </div>
                <div class="wechat-cell-group">
                    <div class="wechat-cell" onclick="showSwitchAccountModal()">
                        <div class="wechat-cell-icon icon-settings">
                            <svg class="svg-icon" style="stroke:currentColor;" viewBox="0 0 24 24"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg>
                        </div>
                        <div class="wechat-cell-text">åˆ‡æ¢è´¦å·</div>
                        <div class="wechat-cell-arrow">â€º</div>
                    </div>
                </div>
                <div class="wechat-cell-group" id="online-feature-section">
                    <div style="padding:12px 16px; font-size:13px; color:#888; display:flex; align-items:center; gap:6px;">
                        <svg class="svg-icon" viewBox="0 0 24 24" style="width:16px; height:16px; stroke:currentColor;"><circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path></svg>
                        è”æœºåŠŸèƒ½
                    </div>
                    <div class="wechat-cell" onclick="showOnlineStatusPage()">
                        <div class="wechat-cell-icon" style="background:linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                            <svg class="svg-icon" style="stroke:#fff;" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path></svg>
                        </div>
                        <div class="wechat-cell-text">è”æœºçŠ¶æ€</div>
                        <div id="online-char-count-badge" style="font-size:12px; color:#999; margin-right:4px;">æœªè¿æ¥</div>
                        <div class="wechat-cell-arrow">â€º</div>
                    </div>
                </div>
            `;
            
            // æ›´æ–°è”æœºçŠ¶æ€æ˜¾ç¤º
            updateOnlineFeatureSection();
            
            container.innerHTML = `<div class="wechat-me-container">${profileHtml}${cellsHtml}</div>`;
            
            // ä½¿ç”¨äº‹ä»¶å§”æ‰˜ç»‘å®šè¡¨æƒ…åŒ…ç‚¹å‡»äº‹ä»¶ï¼ˆåœ¨çˆ¶å®¹å™¨ä¸Šç»‘å®šï¼Œç¡®ä¿åŠ¨æ€å…ƒç´ ä¹Ÿèƒ½å“åº”ï¼‰
            const meContainer = container.querySelector('.wechat-me-container');
            if (meContainer) {
                meContainer.addEventListener('click', function(e) {
                    // æ£€æŸ¥ç‚¹å‡»çš„æ˜¯å¦æ˜¯è¡¨æƒ…åŒ…å•å…ƒæ ¼æˆ–å…¶å­å…ƒç´ 
                    const target = e.target.closest('[data-action="showStickerPage"]');
                    if (target) {
                        console.log('[Debug] Sticker cell clicked via event delegation!');
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('[Debug] showStickerPage type:', typeof showStickerPage);
                        console.log('[Debug] window.showStickerPage type:', typeof window.showStickerPage);
                        if (typeof showStickerPage === 'function') {
                            console.log('[Debug] Calling showStickerPage()');
                            showStickerPage();
                        } else if (typeof window.showStickerPage === 'function') {
                            console.log('[Debug] Calling window.showStickerPage()');
                            window.showStickerPage();
                        } else {
                            console.error('[Debug] showStickerPage function not found, trying direct access');
                            // å°è¯•ç›´æ¥è°ƒç”¨
                            try {
                                const page = document.getElementById('sticker-page');
                                if (page) {
                                    console.log('[Debug] Found sticker-page element, showing it directly');
                                    page.style.display = 'flex';
                                    if (typeof renderStickerCategories === 'function') {
                                        renderStickerCategories();
                                    }
                                } else {
                                    console.error('[Debug] sticker-page element not found in DOM');
                                }
                            } catch (err) {
                                console.error('[Debug] Error:', err);
                            }
                        }
                    }
                });
                console.log('[Debug] Event delegation listener added to wechat-me-container');
            } else {
                console.error('[Debug] wechat-me-container not found!');
            }
            
            // ä¹Ÿç›´æ¥ç»‘å®šä¸€æ¬¡ä½œä¸ºå¤‡ç”¨
            const stickerCell = container.querySelector('[data-action="showStickerPage"]');
            console.log('[Debug] stickerCell found:', stickerCell);
            if (stickerCell) {
                stickerCell.style.cursor = 'pointer';
                stickerCell.addEventListener('click', function(e) {
                    console.log('[Debug] Sticker cell clicked (direct binding)!');
                    e.preventDefault();
                    e.stopPropagation();
                    if (typeof showStickerPage === 'function') {
                        showStickerPage();
                    } else if (typeof window.showStickerPage === 'function') {
                        window.showStickerPage();
                    }
                });
            }
        }

        // æ‰“å¼€ä¸ªäººèµ„æ–™è®¾ç½®é¡µé¢
        async function openProfileSettings() {
            const myChar = await db.characters.get(parseInt(currentMyCharId));
            if (!myChar) {
                alert('è¯·å…ˆç™»å½•è´¦å·');
                return;
            }
            
            const modal = document.createElement('div');
            modal.id = 'profile-settings-modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: #f5f5f5;
                z-index: 10000;
                display: flex;
                flex-direction: column;
            `;
            
            const currentAvatar = myChar.avatar || '';
            const currentName = myChar.name || '';
            
            modal.innerHTML = `
                <div style="background: #fff; height: 88px; padding-top: 44px; padding-left: 16px; padding-right: 16px; display: flex; align-items: center; border-bottom: 1px solid #e8e8e8; box-sizing: border-box;">
                    <svg onclick="closeProfileSettings()" viewBox="0 0 24 24" style="width: 24px; height: 24px; cursor: pointer; stroke: #333; fill: none; stroke-width: 2;">
                        <polyline points="15 18 9 12 15 6"></polyline>
                    </svg>
                    <span style="flex: 1; text-align: center; font-size: 16px; font-weight: 600; margin-left: -24px;">ä¸ªäººä¿¡æ¯</span>
                </div>
                
                <div style="flex: 1; overflow-y: auto;">
                    <div style="background: #fff; margin-top: 12px;">
                        <div onclick="document.getElementById('profile-avatar-input').click()" style="padding: 14px 16px; border-bottom: 1px solid #f0f0f0; display: flex; align-items: center; justify-content: space-between; cursor: pointer;">
                            <span style="font-size: 15px; color: #333;">å¤´åƒ</span>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <div id="profile-avatar-preview" style="width: 50px; height: 50px; border-radius: 6px; background-image: url(${currentAvatar}); background-size: cover; background-position: center; background-color: #f0f0f0;"></div>
                                <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; stroke: #999; fill: none;">
                                    <polyline points="9 18 15 12 9 6"></polyline>
                                </svg>
                            </div>
                        </div>
                        <input type="file" id="profile-avatar-input" accept="image/*" style="display: none;">
                        
                        <div style="padding: 14px 16px; border-bottom: 1px solid #f0f0f0; display: flex; align-items: center; justify-content: space-between;">
                            <span style="font-size: 15px; color: #333;">åå­—</span>
                            <input type="text" id="profile-name-input" value="${currentName}" placeholder="è¯·è¾“å…¥åå­—" style="flex: 1; max-width: 200px; padding: 6px 12px; border: 1px solid #e8e8e8; border-radius: 6px; font-size: 15px; text-align: right;">
                        </div>
                        
                        <div style="padding: 14px 16px; display: flex; align-items: center; justify-content: space-between;">
                            <span style="font-size: 15px; color: #333;">å¾®ä¿¡å·</span>
                            <span style="font-size: 15px; color: #999;">${myChar.identity?.account || `wxid_${myChar.id}`}</span>
                        </div>
                    </div>
                </div>
                
                <div style="padding: 16px; background: #fff; border-top: 1px solid #e8e8e8;">
                    <button onclick="saveProfileSettings()" style="width: 100%; padding: 14px; background: var(--ins-pink); color: #fff; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer;">
                        ä¿å­˜
                    </button>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // ç»‘å®šå¤´åƒä¸Šä¼ äº‹ä»¶
            const avatarInput = document.getElementById('profile-avatar-input');
            const avatarPreview = document.getElementById('profile-avatar-preview');
            
            avatarInput.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        avatarPreview.style.backgroundImage = `url(${event.target.result})`;
                        avatarPreview.dataset.newAvatar = event.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            };
        }
        
        function closeProfileSettings() {
            const modal = document.getElementById('profile-settings-modal');
            if (modal) modal.remove();
        }
        
        async function saveProfileSettings() {
            const myChar = await db.characters.get(parseInt(currentMyCharId));
            if (!myChar) return;
            
            const nameInput = document.getElementById('profile-name-input');
            const avatarPreview = document.getElementById('profile-avatar-preview');
            
            const newName = nameInput.value.trim();
            const newAvatar = avatarPreview.dataset.newAvatar;
            
            if (!newName) {
                alert('åå­—ä¸èƒ½ä¸ºç©º');
                return;
            }
            
            // æ›´æ–°è§’è‰²ä¿¡æ¯
            myChar.name = newName;
            if (newAvatar) {
                myChar.avatar = newAvatar;
            }
            
            await db.characters.put(myChar);
            
            // åˆ·æ–°ä¸ªäººä¸­å¿ƒé¡µé¢
            closeProfileSettings();
            const meTab = document.querySelector('.wechat-tab-item:nth-child(4)');
            if (meTab && meTab.classList.contains('active')) {
                const container = document.getElementById('wechat-content');
                await renderMePage(container);
            }
            
            // âœ… å¦‚æœå½“å‰æœ‰æ‰“å¼€çš„èŠå¤©çª—å£ï¼Œåˆ·æ–°èŠå¤©ç•Œé¢ä»¥æ›´æ–°å¤´åƒ
            if (currentChatCharId) {
                const chatChar = await db.characters.get(currentChatCharId);
                if (chatChar) {
                    await renderChatBody(chatChar);
                }
            }
            
            showToast('ä¿å­˜æˆåŠŸ');
        }

        // å·²ç™»å½•çš„è§’è‰²è´¦å·åˆ—è¡¨ï¼ˆå­˜å‚¨è§’è‰²IDï¼‰
        let loggedInRoleAccounts = JSON.parse(localStorage.getItem('logged_in_role_accounts') || '[]');
        
        // å½“å‰æ˜¯å¦åœ¨æŸ¥çœ‹è§’è‰²è´¦å·ï¼ˆç”¨äºåŒºåˆ†ç”¨æˆ·è´¦å·å’Œè§’è‰²è´¦å·ï¼‰
        let isViewingRoleAccount = false;
        let currentViewingRoleAccountId = null;
        
        async function showSwitchAccountModal() {
            const modal = document.getElementById('switch-account-modal');
            const list = document.getElementById('account-switch-list');
            list.innerHTML = '';
            
            // æ¸…ç©ºè¾“å…¥æ¡†
            document.getElementById('role-login-account').value = '';
            document.getElementById('role-login-password').value = '';
            document.getElementById('role-login-error').style.display = 'none';
            
            // 1. æ˜¾ç¤ºç”¨æˆ·è´¦å·ï¼ˆæˆ‘çš„è´¦å·ï¼‰
            const users = await db.characters.where('type').equals('user').toArray();
            
            if (users.length > 0) {
                const userTitle = document.createElement('div');
                userTitle.style.cssText = 'font-size:12px; color:#999; padding:8px 12px; background:#f8f8f8;';
                userTitle.textContent = 'æˆ‘çš„è´¦å·';
                list.appendChild(userTitle);
                
                users.forEach(u => {
                    const item = document.createElement('div');
                    item.className = 'account-item';
                    item.onclick = () => performSwitchAccount(u.id);
                    
                    const avatarStyle = u.avatar ? `background-image:url(${u.avatar})` : 'background-color:#eee';
                    const isCurrent = !isViewingRoleAccount && currentMyCharId && parseInt(currentMyCharId) === u.id;
                    
                    item.innerHTML = `
                        <div class="account-avatar" style="${avatarStyle}"></div>
                        <div style="flex:1;">
                            <div style="font-weight:500; color:#333;">${u.name}</div>
                            <div style="font-size:12px; color:#999;">${u.identity && u.identity.account ? u.identity.account : 'æ— å¾®ä¿¡å·'}</div>
                        </div>
                        ${isCurrent ? '<div style="color:var(--ins-pink);">âœ“</div>' : ''}
                    `;
                    list.appendChild(item);
                });
            }
            
            // 2. æ˜¾ç¤ºå·²ç™»å½•çš„è§’è‰²è´¦å·
            if (loggedInRoleAccounts.length > 0) {
                const roleTitle = document.createElement('div');
                roleTitle.style.cssText = 'font-size:12px; color:#999; padding:8px 12px; background:#f8f8f8; margin-top:10px;';
                roleTitle.textContent = 'å·²ç™»å½•çš„è§’è‰²è´¦å·ï¼ˆæŸ¥å²—ï¼‰';
                list.appendChild(roleTitle);
                
                for (const roleId of loggedInRoleAccounts) {
                    const role = await db.characters.get(parseInt(roleId));
                    if (!role) continue;
                    
                    const item = document.createElement('div');
                    item.className = 'account-item';
                    item.style.position = 'relative';
                    
                    const avatarStyle = role.avatar ? `background-image:url(${role.avatar})` : 'background-color:#eee';
                    const isCurrent = isViewingRoleAccount && currentViewingRoleAccountId === roleId;
                    
                    item.innerHTML = `
                        <div class="account-avatar" style="${avatarStyle}"></div>
                        <div style="flex:1;" onclick="switchToRoleAccount('${roleId}')">
                            <div style="font-weight:500; color:#333;">${role.name}</div>
                            <div style="font-size:12px; color:#999;">${role.identity && role.identity.account ? role.identity.account : 'æ— å¾®ä¿¡å·'}</div>
                        </div>
                        ${isCurrent ? '<div style="color:var(--ins-pink); margin-right:10px;">âœ“</div>' : ''}
                        <div onclick="event.stopPropagation(); removeRoleAccount('${roleId}')" style="color:#ff3b30; font-size:20px; padding:5px 10px; cursor:pointer;">Ã—</div>
                    `;
                    item.onclick = () => switchToRoleAccount(roleId);
                    list.appendChild(item);
                }
            }
            
            if (users.length === 0 && loggedInRoleAccounts.length === 0) {
                list.innerHTML = '<div style="text-align:center; padding:20px; color:#999;">æš‚æ— è´¦å·</div>';
            }
            
            modal.style.display = 'flex';
        }
        
        // ç§»é™¤å·²ç™»å½•çš„è§’è‰²è´¦å·
        async function removeRoleAccount(roleId) {
            loggedInRoleAccounts = loggedInRoleAccounts.filter(id => id !== roleId);
            localStorage.setItem('logged_in_role_accounts', JSON.stringify(loggedInRoleAccounts));
            
            // å¦‚æœæ­£åœ¨æŸ¥çœ‹è¿™ä¸ªè´¦å·ï¼Œåˆ‡å›ç”¨æˆ·è´¦å·
            if (isViewingRoleAccount && currentViewingRoleAccountId === roleId) {
                isViewingRoleAccount = false;
                currentViewingRoleAccountId = null;
                await switchWechatTab(0);
            }
            
            await showSwitchAccountModal();
        }
        
        // ç™»å½•è§’è‰²è´¦å·
        async function loginRoleAccount() {
            const account = document.getElementById('role-login-account').value.trim();
            const password = document.getElementById('role-login-password').value.trim();
            const errorEl = document.getElementById('role-login-error');
            
            errorEl.style.display = 'none';
            
            if (!account) {
                errorEl.textContent = 'è¯·è¾“å…¥è´¦å·';
                errorEl.style.display = 'block';
                return;
            }
            
            if (!password) {
                errorEl.textContent = 'è¯·è¾“å…¥å¯†ç ';
                errorEl.style.display = 'block';
                return;
            }
            
            // æŸ¥æ‰¾è§’è‰²
            const allChars = await db.characters.toArray();
            const targetChar = allChars.find(c => c.identity && c.identity.account === account);
            
            if (!targetChar) {
                errorEl.textContent = 'è´¦å·ä¸å­˜åœ¨';
                errorEl.style.display = 'block';
                return;
            }
            
            // æ£€æŸ¥æ˜¯ä¸æ˜¯Userç±»å‹ï¼ˆä¸å…è®¸ç™»å½•è‡ªå·±çš„è´¦å·ï¼‰
            if (targetChar.type === 'user') {
                errorEl.textContent = 'è¿™æ˜¯ç”¨æˆ·è´¦å·ï¼Œè¯·ç›´æ¥åˆ‡æ¢';
                errorEl.style.display = 'block';
                return;
            }
            
            // éªŒè¯å¯†ç 
            const correctPassword = targetChar.identity?.password || '';
            if (password !== correctPassword) {
                errorEl.textContent = 'å¯†ç é”™è¯¯';
                errorEl.style.display = 'block';
                return;
            }
            
            // æ£€æŸ¥æ˜¯å¦å·²ç™»å½•
            const roleIdStr = String(targetChar.id);
            if (loggedInRoleAccounts.includes(roleIdStr)) {
                errorEl.textContent = 'è¯¥è´¦å·å·²ç™»å½•ï¼Œå¯ç›´æ¥åˆ‡æ¢';
                errorEl.style.display = 'block';
                return;
            }
            
            // ç™»å½•æˆåŠŸï¼Œæ·»åŠ åˆ°åˆ—è¡¨
            loggedInRoleAccounts.push(roleIdStr);
            localStorage.setItem('logged_in_role_accounts', JSON.stringify(loggedInRoleAccounts));
            
            // æ˜¾ç¤ºåŠ è½½æç¤º
            errorEl.style.color = 'var(--ins-pink)';
            errorEl.textContent = 'æ­£åœ¨ç”Ÿæˆè§’è‰²WeChatæ•°æ®...';
            errorEl.style.display = 'block';
            
            // è°ƒç”¨APIç”Ÿæˆè§’è‰²çš„WeChatæ•°æ®
            try {
                await generateRoleWechatData(targetChar);
                
                // æ¸…ç©ºè¾“å…¥æ¡†
                document.getElementById('role-login-account').value = '';
                document.getElementById('role-login-password').value = '';
                errorEl.style.display = 'none';
                errorEl.style.color = '#ff3b30';
                
                // åˆ·æ–°åˆ—è¡¨å¹¶è‡ªåŠ¨åˆ‡æ¢åˆ°è¯¥è´¦å·
                await showSwitchAccountModal();
                await switchToRoleAccount(roleIdStr);
                
                showToast('ç™»å½•æˆåŠŸï¼Œå·²ç”ŸæˆWeChatæ•°æ®');
            } catch (error) {
                console.error('ç”Ÿæˆè§’è‰²WeChatæ•°æ®å¤±è´¥:', error);
                errorEl.style.color = '#ff3b30';
                errorEl.textContent = 'ç”Ÿæˆæ•°æ®å¤±è´¥ï¼š' + error.message;
                errorEl.style.display = 'block';
            }
        }
        
        // åˆ‡æ¢åˆ°è§’è‰²è´¦å·ï¼ˆæŸ¥å²—æ¨¡å¼ï¼‰
        async function switchToRoleAccount(roleId) {
            // ä¿å­˜åŸæ¥çš„ç”¨æˆ·ID
            if (!window.originalMyCharIdBeforeRoleView) {
                window.originalMyCharIdBeforeRoleView = currentMyCharId;
            }
            
            isViewingRoleAccount = true;
            currentViewingRoleAccountId = roleId;
            
            // åˆ‡æ¢åˆ°è§’è‰²è§†è§’
            const roleChar = await db.characters.get(parseInt(roleId));
            if (roleChar) {
                currentMyCharId = roleChar.id;
            }
            
            closeModal('switch-account-modal');
            
            // åˆ‡æ¢åˆ°èŠå¤©åˆ—è¡¨æ ‡ç­¾å¹¶åˆ·æ–°
            await switchWechatTab(0);
        }
        
        // ç”Ÿæˆè§’è‰²çš„WeChatæ•°æ®ï¼ˆè°ƒç”¨AIï¼‰
        async function generateRoleWechatData(roleChar) {
            console.log('[generateRoleWechatData] å¼€å§‹ä¸ºè§’è‰²ç”ŸæˆWeChatæ•°æ®:', roleChar.name);
            
            // è·å–å½“å‰ç”¨æˆ·
            const myChar = window.originalMyCharIdBeforeRoleView ? 
                await db.characters.get(parseInt(window.originalMyCharIdBeforeRoleView)) : 
                (currentMyCharId ? await db.characters.get(parseInt(currentMyCharId)) : null);
            
            // è·å–è§’è‰²å…³è”çš„ä¸–ç•Œä¹¦
            let loreContext = "";
            const lorebookIds = roleChar.lorebookIds || (roleChar.lorebookId ? [roleChar.lorebookId] : []);
            if (lorebookIds.length > 0) {
                loreContext = await getLorebookContext(lorebookIds, roleChar.name);
            }
            
            // è·å–è§’è‰²ä¸ç”¨æˆ·çš„èŠå¤©è®°å½•
            const accountId = myChar ? String(myChar.id) : getCurrentAccountId();
            const chatHistory = getChatHistory(roleChar, accountId);
            const recentChats = chatHistory.slice(-20).map(m => `${m.role === 'user' ? (myChar?.name || 'ç”¨æˆ·') : roleChar.name}: ${m.content}`).join('\n');
            
            // æ„å»ºAIæç¤º - ç”Ÿæˆæ›´å®Œæ•´çš„æ•°æ®ï¼ŒåŒ…æ‹¬èŠå¤©è®°å½•
            const prompt = `ä½ æ˜¯ä¸€ä¸ªæ•°æ®ç”ŸæˆåŠ©æ‰‹ã€‚è¯·æ ¹æ®ä»¥ä¸‹è§’è‰²ä¿¡æ¯ï¼Œç”Ÿæˆè¿™ä¸ªè§’è‰²çš„å¾®ä¿¡æ•°æ®ã€‚

ã€è§’è‰²ä¿¡æ¯ã€‘
åå­—ï¼š${roleChar.name}
${roleChar.nick ? `æ˜µç§°ï¼š${roleChar.nick}` : ''}
ç±»å‹ï¼š${roleChar.type || 'char'}
è®¾å®šï¼š${roleChar.description || 'æ— '}

${roleChar.identity ? `ã€è™šæ‹Ÿèº«ä»½ã€‘
è´¦å·ï¼š${roleChar.identity.account || 'æœªçŸ¥'}
æ‰‹æœºï¼š${roleChar.identity.phone || 'æœªçŸ¥'}
ä½å€ï¼š${roleChar.identity.address || 'æœªçŸ¥'}
ä½™é¢ï¼š${roleChar.identity.balance || 0}
` : ''}

${myChar ? `ã€ä¸ç”¨æˆ·çš„å…³ç³»ã€‘
ç”¨æˆ·åï¼š${myChar.name}
ç”¨æˆ·è®¾å®šï¼š${myChar.description || 'æ— '}
` : ''}

${recentChats ? `ã€ä¸ç”¨æˆ·çš„æœ€è¿‘èŠå¤©è®°å½•ï¼ˆçœŸå®ï¼‰ã€‘
${recentChats}
` : ''}

${loreContext ? `ã€ä¸–ç•Œè§‚èƒŒæ™¯ã€‘
${loreContext}
` : ''}

è¯·ç”Ÿæˆä»¥ä¸‹JSONæ•°æ®ï¼ˆä¸¥æ ¼æŒ‰ç…§æ ¼å¼è¿”å›ï¼Œä¸è¦åŒ…å«markdownä»£ç å—ï¼‰ï¼š
{
    "friends": [
        {
            "id": "friend_1",
            "name": "å¥½å‹åå­—",
            "remark": "å¤‡æ³¨ï¼ˆå¯é€‰ï¼Œæ²¡æœ‰å°±ç•™ç©ºï¼‰",
            "relation": "å…³ç³»æè¿°ï¼ˆå¦‚ï¼šåŒäº‹ã€æœ‹å‹ã€å®¶äººç­‰ï¼‰",
            "avatar": "",
            "lastMessage": "æœ€åä¸€æ¡æ¶ˆæ¯å†…å®¹",
            "lastMessageTime": "åˆšåˆš/5åˆ†é’Ÿå‰/1å°æ—¶å‰/æ˜¨å¤©ç­‰",
            "unread": 0,
            "chatHistory": [
                {"role": "friend", "content": "æ¶ˆæ¯å†…å®¹", "time": "10:30"},
                {"role": "me", "content": "æ¶ˆæ¯å†…å®¹", "time": "10:32"}
            ]
        }
    ],
    "moments": [
        {
            "author": "å‘å¸ƒè€…åå­—",
            "content": "æœ‹å‹åœˆå†…å®¹",
            "timeAgo": "2å°æ—¶å‰/æ˜¨å¤©/3å¤©å‰ç­‰",
            "likes": ["ç‚¹èµäºº1", "ç‚¹èµäºº2"],
            "comments": [{"name": "è¯„è®ºäºº", "content": "è¯„è®ºå†…å®¹"}]
        }
    ],
    "balance": "ä½™é¢æ•°å­—"
}

ç”Ÿæˆè¦æ±‚ï¼š
1. friendsï¼šç”Ÿæˆ4-8ä¸ªå¥½å‹ï¼Œæ ¹æ®è§’è‰²è®¾å®šå’Œä¸–ç•Œè§‚ç”Ÿæˆåˆé€‚çš„å¥½å‹
   - å¦‚æœæœ‰ä¸ç”¨æˆ·çš„èŠå¤©è®°å½•ï¼Œç”¨æˆ·ï¼ˆ${myChar?.name || 'ç”¨æˆ·'}ï¼‰å¿…é¡»åœ¨å¥½å‹åˆ—è¡¨ä¸­ï¼Œä¸”èŠå¤©è®°å½•è¦åŸºäºçœŸå®è®°å½•
   - æ¯ä¸ªå¥½å‹è¦ç”Ÿæˆ5-15æ¡èŠå¤©è®°å½•ï¼ˆchatHistoryï¼‰ï¼Œä½“ç°ä»–ä»¬çš„å…³ç³»
   - chatHistoryä¸­ roleä¸º"friend"è¡¨ç¤ºå¥½å‹å‘çš„ï¼Œ"me"è¡¨ç¤ºè§’è‰²ï¼ˆ${roleChar.name}ï¼‰å‘çš„
2. momentsï¼šç”Ÿæˆ3-6æ¡æœ‹å‹åœˆï¼Œå¯ä»¥æ˜¯è§’è‰²è‡ªå·±å‘çš„ï¼Œä¹Ÿå¯ä»¥æ˜¯å¥½å‹å‘çš„
   - è¦æœ‰ç‚¹èµå’Œè¯„è®ºï¼Œä½“ç°ç¤¾äº¤äº’åŠ¨
3. balanceï¼šç”Ÿæˆä¸€ä¸ªåˆç†çš„ä½™é¢æ•°å­—
4. æ‰€æœ‰å†…å®¹è¦ç¬¦åˆè§’è‰²çš„æ€§æ ¼ã€èº«ä»½å’Œä¸–ç•Œè§‚è®¾å®š
5. èŠå¤©å†…å®¹è¦è‡ªç„¶ã€ç”ŸåŠ¨ï¼Œä½“ç°äººç‰©å…³ç³»`;

            // è°ƒç”¨AI
            const result = await callAI([
                { role: 'system', content: 'ä½ æ˜¯ä¸€ä¸ªJSONæ•°æ®ç”ŸæˆåŠ©æ‰‹ï¼Œåªè¿”å›çº¯JSONæ ¼å¼ï¼Œä¸è¦åŒ…å«ä»»ä½•markdownæ ‡è®°æˆ–å…¶ä»–æ–‡å­—ã€‚' },
                { role: 'user', content: prompt }
            ], 0.7);
            
            console.log('[generateRoleWechatData] AIè¿”å›:', result);
            
            // è§£æç»“æœ
            let wechatData;
            try {
                // å°è¯•æ¸…ç†å¯èƒ½çš„markdownæ ‡è®°
                let cleanResult = result.trim();
                if (cleanResult.startsWith('```')) {
                    cleanResult = cleanResult.replace(/```json?\n?/g, '').replace(/```$/g, '').trim();
                }
                wechatData = JSON.parse(cleanResult);
            } catch (e) {
                console.error('[generateRoleWechatData] è§£æJSONå¤±è´¥:', e);
                // ä½¿ç”¨é»˜è®¤æ•°æ®
                wechatData = {
                    friends: [{ name: myChar?.name || 'ç”¨æˆ·', remark: '', relation: 'å¥½å‹', lastMessage: '...', lastMessageTime: 'åˆšåˆš', unread: 0 }],
                    moments: [{ content: 'ä»Šå¤©å¤©æ°”ä¸é”™', timeAgo: '1å°æ—¶å‰', likes: 5, comments: 1 }],
                    balance: roleChar.identity?.balance || '100.00'
                };
            }
            
            // ä¿å­˜åˆ°è§’è‰²æ•°æ®ä¸­
            roleChar.generated_wechat_data = {
                ...wechatData,
                generatedAt: Date.now()
            };
            await db.characters.put(roleChar);
            
            console.log('[generateRoleWechatData] æ•°æ®å·²ä¿å­˜:', wechatData);
            return wechatData;
        }
        
        // æ¸²æŸ“è§’è‰²è´¦å·çš„èŠå¤©åˆ—è¡¨ï¼ˆæŸ¥å²—æ¨¡å¼ï¼‰- ä½¿ç”¨AIç”Ÿæˆçš„æ•°æ®
        async function renderRoleAccountWechatList(container) {
            const roleChar = await db.characters.get(parseInt(currentViewingRoleAccountId));
            if (!roleChar) {
                container.innerHTML = '<div class="wechat-empty-state"><div>æš‚æ— æ•°æ®</div></div>';
                return;
            }
            
            // æ£€æŸ¥æ˜¯å¦æœ‰AIç”Ÿæˆçš„æ•°æ®
            const wechatData = roleChar.generated_wechat_data;
            if (!wechatData || !wechatData.friends || wechatData.friends.length === 0) {
                container.innerHTML = `
                    <div class="wechat-empty-state">
                        <svg class="svg-icon" style="width:48px; height:48px; stroke:#ccc;" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><line x1="8" y1="15" x2="16" y2="15"></line><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line></svg>
                        <div>æš‚æ— å¥½å‹æ•°æ®</div>
                        <div style="font-size:12px; color:#999; margin-top:10px;">è¯·é‡æ–°ç™»å½•ç”Ÿæˆæ•°æ®</div>
                    </div>
                `;
                return;
            }

            const friends = wechatData.friends;

            container.innerHTML = '';
            const listDiv = document.createElement('div');
            listDiv.style.width = '100%';
            listDiv.style.background = '#fff';
            listDiv.style.overflowX = 'hidden';
            
            // æ·»åŠ æŸ¥å²—æ¨¡å¼æç¤º
            const tipDiv = document.createElement('div');
            tipDiv.style.cssText = 'padding:10px 16px; background:#FFF5F7; color:#FF6B9D; font-size:12px; border-bottom:1px solid #f0f0f0;';
            tipDiv.innerHTML = `ğŸ” æ­£åœ¨æŸ¥çœ‹ <b>${roleChar.name}</b> çš„å¾®ä¿¡ï¼ˆæŸ¥å²—æ¨¡å¼ï¼‰<span style="float:right; cursor:pointer;" onclick="refreshRoleWechatData()">ğŸ”„ åˆ·æ–°</span>`;
            listDiv.appendChild(tipDiv);

            friends.forEach((f, index) => {
                // å®¹å™¨
                const itemContainer = document.createElement('div');
                itemContainer.className = 'wechat-list-item-container';
                
                // å†…å®¹åŒºåŸŸ
                const contentDiv = document.createElement('div');
                contentDiv.className = 'wechat-list-item-content';
                
                contentDiv.style.display = 'flex';
                contentDiv.style.padding = '12px 16px';
                contentDiv.style.borderBottom = '0.5px solid #f0f0f0';
                contentDiv.style.alignItems = 'center';
                contentDiv.style.gap = '12px';
                contentDiv.style.backgroundColor = '#fff';
                contentDiv.style.cursor = 'pointer';

                // ç‚¹å‡»è¿›å…¥èŠå¤©ï¼ˆæŸ¥å²—æ¨¡å¼ï¼‰
                contentDiv.onclick = () => {
                    openRoleAccountChat(index);
                };

                // ç”Ÿæˆå¤´åƒï¼ˆä½¿ç”¨åå­—é¦–å­—æ¯ï¼‰
                const avatarChar = (f.name || '?').charAt(0);
                const avatarColors = ['#FF6B9D', '#FF9F43', '#54A0FF', '#5F27CD', '#00D2D3', '#10AC84'];
                const avatarColor = avatarColors[index % avatarColors.length];
                
                const lastMsg = f.lastMessage || '';
                const lastTimeStr = f.lastMessageTime || '';
                const unread = f.unread || 0;

                contentDiv.innerHTML = `
                    <div style="width:48px; height:48px; border-radius:6px; background:${avatarColor}; background-size:cover; background-position:center; flex-shrink:0; display:flex; align-items:center; justify-content:center; color:#fff; font-size:20px; font-weight:600;">${avatarChar}</div>
                    <div style="flex:1; min-width:0;">
                        <div style="display:flex; justify-content:space-between; margin-bottom:4px; align-items:center;">
                            <div style="display:flex; align-items:center;">
                                <div style="font-size:16px; font-weight:500; color:#333;">${f.remark || f.name}</div>
                            </div>
                            <div style="font-size:12px; color:#999;">${lastTimeStr}</div>
                        </div>
                        <div style="font-size:14px; color:#999; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${lastMsg}</div>
                    </div>
                    ${unread > 0 ? `<div style="background:#ff3b30; color:#fff; font-size:12px; padding:2px 6px; border-radius:10px; min-width:18px; text-align:center;">${unread}</div>` : ''}
                `;

                itemContainer.appendChild(contentDiv);
                listDiv.appendChild(itemContainer);
            });
            container.appendChild(listDiv);
        }
        
        // åˆ·æ–°è§’è‰²çš„WeChatæ•°æ®
        async function refreshRoleWechatData() {
            const roleChar = await db.characters.get(parseInt(currentViewingRoleAccountId));
            if (!roleChar) return;
            
            showToast('æ­£åœ¨é‡æ–°ç”Ÿæˆæ•°æ®...');
            
            try {
                await generateRoleWechatData(roleChar);
                await switchWechatTab(0);
                showToast('æ•°æ®å·²åˆ·æ–°');
            } catch (error) {
                console.error('åˆ·æ–°æ•°æ®å¤±è´¥:', error);
                showToast('åˆ·æ–°å¤±è´¥ï¼š' + error.message);
            }
        }
        
        // æ‰“å¼€è§’è‰²è´¦å·çš„èŠå¤©çª—å£ï¼ˆæŸ¥å²—æ¨¡å¼ï¼‰- æ˜¾ç¤ºAIç”Ÿæˆçš„èŠå¤©è®°å½•
        async function openRoleAccountChat(friendIndex) {
            const roleChar = await db.characters.get(parseInt(currentViewingRoleAccountId));
            if (!roleChar || !roleChar.generated_wechat_data) return;
            
            const friend = roleChar.generated_wechat_data.friends[friendIndex];
            if (!friend) return;
            
            // ä¿å­˜å½“å‰æŸ¥çœ‹çš„å¥½å‹ç´¢å¼•
            window.currentRoleViewFriendIndex = friendIndex;
            
            // æ˜¾ç¤ºèŠå¤©çª—å£
            const chatWindow = document.getElementById('chat-window');
            const chatTitle = document.getElementById('chat-title');
            const chatBody = document.getElementById('chat-body');
            const chatFooter = document.getElementById('chat-footer');
            
            chatTitle.innerHTML = `${friend.remark || friend.name} <span style="font-size:12px; color:#FF6B9D; font-weight:400;">(${roleChar.name}æŸ¥å²—ä¸­)</span>`;
            chatWindow.style.display = 'flex';
            
            // éšè—è¾“å…¥æ¡†ï¼ˆæŸ¥å²—æ¨¡å¼åªèƒ½çœ‹ï¼Œä¸èƒ½å‘ï¼‰
            chatFooter.style.display = 'none';
            
            // æ¸²æŸ“AIç”Ÿæˆçš„èŠå¤©è®°å½•
            renderRoleAccountChatBody(chatBody, roleChar, friend);
        }
        
        // æ¸²æŸ“è§’è‰²è´¦å·çš„èŠå¤©è®°å½•ï¼ˆAIç”Ÿæˆçš„ï¼‰- ä½¿ç”¨å’Œæ­£å¸¸èŠå¤©ä¸€æ ·çš„æ ·å¼
        function renderRoleAccountChatBody(container, roleChar, friend) {
            const chatHistory = friend.chatHistory || [];
            
            // è§’è‰²å¤´åƒ
            const roleAvatarUrl = roleChar.avatar || '';
            
            // å¥½å‹å¤´åƒé¢œè‰²ï¼ˆç”Ÿæˆä¸€ä¸ªé¢œè‰²ä½œä¸ºé»˜è®¤å¤´åƒï¼‰
            const avatarColors = ['#FF6B9D', '#FF9F43', '#54A0FF', '#5F27CD', '#00D2D3', '#10AC84'];
            const friendAvatarColor = avatarColors[window.currentRoleViewFriendIndex % avatarColors.length];
            const friendAvatarChar = (friend.name || '?').charAt(0);
            
            container.innerHTML = '';
            
            if (chatHistory.length === 0) {
                container.innerHTML = '<div style="text-align:center; padding:40px; color:#999;">æš‚æ— èŠå¤©è®°å½•</div>';
                return;
            }
            
            let lastTimeGroup = '';
            
            chatHistory.forEach((msg, index) => {
                const isMe = msg.role === 'me'; // è§’è‰²å‘çš„
                const time = msg.time || '';
                
                // æ·»åŠ æ—¶é—´æˆ³ï¼ˆå¦‚æœæ—¶é—´å˜åŒ–äº†ï¼‰
                if (time && time !== lastTimeGroup) {
                    const timeStamp = document.createElement('div');
                    timeStamp.className = 'message-timestamp';
                    timeStamp.textContent = time;
                    container.appendChild(timeStamp);
                    lastTimeGroup = time;
                }
                
                // åˆ›å»ºæ¶ˆæ¯è¡Œ - ä½¿ç”¨å’Œæ­£å¸¸èŠå¤©ä¸€æ ·çš„HTMLç»“æ„
                const row = document.createElement('div');
                row.className = `message-row ${isMe ? 'self' : 'other'}`;
                row.dataset.index = index;
                
                // å¤´åƒ
                const avatar = document.createElement('div');
                avatar.className = 'message-avatar';
                
                if (isMe) {
                    // è§’è‰²ï¼ˆ"æˆ‘"ï¼‰çš„å¤´åƒ
                    if (roleAvatarUrl) {
                        avatar.style.backgroundImage = `url(${roleAvatarUrl})`;
                    } else {
                        avatar.style.backgroundColor = '#FF6B9D';
                        avatar.style.display = 'flex';
                        avatar.style.alignItems = 'center';
                        avatar.style.justifyContent = 'center';
                        avatar.style.color = '#fff';
                        avatar.style.fontWeight = '600';
                        avatar.style.fontSize = '14px';
                        avatar.textContent = roleChar.name.charAt(0);
                    }
                } else {
                    // å¥½å‹çš„å¤´åƒ
                    avatar.style.backgroundColor = friendAvatarColor;
                    avatar.style.display = 'flex';
                    avatar.style.alignItems = 'center';
                    avatar.style.justifyContent = 'center';
                    avatar.style.color = '#fff';
                    avatar.style.fontWeight = '600';
                    avatar.style.fontSize = '14px';
                    avatar.textContent = friendAvatarChar;
                }
                
                // å†…å®¹æ°”æ³¡
                const content = document.createElement('div');
                content.className = isMe ? 'message-content user-bubble' : 'message-content ai-bubble';
                content.textContent = msg.content || '';
                
                // ç»„è£…æ¶ˆæ¯è¡Œ
                row.appendChild(avatar);
                row.appendChild(content);
                
                container.appendChild(row);
            });
            
            // æ»šåŠ¨åˆ°åº•éƒ¨
            setTimeout(() => {
                container.scrollTop = container.scrollHeight;
            }, 50);
        }
        
        // æ¸²æŸ“è§’è‰²è´¦å·çš„é€šè®¯å½•ï¼ˆæŸ¥å²—æ¨¡å¼ï¼‰- ä½¿ç”¨AIç”Ÿæˆçš„æ•°æ®
        async function renderRoleAccountContactList(container) {
            const roleChar = await db.characters.get(parseInt(currentViewingRoleAccountId));
            if (!roleChar) {
                container.innerHTML = '<div class="wechat-empty-state"><div>æš‚æ— æ•°æ®</div></div>';
                return;
            }
            
            // æ£€æŸ¥æ˜¯å¦æœ‰AIç”Ÿæˆçš„æ•°æ®
            const wechatData = roleChar.generated_wechat_data;
            if (!wechatData || !wechatData.friends || wechatData.friends.length === 0) {
                container.innerHTML = `
                    <div class="wechat-empty-state">
                        <div>æš‚æ— å¥½å‹æ•°æ®</div>
                    </div>
                `;
                return;
            }
            
            const friends = [...wechatData.friends].sort((a, b) => {
                const nameA = (a.remark || a.name || '').toLowerCase();
                const nameB = (b.remark || b.name || '').toLowerCase();
                return nameA.localeCompare(nameB);
            });
            
            container.innerHTML = '';
            const listDiv = document.createElement('div');
            listDiv.style.width = '100%';
            listDiv.style.background = '#fff';
            
            // æ·»åŠ æŸ¥å²—æ¨¡å¼æç¤º
            const tipDiv = document.createElement('div');
            tipDiv.style.cssText = 'padding:10px 16px; background:#FFF5F7; color:#FF6B9D; font-size:12px; border-bottom:1px solid #f0f0f0;';
            tipDiv.innerHTML = `ğŸ” æ­£åœ¨æŸ¥çœ‹ <b>${roleChar.name}</b> çš„é€šè®¯å½•ï¼ˆ${friends.length}ä½å¥½å‹ï¼‰`;
            listDiv.appendChild(tipDiv);
            
            const avatarColors = ['#FF6B9D', '#FF9F43', '#54A0FF', '#5F27CD', '#00D2D3', '#10AC84'];
            
            friends.forEach((f, index) => {
                // æ‰¾åˆ°åŸå§‹ç´¢å¼•ï¼ˆç”¨äºç‚¹å‡»è¿›å…¥èŠå¤©ï¼‰
                const originalIndex = wechatData.friends.findIndex(fr => fr.id === f.id || fr.name === f.name);
                
                const itemDiv = document.createElement('div');
                itemDiv.style.cssText = 'display:flex; padding:12px 16px; border-bottom:0.5px solid #f0f0f0; align-items:center; gap:12px; background:#fff; cursor:pointer;';
                itemDiv.onclick = () => openRoleAccountChat(originalIndex >= 0 ? originalIndex : index);
                
                const avatarChar = (f.name || '?').charAt(0);
                const avatarColor = avatarColors[index % avatarColors.length];
                
                itemDiv.innerHTML = `
                    <div style="width:48px; height:48px; border-radius:6px; background:${avatarColor}; display:flex; align-items:center; justify-content:center; color:#fff; font-size:20px; font-weight:600;">${avatarChar}</div>
                    <div style="flex:1;">
                        <div style="font-size:16px; font-weight:500; color:#333;">${f.remark || f.name}</div>
                        ${f.relation ? `<div style="font-size:12px; color:#999;">${f.relation}</div>` : ''}
                    </div>
                `;
                
                listDiv.appendChild(itemDiv);
            });
            
            container.appendChild(listDiv);
        }
        
        // æ¸²æŸ“è§’è‰²è´¦å·çš„å‘ç°é¡µï¼ˆæœ‹å‹åœˆï¼ŒæŸ¥å²—æ¨¡å¼ï¼‰
        async function renderRoleAccountDiscoverPage(container) {
            const roleChar = await db.characters.get(parseInt(currentViewingRoleAccountId));
            if (!roleChar) {
                container.innerHTML = '<div class="wechat-empty-state"><div>æš‚æ— æ•°æ®</div></div>';
                return;
            }
            
            // ä½¿ç”¨å’Œæ­£å¸¸å‘ç°é¡µä¸€æ ·çš„å†…å®¹
            const html = `
                <div class="wechat-cell-group" style="margin-top:0;">
                    <div style="padding:10px 16px; background:#FFF5F7; color:#FF6B9D; font-size:12px;">
                        ğŸ” æ­£åœ¨æŸ¥çœ‹ <b>${roleChar.name}</b> çš„å‘ç°
                    </div>
                    <div class="wechat-cell" onclick="showRoleAccountMomentsPage()">
                        <div class="wechat-cell-icon icon-moments">
                            <svg class="svg-icon" style="stroke:currentColor;" viewBox="0 0 24 24"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path></svg>
                        </div>
                        <div class="wechat-cell-text">æœ‹å‹åœˆ</div>
                        <div class="wechat-cell-arrow">â€º</div>
                    </div>
                </div>
            `;
            container.innerHTML = html;
        }
        
        // æ˜¾ç¤ºè§’è‰²è´¦å·çš„æœ‹å‹åœˆé¡µé¢ï¼ˆæŸ¥å²—æ¨¡å¼ï¼‰- ä½¿ç”¨AIç”Ÿæˆçš„æ•°æ®
        async function showRoleAccountMomentsPage() {
            const roleChar = await db.characters.get(parseInt(currentViewingRoleAccountId));
            if (!roleChar) return;
            
            const wechatData = roleChar.generated_wechat_data;
            const moments = wechatData?.moments || [];
            
            // æ˜¾ç¤ºæœ‹å‹åœˆé¡µé¢
            const momentsPage = document.getElementById('moments-page');
            if (!momentsPage) return;
            
            momentsPage.style.display = 'flex';
            
            // ä¿®æ”¹ç”¨æˆ·åå’Œå¤´åƒï¼ˆå°é¢åŒºåŸŸï¼‰
            const userNameEl = document.getElementById('moments-user-name');
            const userAvatarEl = document.getElementById('moments-user-avatar');
            if (userNameEl) {
                userNameEl.innerHTML = `${roleChar.name} <span style="font-size:12px; color:#FF6B9D;">(æŸ¥å²—ä¸­)</span>`;
            }
            if (userAvatarEl && roleChar.avatar) {
                userAvatarEl.style.backgroundImage = `url(${roleChar.avatar})`;
            }
            
            // æ¸²æŸ“AIç”Ÿæˆçš„æœ‹å‹åœˆå†…å®¹åˆ° moments-list
            const momentsList = document.getElementById('moments-list');
            if (momentsList) {
                renderRoleAccountMoments(momentsList, roleChar, moments);
            }
        }
        
        // æ¸²æŸ“è§’è‰²è´¦å·çš„æœ‹å‹åœˆå†…å®¹ - ä½¿ç”¨å’Œæ­£å¸¸æœ‹å‹åœˆä¸€æ ·çš„æ ·å¼
        function renderRoleAccountMoments(container, roleChar, moments) {
            const avatarColors = ['#FF6B9D', '#FF9F43', '#54A0FF', '#5F27CD', '#00D2D3', '#10AC84'];
            
            let html = '';
            
            // æŸ¥å²—æç¤º
            html += `<div style="padding:12px 16px; background:#FFF5F7; color:#FF6B9D; font-size:13px; margin-bottom:10px;">
                ğŸ” æ­£åœ¨æŸ¥çœ‹ <b>${roleChar.name}</b> çš„æœ‹å‹åœˆï¼ˆ${moments.length}æ¡åŠ¨æ€ï¼‰
            </div>`;
            
            if (moments.length === 0) {
                html += '<div style="text-align:center; padding:60px 20px; color:#999;">æš‚æ— æœ‹å‹åœˆåŠ¨æ€</div>';
            } else {
                moments.forEach((m, index) => {
                    const authorName = m.author || roleChar.name;
                    const isRoleMoment = authorName === roleChar.name;
                    const avatarColor = isRoleMoment ? '#FF6B9D' : avatarColors[index % avatarColors.length];
                    const avatarChar = authorName.charAt(0);
                    const avatarStyle = (isRoleMoment && roleChar.avatar) ? 
                        `background-image:url(${roleChar.avatar}); background-size:cover; background-position:center;` : 
                        `background:${avatarColor}; display:flex; align-items:center; justify-content:center; color:#fff; font-size:18px; font-weight:600;`;
                    
                    // ç‚¹èµåˆ—è¡¨
                    const likes = m.likes || [];
                    const likesStr = Array.isArray(likes) ? likes.join('ï¼Œ') : '';
                    
                    // è¯„è®ºåˆ—è¡¨
                    const comments = m.comments || [];
                    let commentsHtml = '';
                    if (comments.length > 0) {
                        commentsHtml = comments.map(c => {
                            return `<div style="font-size:13px; line-height:1.8;"><span style="color:#576B95; font-weight:500;">${c.name || 'åŒ¿å'}</span>ï¼š${c.content || ''}</div>`;
                        }).join('');
                    }
                    
                    html += `
                        <div class="moment-item" style="padding:16px; border-bottom:1px solid #f0f0f0;">
                            <div style="display:flex; align-items:flex-start;">
                                <div style="width:44px; height:44px; border-radius:6px; flex-shrink:0; ${avatarStyle}">${(isRoleMoment && roleChar.avatar) ? '' : avatarChar}</div>
                                <div style="margin-left:12px; flex:1; min-width:0;">
                                    <div style="font-weight:600; font-size:15px; color:#576B95; margin-bottom:6px;">${authorName}</div>
                                    <div style="line-height:1.6; font-size:15px; color:#333; word-break:break-word;">${m.content || ''}</div>
                                    <div style="font-size:12px; color:#999; margin-top:10px;">${m.timeAgo || 'åˆšåˆš'}</div>
                                    ${(likesStr || commentsHtml) ? `
                                    <div style="background:#f5f5f5; padding:8px 10px; border-radius:4px; margin-top:10px;">
                                        ${likesStr ? `<div style="font-size:13px; color:#576B95; ${commentsHtml ? 'margin-bottom:6px; padding-bottom:6px; border-bottom:1px solid #e5e5e5;' : ''}">â¤ï¸ ${likesStr}</div>` : ''}
                                        ${commentsHtml}
                                    </div>
                                    ` : ''}
                                </div>
                            </div>
                        </div>
                    `;
                });
            }
            
            container.innerHTML = html;
        }
        
        // æ¸²æŸ“è§’è‰²è´¦å·çš„"æˆ‘"é¡µé¢ï¼ˆæŸ¥å²—æ¨¡å¼ï¼‰
        async function renderRoleAccountMePage(container) {
            const roleChar = await db.characters.get(parseInt(currentViewingRoleAccountId));
            if (!roleChar) {
                container.innerHTML = '<div class="wechat-empty-state"><div>æš‚æ— æ•°æ®</div></div>';
                return;
            }
            
            const identity = roleChar.identity || {};
            const wechatData = roleChar.generated_wechat_data || {};
            
            // ä¼˜å…ˆä½¿ç”¨AIç”Ÿæˆçš„ä½™é¢ï¼Œå¦åˆ™ä½¿ç”¨è§’è‰²æ¡£æ¡ˆçš„ä½™é¢
            const balance = wechatData.balance || identity.balance || '0.00';
            
            const avatarStyle = roleChar.avatar ? `background-image:url(${roleChar.avatar})` : 'background-color:#eee';
            
            // æ˜¾ç¤ºè§’è‰²æ¡£æ¡ˆçš„æ‰€æœ‰è™šæ‹Ÿèº«ä»½ä¿¡æ¯
            const html = `
                <div style="background:#fff;">
                    <!-- æŸ¥å²—æ¨¡å¼æç¤º -->
                    <div style="padding:10px 16px; background:#FFF5F7; color:#FF6B9D; font-size:12px;">
                        ğŸ” æ­£åœ¨æŸ¥çœ‹ <b>${roleChar.name}</b> çš„ä¸ªäººä¿¡æ¯
                    </div>
                    
                    <!-- ä¸ªäººä¿¡æ¯å¤´éƒ¨ -->
                    <div style="padding:20px; text-align:center; background:linear-gradient(135deg, #FFB6C1 0%, #FFC0CB 100%);">
                        <div style="width:80px; height:80px; border-radius:12px; ${avatarStyle}; background-size:cover; background-position:center; margin:0 auto 10px; border:2px solid rgba(255,255,255,0.3);"></div>
                        <div style="font-size:18px; font-weight:600; color:#fff; margin-bottom:5px;">${roleChar.name}</div>
                        ${roleChar.nick ? `<div style="font-size:14px; color:rgba(255,255,255,0.8); margin-bottom:5px;">${roleChar.nick}</div>` : ''}
                        <div style="font-size:14px; color:rgba(255,255,255,0.9);">å¾®ä¿¡å·ï¼š${identity.account || 'æœªè®¾ç½®'}</div>
                    </div>
                    
                    <!-- ä½™é¢ -->
                    <div style="padding:15px 16px; border-bottom:1px solid #f0f0f0;">
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                            <div style="font-size:16px; font-weight:500;">ğŸ’° é’±åŒ…ä½™é¢</div>
                            <div style="font-size:20px; font-weight:600; color:#FF6B9D;">Â¥${balance}</div>
                        </div>
                    </div>
                    
                    <!-- è™šæ‹Ÿèº«ä»½ä¿¡æ¯ -->
                    <div style="padding:15px 16px; background:#f8f8f8;">
                        <div style="font-size:14px; font-weight:600; color:#666; margin-bottom:10px;">ğŸ” è™šæ‹Ÿèº«ä»½ä¿¡æ¯</div>
                    </div>
                    
                    ${identity.password ? `
                    <div style="padding:15px 16px; border-bottom:1px solid #f0f0f0;">
                        <div style="font-size:14px; color:#666; margin-bottom:5px;">è´¦å·å¯†ç </div>
                        <div style="font-size:16px; font-family:monospace; color:#FF6B9D;">${identity.password}</div>
                    </div>
                    ` : ''}
                    
                    <div style="padding:15px 16px; border-bottom:1px solid #f0f0f0;">
                        <div style="font-size:14px; color:#666; margin-bottom:5px;">ğŸ“± æ‰‹æœºå·</div>
                        <div style="font-size:16px;">${identity.phone || 'æœªè®¾ç½®'}</div>
                    </div>
                    
                    <div style="padding:15px 16px; border-bottom:1px solid #f0f0f0;">
                        <div style="font-size:14px; color:#666; margin-bottom:5px;">ğŸ  ä½å€</div>
                        <div style="font-size:16px;">${identity.address || 'æœªè®¾ç½®'}</div>
                    </div>
                    
                    ${identity.id_card ? `
                    <div style="padding:15px 16px; border-bottom:1px solid #f0f0f0;">
                        <div style="font-size:14px; color:#666; margin-bottom:5px;">ğŸªª èº«ä»½è¯å·</div>
                        <div style="font-size:16px; font-family:monospace;">${identity.id_card}</div>
                    </div>
                    ` : ''}
                    
                    ${identity.bank_card ? `
                    <div style="padding:15px 16px; border-bottom:1px solid #f0f0f0;">
                        <div style="font-size:14px; color:#666; margin-bottom:5px;">ğŸ’³ é“¶è¡Œå¡å·</div>
                        <div style="font-size:16px; font-family:monospace;">${identity.bank_card}</div>
                    </div>
                    ` : ''}
                    
                    ${identity.bank_password ? `
                    <div style="padding:15px 16px; border-bottom:1px solid #f0f0f0;">
                        <div style="font-size:14px; color:#666; margin-bottom:5px;">ğŸ”‘ é“¶è¡Œå¯†ç </div>
                        <div style="font-size:16px; font-family:monospace; color:#FF6B9D;">${identity.bank_password}</div>
                    </div>
                    ` : ''}
                    
                    <!-- é€€å‡ºæŸ¥å²—æŒ‰é’® -->
                    <div style="padding:20px 16px;">
                        <button onclick="exitRoleAccountView()" style="width:100%; padding:14px; background:#FF6B9D; color:#fff; border:none; border-radius:10px; font-size:16px; cursor:pointer; font-weight:600;">é€€å‡ºæŸ¥å²—æ¨¡å¼</button>
                    </div>
                </div>
            `;
            
            container.innerHTML = html;
        }
        
        // é€€å‡ºæŸ¥å²—æ¨¡å¼
        async function exitRoleAccountView() {
            isViewingRoleAccount = false;
            currentViewingRoleAccountId = null;
            
            // æ¢å¤åŸæ¥çš„ç”¨æˆ·ID
            if (window.originalMyCharIdBeforeRoleView) {
                currentMyCharId = window.originalMyCharIdBeforeRoleView;
                window.originalMyCharIdBeforeRoleView = null;
            }
            
            await switchWechatTab(0);
            showToast('å·²é€€å‡ºæŸ¥å²—æ¨¡å¼');
        }

        // ========== è´¦å·éš”ç¦»è¾…åŠ©å‡½æ•° ==========
        // è·å–å½“å‰è´¦å·IDï¼ˆç”¨äºæ•°æ®éš”ç¦»ï¼‰
        function getCurrentAccountId() {
            return currentMyCharId ? String(currentMyCharId) : null;
        }

        // è·å–è§’è‰²çš„å¥½å‹çŠ¶æ€ï¼ˆæŒ‰è´¦å·éš”ç¦»ï¼‰
        function getFriendStatus(char, accountId) {
            if (!accountId) return char.wechat_status || 'stranger';
            if (!char.wechat_status_by_user) {
                // å¦‚æœæ–°ç»“æ„ä¸å­˜åœ¨ï¼Œå°è¯•ä»æ—§ç»“æ„è¿ç§»
                if (char.wechat_status) {
                    if (!char.wechat_status_by_user) char.wechat_status_by_user = {};
                    char.wechat_status_by_user[accountId] = char.wechat_status;
                }
            }
            return char.wechat_status_by_user?.[accountId] || 'stranger';
        }

        // è®¾ç½®è§’è‰²çš„å¥½å‹çŠ¶æ€ï¼ˆæŒ‰è´¦å·éš”ç¦»ï¼‰
        async function setFriendStatus(char, accountId, status) {
            if (!accountId) {
                // å…¼å®¹æ—§ä»£ç ï¼šå¦‚æœæ²¡æœ‰è´¦å·IDï¼Œä½¿ç”¨æ—§ç»“æ„
                char.wechat_status = status;
            } else {
                if (!char.wechat_status_by_user) char.wechat_status_by_user = {};
                char.wechat_status_by_user[accountId] = status;
            }
            await db.characters.put(char);
        }

        // è·å–è§’è‰²çš„èŠå¤©è®°å½•ï¼ˆæŒ‰è´¦å·éš”ç¦»ï¼‰
        function getChatHistory(char, accountId) {
            let history;
            if (!accountId) {
                history = char.chat_history || [];
            } else {
                if (!char.chat_history_by_user) {
                    // å¦‚æœæ–°ç»“æ„ä¸å­˜åœ¨ï¼Œå°è¯•ä»æ—§ç»“æ„è¿ç§»
                    if (char.chat_history && char.chat_history.length > 0) {
                        if (!char.chat_history_by_user) char.chat_history_by_user = {};
                        char.chat_history_by_user[accountId] = [...char.chat_history];
                    }
                }
                history = char.chat_history_by_user?.[accountId] || [];
            }
            // æŒ‰æ—¶é—´æˆ³æ’åºï¼Œç¡®ä¿æ¶ˆæ¯é¡ºåºæ­£ç¡®
            return [...history].sort((a, b) => (a.time || 0) - (b.time || 0));
        }

        // è®¾ç½®è§’è‰²çš„èŠå¤©è®°å½•ï¼ˆæŒ‰è´¦å·éš”ç¦»ï¼‰
        async function setChatHistory(char, accountId, history) {
            if (!accountId) {
                // å…¼å®¹æ—§ä»£ç ï¼šå¦‚æœæ²¡æœ‰è´¦å·IDï¼Œä½¿ç”¨æ—§ç»“æ„
                char.chat_history = history;
            } else {
                if (!char.chat_history_by_user) char.chat_history_by_user = {};
                char.chat_history_by_user[accountId] = history;
            }
            await db.characters.put(char);
        }

        // æ•°æ®è¿ç§»ï¼šå°†æ—§ç»“æ„è¿ç§»åˆ°æ–°ç»“æ„ï¼ˆä¸å½±å“ç°æœ‰æ•°æ®ï¼‰
        async function migrateAccountData() {
            const migrationKey = 'account_isolation_migrated';
            if (localStorage.getItem(migrationKey) === 'true') {
                return; // å·²ç»è¿ç§»è¿‡
            }

            console.log('[Migration] å¼€å§‹è¿ç§»è´¦å·éš”ç¦»æ•°æ®...');
            const allChars = await db.characters.toArray();
            let migratedCount = 0;

            for (const char of allChars) {
                let needSave = false;

                // è¿ç§»å¥½å‹çŠ¶æ€ï¼šå¦‚æœæœ‰æ—§çš„å¥½å‹çŠ¶æ€ï¼Œä¸ºæ‰€æœ‰Userè´¦å·åˆ›å»ºæ˜ å°„
                if (char.wechat_status && !char.wechat_status_by_user) {
                    char.wechat_status_by_user = {};
                    // ä¸ºæ‰€æœ‰Userè´¦å·å¤åˆ¶å½“å‰çŠ¶æ€
                    const allUsers = await db.characters.where('type').equals('user').toArray();
                    for (const user of allUsers) {
                        char.wechat_status_by_user[String(user.id)] = char.wechat_status;
                    }
                    needSave = true;
                }

                // è¿ç§»èŠå¤©è®°å½•ï¼šå¦‚æœæœ‰æ—§çš„èŠå¤©è®°å½•ï¼Œä¸ºæ‰€æœ‰Userè´¦å·åˆ›å»ºæ˜ å°„
                if (char.chat_history && char.chat_history.length > 0 && !char.chat_history_by_user) {
                    char.chat_history_by_user = {};
                    // ä¸ºæ‰€æœ‰Userè´¦å·å¤åˆ¶å½“å‰èŠå¤©è®°å½•
                    const allUsers = await db.characters.where('type').equals('user').toArray();
                    for (const user of allUsers) {
                        char.chat_history_by_user[String(user.id)] = [...char.chat_history];
                    }
                    needSave = true;
                }

                if (needSave) {
                    await db.characters.put(char);
                    migratedCount++;
                }
            }

            localStorage.setItem(migrationKey, 'true');
            console.log(`[Migration] è¿ç§»å®Œæˆï¼Œå…±å¤„ç† ${migratedCount} ä¸ªè§’è‰²`);
        }

        async function performSwitchAccount(id) {
            // é€€å‡ºæŸ¥å²—æ¨¡å¼ï¼ˆå¦‚æœæ­£åœ¨æŸ¥å²—ï¼‰
            if (isViewingRoleAccount) {
                isViewingRoleAccount = false;
                currentViewingRoleAccountId = null;
            }
            
            currentMyCharId = id;
            localStorage.setItem('current_my_char_id', id);
            window.originalMyCharIdBeforeRoleView = null; // æ¸…é™¤ä¿å­˜çš„ID
            
            closeModal('switch-account-modal');
            
            // âœ… æ£€æŸ¥åˆ‡æ¢åˆ°çš„è´¦å·æ˜¯å¦å·²æ³¨å†Œå¾®ä¿¡å·
            const targetUser = await db.characters.get(parseInt(id));
            if (targetUser && (!targetUser.identity || !targetUser.identity.wechat_registered)) {
                // è¯¥è´¦å·æœªæ³¨å†Œå¾®ä¿¡å·ï¼Œæ˜¾ç¤ºæ³¨å†Œé¡µé¢
                console.log('[åˆ‡æ¢è´¦å·] ç›®æ ‡è´¦å·æœªæ³¨å†Œå¾®ä¿¡å·ï¼Œæ˜¾ç¤ºæ³¨å†Œé¡µé¢');
                await showWechatRegisterPageForUser(id);
                return;
            }
            
            // åˆ·æ–°æ‰€æœ‰ç›¸å…³é¡µé¢
            const content = document.getElementById('wechat-content');
            if (content) {
                // æ ¹æ®å½“å‰tabåˆ·æ–°å¯¹åº”å†…å®¹
                const activeTab = document.querySelector('.wechat-tab-item.active');
                if (activeTab) {
                    const tabIndex = Array.from(document.querySelectorAll('.wechat-tab-item')).indexOf(activeTab);
                    switchWechatTab(tabIndex);
                } else {
                    await renderMePage(content);
                }
            }
            
            // åˆ·æ–°é’±åŒ…ä½™é¢æ˜¾ç¤º
            updateWalletBalanceDisplay();
            updateBalancePageDisplay();
        }
        
        // ä¸ºæŒ‡å®šç”¨æˆ·æ˜¾ç¤ºå¾®ä¿¡æ³¨å†Œé¡µé¢
        async function showWechatRegisterPageForUser(userId) {
            const registerPage = document.getElementById('wechat-register-page');
            const userSelect = document.getElementById('register-user-select');
            
            // æ¸…ç©ºä¸‹æ‹‰æ¡†å¹¶è®¾ç½®ä¸ºæŒ‡å®šç”¨æˆ·
            const user = await db.characters.get(parseInt(userId));
            if (!user) {
                showToast('ç”¨æˆ·ä¸å­˜åœ¨');
                return;
            }
            
            userSelect.innerHTML = `<option value="${user.id}" selected>${user.name}</option>`;
            
            // æ˜¾ç¤ºæ³¨å†Œé¡µé¢
            registerPage.style.display = 'flex';
        }

        // æ¸²æŸ“å¾®ä¿¡èŠå¤©åˆ—è¡¨
        async function renderWechatList(container) {
            // æŸ¥å²—æ¨¡å¼ï¼šæ˜¾ç¤ºè§’è‰²ç”Ÿæˆçš„æ•°æ®
            if (isViewingRoleAccount && currentViewingRoleAccountId) {
                await renderRoleAccountWechatList(container);
                return;
            }
            
            const accountId = getCurrentAccountId();
            // è·å–æ‰€æœ‰è§’è‰²ï¼Œç„¶åæŒ‰è´¦å·è¿‡æ»¤å¥½å‹ï¼ˆåŒ…æ‹¬å·²åˆ é™¤å’Œå·²æ‹‰é»‘çš„ï¼‰
            let allChars = await db.characters.toArray();
            let friends = allChars.filter(c => {
                if (c.type === 'user') return false; // æ’é™¤Userç±»å‹
                const status = getFriendStatus(c, accountId);
                return status === 'friend' || status === 'deleted' || status === 'blocked'; // åŒ…æ‹¬å·²åˆ é™¤å’Œå·²æ‹‰é»‘çš„å¥½å‹
            });
            
            // è·å–ç¾¤èŠåˆ—è¡¨
            let groupChats = [];
            try {
                groupChats = await getGroupChats(accountId);
            } catch (e) {
                console.log('è·å–ç¾¤èŠåˆ—è¡¨å¤±è´¥ï¼Œå¯èƒ½è¡¨ä¸å­˜åœ¨:', e);
            }
            
            // å°†ç¾¤èŠè½¬æ¢ä¸ºç»Ÿä¸€æ ¼å¼ï¼Œæ·»åŠ æ ‡è®°
            const groupItems = groupChats.map(g => ({
                ...g,
                _isGroup: true,
                _groupId: g.id
            }));
            
            // åˆå¹¶å¥½å‹å’Œç¾¤èŠåˆ—è¡¨
            let allItems = [...friends.map(f => ({...f, _isGroup: false})), ...groupItems];
            
            // æ’åºé€»è¾‘ï¼šç½®é¡¶ > æœ€åæ¶ˆæ¯æ—¶é—´ > æ›´æ–°æ—¶é—´
            allItems.sort((a, b) => {
                // 1. ç½®é¡¶åˆ¤æ–­
                if (a.is_pinned && !b.is_pinned) return -1;
                if (!a.is_pinned && b.is_pinned) return 1;
                
                // 2. æ—¶é—´åˆ¤æ–­
                const getLastTime = (item) => {
                    if (item._isGroup) {
                        const history = item.chat_history || [];
                        if (history.length > 0) {
                            return history[history.length - 1].time;
                        }
                        return item.updated_at || item.created_at || 0;
                    } else {
                        const history = getChatHistory(item, accountId);
                        if (history && history.length > 0) {
                            return history[history.length - 1].time;
                        }
                        return item.updated_at || 0;
                    }
                };
                
                const timeA = getLastTime(a);
                const timeB = getLastTime(b);
                
                return timeB - timeA; // é™åº
            });
            
            if (allItems.length === 0) {
                container.innerHTML = `
                    <div class="wechat-empty-state">
                        <svg class="svg-icon" style="width:48px; height:48px; stroke:#ccc;" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><line x1="8" y1="15" x2="16" y2="15"></line><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line></svg>
                        <div>æš‚æ— å¥½å‹</div>
                    </div>
                `;
                return;
            }

            container.innerHTML = '';
            const listDiv = document.createElement('div');
            listDiv.style.width = '100%';
            listDiv.style.background = '#fff';
            listDiv.style.overflowX = 'hidden';

            allItems.forEach(f => {
                // ç¾¤èŠé¡¹æ¸²æŸ“
                if (f._isGroup) {
                    const itemContainer = document.createElement('div');
                    itemContainer.className = 'wechat-list-item-container';
                    
                    const actionsDiv = document.createElement('div');
                    actionsDiv.className = 'wechat-item-actions';
                    actionsDiv.innerHTML = `
                        <button class="wechat-action-btn btn-pin" onclick="toggleGroupPin(${f._groupId}, event)">${f.is_pinned ? 'å–æ¶ˆç½®é¡¶' : 'ç½®é¡¶'}</button>
                        <button class="wechat-action-btn btn-delete" onclick="deleteGroup(${f._groupId}, event)">åˆ é™¤</button>
                    `;
                    
                    const contentDiv = document.createElement('div');
                    contentDiv.className = 'wechat-list-item-content';
                    contentDiv.style.cssText = 'display:flex; padding:12px 16px; border-bottom:0.5px solid #f0f0f0; align-items:center; gap:12px; background-color:' + (f.is_pinned ? '#f8f8f8' : '#fff');
                    
                    contentDiv.onclick = () => openGroupChatWindow(f._groupId);
                    
                    const avatarStyle = f.avatar ? `background-image:url(${f.avatar})` : 'background-color:#eee';
                    
                    let lastMsg = '';
                    let lastTimeStr = '';
                    const history = f.chat_history || [];
                    if (history.length > 0) {
                        const last = history[history.length - 1];
                        lastMsg = last.content;
                        if (lastMsg.startsWith('[img:')) lastMsg = '[å›¾ç‰‡]';
                        if (last.role === 'system') lastMsg = '[ç³»ç»Ÿæ¶ˆæ¯]';
                        
                        const d = new Date(last.time);
                        const now = new Date();
                        if (d.toDateString() === now.toDateString()) {
                            lastTimeStr = `${d.getHours()}:${d.getMinutes().toString().padStart(2,'0')}`;
                        } else {
                            lastTimeStr = `${d.getMonth()+1}/${d.getDate()}`;
                        }
                    }
                    
                    // åˆ¤æ–­æ˜¯å¦æ˜¯è”æœºç¾¤èŠ
                    const isOnlineGroup = f.isOnlineGroup;
                    const groupTag = isOnlineGroup 
                        ? '<span style="background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); color:#fff; font-size:9px; padding:1px 4px; border-radius:2px; margin-left:6px;">è”æœºç¾¤</span>'
                        : '<span style="background:#07c160; color:#fff; font-size:9px; padding:1px 4px; border-radius:2px; margin-left:6px;">ç¾¤</span>';
                    
                    contentDiv.innerHTML = `
                        <div style="width:48px; height:48px; border-radius:6px; ${avatarStyle}; background-size:cover; background-position:center; flex-shrink:0;"></div>
                        <div style="flex:1; min-width:0;">
                            <div style="display:flex; justify-content:space-between; margin-bottom:4px; align-items:center;">
                                <div style="display:flex; align-items:center;">
                                    <div style="font-size:16px; font-weight:500; color:#333;">${f.name}</div>
                                    ${groupTag}
                                </div>
                                <div style="font-size:12px; color:#999;">${lastTimeStr}</div>
                            </div>
                            <div style="font-size:14px; color:#999; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${lastMsg}</div>
                        </div>
                    `;
                    
                    bindSwipeEvents(contentDiv, itemContainer);
                    itemContainer.appendChild(actionsDiv);
                    itemContainer.appendChild(contentDiv);
                    listDiv.appendChild(itemContainer);
                    return;
                }
                
                // å¥½å‹é¡¹æ¸²æŸ“ï¼ˆåŸæœ‰ä»£ç ï¼‰
                // å®¹å™¨
                const itemContainer = document.createElement('div');
                itemContainer.className = 'wechat-list-item-container';
                
                // èƒŒæ™¯æ“ä½œæŒ‰é’®
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'wechat-item-actions';
                actionsDiv.innerHTML = `
                    <button class="wechat-action-btn btn-pin" onclick="togglePin(${f.id}, event)">${f.is_pinned ? 'å–æ¶ˆç½®é¡¶' : 'ç½®é¡¶'}</button>
                    <button class="wechat-action-btn btn-delete" onclick="deleteFriend(${f.id}, event)">åˆ é™¤</button>
                `;
                
                // å†…å®¹åŒºåŸŸ (å¯æ»‘åŠ¨)
                const contentDiv = document.createElement('div');
                contentDiv.className = 'wechat-list-item-content';
                
                // å†…å®¹æ ·å¼
                contentDiv.style.display = 'flex';
                contentDiv.style.padding = '12px 16px';
                contentDiv.style.borderBottom = '0.5px solid #f0f0f0';
                contentDiv.style.alignItems = 'center';
                contentDiv.style.gap = '12px';
                contentDiv.style.backgroundColor = f.is_pinned ? '#f8f8f8' : '#fff';

                // ç‚¹å‡»è¿›å…¥èŠå¤©
                contentDiv.onclick = (e) => {
                    if (itemContainer.dataset.swiped === 'true') {
                        resetSwipe(contentDiv);
                        itemContainer.dataset.swiped = 'false';
                        return;
                    }
                    openChatWindow(f.id);
                };

                const avatarStyle = f.avatar ? `background-image:url(${f.avatar})` : 'background-color:#eee';
                
                // æ£€æŸ¥å¥½å‹çŠ¶æ€
                const friendStatus = getFriendStatus(f, accountId);
                const isDeleted = friendStatus === 'deleted';
                const isBlocked = friendStatus === 'blocked';
                
                let lastMsg = '';
                let lastTimeStr = '';
                const history = getChatHistory(f, accountId);
                if (history && history.length > 0) {
                    const last = history[history.length - 1];
                    lastMsg = last.content;
                    if (lastMsg.startsWith('[img:')) lastMsg = '[å›¾ç‰‡]';
                    if (lastMsg.startsWith('[voice:')) lastMsg = '[è¯­éŸ³]';
                    if (lastMsg.startsWith('[imgcard:')) lastMsg = '[å¡ç‰‡]';
                    
                    const d = new Date(last.time);
                    const now = new Date();
                    if (d.toDateString() === now.toDateString()) {
                        lastTimeStr = `${d.getHours()}:${d.getMinutes().toString().padStart(2,'0')}`;
                    } else {
                        lastTimeStr = `${d.getMonth()+1}/${d.getDate()}`;
                    }
                }
                
                // æ ¹æ®çŠ¶æ€æ·»åŠ æ ‡è¯†
                let statusBadge = '';
                if (isDeleted) {
                    statusBadge = '<span style="background:#ff9500; color:#fff; font-size:10px; padding:2px 6px; border-radius:3px; margin-left:6px;">å·²åˆ é™¤</span>';
                } else if (isBlocked) {
                    statusBadge = '<span style="background:#ff3b30; color:#fff; font-size:10px; padding:2px 6px; border-radius:3px; margin-left:6px;">å·²æ‹‰é»‘</span>';
                }
                const textColor = (isDeleted || isBlocked) ? '#999' : '#333';

                contentDiv.innerHTML = `
                    <div style="width:48px; height:48px; border-radius:6px; ${avatarStyle}; background-size:cover; background-position:center; flex-shrink:0; ${(isDeleted || isBlocked) ? 'opacity:0.6;' : ''}"></div>
                    <div style="flex:1; min-width:0;">
                        <div style="display:flex; justify-content:space-between; margin-bottom:4px; align-items:center;">
                            <div style="display:flex; align-items:center;">
                                <div style="font-size:16px; font-weight:500; color:${textColor};">${f.name}</div>
                                ${statusBadge}
                            </div>
                            <div style="font-size:12px; color:#999;">${lastTimeStr}</div>
                        </div>
                        <div style="font-size:14px; color:#999; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${lastMsg}</div>
                    </div>
                `;

                bindSwipeEvents(contentDiv, itemContainer);

                itemContainer.appendChild(actionsDiv);
                itemContainer.appendChild(contentDiv);
                listDiv.appendChild(itemContainer);
            });
            container.appendChild(listDiv);
        }

        // æ»‘åŠ¨äº‹ä»¶ç»‘å®š
        function bindSwipeEvents(element, container) {
            let startX = 0;
            let currentX = 0;
            let isSwiping = false;
            const threshold = 30; // è§¦å‘é˜ˆå€¼
            const maxSwipe = 160; // ä¸¤ä¸ªæŒ‰é’®å®½åº¦

            element.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                // å¤ä½å…¶ä»–é¡¹
                document.querySelectorAll('.wechat-list-item-content').forEach(el => {
                    if (el !== element && el.style.transform && el.style.transform !== 'translateX(0px)') {
                        el.style.transform = 'translateX(0px)';
                        el.parentElement.dataset.swiped = 'false';
                    }
                });
            }, {passive: true});

            element.addEventListener('touchmove', (e) => {
                currentX = e.touches[0].clientX;
                let diff = currentX - startX;
                
                if (diff < 0) {
                    if (Math.abs(diff) > 10) isSwiping = true;
                    let move = diff;
                    if (Math.abs(move) > maxSwipe) {
                        move = -maxSwipe - (Math.abs(move) - maxSwipe) * 0.2;
                    }
                    element.style.transform = `translateX(${move}px)`;
                } else if (container.dataset.swiped === 'true') {
                    let move = -maxSwipe + diff;
                    if (move > 0) move = 0;
                    element.style.transform = `translateX(${move}px)`;
                }
            }, {passive: true});

            element.addEventListener('touchend', (e) => {
                if (!isSwiping && container.dataset.swiped !== 'true') return;
                
                const diff = currentX - startX;
                if (diff < -threshold || (container.dataset.swiped === 'true' && diff < threshold && diff > -threshold)) {
                    element.style.transform = `translateX(-${maxSwipe}px)`;
                    container.dataset.swiped = 'true';
                } else {
                    element.style.transform = 'translateX(0px)';
                    container.dataset.swiped = 'false';
                }
                isSwiping = false;
            });
        }

        function resetSwipe(element) {
            element.style.transform = 'translateX(0px)';
        }

        async function togglePin(id, e) {
            e.stopPropagation();
            const char = await db.characters.get(id);
            if (char) {
                char.is_pinned = !char.is_pinned;
                await db.characters.put(char);
                renderWechatList(document.getElementById('wechat-content'));
            }
        }
        
        // ç¾¤èŠç½®é¡¶åˆ‡æ¢
        async function toggleGroupPin(groupId, e) {
            e.stopPropagation();
            const group = await db.group_chats.get(groupId);
            if (group) {
                group.is_pinned = !group.is_pinned;
                await db.group_chats.put(group);
                renderWechatList(document.getElementById('wechat-content'));
            }
        }
        
        // åˆ é™¤ç¾¤èŠ
        async function deleteGroup(groupId, e) {
            e.stopPropagation();
            if (confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªç¾¤èŠå—ï¼Ÿ\n(èŠå¤©è®°å½•å°†è¢«æ¸…é™¤)')) {
                await db.group_chats.delete(groupId);
                renderWechatList(document.getElementById('wechat-content'));
            }
        }

        async function deleteFriend(id, e) {
            e.stopPropagation();
            if (confirm('ç¡®å®šè¦åˆ é™¤è¿™ä½å¥½å‹å—ï¼Ÿ\n(è§’è‰²æ¡£æ¡ˆä¿ç•™ï¼Œä»…åˆ é™¤å¥½å‹å…³ç³»)')) {
                const char = await db.characters.get(id);
                if (char) {
                    const accountId = getCurrentAccountId();
                    await setFriendStatus(char, accountId, 'stranger');
                    char.is_pinned = false;
                    await db.characters.put(char);
                    renderWechatList(document.getElementById('wechat-content'));
                }
            }
        }

        // æ¸²æŸ“é€šè®¯å½•åˆ—è¡¨
        async function renderContactList(container) {
            const accountId = getCurrentAccountId();
            // è·å–æ‰€æœ‰è§’è‰²ï¼Œç„¶åæŒ‰è´¦å·è¿‡æ»¤å¥½å‹
            let allChars = await db.characters.toArray();
            const friends = allChars.filter(c => {
                if (c.type === 'user') return false; // æ’é™¤Userç±»å‹
                const status = getFriendStatus(c, accountId);
                return status === 'friend';
            });
            
            container.innerHTML = '';
            const listDiv = document.createElement('div');
            listDiv.style.width = '100%';
            listDiv.style.background = '#fff';
            
            // æ·»åŠ "æ–°çš„å¥½å‹"å…¥å£
            const allRequests = await db.friend_requests.toArray();
            const pendingRequests = allRequests.filter(req => 
                req.toCharId === parseInt(accountId) && req.status === 'pending'
            );
            const newFriendItem = document.createElement('div');
            newFriendItem.style.display = 'flex';
            newFriendItem.style.padding = '12px 16px';
            newFriendItem.style.borderBottom = '0.5px solid #f0f0f0';
            newFriendItem.style.alignItems = 'center';
            newFriendItem.style.gap = '12px';
            newFriendItem.style.cursor = 'pointer';
            newFriendItem.onclick = () => showNewFriendsPage();
            
            const badgeHtml = pendingRequests.length > 0 ? 
                `<div style="background:#ff3b30; color:#fff; font-size:12px; padding:2px 6px; border-radius:10px; min-width:18px; text-align:center;">${pendingRequests.length}</div>` : '';
            
            newFriendItem.innerHTML = `
                <div style="width:40px; height:40px; border-radius:4px; background:linear-gradient(135deg, #ffc2d1 0%, #ff8fab 100%); display:flex; align-items:center; justify-content:center;">
                    <svg class="svg-icon" style="width:24px; height:24px; stroke:#fff;" viewBox="0 0 24 24">
                        <path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                        <circle cx="8.5" cy="7" r="4"></circle>
                        <line x1="20" y1="8" x2="20" y2="14"></line>
                        <line x1="23" y1="11" x2="17" y2="11"></line>
                    </svg>
                </div>
                <div style="flex:1; font-size:16px; font-weight:500; color:#333;">æ–°çš„å¥½å‹</div>
                ${badgeHtml}
            `;
            listDiv.appendChild(newFriendItem);
            
            if (friends.length === 0) {
                const emptyDiv = document.createElement('div');
                emptyDiv.style.textAlign = 'center';
                emptyDiv.style.padding = '40px 20px';
                emptyDiv.style.color = '#999';
                emptyDiv.innerHTML = `
                    <svg class="svg-icon" style="width:48px; height:48px; stroke:#ccc; margin-bottom:10px;" viewBox="0 0 24 24"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path></svg>
                    <div>é€šè®¯å½•ä¸ºç©º</div>
                `;
                listDiv.appendChild(emptyDiv);
            } else {
                friends.forEach(f => {
                    const item = document.createElement('div');
                    item.style.display = 'flex';
                    item.style.padding = '10px 16px';
                    item.style.borderBottom = '0.5px solid #f0f0f0';
                    item.style.alignItems = 'center';
                    item.style.gap = '12px';
                    item.onclick = () => openChatWindow(f.id);

                    const avatarStyle = f.avatar ? `background-image:url(${f.avatar})` : 'background-color:#eee';
                    
                    item.innerHTML = `
                        <div style="width:40px; height:40px; border-radius:4px; ${avatarStyle}; background-size:cover; background-position:center;"></div>
                        <div style="font-size:16px; font-weight:500; color:#333;">${f.name}</div>
                    `;
                    listDiv.appendChild(item);
                });
            }
            container.appendChild(listDiv);
        }

        // èœå•ä¸å¼¹çª—é€»è¾‘
        function toggleWechatMenu() {
            const menu = document.getElementById('wechat-menu');
            menu.style.display = menu.style.display === 'flex' ? 'none' : 'flex';
            // ç‚¹å‡»å¤–éƒ¨å…³é—­ (ç®€å•å¤„ç†)
            setTimeout(() => {
                document.addEventListener('click', closeMenuOutside);
            }, 0);
        }
        function closeMenuOutside(e) {
            const menu = document.getElementById('wechat-menu');
            if (!menu.contains(e.target) && !e.target.closest('.wechat-add')) {
                menu.style.display = 'none';
                document.removeEventListener('click', closeMenuOutside);
            }
        }

        function closeModal(id) {
            document.getElementById(id).style.display = 'none';
            
            // å¦‚æœæ˜¯åˆ›å»ºç¾¤èŠå¼¹çª—ï¼Œé‡ç½®çŠ¶æ€
            if (id === 'create-group-modal') {
                window._addingGroupMembers = false;
                const nameInput = document.getElementById('group-name-input');
                if (nameInput) nameInput.style.display = '';
                const title = document.querySelector('#create-group-modal .modal-title');
                if (title) title.innerText = 'åˆ›å»ºç¾¤èŠ';
            }
        }

        // å½“å‰å¿ƒå£°ç›¸å…³å˜é‡
        let currentThoughtsCharId = null;
        let currentThoughtsMessageIndex = null;

        // æ˜¾ç¤ºè§’è‰²å¿ƒå£°
        async function showCharacterThoughts(charId, messageIndex) {
            if (!charId) return;
            
            const char = await db.characters.get(charId);
            if (!char) return;
            
            currentThoughtsCharId = charId;
            currentThoughtsMessageIndex = messageIndex;
            
            const modal = document.getElementById('thoughts-modal');
            const title = document.getElementById('thoughts-modal-title');
            const currentText = document.getElementById('thoughts-current-text');
            const currentTime = document.getElementById('thoughts-current-time');
            const historyContent = document.getElementById('thoughts-history-content');
            const historySection = document.getElementById('thoughts-history');
            const arrow = document.getElementById('thoughts-arrow');
            
            title.textContent = `TAçš„å¿ƒå£°`;
            
            // é‡ç½®å†å²åŒºåŸŸçŠ¶æ€
            historySection.style.display = 'none';
            arrow.classList.remove('expanded');
            historyContent.innerHTML = '';
            
            // è·å–å¿ƒå£°
            if (!char.thoughts || char.thoughts.length === 0) {
                currentText.textContent = 'æš‚æ— å¿ƒå£°';
                currentTime.textContent = '';
                document.getElementById('thoughts-history-btn').style.display = 'none';
            } else {
                // æ‰¾åˆ°æœ€æ–°çš„å¿ƒå£°ä½œä¸ºå½“å‰å¿ƒå£°
                const latestThought = char.thoughts[char.thoughts.length - 1];
                currentText.textContent = latestThought.content;
                const timeStr = new Date(latestThought.time).toLocaleString('zh-CN', {
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
                currentTime.textContent = timeStr;
                
                // å¦‚æœæœ‰å†å²å¿ƒå£°ï¼ˆè¶…è¿‡1æ¡ï¼‰ï¼Œæ˜¾ç¤ºæŸ¥çœ‹å†å²æŒ‰é’®
                if (char.thoughts.length > 1) {
                    document.getElementById('thoughts-history-btn').style.display = 'flex';
                    
                    // æ¸²æŸ“å†å²å¿ƒå£°ï¼ˆé™¤äº†æœ€æ–°çš„ï¼‰
                    const historyThoughts = char.thoughts.slice(0, -1).reverse();
                    historyThoughts.forEach(thought => {
                        const item = document.createElement('div');
                        item.className = 'thoughts-history-item';
                        
                        const text = document.createElement('div');
                        text.className = 'thoughts-history-text';
                        text.textContent = thought.content;
                        
                        const time = document.createElement('div');
                        time.className = 'thoughts-history-time';
                        time.textContent = new Date(thought.time).toLocaleString('zh-CN', {
                            month: 'short',
                            day: 'numeric',
                            hour: '2-digit',
                            minute: '2-digit'
                        });
                        
                        item.appendChild(text);
                        item.appendChild(time);
                        historyContent.appendChild(item);
                    });
                } else {
                    document.getElementById('thoughts-history-btn').style.display = 'none';
                }
            }
            
            modal.style.display = 'flex';
        }

        // åˆ‡æ¢å†å²å¿ƒå£°æ˜¾ç¤º
        function toggleThoughtsHistory() {
            const historySection = document.getElementById('thoughts-history');
            const arrow = document.getElementById('thoughts-arrow');
            
            if (historySection.style.display === 'none') {
                historySection.style.display = 'block';
                arrow.classList.add('expanded');
            } else {
                historySection.style.display = 'none';
                arrow.classList.remove('expanded');
            }
        }

        // ç¼–è¾‘å½“å‰å¿ƒå£°
        async function editCurrentThought() {
            if (!currentThoughtsCharId) return;
            
            const char = await db.characters.get(currentThoughtsCharId);
            if (!char || !char.thoughts || char.thoughts.length === 0) {
                showToast('æš‚æ— å¿ƒå£°å¯ç¼–è¾‘');
                return;
            }
            
            const latestThought = char.thoughts[char.thoughts.length - 1];
            const newContent = prompt('ç¼–è¾‘å¿ƒå£°ï¼š', latestThought.content);
            
            if (newContent !== null && newContent.trim()) {
                char.thoughts[char.thoughts.length - 1].content = newContent.trim();
                await db.characters.put(char);
                
                // æ›´æ–°æ˜¾ç¤º
                document.getElementById('thoughts-current-text').textContent = newContent.trim();
                showToast('å¿ƒå£°å·²æ›´æ–°');
            }
        }

        // é‡æ–°ç”Ÿæˆå¿ƒå£°
        async function regenerateThought() {
            if (!currentThoughtsCharId) return;
            
            const char = await db.characters.get(currentThoughtsCharId);
            if (!char) return;
            
            showToast('æ­£åœ¨ç”Ÿæˆæ–°å¿ƒå£°...');
            
            // å…³é—­å¼¹çª—
            closeModal('thoughts-modal');
            
            // è§¦å‘AIé‡æ–°ç”Ÿæˆï¼ˆè¿™é‡Œç®€å•å¤„ç†ï¼Œå®é™…å¯ä»¥è°ƒç”¨AIæ¥å£ï¼‰
            // ç”±äºå¿ƒå£°æ˜¯åœ¨AIå›å¤æ—¶è‡ªåŠ¨ç”Ÿæˆçš„ï¼Œè¿™é‡Œæç¤ºç”¨æˆ·å‘é€æ¶ˆæ¯è§¦å‘
            showToast('è¯·å‘é€ä¸€æ¡æ¶ˆæ¯æ¥è§¦å‘æ–°çš„å¿ƒå£°ç”Ÿæˆ');
        }

        // æœç´¢å¥½å‹
        function showAddFriendModal() {
            document.getElementById('search-friend-modal').style.display = 'flex';
            document.getElementById('wechat-menu').style.display = 'none';
            // é‡ç½®çŠ¶æ€
            document.getElementById('search-account-input').value = '';
            document.getElementById('search-result-area').style.display = 'none';
            document.getElementById('apply-area').style.display = 'none';
            document.getElementById('search-cancel-btn').style.display = 'block';
        }

        let searchTargetChar = null;

        // è¾…åŠ©ï¼šè·å–ä¸–ç•Œä¹¦ä¸Šä¸‹æ–‡ (ç®€å•çš„å…³é”®è¯åŒ¹é…)
        // æ”¯æŒå•ä¸ªIDæˆ–IDæ•°ç»„
        async function getLorebookContext(lorebookIdOrIds, keywords) {
            if (!lorebookIdOrIds) return "";
            
            // å…¼å®¹æ—§æ•°æ®ï¼šå¦‚æœæ˜¯å•ä¸ªIDï¼Œè½¬æ¢ä¸ºæ•°ç»„
            const ids = Array.isArray(lorebookIdOrIds) ? lorebookIdOrIds : [lorebookIdOrIds];
            if (ids.length === 0) return "";
            
            let allContext = [];
            const checkText = keywords.toLowerCase();
            
            // éå†æ‰€æœ‰ä¸–ç•Œä¹¦
            for (const id of ids) {
                const book = await db.lorebooks.get(id);
                if (!book || !book.content || !book.content.entries) continue;
                
                const entries = Object.values(book.content.entries);
                
                entries.forEach(entry => {
                    if (!entry.enabled) return;
                    // entry.key å¯èƒ½æ˜¯æ•°ç»„æˆ–å­—ç¬¦ä¸²
                    const keys = Array.isArray(entry.key) ? entry.key : [entry.key];
                    
                    const isMatch = keys.some(k => {
                        if(!k) return false;
                        return checkText.includes(k.toLowerCase());
                    });
                    
                    if (isMatch) {
                        allContext.push(entry.content);
                    }
                });
            }
            
            if (allContext.length > 0) {
                // ç®€å•æˆªæ–­ï¼Œé˜²æ­¢çˆ† Token
                const fullText = allContext.join('\n');
                const safeText = fullText.length > 10000 ? fullText.slice(0, 10000) + '...(å·²æˆªæ–­)' : fullText;
                return `ã€ç›¸å…³ä¸–ç•Œä¹¦è®¾å®šã€‘:\n${safeText}\n`;
            }
            return "";
        }

        async function searchAccount() {
            const acc = document.getElementById('search-account-input').value.trim();
            if(!acc) return;
            
            // å…¨è¡¨æ‰«æåŒ¹é… identity.account
            const allChars = await db.characters.toArray();
            const target = allChars.find(c => c.identity && c.identity.account === acc);
            
            if (target) {
                searchTargetChar = target;
                document.getElementById('search-result-area').style.display = 'flex';
                document.getElementById('search-result-name').innerText = target.name;
                document.getElementById('search-result-id').innerText = "è´¦å·: " + acc;
                if(target.avatar) {
                    document.getElementById('search-result-avatar').style.backgroundImage = `url(${target.avatar})`;
                } else {
                    document.getElementById('search-result-avatar').style.backgroundImage = '';
                }
                
                // --- æ–°å¢ï¼šåŠ è½½ User åˆ—è¡¨ä¾›é€‰æ‹© ---
                const users = allChars.filter(c => c.type === 'user');
                const userSelect = document.getElementById('apply-user-select');
                userSelect.innerHTML = '';
                if(users.length === 0) {
                    const opt = document.createElement('option');
                    opt.value = "";
                    opt.text = "æ—  User è§’è‰² (è¯·å…ˆå»è§’è‰²æ¡£æ¡ˆæ–°å»º)";
                    userSelect.appendChild(opt);
                } else {
                    users.forEach(u => {
                        const opt = document.createElement('option');
                        opt.value = u.id;
                        opt.text = u.name;
                        userSelect.appendChild(opt);
                    });
                }
                
                document.getElementById('apply-area').style.display = 'block';
                document.getElementById('search-cancel-btn').style.display = 'none';
            } else {
                alert("æœªæ‰¾åˆ°è¯¥è´¦å·");
                searchTargetChar = null;
                document.getElementById('search-result-area').style.display = 'none';
                document.getElementById('apply-area').style.display = 'none';
            }
        }

        async function sendFriendRequest() {
            if(!searchTargetChar) return;
            
            const reason = document.getElementById('apply-reason').value.trim();
            const selectedUserId = document.getElementById('apply-user-select').value;
            
            if(!selectedUserId) {
                alert("è¯·å…ˆé€‰æ‹©ä¸€ä¸ª User èº«ä»½è¿›è¡Œç”³è¯·");
                return;
            }
            
            closeModal('search-friend-modal');
            alert("å¥½å‹ç”³è¯·å·²å‘é€ï¼Œè¯·ç¨å€™...");

            try {
                // 1. è·å– User æ•°æ®
                const userChar = await db.characters.get(parseInt(selectedUserId));
                
                // 2. å‡†å¤‡ Lorebook åŒ¹é…å…³é”®è¯ (Userå + Charå + ç”³è¯·ç†ç”±)
                const keywords = `${userChar.name} ${searchTargetChar.name} ${reason}`;
                
                // 3. è·å–åŒæ–¹ Lorebook ä¸Šä¸‹æ–‡ï¼ˆæ”¯æŒå¤šä¸ªä¸–ç•Œä¹¦ï¼‰
                const userLorebookIds = userChar.lorebookIds || (userChar.lorebookId ? [userChar.lorebookId] : []);
                const charLorebookIds = searchTargetChar.lorebookIds || (searchTargetChar.lorebookId ? [searchTargetChar.lorebookId] : []);
                const userLore = await getLorebookContext(userLorebookIds, keywords);
                const charLore = await getLorebookContext(charLorebookIds, keywords);
                
                // 4. æ„å»º Prompt
                const prompt = `[åœºæ™¯: å¾®ä¿¡å¥½å‹ç”³è¯·]
ã€ç”³è¯·äººä¿¡æ¯ã€‘
åå­—: ${userChar.name}
è®¾å®š: ${userChar.description || 'æ— '}
è™šæ‹Ÿè´¦å·: ${userChar.identity?.account || 'æœªçŸ¥'}

ã€è¢«ç”³è¯·äºº(ä½ )çš„ä¿¡æ¯ã€‘
åå­—: ${searchTargetChar.name}
è®¾å®š: ${searchTargetChar.description || 'æ— '}
è™šæ‹Ÿè´¦å·: ${searchTargetChar.identity?.account || 'æœªçŸ¥'}

${userLore}
${charLore}

User(${userChar.name}) å‘ä½ å‘é€äº†å¥½å‹ç”³è¯·ï¼Œé™„è¨€ï¼šâ€œ${reason || 'æˆ‘æ˜¯æœ‹å‹'}â€ã€‚

è¯·ä»¥ ${searchTargetChar.name} çš„èº«ä»½ï¼Œæ ¹æ®åŒæ–¹è®¾å®šå’Œä¸–ç•Œä¹¦å…³ç³»ï¼Œå†³å®šæ˜¯å¦é€šè¿‡å¥½å‹ç”³è¯·ã€‚
è¦æ±‚ï¼š
1. å¿…é¡»ç¬¦åˆè§’è‰²æ€§æ ¼ã€‚å¦‚æœæ˜¯é«˜å†·/è°¨æ…çš„è§’è‰²ï¼Œå¯èƒ½ä¼šæ‹’ç»é™Œç”Ÿäººï¼›å¦‚æœæ˜¯å¤–å‘/è®¤è¯†çš„è§’è‰²ï¼Œåˆ™ä¼šé€šè¿‡ã€‚
2. ä»”ç»†æ£€æŸ¥ä¸–ç•Œä¹¦å’Œè®¾å®šä¸­æ˜¯å¦æœ‰ä¸¤äººçš„å…³ç³»æè¿°ã€‚
3. å¦‚æœé€šè¿‡ï¼Œè¯·ç»™å‡º 2 åˆ° 3 æ¡ç¬¦åˆè§’è‰²æ€§æ ¼ã€çº¿ä¸ŠèŠå¤©é£æ ¼çš„å›å¤ã€‚
   - **å¿…é¡»**ä½¿ç”¨åˆ†éš”ç¬¦ "|||" æ¥éš”å¼€æ¯ä¸€æ¡æ¶ˆæ¯ã€‚
   - **ä¸¥ç¦ä½¿ç”¨é€—å·**ï¼ˆåŒ…æ‹¬ä¸­æ–‡é€—å·å’Œè‹±æ–‡é€—å·ï¼‰ã€‚å¦‚æœæƒ³è¡¨è¾¾åœé¡¿ï¼Œè¯·ç›´æ¥æ‹†åˆ†æˆä¸‹ä¸€æ¡æ¶ˆæ¯ï¼Œæˆ–è€…ç”¨ç©ºæ ¼ä»£æ›¿ã€‚
   - é”™è¯¯ç¤ºä¾‹ï¼šä½ å¥½ï¼Œæˆ‘æ˜¯XXXï¼Œå¾ˆé«˜å…´è®¤è¯†ä½ 
   - æ­£ç¡®ç¤ºä¾‹ï¼šä½ å¥½|||æˆ‘æ˜¯XXX|||å¾ˆé«˜å…´è®¤è¯†ä½ 
4. å¦‚æœæ‹’ç»ï¼Œè¯·ç»™å‡ºç®€çŸ­çš„å¿ƒç†æ´»åŠ¨æˆ–æ‹’ç»ç†ç”±ï¼ˆä½œä¸º reply è¿”å›ï¼‰ã€‚

è¯·ä¸¥æ ¼è¿”å› JSON æ ¼å¼ï¼š
{
    "accepted": true, // æˆ– false
    "reply": "å›å¤å†…å®¹|||ç¬¬äºŒæ¡å†…å®¹"
}`;

                // 5. è°ƒç”¨ AI
                const resultStr = await callAI([
                    { role: "system", content: "ä½ æ˜¯ä¸€ä¸ªåªè¾“å‡ºJSONçš„è§’è‰²æ‰®æ¼”è¾…åŠ©ç³»ç»Ÿã€‚" },
                    { role: "user", content: prompt }
                ]);
                
                let result = extractAndParseJSON(resultStr);
                
                if (!result) {
                    console.error("JSONæå–/è§£æå¤±è´¥");
                    result = { accepted: true, reply: "ä½ å¥½å‘€|||æˆ‘æ˜¯æ–°æœ‹å‹(è§£æå¤±è´¥å…œåº•)" }; 
                }

                if (result.accepted) {
                    // æ›´æ–°æ•°æ®åº“
                    const char = await db.characters.get(searchTargetChar.id);
                    const accountId = String(selectedUserId);
                    await setFriendStatus(char, accountId, 'friend');
                    // ç»‘å®šèŠå¤©ç”¨çš„ User ID (å¯é€‰ï¼Œå¦‚æœä»¥åæ”¯æŒå¤š User åˆ‡æ¢)
                    // char.linked_user_id = userChar.id; 
                    
                    // è·å–å½“å‰è´¦å·çš„èŠå¤©è®°å½•
                    let history = getChatHistory(char, accountId);
                    
                    // 1. å­˜å…¥ç³»ç»Ÿå›ºå®šæ¶ˆæ¯
                    history.push({
                        role: 'char', // è¿™é‡Œè™½ç„¶æ˜¯ç³»ç»Ÿæ¶ˆæ¯ï¼Œä½†åœ¨å¾®ä¿¡é‡Œé€šå¸¸æ˜¾ç¤ºä¸ºä¸­é—´çš„ç°è‰²å°å­—ï¼Œæˆ–è€…å¯¹æ–¹å‘çš„ç¬¬ä¸€å¥è¯ã€‚
                        // ä¸ºäº†ç¬¦åˆâ€œç¬¬ä¸€æ¡æ¶ˆæ¯æ˜¯å¯¹æ–¹åŒæ„äº†æ‚¨çš„å¥½å‹ç”³è¯·â€çš„éœ€æ±‚ï¼Œè¿™é‡Œæ¨¡æ‹Ÿç³»ç»Ÿæç¤º
                        // ä½†å¦‚æœæ˜¯ä½œä¸ºå¯¹æ–¹å‘å‡ºçš„æ¶ˆæ¯ï¼ˆæ°”æ³¡ï¼‰ï¼Œåˆ™role='char'ã€‚
                        // å¦‚æœæƒ³è¦ä¸­é—´ç°è‰²å°å­—ï¼Œå¯èƒ½éœ€è¦æ–°çš„typeï¼Œè¿™é‡Œæš‚ä¸”ç”¨ç‰¹æ®Šå†…å®¹æˆ–charè§’è‰²å‘
                        // æ ¹æ®éœ€æ±‚"åº”è¯¥æœ‰ç¬¬ä¸€æ¡æ¶ˆæ¯æ˜¯å¯¹æ–¹åŒæ„äº†æ‚¨çš„å¥½å‹ç”³è¯·"ï¼Œè¿™é‡Œæ¨¡æ‹Ÿå¾®ä¿¡çš„ç³»ç»Ÿæç¤º
                        role: 'char', 
                        content: 'æˆ‘é€šè¿‡äº†ä½ çš„å¥½å‹éªŒè¯è¯·æ±‚ï¼Œç°åœ¨æˆ‘ä»¬å¯ä»¥å¼€å§‹èŠå¤©äº†',
                        time: Date.now()
                    });

                    // 2. å¤„ç† AI å›å¤ï¼ˆæ¸…æ´—é€—å· + æ‹†åˆ†ï¼‰
                    let cleanReply = result.reply.replace(/[,ï¼Œ]/g, ' '); 
                    let segments = cleanReply.split('|||').map(s => s.trim()).filter(s => s);
                    
                    // ä¾æ¬¡å­˜å…¥
                    for (let i = 0; i < segments.length; i++) {
                        history.push({
                            role: 'char',
                            content: segments[i],
                            time: Date.now() + (i + 1) * 500 // ç¨å¾®é”™å¼€æ—¶é—´
                        });
                    }
                    
                    await setChatHistory(char, accountId, history);
                    
                    // åˆ·æ–°åˆ—è¡¨
                    if (document.querySelector('.wechat-tab-item.active').innerText.includes('å¾®ä¿¡')) {
                        renderWechatList(document.getElementById('wechat-content'));
                    }

                    // å‘é€é€šçŸ¥
                    const notifyText = segments.length > 0 ? segments[0] : 'æˆ‘é€šè¿‡äº†ä½ çš„å¥½å‹éªŒè¯è¯·æ±‚';
                    sendSystemNotification("å¾®ä¿¡", `${char.name} é€šè¿‡äº†ä½ çš„éªŒè¯: ${notifyText}`);
                } else {
                    sendSystemNotification("å¾®ä¿¡", `${searchTargetChar.name} æ‹’ç»äº†ç”³è¯·: ${result.reply}`);
                }

            } catch (err) {
                console.error(err);
                alert("è¯·æ±‚å¤„ç†å¤±è´¥: " + err.message);
            }
        }

        // ç›´æ¥å¯¼å…¥é€»è¾‘
        async function showDirectAddModal() {
            document.getElementById('direct-add-modal').style.display = 'flex';
            document.getElementById('wechat-menu').style.display = 'none';
            
            const list = document.getElementById('direct-add-list');
            list.innerHTML = '';
            
            // è·å–éå¥½å‹è§’è‰²
            const accountId = getCurrentAccountId();
            const allChars = await db.characters.toArray();
            // è¿‡æ»¤æ‰å·²ç»æ˜¯å¥½å‹çš„ï¼Œä»¥åŠ type ä¸º 'user' çš„è§’è‰²
            const candidates = allChars.filter(c => {
                if (c.type === 'user') return false;
                const status = getFriendStatus(c, accountId);
                return status !== 'friend';
            });
            
            if(candidates.length === 0) {
                list.innerHTML = '<div style="text-align:center;color:#999;margin-top:20px;">æ²¡æœ‰å¯æ·»åŠ çš„è§’è‰²</div>';
                return;
            }
            
            candidates.forEach(c => {
                const item = document.createElement('div');
                item.style.display = 'flex';
                item.style.alignItems = 'center';
                item.style.justifyContent = 'space-between';
                item.style.padding = '10px';
                item.style.background = '#f9f9f9';
                item.style.borderRadius = '8px';
                
                item.innerHTML = `
                    <div style="font-weight:500;">${c.name}</div>
                    <button style="background:var(--ins-pink); color:#fff; border:none; padding:6px 12px; border-radius:4px; font-size:12px;" onclick="directAddFriend(${c.id})">æ·»åŠ </button>
                `;
                list.appendChild(item);
            });
        }

        async function directAddFriend(id) {
            const char = await db.characters.get(id);
            if(char) {
                const accountId = getCurrentAccountId();
                await setFriendStatus(char, accountId, 'friend');
                // ç›´æ¥æ·»åŠ é»˜è®¤æ²¡æœ‰æ¶ˆæ¯ï¼Œæˆ–è€…å¯ä»¥åŠ ä¸€æ¡ç³»ç»Ÿæ¶ˆæ¯
                let history = getChatHistory(char, accountId);
                // history.push({ role: 'system', content: 'ä½ ä»¬å·²æˆä¸ºå¥½å‹ï¼Œå¼€å§‹èŠå¤©å§', time: Date.now() });
                await setChatHistory(char, accountId, history);
                closeModal('direct-add-modal');
                alert(`å·²å°† ${char.name} æ·»åŠ åˆ°é€šè®¯å½•`);
                
                // åˆ·æ–°
                if (document.querySelector('.wechat-tab-item.active').innerText.includes('å¾®ä¿¡')) {
                    renderWechatList(document.getElementById('wechat-content'));
                }
            }
        }

        // --- ç¾¤èŠåŠŸèƒ½ ---
        // é»˜è®¤ç¾¤å¤´åƒ
        const DEFAULT_GROUP_AVATAR = 'https://img.heliar.top/file/1770017506622_IMG_0773.jpeg';
        
        // æ˜¾ç¤ºåˆ›å»ºç¾¤èŠå¼¹çª—
        async function showCreateGroupModal() {
            document.getElementById('create-group-modal').style.display = 'flex';
            document.getElementById('wechat-menu').style.display = 'none';
            document.getElementById('group-name-input').value = '';
            
            const list = document.getElementById('group-friends-list');
            list.innerHTML = '';
            
            // è·å–å½“å‰è´¦å·çš„å¥½å‹åˆ—è¡¨
            const accountId = getCurrentAccountId();
            const allChars = await db.characters.toArray();
            const friends = allChars.filter(c => {
                if (c.type === 'user') return false;
                const status = getFriendStatus(c, accountId);
                return status === 'friend';
            });
            
            if (friends.length === 0) {
                list.innerHTML = '<div style="text-align:center; color:#999; margin-top:40px;">æš‚æ— å¥½å‹<br><span style="font-size:12px;">è¯·å…ˆæ·»åŠ å¥½å‹å†åˆ›å»ºç¾¤èŠ</span></div>';
                return;
            }
            
            friends.forEach(f => {
                const item = document.createElement('div');
                item.style.cssText = 'display:flex; align-items:center; padding:12px 0; border-bottom:0.5px solid #f0f0f0; cursor:pointer;';
                item.dataset.charId = f.id;
                item.dataset.selected = 'false';
                
                const avatarStyle = f.avatar ? `background-image:url(${f.avatar})` : 'background-color:#eee';
                
                item.innerHTML = `
                    <div class="group-select-checkbox" style="width:22px; height:22px; border:2px solid #ddd; border-radius:50%; margin-right:12px; display:flex; align-items:center; justify-content:center; transition:all 0.2s;">
                        <svg class="check-icon" style="width:14px; height:14px; stroke:#fff; fill:none; stroke-width:3; display:none;" viewBox="0 0 24 24"><polyline points="20 6 9 17 4 12"></polyline></svg>
                    </div>
                    <div style="width:40px; height:40px; border-radius:4px; ${avatarStyle}; background-size:cover; background-position:center; margin-right:12px;"></div>
                    <div style="font-size:16px; color:#333;">${f.remark || f.name}</div>
                `;
                
                item.onclick = function() {
                    const isSelected = this.dataset.selected === 'true';
                    const checkbox = this.querySelector('.group-select-checkbox');
                    const checkIcon = this.querySelector('.check-icon');
                    
                    if (isSelected) {
                        this.dataset.selected = 'false';
                        checkbox.style.background = 'transparent';
                        checkbox.style.borderColor = '#ddd';
                        checkIcon.style.display = 'none';
                    } else {
                        this.dataset.selected = 'true';
                        checkbox.style.background = 'var(--ins-pink)';
                        checkbox.style.borderColor = 'var(--ins-pink)';
                        checkIcon.style.display = 'block';
                    }
                };
                
                list.appendChild(item);
            });
        }
        
        // ç¡®è®¤åˆ›å»ºç¾¤èŠ
        async function confirmCreateGroup() {
            const list = document.getElementById('group-friends-list');
            const selectedItems = list.querySelectorAll('[data-selected="true"]');
            const memberIds = Array.from(selectedItems).map(item => parseInt(item.dataset.charId));
            
            if (memberIds.length < 1) {
                alert('è¯·è‡³å°‘é€‰æ‹©1ä½å¥½å‹');
                return;
            }
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯æ·»åŠ ç¾¤æˆå‘˜æ¨¡å¼
            if (window._addingGroupMembers && window.currentGroupChatId) {
                await addMembersToGroup(memberIds);
                return;
            }
            
            const groupName = document.getElementById('group-name-input').value.trim();
            const accountId = getCurrentAccountId();
            
            // è·å–é€‰ä¸­æˆå‘˜çš„åç§°ç”¨äºç”Ÿæˆé»˜è®¤ç¾¤å
            let defaultName = '';
            if (!groupName) {
                const memberChars = await Promise.all(memberIds.map(id => db.characters.get(id)));
                const myChar = currentMyCharId ? await db.characters.get(parseInt(currentMyCharId)) : null;
                const names = memberChars.map(c => c.remark || c.name);
                if (myChar) names.unshift(myChar.name);
                defaultName = names.slice(0, 4).join('ã€');
                if (names.length > 4) defaultName += '...';
            }
            
            // åˆ›å»ºç¾¤èŠè®°å½•
            const groupChat = {
                name: groupName || defaultName,
                avatar: DEFAULT_GROUP_AVATAR,
                memberIds: memberIds,
                ownerAccountId: accountId,
                created_at: Date.now(),
                updated_at: Date.now(),
                is_pinned: false,
                chat_history: [{
                    role: 'system',
                    content: 'ç¾¤èŠå·²åˆ›å»º',
                    time: Date.now()
                }]
            };
            
            const groupId = await db.group_chats.add(groupChat);
            
            closeModal('create-group-modal');
            alert(`ç¾¤èŠ"${groupChat.name}"åˆ›å»ºæˆåŠŸï¼`);
            
            // åˆ·æ–°èŠå¤©åˆ—è¡¨
            if (document.querySelector('.wechat-tab-item.active')?.innerText.includes('å¾®ä¿¡')) {
                renderWechatList(document.getElementById('wechat-content'));
            }
            
            // æ‰“å¼€ç¾¤èŠçª—å£
            openGroupChatWindow(groupId);
        }
        
        // æ·»åŠ æˆå‘˜åˆ°ç¾¤èŠ
        async function addMembersToGroup(memberIds) {
            const group = await db.group_chats.get(window.currentGroupChatId);
            if (!group) return;
            
            // æ·»åŠ æ–°æˆå‘˜
            const newMemberNames = [];
            for (const memberId of memberIds) {
                if (!group.memberIds.includes(memberId)) {
                    group.memberIds.push(memberId);
                    const char = await db.characters.get(memberId);
                    if (char) newMemberNames.push(char.remark || char.name);
                }
            }
            
            if (newMemberNames.length > 0) {
                // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯
                group.chat_history.push({
                    role: 'system',
                    content: `${newMemberNames.join('ã€')} åŠ å…¥äº†ç¾¤èŠ`,
                    time: Date.now()
                });
            }
            
            group.updated_at = Date.now();
            await db.group_chats.put(group);
            
            // é‡ç½®çŠ¶æ€
            window._addingGroupMembers = false;
            document.getElementById('group-name-input').style.display = '';
            document.querySelector('#create-group-modal .modal-title').innerText = 'åˆ›å»ºç¾¤èŠ';
            
            closeModal('create-group-modal');
            
            // åˆ·æ–°ç¾¤æˆå‘˜åˆ—è¡¨å’ŒèŠå¤©
            await renderGroupMemberList(group);
            await renderGroupChatBody(group);
            
            alert(`å·²æ·»åŠ  ${newMemberNames.length} ä½æˆå‘˜`);
        }
        
        // æ‰“å¼€ç¾¤èŠçª—å£
        async function openGroupChatWindow(groupId) {
            const group = await db.group_chats.get(groupId);
            if (!group) return;
            
            // å¦‚æœæ˜¯è”æœºç¾¤èŠï¼Œè°ƒç”¨è”æœºç¾¤èŠçš„æ‰“å¼€æ–¹æ³•
            if (group.isOnlineGroup && group.onlineGroupId) {
                openOnlineGroup(group.onlineGroupId);
                return;
            }
            
            // è®¾ç½®å½“å‰èŠå¤©ä¸ºç¾¤èŠæ¨¡å¼
            currentChatCharId = null;
            window.currentGroupChatId = groupId;
            
            const titleEl = document.getElementById('chat-title');
            titleEl.innerText = group.name;
            titleEl.style.cursor = 'pointer';
            titleEl.onclick = () => showGroupDetail(groupId);
            
            document.getElementById('chat-window').style.display = 'flex';
            
            // æ˜¾ç¤ºè¾“å…¥æ¡†
            const chatFooter = document.getElementById('chat-footer');
            chatFooter.style.display = 'flex';
            
            await renderGroupChatBody(group);
        }
        
        // æ˜¾ç¤ºç¾¤èŠè¯¦æƒ…é¡µ
        async function showGroupDetail(groupId) {
            const group = await db.group_chats.get(groupId || window.currentGroupChatId);
            if (!group) return;
            
            document.getElementById('group-detail-page').style.display = 'flex';
            
            // è®¾ç½®ç¾¤å¤´åƒ
            const avatarEl = document.getElementById('group-detail-avatar');
            if (group.avatar) {
                avatarEl.style.backgroundImage = `url(${group.avatar})`;
            } else {
                avatarEl.style.backgroundImage = '';
                avatarEl.style.backgroundColor = '#eee';
            }
            
            // è®¾ç½®ç¾¤åç§°
            document.getElementById('group-detail-name').value = group.name || '';
            
            // è®¾ç½®æˆ‘çš„ç¾¤æ˜µç§°
            document.getElementById('group-detail-nickname').value = group.myNickname || '';
            
            // è®¾ç½®å¼€å…³çŠ¶æ€
            document.getElementById('group-detail-mute').checked = group.is_muted || false;
            document.getElementById('group-detail-pin').checked = group.is_pinned || false;
            
            // è®¾ç½®è‡ªåŠ¨æ€»ç»“è®¾ç½®
            document.getElementById('group-detail-auto-summary-switch').checked = group.auto_summary_enabled || false;
            document.getElementById('group-detail-summary-interval').value = group.summary_interval || '';
            
            // æ›´æ–°æ€»ç»“è®¡æ•°
            const accountId = getCurrentAccountId();
            if (accountId && group.id) {
                await updateSummaryCount('group', group.id, accountId);
            }
            
            // æ¸²æŸ“ç¾¤æˆå‘˜åˆ—è¡¨
            await renderGroupMemberList(group);
            
            // åŠ è½½ä¸–ç•Œä¹¦åˆ—è¡¨ï¼ˆå¤šé€‰ï¼‰
            const lorebooks = await db.lorebooks.toArray();
            const lbList = document.getElementById('group-detail-lorebook-list');
            lbList.innerHTML = '';
            
            // å…¼å®¹æ—§æ•°æ®ï¼šå¦‚æœlorebookIdå­˜åœ¨ä½†lorebookIdsä¸å­˜åœ¨ï¼Œè½¬æ¢ä¸ºæ•°ç»„
            const selectedIds = group.lorebookIds || (group.lorebookId ? [group.lorebookId] : []);
            
            if (lorebooks.length === 0) {
                lbList.innerHTML = '<div style="padding:8px; color:#999; font-size:12px; text-align:center;">æš‚æ— ä¸–ç•Œä¹¦</div>';
            } else {
                lorebooks.forEach(lb => {
                    const label = document.createElement('label');
                    label.style.cssText = 'display:flex; align-items:center; padding:8px; cursor:pointer; border-radius:6px; margin-bottom:4px;';
                    label.style.background = selectedIds.includes(lb.id) ? '#f0f0f5' : 'transparent';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.value = lb.id;
                    checkbox.checked = selectedIds.includes(lb.id);
                    checkbox.style.marginRight = '8px';
                    checkbox.onchange = () => {
                        label.style.background = checkbox.checked ? '#f0f0f5' : 'transparent';
                        updateGroupLorebookCount();
                        saveGroupDetail();
                    };
                    
                    const name = document.createElement('span');
                    name.textContent = lb.name;
                    name.style.fontSize = '14px';
                    name.style.color = '#333';
                    
                    label.appendChild(checkbox);
                    label.appendChild(name);
                    lbList.appendChild(label);
                });
            }
            
            updateGroupLorebookCount();
        }
        
        // æ¸²æŸ“ç¾¤æˆå‘˜åˆ—è¡¨é¢„è§ˆï¼ˆè¯¦æƒ…é¡µï¼‰
        async function renderGroupMemberList(group) {
            const listEl = document.getElementById('group-member-list');
            listEl.innerHTML = '';
            
            // æ·»åŠ è‡ªå·±
            const myChar = currentMyCharId ? await db.characters.get(parseInt(currentMyCharId)) : null;
            if (myChar) {
                const myAvatar = myChar.avatar || '';
                const myAvatarStyle = myAvatar ? `background-image:url(${myAvatar})` : 'background-color:#eee';
                const myItem = document.createElement('div');
                myItem.style.cssText = 'display:flex; flex-direction:column; align-items:center; width:60px;';
                myItem.innerHTML = `
                    <div style="width:44px; height:44px; border-radius:6px; ${myAvatarStyle}; background-size:cover; background-position:center; position:relative;">
                        <div style="position:absolute; bottom:-2px; right:-2px; background:#07c160; color:#fff; font-size:8px; padding:1px 3px; border-radius:2px;">ç¾¤ä¸»</div>
                    </div>
                    <div style="font-size:11px; color:#333; margin-top:4px; text-align:center; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; width:100%;">${group.myNickname || myChar.name || 'æˆ‘'}</div>
                `;
                listEl.appendChild(myItem);
            }
            
            // æ·»åŠ å…¶ä»–æˆå‘˜ï¼ˆæœ€å¤šæ˜¾ç¤º8ä¸ªé¢„è§ˆï¼‰
            const memberIds = group.memberIds || [];
            const adminIds = group.adminIds || [];
            const displayCount = Math.min(memberIds.length, 7);
            
            for (let i = 0; i < displayCount; i++) {
                const memberId = memberIds[i];
                const char = await db.characters.get(memberId);
                if (!char) continue;
                
                const isAdmin = adminIds.includes(memberId);
                const avatarStyle = char.avatar ? `background-image:url(${char.avatar})` : 'background-color:#eee';
                const item = document.createElement('div');
                item.style.cssText = 'display:flex; flex-direction:column; align-items:center; width:60px;';
                item.innerHTML = `
                    <div style="width:44px; height:44px; border-radius:6px; ${avatarStyle}; background-size:cover; background-position:center; position:relative;">
                        ${isAdmin ? '<div style="position:absolute; bottom:-2px; right:-2px; background:#ff9500; color:#fff; font-size:8px; padding:1px 3px; border-radius:2px;">ç®¡ç†</div>' : ''}
                    </div>
                    <div style="font-size:11px; color:#333; margin-top:4px; text-align:center; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; width:100%;">${char.remark || char.name}</div>
                `;
                listEl.appendChild(item);
            }
            
            // å¦‚æœæˆå‘˜è¶…è¿‡8ä¸ªï¼Œæ˜¾ç¤ºæ›´å¤š
            if (memberIds.length > 7) {
                const moreItem = document.createElement('div');
                moreItem.style.cssText = 'display:flex; flex-direction:column; align-items:center; width:60px; cursor:pointer;';
                moreItem.innerHTML = `
                    <div style="width:44px; height:44px; border-radius:6px; background:#f0f0f0; display:flex; align-items:center; justify-content:center; font-size:14px; color:#999;">+${memberIds.length - 7}</div>
                    <div style="font-size:11px; color:#999; margin-top:4px;">æ›´å¤š</div>
                `;
                moreItem.onclick = () => showGroupMemberManage();
                listEl.appendChild(moreItem);
            }
            
            // æ›´æ–°æˆå‘˜æ•°é‡
            const totalCount = memberIds.length + 1; // +1 åŒ…å«è‡ªå·±
            document.getElementById('group-member-count').innerText = `${totalCount}äºº`;
            const countText = document.getElementById('group-member-count-text');
            if (countText) countText.innerText = `${totalCount}äºº`;
        }
        
        // å½“å‰æ“ä½œçš„æˆå‘˜ID
        let currentActionMemberId = null;
        
        // æ˜¾ç¤ºç¾¤æˆå‘˜ç®¡ç†é¡µé¢
        async function showGroupMemberManage() {
            if (!window.currentGroupChatId) return;
            
            const group = await db.group_chats.get(window.currentGroupChatId);
            if (!group) return;
            
            document.getElementById('group-member-manage-page').style.display = 'flex';
            
            await renderGroupMemberManageList(group);
        }
        
        // éšè—ç¾¤æˆå‘˜ç®¡ç†é¡µé¢
        function hideGroupMemberManage() {
            document.getElementById('group-member-manage-page').style.display = 'none';
        }
        
        // æ¸²æŸ“ç¾¤æˆå‘˜ç®¡ç†åˆ—è¡¨
        async function renderGroupMemberManageList(group) {
            const ownerEl = document.getElementById('group-owner-info');
            const adminListEl = document.getElementById('group-admin-list');
            const memberListEl = document.getElementById('group-normal-member-list');
            const noAdminEl = document.getElementById('group-no-admin');
            
            ownerEl.innerHTML = '';
            adminListEl.innerHTML = '';
            memberListEl.innerHTML = '';
            
            const adminIds = group.adminIds || [];
            const mutedIds = group.mutedMembers || [];
            
            // æ£€æŸ¥å½“å‰ç”¨æˆ·æƒé™
            const isOwner = group.ownerAccountId === getCurrentAccountId();
            const currentUserIsAdmin = adminIds.includes(parseInt(currentMyCharId));
            const hasManagePermission = isOwner || currentUserIsAdmin;
            
            // æ¸²æŸ“ç¾¤ä¸»ï¼ˆè‡ªå·±ï¼‰
            const myChar = currentMyCharId ? await db.characters.get(parseInt(currentMyCharId)) : null;
            if (myChar) {
                const myAvatar = myChar.avatar || '';
                const myAvatarStyle = myAvatar ? `background-image:url(${myAvatar})` : 'background-color:#eee';
                ownerEl.innerHTML = `
                    <div style="display:flex; align-items:center; gap:12px;">
                        <div style="width:44px; height:44px; border-radius:6px; ${myAvatarStyle}; background-size:cover; background-position:center;"></div>
                        <div style="flex:1;">
                            <div style="font-size:16px; font-weight:500; color:#333;">${group.myNickname || myChar.name || 'æˆ‘'}</div>
                            <div style="font-size:12px; color:#07c160;">ç¾¤ä¸»</div>
                        </div>
                    </div>
                `;
            }
            
            // åˆ†ç±»æˆå‘˜
            const admins = [];
            const members = [];
            
            for (const memberId of (group.memberIds || [])) {
                const char = await db.characters.get(memberId);
                if (!char) continue;
                
                if (adminIds.includes(memberId)) {
                    admins.push({ char, memberId });
                } else {
                    members.push({ char, memberId });
                }
            }
            
            // æ¸²æŸ“ç®¡ç†å‘˜
            if (admins.length === 0) {
                noAdminEl.style.display = 'block';
            } else {
                noAdminEl.style.display = 'none';
                for (const { char, memberId } of admins) {
                    const isMuted = mutedIds.includes(memberId);
                    const avatarStyle = char.avatar ? `background-image:url(${char.avatar})` : 'background-color:#eee';
                    const item = document.createElement('div');
                    // åªæœ‰ç¾¤ä¸»å¯ä»¥æ“ä½œç®¡ç†å‘˜
                    const canOperate = isOwner;
                    item.style.cssText = `display:flex; align-items:center; gap:12px; padding:12px 16px; border-bottom:0.5px solid #f0f0f0; ${canOperate ? 'cursor:pointer;' : ''}`;
                    item.innerHTML = `
                        <div style="width:44px; height:44px; border-radius:6px; ${avatarStyle}; background-size:cover; background-position:center;"></div>
                        <div style="flex:1;">
                            <div style="font-size:16px; font-weight:500; color:#333;">${char.remark || char.name}</div>
                            <div style="font-size:12px; color:#ff9500;">${isMuted ? 'å·²ç¦è¨€ Â· ' : ''}ç®¡ç†å‘˜</div>
                        </div>
                        ${canOperate ? '<svg style="width:20px; height:20px; stroke:#ccc;" viewBox="0 0 24 24" fill="none" stroke-width="2"><polyline points="9 18 15 12 9 6"></polyline></svg>' : ''}
                    `;
                    if (canOperate) {
                        item.onclick = () => showMemberActionModal(memberId, char, true, isMuted);
                    }
                    adminListEl.appendChild(item);
                }
            }
            
            // æ¸²æŸ“æ™®é€šæˆå‘˜
            for (const { char, memberId } of members) {
                const isMuted = mutedIds.includes(memberId);
                const avatarStyle = char.avatar ? `background-image:url(${char.avatar})` : 'background-color:#eee';
                const item = document.createElement('div');
                // ç¾¤ä¸»å’Œç®¡ç†å‘˜éƒ½å¯ä»¥æ“ä½œæ™®é€šæˆå‘˜
                const canOperate = hasManagePermission;
                item.style.cssText = `display:flex; align-items:center; gap:12px; padding:12px 16px; border-bottom:0.5px solid #f0f0f0; ${canOperate ? 'cursor:pointer;' : ''}`;
                item.innerHTML = `
                    <div style="width:44px; height:44px; border-radius:6px; ${avatarStyle}; background-size:cover; background-position:center;"></div>
                    <div style="flex:1;">
                        <div style="font-size:16px; font-weight:500; color:#333;">${char.remark || char.name}</div>
                        ${isMuted ? '<div style="font-size:12px; color:#ff3b30;">å·²ç¦è¨€</div>' : ''}
                    </div>
                    ${canOperate ? '<svg style="width:20px; height:20px; stroke:#ccc;" viewBox="0 0 24 24" fill="none" stroke-width="2"><polyline points="9 18 15 12 9 6"></polyline></svg>' : ''}
                `;
                if (canOperate) {
                    item.onclick = () => showMemberActionModal(memberId, char, false, isMuted);
                }
                memberListEl.appendChild(item);
            }
            
            if (members.length === 0) {
                memberListEl.innerHTML = '<div style="padding:20px 16px; text-align:center; color:#999; font-size:13px;">æš‚æ— æ™®é€šæˆå‘˜</div>';
            }
        }
        
        // æ˜¾ç¤ºæˆå‘˜æ“ä½œå¼¹çª—
        async function showMemberActionModal(memberId, char, isAdmin, isMuted) {
            currentActionMemberId = memberId;
            
            const group = await db.group_chats.get(window.currentGroupChatId);
            if (!group) return;
            
            // æ£€æŸ¥å½“å‰ç”¨æˆ·æ˜¯å¦æ˜¯ç¾¤ä¸»ï¼ˆåˆ›å»ºè€…ï¼‰
            const isOwner = group.ownerAccountId === getCurrentAccountId();
            // æ£€æŸ¥å½“å‰ç”¨æˆ·æ˜¯å¦æ˜¯ç®¡ç†å‘˜
            const currentUserIsAdmin = (group.adminIds || []).includes(parseInt(currentMyCharId));
            
            const avatarStyle = char.avatar ? `url(${char.avatar})` : '#eee';
            document.getElementById('member-action-avatar').style.backgroundImage = avatarStyle;
            document.getElementById('member-action-name').innerText = char.remark || char.name;
            document.getElementById('member-action-role').innerText = isAdmin ? 'ç®¡ç†å‘˜' : 'ç¾¤æˆå‘˜';
            
            // æƒé™æ§åˆ¶ï¼š
            // - ç¾¤ä¸»å¯ä»¥åšæ‰€æœ‰æ“ä½œ
            // - ç®¡ç†å‘˜åªèƒ½å¯¹æ™®é€šæˆå‘˜æ“ä½œï¼ˆä¸èƒ½å¯¹å…¶ä»–ç®¡ç†å‘˜æ“ä½œï¼‰
            
            const setAdminBtn = document.getElementById('member-action-set-admin');
            const removeAdminBtn = document.getElementById('member-action-remove-admin');
            const muteBtn = document.getElementById('member-action-mute');
            const kickBtn = document.getElementById('member-action-kick');
            
            if (isOwner) {
                // ç¾¤ä¸»ï¼šå®Œæ•´æƒé™
                setAdminBtn.style.display = isAdmin ? 'none' : 'block';
                removeAdminBtn.style.display = isAdmin ? 'block' : 'none';
                muteBtn.style.display = 'block';
                kickBtn.style.display = 'block';
            } else if (currentUserIsAdmin) {
                // ç®¡ç†å‘˜ï¼šåªèƒ½æ“ä½œæ™®é€šæˆå‘˜
                setAdminBtn.style.display = 'none'; // ç®¡ç†å‘˜ä¸èƒ½è®¾ç½®ç®¡ç†å‘˜
                removeAdminBtn.style.display = 'none'; // ç®¡ç†å‘˜ä¸èƒ½å–æ¶ˆç®¡ç†å‘˜
                
                if (isAdmin) {
                    // ä¸èƒ½å¯¹å…¶ä»–ç®¡ç†å‘˜æ“ä½œ
                    muteBtn.style.display = 'none';
                    kickBtn.style.display = 'none';
                } else {
                    // å¯ä»¥å¯¹æ™®é€šæˆå‘˜æ“ä½œ
                    muteBtn.style.display = 'block';
                    kickBtn.style.display = 'block';
                }
            } else {
                // æ™®é€šæˆå‘˜ï¼šæ²¡æœ‰ç®¡ç†æƒé™
                setAdminBtn.style.display = 'none';
                removeAdminBtn.style.display = 'none';
                muteBtn.style.display = 'none';
                kickBtn.style.display = 'none';
            }
            
            // ç¦è¨€æŒ‰é’®æ–‡å­—
            muteBtn.innerText = isMuted ? 'è§£é™¤ç¦è¨€' : 'ç¦è¨€';
            muteBtn.style.color = isMuted ? '#07c160' : '#ff9500';
            
            document.getElementById('member-action-modal').style.display = 'flex';
        }
        
        // è®¾ä¸ºç®¡ç†å‘˜ï¼ˆåªæœ‰ç¾¤ä¸»å¯ä»¥ï¼‰
        async function setMemberAsAdmin() {
            if (!window.currentGroupChatId || !currentActionMemberId) return;
            
            const group = await db.group_chats.get(window.currentGroupChatId);
            if (!group) return;
            
            // æƒé™æ£€æŸ¥ï¼šåªæœ‰ç¾¤ä¸»å¯ä»¥è®¾ç½®ç®¡ç†å‘˜
            if (group.ownerAccountId !== getCurrentAccountId()) {
                alert('åªæœ‰ç¾¤ä¸»å¯ä»¥è®¾ç½®ç®¡ç†å‘˜');
                return;
            }
            
            if (!group.adminIds) group.adminIds = [];
            if (!group.adminIds.includes(currentActionMemberId)) {
                group.adminIds.push(currentActionMemberId);
                
                const char = await db.characters.get(currentActionMemberId);
                group.chat_history.push({
                    role: 'system',
                    content: `${char?.name || 'æˆå‘˜'} å·²è¢«è®¾ä¸ºç®¡ç†å‘˜`,
                    time: Date.now()
                });
            }
            
            group.updated_at = Date.now();
            await db.group_chats.put(group);
            
            closeModal('member-action-modal');
            await renderGroupMemberManageList(group);
            await renderGroupMemberList(group);
        }
        
        // å–æ¶ˆç®¡ç†å‘˜ï¼ˆåªæœ‰ç¾¤ä¸»å¯ä»¥ï¼‰
        async function removeMemberAdmin() {
            if (!window.currentGroupChatId || !currentActionMemberId) return;
            
            const group = await db.group_chats.get(window.currentGroupChatId);
            if (!group) return;
            
            // æƒé™æ£€æŸ¥ï¼šåªæœ‰ç¾¤ä¸»å¯ä»¥å–æ¶ˆç®¡ç†å‘˜
            if (group.ownerAccountId !== getCurrentAccountId()) {
                alert('åªæœ‰ç¾¤ä¸»å¯ä»¥å–æ¶ˆç®¡ç†å‘˜');
                return;
            }
            
            group.adminIds = (group.adminIds || []).filter(id => id !== currentActionMemberId);
            
            const char = await db.characters.get(currentActionMemberId);
            group.chat_history.push({
                role: 'system',
                content: `${char?.name || 'æˆå‘˜'} å·²è¢«å–æ¶ˆç®¡ç†å‘˜`,
                time: Date.now()
            });
            
            group.updated_at = Date.now();
            await db.group_chats.put(group);
            
            closeModal('member-action-modal');
            await renderGroupMemberManageList(group);
            await renderGroupMemberList(group);
        }
        
        // ç¦è¨€/è§£é™¤ç¦è¨€ï¼ˆç¾¤ä¸»å’Œç®¡ç†å‘˜éƒ½å¯ä»¥ï¼Œä½†ç®¡ç†å‘˜åªèƒ½å¯¹æ™®é€šæˆå‘˜æ“ä½œï¼‰
        async function toggleMemberMute() {
            if (!window.currentGroupChatId || !currentActionMemberId) return;
            
            const group = await db.group_chats.get(window.currentGroupChatId);
            if (!group) return;
            
            const isOwner = group.ownerAccountId === getCurrentAccountId();
            const currentUserIsAdmin = (group.adminIds || []).includes(parseInt(currentMyCharId));
            const targetIsAdmin = (group.adminIds || []).includes(currentActionMemberId);
            
            // æƒé™æ£€æŸ¥
            if (!isOwner && !currentUserIsAdmin) {
                alert('åªæœ‰ç¾¤ä¸»æˆ–ç®¡ç†å‘˜å¯ä»¥ç¦è¨€æˆå‘˜');
                return;
            }
            
            // ç®¡ç†å‘˜ä¸èƒ½ç¦è¨€å…¶ä»–ç®¡ç†å‘˜
            if (!isOwner && targetIsAdmin) {
                alert('ç®¡ç†å‘˜ä¸èƒ½ç¦è¨€å…¶ä»–ç®¡ç†å‘˜');
                return;
            }
            
            if (!group.mutedMembers) group.mutedMembers = [];
            
            const char = await db.characters.get(currentActionMemberId);
            const isMuted = group.mutedMembers.includes(currentActionMemberId);
            
            if (isMuted) {
                group.mutedMembers = group.mutedMembers.filter(id => id !== currentActionMemberId);
                group.chat_history.push({
                    role: 'system',
                    content: `${char?.name || 'æˆå‘˜'} å·²è¢«è§£é™¤ç¦è¨€`,
                    time: Date.now()
                });
            } else {
                group.mutedMembers.push(currentActionMemberId);
                group.chat_history.push({
                    role: 'system',
                    content: `${char?.name || 'æˆå‘˜'} å·²è¢«ç¦è¨€`,
                    time: Date.now()
                });
            }
            
            group.updated_at = Date.now();
            await db.group_chats.put(group);
            
            closeModal('member-action-modal');
            await renderGroupMemberManageList(group);
        }
        
        // è¸¢å‡ºç¾¤èŠï¼ˆç¾¤ä¸»å’Œç®¡ç†å‘˜éƒ½å¯ä»¥ï¼Œä½†ç®¡ç†å‘˜åªèƒ½è¸¢æ™®é€šæˆå‘˜ï¼‰
        async function kickMember() {
            if (!window.currentGroupChatId || !currentActionMemberId) return;
            
            const group = await db.group_chats.get(window.currentGroupChatId);
            if (!group) return;
            
            const isOwner = group.ownerAccountId === getCurrentAccountId();
            const currentUserIsAdmin = (group.adminIds || []).includes(parseInt(currentMyCharId));
            const targetIsAdmin = (group.adminIds || []).includes(currentActionMemberId);
            
            // æƒé™æ£€æŸ¥
            if (!isOwner && !currentUserIsAdmin) {
                alert('åªæœ‰ç¾¤ä¸»æˆ–ç®¡ç†å‘˜å¯ä»¥ç§»é™¤æˆå‘˜');
                return;
            }
            
            // ç®¡ç†å‘˜ä¸èƒ½è¸¢å…¶ä»–ç®¡ç†å‘˜
            if (!isOwner && targetIsAdmin) {
                alert('ç®¡ç†å‘˜ä¸èƒ½ç§»é™¤å…¶ä»–ç®¡ç†å‘˜');
                return;
            }
            
            const char = await db.characters.get(currentActionMemberId);
            if (!confirm(`ç¡®å®šè¦å°† ${char?.name || 'è¯¥æˆå‘˜'} ç§»å‡ºç¾¤èŠå—ï¼Ÿ`)) return;
            
            // ä»æˆå‘˜åˆ—è¡¨ç§»é™¤
            group.memberIds = (group.memberIds || []).filter(id => id !== currentActionMemberId);
            // ä»ç®¡ç†å‘˜åˆ—è¡¨ç§»é™¤
            group.adminIds = (group.adminIds || []).filter(id => id !== currentActionMemberId);
            // ä»ç¦è¨€åˆ—è¡¨ç§»é™¤
            group.mutedMembers = (group.mutedMembers || []).filter(id => id !== currentActionMemberId);
            
            group.chat_history.push({
                role: 'system',
                content: `${char?.name || 'æˆå‘˜'} å·²è¢«ç§»å‡ºç¾¤èŠ`,
                time: Date.now()
            });
            
            group.updated_at = Date.now();
            await db.group_chats.put(group);
            
            closeModal('member-action-modal');
            await renderGroupMemberManageList(group);
            await renderGroupMemberList(group);
            await renderGroupChatBody(group);
        }
        
        // éšè—ç¾¤èŠè¯¦æƒ…é¡µ
        function hideGroupDetail() {
            document.getElementById('group-detail-page').style.display = 'none';
        }
        
        // åˆ‡æ¢ç¾¤èŠä¸–ç•Œä¹¦åˆ—è¡¨
        function toggleGroupLorebookList() {
            const list = document.getElementById('group-detail-lorebook-list');
            const toggle = document.getElementById('group-detail-lorebook-toggle');
            if (list.style.display === 'none' || !list.style.display) {
                list.style.display = 'block';
                toggle.textContent = 'âˆ¨';
            } else {
                list.style.display = 'none';
                toggle.textContent = 'â€º';
            }
        }
        
        // æ›´æ–°ç¾¤èŠä¸–ç•Œä¹¦è®¡æ•°
        function updateGroupLorebookCount() {
            const checkboxes = document.querySelectorAll('#group-detail-lorebook-list input[type="checkbox"]:checked');
            const count = checkboxes.length;
            document.getElementById('group-detail-lorebook-count').textContent = `${count}ä¸ª`;
        }
        
        // ä¿å­˜ç¾¤èŠè¯¦æƒ…
        async function saveGroupDetail() {
            if (!window.currentGroupChatId) return;
            
            const group = await db.group_chats.get(window.currentGroupChatId);
            if (!group) return;
            
            group.name = document.getElementById('group-detail-name').value.trim() || group.name;
            group.myNickname = document.getElementById('group-detail-nickname').value.trim();
            group.is_muted = document.getElementById('group-detail-mute').checked;
            group.is_pinned = document.getElementById('group-detail-pin').checked;
            
            // è·å–é€‰ä¸­çš„ä¸–ç•Œä¹¦IDæ•°ç»„
            const checkboxes = document.querySelectorAll('#group-detail-lorebook-list input[type="checkbox"]:checked');
            const lorebookIds = Array.from(checkboxes).map(cb => parseInt(cb.value));
            group.lorebookIds = lorebookIds.length > 0 ? lorebookIds : null;
            
            // è‡ªåŠ¨æ€»ç»“è®¾ç½®
            group.auto_summary_enabled = document.getElementById('group-detail-auto-summary-switch').checked;
            const summaryInterval = parseInt(document.getElementById('group-detail-summary-interval').value);
            group.summary_interval = summaryInterval > 0 ? summaryInterval : 50;
            
            group.updated_at = Date.now();
            
            await db.group_chats.put(group);
            
            // æ›´æ–°èŠå¤©çª—å£æ ‡é¢˜
            document.getElementById('chat-title').innerText = group.name;
        }
        
        // è®¾ç½®ç¾¤å¤´åƒ
        async function setGroupAvatar(input) {
            if (!input.files || !input.files[0] || !window.currentGroupChatId) return;
            
            const file = input.files[0];
            const reader = new FileReader();
            
            reader.onload = async (e) => {
                const avatarUrl = e.target.result;
                
                const group = await db.group_chats.get(window.currentGroupChatId);
                if (!group) return;
                
                group.avatar = avatarUrl;
                group.updated_at = Date.now();
                await db.group_chats.put(group);
                
                // æ›´æ–°è¯¦æƒ…é¡µå¤´åƒ
                document.getElementById('group-detail-avatar').style.backgroundImage = `url(${avatarUrl})`;
            };
            
            reader.readAsDataURL(file);
            input.value = '';
        }
        
        // æ¸…ç©ºç¾¤èŠè®°å½•
        async function clearGroupChatHistory() {
            if (!window.currentGroupChatId) return;
            
            if (!confirm('ç¡®å®šè¦æ¸…ç©ºè¯¥ç¾¤èŠçš„æ‰€æœ‰èŠå¤©è®°å½•å—ï¼Ÿ')) return;
            
            const group = await db.group_chats.get(window.currentGroupChatId);
            if (!group) return;
            
            group.chat_history = [{
                role: 'system',
                content: 'èŠå¤©è®°å½•å·²æ¸…ç©º',
                time: Date.now()
            }];
            group.updated_at = Date.now();
            
            await db.group_chats.put(group);
            await renderGroupChatBody(group);
            
            alert('èŠå¤©è®°å½•å·²æ¸…ç©º');
        }
        
        // é€€å‡ºç¾¤èŠ
        async function exitGroup() {
            if (!window.currentGroupChatId) return;
            
            if (!confirm('ç¡®å®šè¦åˆ é™¤å¹¶é€€å‡ºè¯¥ç¾¤èŠå—ï¼Ÿ')) return;
            
            await db.group_chats.delete(window.currentGroupChatId);
            
            hideGroupDetail();
            hideChatWindow();
            
            // åˆ·æ–°èŠå¤©åˆ—è¡¨
            if (document.querySelector('.wechat-tab-item.active')?.innerText.includes('å¾®ä¿¡')) {
                renderWechatList(document.getElementById('wechat-content'));
            }
            
            alert('å·²é€€å‡ºç¾¤èŠ');
        }
        
        // ç§»é™¤ç¾¤æˆå‘˜
        async function removeGroupMember(groupId, memberId) {
            const group = await db.group_chats.get(groupId);
            if (!group) return;
            
            group.memberIds = group.memberIds.filter(id => id !== memberId);
            group.updated_at = Date.now();
            
            // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯
            const char = await db.characters.get(memberId);
            group.chat_history.push({
                role: 'system',
                content: `${char?.name || 'æˆå‘˜'} å·²è¢«ç§»å‡ºç¾¤èŠ`,
                time: Date.now()
            });
            
            await db.group_chats.put(group);
            await renderGroupMemberList(group);
            await renderGroupChatBody(group);
        }
        
        // æ˜¾ç¤ºæ·»åŠ ç¾¤æˆå‘˜å¼¹çª—
        async function showAddGroupMemberModal() {
            if (!window.currentGroupChatId) return;
            
            const group = await db.group_chats.get(window.currentGroupChatId);
            if (!group) return;
            
            // å¤ç”¨åˆ›å»ºç¾¤èŠçš„å¼¹çª—é€»è¾‘
            document.getElementById('create-group-modal').style.display = 'flex';
            document.getElementById('group-name-input').style.display = 'none';
            document.querySelector('#create-group-modal .modal-title').innerText = 'æ·»åŠ ç¾¤æˆå‘˜';
            
            const list = document.getElementById('group-friends-list');
            list.innerHTML = '';
            
            const accountId = getCurrentAccountId();
            const allChars = await db.characters.toArray();
            const existingMemberIds = group.memberIds || [];
            
            // è¿‡æ»¤å‡ºè¿˜ä¸åœ¨ç¾¤é‡Œçš„å¥½å‹
            const friends = allChars.filter(c => {
                if (c.type === 'user') return false;
                if (existingMemberIds.includes(c.id)) return false;
                const status = getFriendStatus(c, accountId);
                return status === 'friend';
            });
            
            if (friends.length === 0) {
                list.innerHTML = '<div style="text-align:center; color:#999; margin-top:40px;">æ²¡æœ‰å¯æ·»åŠ çš„å¥½å‹</div>';
                return;
            }
            
            friends.forEach(f => {
                const item = document.createElement('div');
                item.style.cssText = 'display:flex; align-items:center; padding:12px 0; border-bottom:0.5px solid #f0f0f0; cursor:pointer;';
                item.dataset.charId = f.id;
                item.dataset.selected = 'false';
                
                const avatarStyle = f.avatar ? `background-image:url(${f.avatar})` : 'background-color:#eee';
                
                item.innerHTML = `
                    <div class="group-select-checkbox" style="width:22px; height:22px; border:2px solid #ddd; border-radius:50%; margin-right:12px; display:flex; align-items:center; justify-content:center; transition:all 0.2s;">
                        <svg class="check-icon" style="width:14px; height:14px; stroke:#fff; fill:none; stroke-width:3; display:none;" viewBox="0 0 24 24"><polyline points="20 6 9 17 4 12"></polyline></svg>
                    </div>
                    <div style="width:40px; height:40px; border-radius:4px; ${avatarStyle}; background-size:cover; background-position:center; margin-right:12px;"></div>
                    <div style="font-size:16px; color:#333;">${f.remark || f.name}</div>
                `;
                
                item.onclick = function() {
                    const isSelected = this.dataset.selected === 'true';
                    const checkbox = this.querySelector('.group-select-checkbox');
                    const checkIcon = this.querySelector('.check-icon');
                    
                    if (isSelected) {
                        this.dataset.selected = 'false';
                        checkbox.style.background = 'transparent';
                        checkbox.style.borderColor = '#ddd';
                        checkIcon.style.display = 'none';
                    } else {
                        this.dataset.selected = 'true';
                        checkbox.style.background = 'var(--ins-pink)';
                        checkbox.style.borderColor = 'var(--ins-pink)';
                        checkIcon.style.display = 'block';
                    }
                };
                
                list.appendChild(item);
            });
            
            // ä¿®æ”¹ç¡®è®¤æŒ‰é’®è¡Œä¸º
            window._addingGroupMembers = true;
        }
        
        // æ¸²æŸ“ç¾¤èŠæ¶ˆæ¯
        async function renderGroupChatBody(group) {
            const body = document.getElementById('chat-body');
            body.innerHTML = '';
            
            let history = group.chat_history || [];
            // æŒ‰æ—¶é—´æˆ³æ’åºï¼Œç¡®ä¿æ¶ˆæ¯é¡ºåºæ­£ç¡®
            history = [...history].sort((a, b) => (a.time || 0) - (b.time || 0));
            
            const accountId = getCurrentAccountId();
            const myChar = currentMyCharId ? await db.characters.get(parseInt(currentMyCharId)) : null;
            
            // è·å–æˆ‘çš„ç¾¤æ˜µç§°
            const myNickname = group.myNickname || (myChar ? myChar.name : 'æˆ‘');
            
            // é¢„åŠ è½½æ‰€æœ‰æˆå‘˜ä¿¡æ¯
            const memberMap = {};
            for (const memberId of group.memberIds) {
                const char = await db.characters.get(memberId);
                if (char) memberMap[memberId] = char;
            }
            
            // è¾…åŠ©å‡½æ•°ï¼šæ¸²æŸ“ç¾¤èŠæ¶ˆæ¯å†…å®¹ï¼ˆæ”¯æŒç‰¹æ®Šæ ¼å¼ï¼‰
            function renderGroupMessageContent(content, isSelf, msgType) {
                if (!content) return '';
                
                // å¤„ç†çº¢åŒ…æ¶ˆæ¯ - INSé£æ ¼çº¯ç™½å¡ç‰‡
                if (msgType === 'redpacket') {
                    try {
                        const data = JSON.parse(content);
                        const isAllClaimed = (data.claimed?.length || 0) >= data.count;
                        return `<div onclick="showRedPacketDetail('${data.id}')" style="width:220px; background:#fff; border-radius:12px; overflow:hidden; cursor:pointer; box-shadow:0 1px 3px rgba(0,0,0,0.08); border:1px solid #eee;">
                            <div style="padding:14px 16px; display:flex; align-items:center; gap:12px;">
                                <div style="width:40px; height:40px; background:#fff; border-radius:10px; display:flex; align-items:center; justify-content:center; border:1px solid #eee;">
                                    <svg viewBox="0 0 24 24" style="width:20px; height:20px; stroke:#666; fill:none; stroke-width:1.5;"><rect x="3" y="4" width="18" height="16" rx="2"/><path d="M3 10h18"/><circle cx="12" cy="15" r="2"/></svg>
                                </div>
                                <div style="flex:1;">
                                    <div style="font-size:14px; color:#333; margin-bottom:2px;">${escapeHtml(data.wish || 'æ­å–œå‘è´¢')}</div>
                                    <div style="font-size:11px; color:#999;">${data.redpacketType === 'lucky' ? 'æ‹¼æ‰‹æ°”çº¢åŒ…' : 'æ™®é€šçº¢åŒ…'}</div>
                                </div>
                            </div>
                            <div style="padding:8px 16px; display:flex; justify-content:space-between; align-items:center; border-top:1px solid #eee;">
                                <span style="font-size:11px; color:#999;">çº¢åŒ…</span>
                                <span style="font-size:11px; color:#999;">${isAllClaimed ? 'å·²é¢†å®Œ' : `${data.claimed?.length || 0}/${data.count}å·²é¢†`}</span>
                            </div>
                        </div>`;
                    } catch(e) {
                        return content;
                    }
                }
                
                // å¤„ç†è½¬è´¦æ¶ˆæ¯ - INSé£æ ¼çº¯ç™½å¡ç‰‡
                if (msgType === 'transfer') {
                    try {
                        const data = JSON.parse(content);
                        const targetHint = data.targetName ? `è½¬ç»™ ${data.targetName}` : 'è½¬è´¦';
                        const msgId = m.id || ('trans_' + m.time);
                        return `<div onclick="receiveGroupTransfer('${msgId}')" style="width:220px; background:#fff; border-radius:12px; overflow:hidden; box-shadow:0 1px 3px rgba(0,0,0,0.08); border:1px solid #eee; cursor:pointer;">
                            <div style="padding:14px 16px; display:flex; align-items:center; gap:12px;">
                                <div style="width:40px; height:40px; background:#fff; border-radius:10px; display:flex; align-items:center; justify-content:center; border:1px solid #eee;">
                                    <svg viewBox="0 0 24 24" style="width:20px; height:20px; stroke:#666; fill:none; stroke-width:1.5;"><path d="M17 1l4 4-4 4"/><path d="M3 11V9a4 4 0 0 1 4-4h14"/><path d="M7 23l-4-4 4-4"/><path d="M21 13v2a4 4 0 0 1-4 4H3"/></svg>
                                </div>
                                <div style="flex:1;">
                                    <div style="font-size:18px; font-weight:600; color:#333; margin-bottom:2px;">Â¥${data.amount}</div>
                                    <div style="font-size:12px; color:#999;">${escapeHtml(data.desc || 'è½¬è´¦')}</div>
                                </div>
                            </div>
                            <div style="padding:8px 16px; display:flex; justify-content:space-between; align-items:center; border-top:1px solid #eee;">
                                <span style="font-size:11px; color:#999;">${targetHint}</span>
                                <span style="font-size:11px; color:#999;">${data.status === 'received' ? 'å·²æ”¶æ¬¾' : 'å¾…æ”¶æ¬¾'}</span>
                            </div>
                        </div>`;
                    } catch(e) {
                        return content;
                    }
                }
                
                // å¤„ç†å›¾ç‰‡å¡ç‰‡æ¶ˆæ¯ [imgcard:æ–‡å­—å†…å®¹] - ä½¿ç”¨ä¸ç§èŠç›¸åŒçš„æ ·å¼
                if (content.startsWith('[imgcard:')) {
                    const cardText = content.substring(9, content.length - 1).trim();
                    return `<div class="img-card-bubble" data-text="${escapeHtml(cardText)}" data-expanded="false" onclick="showImageCardContent(this)">
                        <div class="img-card-placeholder">
                            <svg class="img-card-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                                <circle cx="8.5" cy="8.5" r="1.5"></circle>
                                <polyline points="21 15 16 10 5 21"></polyline>
                            </svg>
                            <div class="img-card-hint">ç‚¹å‡»æŸ¥çœ‹æ–‡å­—</div>
                        </div>
                    </div>`;
                }
                
                // å¤„ç†å›¾ç‰‡æ¶ˆæ¯ [img:url]
                if (content.startsWith('[img:')) {
                    const imgUrl = content.substring(5, content.length - 1).trim();
                    return `<img src="${imgUrl}" class="chat-image" style="max-width:200px; max-height:200px; border-radius:8px; cursor:pointer;" onclick="showFullImage(this.src)" onerror="this.style.display='none';" />`;
                }
                
                // å¤„ç†è¯­éŸ³æ¶ˆæ¯ [voice:æ–‡å­—å†…å®¹]
                if (content.startsWith('[voice:')) {
                    const voiceText = content.substring(7, content.length - 1).trim();
                    const bgColor = isSelf ? '#ffe4e8' : '#f2f2f7';
                    const barCount = Math.min(Math.max(Math.ceil(voiceText.length / 3), 3), 10);
                    let bars = '';
                    for (let i = 0; i < barCount; i++) {
                        const height = 8 + Math.random() * 12;
                        bars += `<div style="width:3px; height:${height}px; background:#999; border-radius:2px;"></div>`;
                    }
                    return `<div class="voice-bubble" data-text="${escapeHtml(voiceText)}" style="background:${bgColor}; padding:10px 14px; border-radius:18px; cursor:pointer; display:flex; align-items:center; gap:8px; min-width:80px;" onclick="playVoiceBubble(this)">
                        <svg viewBox="0 0 24 24" style="width:16px; height:16px; fill:#666;"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02z"/></svg>
                        <div style="display:flex; align-items:center; gap:2px;">${bars}</div>
                        <span style="font-size:12px; color:#666;">${Math.ceil(voiceText.length / 5)}"</span>
                    </div>`;
                }
                
                // æ™®é€šæ–‡æœ¬æ¶ˆæ¯ï¼Œä½¿ç”¨ renderMessageContent å¤„ç†ï¼ˆæ”¯æŒé“¾æ¥å’Œå›¾ç‰‡URLï¼‰
                return renderMessageContent(content);
            }
            
            let msgIndex = 0;
            for (const msg of history) {
                const currentIndex = msgIndex;
                const msgDiv = document.createElement('div');
                msgDiv.style.marginBottom = '12px';
                msgDiv.className = 'group-message-row';
                msgDiv.dataset.msgIndex = currentIndex;
                
                if (msg.role === 'system') {
                    // ç³»ç»Ÿæ¶ˆæ¯ï¼ˆä¸æ”¯æŒé•¿æŒ‰ï¼‰
                    msgDiv.style.textAlign = 'center';
                    msgDiv.innerHTML = `<span style="background:#fff; color:#999; font-size:12px; padding:4px 12px; border-radius:4px; border:1px solid #ddd;">${msg.content}</span>`;
                    msgIndex++;
                } else if (msg.role === 'user') {
                    // æˆ‘å‘çš„æ¶ˆæ¯
                    msgDiv.style.display = 'flex';
                    msgDiv.style.flexDirection = 'row-reverse';
                    msgDiv.style.alignItems = 'flex-end';
                    msgDiv.style.gap = '8px';
                    
                    const myAvatar = myChar?.avatar || '';
                    const avatarStyle = myAvatar ? `background-image:url(${myAvatar})` : 'background:#ccc';
                    
                    // åˆ¤æ–­æ˜¯å¦æ˜¯ç‰¹æ®Šæ¶ˆæ¯ç±»å‹ï¼ˆä¸éœ€è¦æ°”æ³¡åŒ…è£¹ï¼‰
                    const isSpecialMsg = msg.content.startsWith('[imgcard:') || msg.content.startsWith('[img:') || msg.content.startsWith('[voice:') || msg.type === 'redpacket' || msg.type === 'transfer';
                    const renderedContent = renderGroupMessageContent(msg.content, true, msg.type);
                    
                    msgDiv.classList.add('self');
                    if (isSpecialMsg) {
                        msgDiv.innerHTML = `
                            <div style="width:32px; height:32px; border-radius:50%; ${avatarStyle}; background-size:cover; background-position:center; flex-shrink:0; margin-bottom:2px;"></div>
                            <div style="display:flex; flex-direction:column; align-items:flex-end; max-width:70%;">
                                <div style="font-size:12px; color:#999; margin-bottom:2px;">${myNickname}</div>
                                <div style="display:flex; align-items:flex-end; gap:6px;">
                                    <div style="font-size:10px; color:#999;">${formatChatTime(msg.time)}</div>
                                    <div class="group-msg-content" data-index="${currentIndex}">${renderedContent}</div>
                                </div>
                            </div>
                        `;
                    } else {
                        // æ£€æŸ¥æ˜¯å¦æœ‰å¼•ç”¨
                        const quoteHtml = msg.quote ? `<div class="quoted-message" style="margin-bottom:6px;"><div class="quoted-message-name">${escapeHtml(msg.quote.name)}</div><div class="quoted-message-text">${escapeHtml(msg.quote.content)}</div></div>` : '';
                        
                        msgDiv.innerHTML = `
                            <div style="width:32px; height:32px; border-radius:50%; ${avatarStyle}; background-size:cover; background-position:center; flex-shrink:0; margin-bottom:2px;"></div>
                            <div style="display:flex; flex-direction:column; align-items:flex-end; max-width:70%;">
                                <div style="font-size:12px; color:#999; margin-bottom:2px;">${myNickname}</div>
                                <div style="display:flex; align-items:flex-end; gap:6px;">
                                    <div style="font-size:10px; color:#999;">${formatChatTime(msg.time)}</div>
                                    <div class="group-msg-content" data-index="${currentIndex}" style="background:#ffe4e8; color:#000; padding:6px 10px; border-radius:18px 18px 4px 18px; font-size:15px; line-height:1.5; word-break:break-word;">${quoteHtml}${renderedContent}</div>
                                </div>
                            </div>
                        `;
                    }
                    msgIndex++;
                } else {
                    // ç¾¤æˆå‘˜å‘çš„æ¶ˆæ¯
                    const senderChar = msg.senderId ? memberMap[msg.senderId] : null;
                    // ä¼˜å…ˆä½¿ç”¨ç¾¤æ˜µç§°ï¼Œå…¶æ¬¡ç”¨å¤‡æ³¨åï¼Œæœ€åç”¨åŸå
                    const memberNicknames = group.memberNicknames || {};
                    const senderName = memberNicknames[msg.senderId] || (senderChar ? (senderChar.remark || senderChar.name) : 'æœªçŸ¥æˆå‘˜');
                    const senderAvatar = senderChar?.avatar || '';
                    const avatarStyle = senderAvatar ? `background-image:url(${senderAvatar})` : 'background:#ccc';
                    
                    msgDiv.style.display = 'flex';
                    msgDiv.style.alignItems = 'flex-end';
                    msgDiv.style.gap = '8px';
                    
                    // åˆ¤æ–­æ˜¯å¦æ˜¯ç‰¹æ®Šæ¶ˆæ¯ç±»å‹
                    const isSpecialMsg = msg.content.startsWith('[imgcard:') || msg.content.startsWith('[img:') || msg.content.startsWith('[voice:') || msg.type === 'redpacket' || msg.type === 'transfer';
                    const renderedContent = renderGroupMessageContent(msg.content, false, msg.type);
                    
                    // æ£€æŸ¥æ˜¯å¦æœ‰å¼•ç”¨
                    const quoteHtml = msg.quote ? `<div class="quoted-message" style="margin-bottom:6px;"><div class="quoted-message-name">${escapeHtml(msg.quote.name)}</div><div class="quoted-message-text">${escapeHtml(msg.quote.content)}</div></div>` : '';
                    
                    if (isSpecialMsg) {
                        msgDiv.innerHTML = `
                            <div style="width:32px; height:32px; border-radius:50%; ${avatarStyle}; background-size:cover; background-position:center; flex-shrink:0; margin-bottom:2px;"></div>
                            <div style="display:flex; flex-direction:column; max-width:70%;">
                                <div style="font-size:12px; color:#999; margin-bottom:2px;">${senderName}</div>
                                <div style="display:flex; align-items:flex-end; gap:6px;">
                                    <div class="group-msg-content" data-index="${currentIndex}">${renderedContent}</div>
                                    <div style="font-size:10px; color:#999;">${formatChatTime(msg.time)}</div>
                                </div>
                            </div>
                        `;
                    } else {
                        msgDiv.innerHTML = `
                            <div style="width:32px; height:32px; border-radius:50%; ${avatarStyle}; background-size:cover; background-position:center; flex-shrink:0; margin-bottom:2px;"></div>
                            <div style="display:flex; flex-direction:column; max-width:70%;">
                                <div style="font-size:12px; color:#999; margin-bottom:2px;">${senderName}</div>
                                <div style="display:flex; align-items:flex-end; gap:6px;">
                                    <div class="group-msg-content" data-index="${currentIndex}" style="background:#f2f2f7; color:#000; padding:6px 10px; border-radius:18px 18px 18px 4px; font-size:15px; line-height:1.5; word-break:break-word;">${quoteHtml}${renderedContent}</div>
                                    <div style="font-size:10px; color:#999;">${formatChatTime(msg.time)}</div>
                                </div>
                            </div>
                        `;
                    }
                    msgIndex++;
                }
                
                body.appendChild(msgDiv);
                
                // ç»‘å®šé•¿æŒ‰äº‹ä»¶ï¼ˆéç³»ç»Ÿæ¶ˆæ¯ï¼‰
                if (msg.role !== 'system') {
                    const contentEl = msgDiv.querySelector('.group-msg-content');
                    if (contentEl) {
                        bindGroupMessageEvents(contentEl, currentIndex);
                    }
                }
            }
            
            // æ»šåŠ¨åˆ°åº•éƒ¨
            body.scrollTop = body.scrollHeight;
        }
        
        // ç¾¤èŠæ¶ˆæ¯é•¿æŒ‰äº‹ä»¶ç»‘å®š
        function bindGroupMessageEvents(element, index) {
            const startHandler = (e) => {
                if (isSelectionMode) return;
                isLongPress = false;
                longPressTimer = setTimeout(() => {
                    isLongPress = true;
                    showGroupContextMenu(e, index, element);
                }, 500);
            };

            const cancelHandler = () => {
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
            };
            
            const endHandler = (e) => {
                cancelHandler();
                if (isLongPress) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            };

            element.addEventListener('touchstart', startHandler, {passive: true});
            element.addEventListener('touchmove', cancelHandler, {passive: true});
            element.addEventListener('touchend', endHandler);
            element.addEventListener('mousedown', startHandler);
            element.addEventListener('mousemove', cancelHandler);
            element.addEventListener('mouseup', endHandler);
            element.addEventListener('contextmenu', (e) => e.preventDefault());
        }
        
        // ç¾¤èŠæ¶ˆæ¯å³é”®èœå•
        function showGroupContextMenu(event, index, element) {
            if (navigator.vibrate) navigator.vibrate(50);
            
            activeMsgIndex = index;
            activeGroupMsgIndex = index;
            element.classList.add('active');

            const menu = document.getElementById('msg-context-menu');
            const overlay = document.getElementById('menu-overlay');
            
            let clientX, clientY;
            if (event.touches && event.touches.length > 0) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }

            const winWidth = window.innerWidth;
            const winHeight = window.innerHeight;
            let menuX = clientX;
            let menuY = clientY - 60;

            menu.style.display = 'flex';
            
            if (menuX + menu.offsetWidth > winWidth) {
                menuX = winWidth - menu.offsetWidth - 10;
            }
            if (menuX < 10) {
                menuX = 10;
            }
            if (menuY < 10) {
                menuY = clientY + 10;
            }
            if (menuY + menu.offsetHeight > winHeight) {
                menuY = winHeight - menu.offsetHeight - 10;
            }

            menu.style.left = menuX + 'px';
            menu.style.top = menuY + 'px';
            
            overlay.style.display = 'block';
        }
        
        // ç¾¤èŠæ¶ˆæ¯ç´¢å¼•
        let activeGroupMsgIndex = -1;
        
        // è·å–ç¾¤èŠåˆ—è¡¨
        async function getGroupChats(accountId) {
            try {
                const allGroups = await db.group_chats.where('ownerAccountId').equals(accountId).toArray();
                return allGroups;
            } catch (e) {
                // å¦‚æœè¡¨ä¸å­˜åœ¨ï¼Œè¿”å›ç©ºæ•°ç»„
                return [];
            }
        }
        
        // æ ¼å¼åŒ–èŠå¤©æ—¶é—´
        function formatChatTime(timestamp) {
            if (!timestamp) return '';
            const d = new Date(timestamp);
            const now = new Date();
            if (d.toDateString() === now.toDateString()) {
                return `${d.getHours()}:${d.getMinutes().toString().padStart(2, '0')}`;
            } else {
                return `${d.getMonth() + 1}/${d.getDate()} ${d.getHours()}:${d.getMinutes().toString().padStart(2, '0')}`;
            }
        }

        // --- æ–°çš„å¥½å‹é¡µé¢é€»è¾‘ ---
        async function showNewFriendsPage() {
            document.getElementById('new-friends-page').style.display = 'flex';
            await renderNewFriendsPage();
        }

        function hideNewFriendsPage() {
            document.getElementById('new-friends-page').style.display = 'none';
        }

        async function renderNewFriendsPage() {
            const accountId = getCurrentAccountId();
            if (!accountId) {
                document.getElementById('new-friends-content').innerHTML = `
                    <div style="text-align:center; padding:60px 20px; color:#999;">
                        è¯·å…ˆåˆ‡æ¢åˆ°ä½ çš„è´¦å·ï¼ˆUserç±»å‹è§’è‰²ï¼‰
                    </div>
                `;
                return;
            }
            
            const container = document.getElementById('new-friends-content');
            
            // è·å–æ‰€æœ‰ç›¸å…³çš„å¥½å‹ç”³è¯·ï¼šå‘ç»™æˆ‘çš„ + æˆ‘å‘é€çš„ + è”æœºå¥½å‹ç”³è¯·
            const allRequests = await db.friend_requests.toArray();
            const myRequests = allRequests.filter(req => 
                req.toAccountId === accountId || // è”æœºå¥½å‹ç”³è¯·
                req.toCharId === parseInt(accountId) || 
                req.fromCharId === parseInt(accountId)
            ).sort((a, b) => b.time - a.time);
            
            if (myRequests.length === 0) {
                container.innerHTML = `
                    <div style="text-align:center; padding:60px 20px; color:#999;">
                        <svg class="svg-icon" style="width:48px; height:48px; stroke:#ccc; margin-bottom:10px;" viewBox="0 0 24 24">
                            <path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                            <circle cx="8.5" cy="7" r="4"></circle>
                            <line x1="20" y1="8" x2="20" y2="14"></line>
                            <line x1="23" y1="11" x2="17" y2="11"></line>
                        </svg>
                        <div>æš‚æ— å¥½å‹ç”³è¯·</div>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = '';
            const listDiv = document.createElement('div');
            listDiv.style.width = '100%';
            listDiv.style.background = '#fff';
            
            for (const req of myRequests) {
                // å¤„ç†è”æœºç¾¤èŠé‚€è¯·
                if (req.isGroupInvite && req.groupData) {
                    const groupInvite = req.groupData;
                    const item = document.createElement('div');
                    item.style.display = 'flex';
                    item.style.padding = '12px 16px';
                    item.style.borderBottom = '0.5px solid #f0f0f0';
                    item.style.alignItems = 'center';
                    item.style.gap = '12px';
                    
                    let buttons = '';
                    let statusLabel = '';
                    
                    if (req.status === 'pending') {
                        buttons = `
                            <button onclick="acceptGroupInvite(${req.id})" style="background:var(--ins-pink); color:#fff; border:none; padding:6px 16px; border-radius:4px; font-size:14px; margin-right:8px;">åŒæ„</button>
                            <button onclick="rejectGroupInvite(${req.id})" style="background:#f0f0f0; color:#666; border:none; padding:6px 16px; border-radius:4px; font-size:14px;">æ‹’ç»</button>
                        `;
                    } else if (req.status === 'accepted') {
                        statusLabel = '<div style="color:#999; font-size:12px;">å·²åŠ å…¥</div>';
                    } else {
                        statusLabel = '<div style="color:#999; font-size:12px;">å·²æ‹’ç»</div>';
                    }
                    
                    item.innerHTML = `
                        <div style="width:48px; height:48px; border-radius:4px; background:linear-gradient(135deg, #f093fb 0%, #f5576c 100%); display:flex; align-items:center; justify-content:center; flex-shrink:0; position:relative;">
                            <svg style="width:24px; height:24px; stroke:#fff; fill:none;" viewBox="0 0 24 24"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg>
                            <div style="position:absolute; bottom:-2px; right:-2px; background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius:50%; width:16px; height:16px; display:flex; align-items:center; justify-content:center;">
                                <svg style="width:10px; height:10px; stroke:#fff; fill:none;" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle></svg>
                            </div>
                        </div>
                        <div style="flex:1; min-width:0;">
                            <div style="font-size:16px; font-weight:500; color:#333; margin-bottom:4px;">
                                ç¾¤èŠé‚€è¯·
                                <span style="font-size:11px; color:#f5576c; margin-left:6px;">è”æœºç¾¤èŠ</span>
                            </div>
                            <div style="font-size:12px; color:#666; line-height:1.5;">${groupInvite.inviter_name} é‚€è¯·ä½ åŠ å…¥ã€Œ${groupInvite.group_name}ã€</div>
                        </div>
                        <div style="display:flex; align-items:center; flex-shrink:0;">
                            ${buttons}${statusLabel}
                        </div>
                    `;
                    listDiv.appendChild(item);
                    continue;
                }
                
                // å¤„ç†è”æœºå¥½å‹ç”³è¯·
                if (req.isOnline && req.onlineData) {
                    const onlineReq = req.onlineData;
                    const item = document.createElement('div');
                    item.style.display = 'flex';
                    item.style.padding = '12px 16px';
                    item.style.borderBottom = '0.5px solid #f0f0f0';
                    item.style.alignItems = 'center';
                    item.style.gap = '12px';
                    
                    const avatarStyle = onlineReq.from_avatar ? `background-image:url(${onlineReq.from_avatar})` : 'background-color:#eee';
                    
                    let buttons = '';
                    let statusLabel = '';
                    
                    if (req.status === 'pending') {
                        buttons = `
                            <button onclick="acceptFriendRequest(${req.id})" style="background:var(--ins-pink); color:#fff; border:none; padding:6px 16px; border-radius:4px; font-size:14px; margin-right:8px;">æ¥å—</button>
                            <button onclick="rejectFriendRequest(${req.id})" style="background:#f0f0f0; color:#666; border:none; padding:6px 16px; border-radius:4px; font-size:14px;">æ‹’ç»</button>
                        `;
                    } else if (req.status === 'accepted') {
                        statusLabel = '<div style="color:#999; font-size:12px;">å·²æ·»åŠ </div>';
                    } else {
                        statusLabel = '<div style="color:#999; font-size:12px;">å·²æ‹’ç»</div>';
                    }
                    
                    item.innerHTML = `
                        <div style="width:48px; height:48px; border-radius:4px; ${avatarStyle}; background-size:cover; background-position:center; flex-shrink:0; position:relative;">
                            <div style="position:absolute; bottom:-2px; right:-2px; background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius:50%; width:16px; height:16px; display:flex; align-items:center; justify-content:center;">
                                <svg style="width:10px; height:10px; stroke:#fff; fill:none;" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle></svg>
                            </div>
                        </div>
                        <div style="flex:1; min-width:0;">
                            <div style="font-size:16px; font-weight:500; color:#333; margin-bottom:4px;">
                                ${onlineReq.from_nickname || onlineReq.from_wx_account}
                                <span style="font-size:11px; color:#667eea; margin-left:6px;">è”æœº</span>
                            </div>
                            <div style="font-size:12px; color:#666; line-height:1.5; white-space:pre-line; word-break:break-word;">${onlineReq.message || 'è¯·æ±‚æ·»åŠ ä½ ä¸ºå¥½å‹'}</div>
                        </div>
                        <div style="display:flex; align-items:center; flex-shrink:0;">
                            ${buttons}${statusLabel}
                        </div>
                    `;
                    listDiv.appendChild(item);
                    continue;
                }
                
                // å¤„ç†æœ¬åœ°å¥½å‹ç”³è¯·
                const isReceived = req.toCharId === parseInt(accountId);
                const relatedCharId = isReceived ? req.fromCharId : req.toCharId;
                const relatedChar = await db.characters.get(relatedCharId);
                if (!relatedChar) continue;
                
                const item = document.createElement('div');
                item.style.display = 'flex';
                item.style.padding = '12px 16px';
                item.style.borderBottom = '0.5px solid #f0f0f0';
                item.style.alignItems = 'center';
                item.style.gap = '12px';
                
                const avatarStyle = relatedChar.avatar ? `background-image:url(${relatedChar.avatar})` : 'background-color:#eee';
                
                let buttons = '';
                let statusLabel = '';
                
                if (isReceived) {
                    // æ”¶åˆ°çš„ç”³è¯·
                    if (req.status === 'pending') {
                        buttons = `
                            <button onclick="acceptFriendRequest(${req.id})" style="background:var(--ins-pink); color:#fff; border:none; padding:6px 16px; border-radius:4px; font-size:14px; margin-right:8px;">æ¥å—</button>
                            <button onclick="rejectFriendRequest(${req.id})" style="background:#f0f0f0; color:#666; border:none; padding:6px 16px; border-radius:4px; font-size:14px;">æ‹’ç»</button>
                        `;
                    } else if (req.status === 'accepted') {
                        statusLabel = '<div style="color:#999; font-size:12px;">å·²æ·»åŠ </div>';
                    } else {
                        statusLabel = '<div style="color:#999; font-size:12px;">å·²æ‹’ç»</div>';
                    }
                } else {
                    // å‘é€çš„ç”³è¯·
                    if (req.status === 'pending') {
                        statusLabel = '<div style="color:#999; font-size:12px;">ç­‰å¾…éªŒè¯</div>';
                    } else if (req.status === 'accepted') {
                        statusLabel = '<div style="color:#07c160; font-size:12px;">å·²æ¥å—</div>';
                    } else {
                        statusLabel = '<div style="color:#999; font-size:12px;">å·²æ‹’ç»</div>';
                    }
                }
                
                const messageText = isReceived ? (req.message || 'è¯·æ±‚æ·»åŠ ä½ ä¸ºå¥½å‹') : `ä½ å·²å‘é€å¥½å‹ç”³è¯·`;
                
                item.innerHTML = `
                    <div style="width:48px; height:48px; border-radius:4px; ${avatarStyle}; background-size:cover; background-position:center; flex-shrink:0;"></div>
                    <div style="flex:1; min-width:0;">
                        <div style="font-size:16px; font-weight:500; color:#333; margin-bottom:4px;">${relatedChar.name}</div>
                        <div style="font-size:12px; color:#666; line-height:1.5; white-space:pre-line; word-break:break-word;">${messageText}</div>
                    </div>
                    <div style="display:flex; align-items:center; flex-shrink:0;">
                        ${buttons}${statusLabel}
                    </div>
                `;
                listDiv.appendChild(item);
            }
            
            container.appendChild(listDiv);
        }

        async function acceptFriendRequest(requestId) {
            const request = await db.friend_requests.get(requestId);
            if (!request) return;
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯è”æœºå¥½å‹ç”³è¯·
            if (request.isOnline && request.onlineData) {
                // è”æœºå¥½å‹ç”³è¯· - å‘é€åˆ°æœåŠ¡å™¨
                if (!onlineConnected || !onlineUserData) {
                    alert('è¯·å…ˆè¿æ¥æœåŠ¡å™¨å¹¶ç™»å½•');
                    return;
                }
                
                const onlineReq = request.onlineData;
                // æ‰¾åˆ°è¦æ¥å—ç”³è¯·çš„è§’è‰²ï¼ˆè¢«ç”³è¯·æ–¹ï¼‰
                const myChars = await db.characters.where('type').equals('user').toArray();
                const myChar = myChars.find(c => c.identity?.account === onlineReq.to_wx_account) ||
                               myChars.find(c => onlineCharacters.some(oc => oc.wx_account === c.identity?.account));
                
                if (!myChar || !myChar.identity?.account) {
                    alert('è¯·å…ˆä¸Šçº¿ä¸€ä¸ªè§’è‰²');
                    return;
                }
                
                onlineSocket.send(JSON.stringify({
                    type: 'accept_friend_request',
                    request_id: onlineReq.id,
                    my_wx_account: myChar.identity.account
                }));
                
                // æ›´æ–°æœ¬åœ°çŠ¶æ€
                request.status = 'accepted';
                await db.friend_requests.put(request);
                
                await renderNewFriendsPage();
                return;
            }
            
            // æœ¬åœ°å¥½å‹ç”³è¯·
            const char = await db.characters.get(request.fromCharId);
            if (!char) return;
            
            const accountId = getCurrentAccountId();
            
            // æ›´æ–°å¥½å‹çŠ¶æ€
            await setFriendStatus(char, accountId, 'friend');
            
            // æ›´æ–°ç”³è¯·çŠ¶æ€
            request.status = 'accepted';
            await db.friend_requests.put(request);
            
            // è‡ªåŠ¨å‘é€"æˆ‘å·²åŒæ„äº†ä½ çš„å¥½å‹ç”³è¯·"æ¶ˆæ¯
            let history = getChatHistory(char, accountId);
            const acceptMessage = {
                role: 'user',
                content: 'æˆ‘å·²åŒæ„äº†ä½ çš„å¥½å‹ç”³è¯·',
                time: Date.now()
            };
            history.push(acceptMessage);
            await setChatHistory(char, accountId, history);
            
            // åˆ·æ–°é¡µé¢
            await renderNewFriendsPage();
            
            // å¦‚æœå½“å‰åœ¨é€šè®¯å½•é¡µé¢ï¼Œä¹Ÿåˆ·æ–°é€šè®¯å½•
            const activeTab = document.querySelector('.wechat-tab-item.active');
            if (activeTab && activeTab.innerText.includes('é€šè®¯å½•')) {
                await renderContactList(document.getElementById('wechat-content'));
            }
            
            // å¦‚æœå½“å‰æ­£åœ¨å’Œè¿™ä¸ªè§’è‰²èŠå¤©ï¼Œåˆ·æ–°èŠå¤©çª—å£
            if (currentChatCharId === char.id) {
                await renderChatBody(char);
            }
            
            alert(`å·²æ·»åŠ  ${char.name} ä¸ºå¥½å‹`);
        }

        async function rejectFriendRequest(requestId) {
            const request = await db.friend_requests.get(requestId);
            if (!request) return;
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯è”æœºå¥½å‹ç”³è¯·
            if (request.isOnline && request.onlineData) {
                // è”æœºå¥½å‹ç”³è¯· - å‘é€åˆ°æœåŠ¡å™¨
                if (onlineConnected && onlineUserData) {
                    const onlineReq = request.onlineData;
                    const myChars = await db.characters.where('type').equals('user').toArray();
                    const myChar = myChars.find(c => c.identity?.account === onlineReq.to_wx_account) ||
                                   myChars.find(c => onlineCharacters.some(oc => oc.wx_account === c.identity?.account));
                    
                    if (myChar?.identity?.account) {
                        onlineSocket.send(JSON.stringify({
                            type: 'reject_friend_request',
                            request_id: onlineReq.id,
                            my_wx_account: myChar.identity.account
                        }));
                    }
                }
            }
            
            // æ›´æ–°ç”³è¯·çŠ¶æ€
            request.status = 'rejected';
            await db.friend_requests.put(request);
            
            // åˆ·æ–°é¡µé¢
            await renderNewFriendsPage();
        }

        // æ¥å—ç¾¤èŠé‚€è¯· - å¼¹å‡ºé€‰æ‹©è§’è‰²çš„å¼¹çª—
        async function acceptGroupInvite(requestId) {
            const request = await db.friend_requests.get(requestId);
            if (!request || !request.isGroupInvite || !request.groupData) return;
            
            if (!onlineConnected || !onlineUserData) {
                alert('è¯·å…ˆè¿æ¥æœåŠ¡å™¨å¹¶ç™»å½•');
                return;
            }
            
            const myWx = getMyOnlineWxAccount();
            if (!myWx) {
                alert('è¯·å…ˆä¸Šçº¿ä¸€ä¸ªè§’è‰²');
                return;
            }
            
            // æ˜¾ç¤ºé€‰æ‹©è§’è‰²çš„å¼¹çª—
            showJoinGroupWithCharModal(requestId, request.groupData);
        }

        // æ˜¾ç¤ºåŠ å…¥ç¾¤èŠå¹¶é€‰æ‹©è§’è‰²çš„å¼¹çª—
        async function showJoinGroupWithCharModal(requestId, groupData) {
            // è·å–æ‰€æœ‰å¯ç”¨çš„è§’è‰²ï¼ˆéUserç±»å‹å’Œéè”æœºå¥½å‹ï¼‰
            const chars = await db.characters.toArray();
            const availableChars = chars.filter(c => c.type !== 'user' && c.type !== 'online_friend');
            
            const modal = document.createElement('div');
            modal.id = 'join-group-char-modal';
            modal.style.cssText = `position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); z-index:10000; display:flex; align-items:center; justify-content:center;`;
            
            modal.innerHTML = `
                <div style="background:#fff; border-radius:16px; padding:24px; width:85%; max-width:360px;">
                    <h3 style="margin:0 0 16px 0; text-align:center; font-size:18px;">åŠ å…¥ã€Œ${groupData.group_name}ã€</h3>
                    
                    <div style="margin-bottom:16px;">
                        <div style="font-size:13px; color:#666; margin-bottom:8px;">é€‰æ‹©è¦å¸¦å…¥ç¾¤èŠçš„è§’è‰²ï¼š</div>
                        <select id="join-group-char-select-modal" style="width:100%; padding:12px; border:1px solid #ddd; border-radius:8px; font-size:14px;">
                            <option value="">ä¸å¸¦è§’è‰²</option>
                            ${availableChars.map(c => `<option value="${c.id}">${c.name}</option>`).join('')}
                        </select>
                    </div>
                    
                    <div style="font-size:12px; color:#999; margin-bottom:20px; line-height:1.5;">
                        å¸¦å…¥è§’è‰²åï¼Œä½ å¯ä»¥åœ¨ç¾¤èŠä¸­è®©è¯¥è§’è‰²å‘è¨€ï¼ˆè°ƒç”¨AIï¼‰
                    </div>
                    
                    <div style="display:flex; gap:12px;">
                        <button onclick="this.closest('#join-group-char-modal').remove()" style="flex:1; padding:12px; background:#f0f0f0; color:#666; border:none; border-radius:8px; font-size:15px; cursor:pointer;">å–æ¶ˆ</button>
                        <button onclick="doAcceptGroupInvite(${requestId}, '${groupData.group_id}')" style="flex:1; padding:12px; background:var(--ins-pink); color:#fff; border:none; border-radius:8px; font-size:15px; cursor:pointer;">åŠ å…¥ç¾¤èŠ</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }

        // æ‰§è¡Œæ¥å—ç¾¤èŠé‚€è¯·
        async function doAcceptGroupInvite(requestId, groupId) {
            const charSelect = document.getElementById('join-group-char-select-modal');
            const charId = charSelect?.value;
            
            let myChar = null;
            if (charId) {
                const char = await db.characters.get(parseInt(charId));
                if (char) {
                    myChar = {
                        name: char.name,
                        avatar: char.avatar || '',
                        desc: char.description?.substring(0, 200) || ''
                    };
                }
            }
            
            const myWx = getMyOnlineWxAccount();
            if (!myWx) {
                alert('è¯·å…ˆä¸Šçº¿ä¸€ä¸ªè§’è‰²');
                return;
            }
            
            // å‘é€åŠ å…¥ç¾¤èŠè¯·æ±‚
            onlineSocket.send(JSON.stringify({
                type: 'join_online_group',
                group_id: groupId,
                my_wx_account: myWx,
                my_character: myChar
            }));
            
            // æ›´æ–°æœ¬åœ°çŠ¶æ€
            const request = await db.friend_requests.get(requestId);
            if (request) {
                request.status = 'accepted';
                await db.friend_requests.put(request);
            }
            
            // å…³é—­å¼¹çª—å¹¶åˆ·æ–°é¡µé¢
            document.getElementById('join-group-char-modal')?.remove();
            await renderNewFriendsPage();
        }

        // æ‹’ç»ç¾¤èŠé‚€è¯·
        async function rejectGroupInvite(requestId) {
            const request = await db.friend_requests.get(requestId);
            if (!request || !request.isGroupInvite) return;
            
            // æ›´æ–°çŠ¶æ€
            request.status = 'rejected';
            await db.friend_requests.put(request);
            
            // åˆ·æ–°é¡µé¢
            await renderNewFriendsPage();
        }

        async function deleteFriendConfirm() {
            if (!currentChatCharId) return;
            
            const char = await db.characters.get(currentChatCharId);
            if (!char) return;
            
            if (confirm(`ç¡®å®šè¦åˆ é™¤å¥½å‹ ${char.name} å—ï¼Ÿåˆ é™¤åå°†æ— æ³•ç›´æ¥å‘é€æ¶ˆæ¯ï¼Œéœ€è¦é‡æ–°å‘é€å¥½å‹ç”³è¯·ã€‚`)) {
                await deleteFriendAction(currentChatCharId);
            }
        }

        async function blockFriendConfirm() {
            if (!currentChatCharId) return;
            
            const char = await db.characters.get(currentChatCharId);
            if (!char) return;
            
            if (confirm(`ç¡®å®šè¦æ‹‰é»‘å¥½å‹ ${char.name} å—ï¼Ÿæ‹‰é»‘åå¯¹æ–¹å°†æ— æ³•å‘é€å¥½å‹ç”³è¯·ï¼Œä½†åœ¨å¿«è¿›æ—¶é—´æ—¶å¯èƒ½ä¼šå°è¯•è”ç³»ä½ ã€‚`)) {
                await blockFriendAction(currentChatCharId);
            }
        }

        async function blockFriendAction(charId) {
            const char = await db.characters.get(charId);
            if (!char) return;
            
            const accountId = getCurrentAccountId();
            
            // å°†å¥½å‹çŠ¶æ€æ”¹ä¸ºæ‹‰é»‘
            await setFriendStatus(char, accountId, 'blocked');
            
            // åˆå§‹åŒ–ç­‰å¾…å¥½å‹ç”³è¯·çš„è®¾ç½®ï¼ˆä¸åˆ é™¤å¥½å‹é€»è¾‘ç›¸åŒï¼‰
            if (!char.wait_friend_settings) {
                char.wait_friend_settings = {};
            }
            if (!char.wait_friend_settings[accountId]) {
                char.wait_friend_settings[accountId] = {
                    enabled: false,
                    interval: 60, // é»˜è®¤60åˆ†é’Ÿ
                    lastCheckTime: Date.now(),
                    nextCheckTime: null
                };
            }
            await db.characters.put(char);
            
            // å…³é—­èŠå¤©è¯¦æƒ…é¡µä½†ä¿æŒèŠå¤©çª—å£æ‰“å¼€ï¼Œæ˜¾ç¤ºç­‰å¾…ç•Œé¢
            hideChatDetail();
            
            // åˆ·æ–°èŠå¤©çª—å£æ˜¾ç¤ºç­‰å¾…ç•Œé¢
            if (currentChatCharId === charId) {
                await renderChatBody(char);
            }
            
            // åˆ·æ–°å¾®ä¿¡é¡µé¢
            const activeTab = document.querySelector('.wechat-tab-item.active');
            if (activeTab) {
                const tabIndex = Array.from(document.querySelectorAll('.wechat-tab-item')).indexOf(activeTab);
                switchWechatTab(tabIndex);
            }
            
            alert(`å·²æ‹‰é»‘å¥½å‹ ${char.name}ï¼ŒèŠå¤©è®°å½•å·²ä¿ç•™`);
        }

        async function deleteFriendAction(charId) {
            const char = await db.characters.get(charId);
            if (!char) return;
            
            const accountId = getCurrentAccountId();
            
            // å°†å¥½å‹çŠ¶æ€æ”¹ä¸ºé™Œç”Ÿäººï¼ˆä¸åˆ é™¤èŠå¤©è®°å½•ï¼‰
            await setFriendStatus(char, accountId, 'deleted');
            
            // åˆå§‹åŒ–ç­‰å¾…å¥½å‹ç”³è¯·çš„è®¾ç½®
            if (!char.wait_friend_settings) {
                char.wait_friend_settings = {};
            }
            if (!char.wait_friend_settings[accountId]) {
                char.wait_friend_settings[accountId] = {
                    enabled: false,
                    interval: 60, // é»˜è®¤60åˆ†é’Ÿ
                    lastCheckTime: Date.now(),
                    nextCheckTime: null
                };
            }
            await db.characters.put(char);
            
            // å…³é—­èŠå¤©è¯¦æƒ…é¡µä½†ä¿æŒèŠå¤©çª—å£æ‰“å¼€ï¼Œæ˜¾ç¤ºç­‰å¾…ç•Œé¢
            hideChatDetail();
            
            // åˆ·æ–°èŠå¤©çª—å£æ˜¾ç¤ºç­‰å¾…ç•Œé¢
            if (currentChatCharId === charId) {
                await renderChatBody(char);
            }
            
            // åˆ·æ–°å¾®ä¿¡é¡µé¢
            const activeTab = document.querySelector('.wechat-tab-item.active');
            if (activeTab) {
                const tabIndex = Array.from(document.querySelectorAll('.wechat-tab-item')).indexOf(activeTab);
                switchWechatTab(tabIndex);
            }
            
            alert(`å·²åˆ é™¤å¥½å‹ ${char.name}ï¼ŒèŠå¤©è®°å½•å·²ä¿ç•™`);
        }

        async function sendFriendRequestTo(charId, message) {
            const accountId = getCurrentAccountId();
            if (!accountId) {
                alert('è¯·å…ˆåˆ‡æ¢åˆ°ä½ çš„è´¦å·ï¼ˆUserç±»å‹è§’è‰²ï¼‰');
                return;
            }
            
            const targetChar = await db.characters.get(charId);
            if (!targetChar) return;
            
            // æ£€æŸ¥è§’è‰²æ˜¯å¦è¢«ç”¨æˆ·æ‹‰é»‘
            const status = getFriendStatus(targetChar, accountId);
            if (status === 'blocked') {
                alert('è¯¥è§’è‰²å·²è¢«ä½ æ‹‰é»‘ï¼Œæ— æ³•å‘é€å¥½å‹ç”³è¯·');
                return;
            }
            
            // æ£€æŸ¥æ˜¯å¦å·²ç»å‘é€è¿‡ç”³è¯·
            const existingRequest = await db.friend_requests
                .where({fromCharId: parseInt(accountId), toCharId: charId, status: 'pending'})
                .first();
            
            if (existingRequest) {
                alert('å·²å‘é€è¿‡å¥½å‹ç”³è¯·ï¼Œè¯·ç­‰å¾…å¯¹æ–¹å¤„ç†');
                return;
            }
            
            // åˆ›å»ºå¥½å‹ç”³è¯·è®°å½•
            const requestId = await db.friend_requests.add({
                fromCharId: parseInt(accountId),
                toCharId: charId,
                message: message || 'è¯·æ±‚æ·»åŠ ä½ ä¸ºå¥½å‹',
                status: 'pending',
                time: Date.now()
            });
            
            alert(`å¥½å‹ç”³è¯·å·²å‘é€ç»™ ${targetChar.name}\n\nå¯¹æ–¹éœ€è¦åœ¨"æ–°çš„å¥½å‹"ä¸­æ¥å—ç”³è¯·ï¼Œæˆ–è€…ä½ å¯ä»¥è®©AIè‡ªåŠ¨åˆ¤æ–­æ˜¯å¦æ¥å—ã€‚`);
            
            // è¯¢é—®æ˜¯å¦è®©AIè‡ªåŠ¨åˆ¤æ–­
            if (targetChar.type !== 'user') {
                // æ£€æŸ¥APIå¯†é’¥ï¼ˆä»æ•°æ®åº“è·å–ï¼Œå’Œæ­£å¸¸èŠå¤©ä¸€æ ·ï¼‰
                const apiKeyData = await db.dexiData.get('aiApiKey');
                const apiKey = apiKeyData?.value ? apiKeyData.value.trim() : '';
                
                if (!apiKey) {
                    const configNow = confirm('âš ï¸ æœªé…ç½®AIå¯†é’¥\n\nAIè‡ªåŠ¨åˆ¤æ–­éœ€è¦é…ç½®APIå¯†é’¥ã€‚\n\næ˜¯å¦ç°åœ¨å»é…ç½®ï¼Ÿ\nï¼ˆç‚¹å‡»å–æ¶ˆåˆ™éœ€è¦åœ¨"æ–°çš„å¥½å‹"ä¸­æ‰‹åŠ¨æ¥å—ï¼‰');
                    if (configNow) {
                        document.getElementById('setting-page').style.display = 'flex';
                    }
                    return;
                }
                
                const useAI = confirm('æ˜¯å¦è®©AIæ ¹æ®è§’è‰²æ€§æ ¼è‡ªåŠ¨åˆ¤æ–­æ˜¯å¦æ¥å—ï¼Ÿ\n\nç‚¹å‡»"ç¡®å®š"ä½¿ç”¨AIåˆ¤æ–­ï¼Œç‚¹å‡»"å–æ¶ˆ"éœ€è¦æ‰‹åŠ¨åœ¨"æ–°çš„å¥½å‹"ä¸­æ¥å—ã€‚');
                
                if (useAI) {
                    // æ˜¾ç¤ºåŠ è½½æç¤º
                    const loadingDiv = document.createElement('div');
                    loadingDiv.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.7); display:flex; flex-direction:column; align-items:center; justify-content:center; z-index:9999;';
                    loadingDiv.innerHTML = `
                        <div style="background:#fff; padding:30px 40px; border-radius:16px; text-align:center; box-shadow:0 10px 40px rgba(0,0,0,0.3);">
                            <div style="width:50px; height:50px; border:4px solid #f3f3f3; border-top:4px solid var(--ins-pink); border-radius:50%; margin:0 auto 20px; animation:spin 1s linear infinite;"></div>
                            <div style="font-size:18px; font-weight:600; color:#333; margin-bottom:8px;">AIåˆ¤æ–­ä¸­...</div>
                            <div style="font-size:14px; color:#999;">${targetChar.name} æ­£åœ¨è€ƒè™‘æ˜¯å¦æ¥å—</div>
                        </div>
                    `;
                    document.body.appendChild(loadingDiv);
                    
                    try {
                        // è°ƒç”¨AIåˆ¤æ–­æ˜¯å¦æ¥å—å¥½å‹ç”³è¯·
                        const willAccept = await aiDecideAcceptFriendRequest(targetChar, accountId, message);
                        
                        document.body.removeChild(loadingDiv);
                        
                        if (willAccept) {
                            // AIå†³å®šæ¥å—
                            const request = await db.friend_requests.get(requestId);
                            request.status = 'accepted';
                            await db.friend_requests.put(request);
                            
                            // æ·»åŠ ä¸ºå¥½å‹
                            await setFriendStatus(targetChar, accountId, 'friend');
                            
                            alert(`âœ… ${targetChar.name} æ¥å—äº†ä½ çš„å¥½å‹ç”³è¯·ï¼`);
                            
                            // åˆ·æ–°ç•Œé¢
                            const activeTab = document.querySelector('.wechat-tab-item.active');
                            if (activeTab) {
                                const tabIndex = Array.from(document.querySelectorAll('.wechat-tab-item')).indexOf(activeTab);
                                switchWechatTab(tabIndex);
                            }
                        } else {
                            // AIå†³å®šæ‹’ç»
                            alert(`âŒ ${targetChar.name} æ‹’ç»äº†ä½ çš„å¥½å‹ç”³è¯·ã€‚`);
                        }
                    } catch (error) {
                        if (document.body.contains(loadingDiv)) {
                            document.body.removeChild(loadingDiv);
                        }
                        alert('AIåˆ¤æ–­å¤±è´¥ï¼š' + error.message + '\n\nè¯·å‰å¾€"æ–°çš„å¥½å‹"ä¸­æ‰‹åŠ¨å¤„ç†ã€‚');
                    }
                }
            }
        }
        
        // AIåˆ¤æ–­æ˜¯å¦æ¥å—å¥½å‹ç”³è¯·
        async function aiDecideAcceptFriendRequest(char, accountId, requestMessage) {
            try {
                // ä»æ•°æ®åº“è·å–APIé…ç½®ï¼ˆå’Œæ­£å¸¸èŠå¤©ä¸€æ ·ï¼‰
                const urlData = await db.dexiData.get('aiBaseUrl');
                const keyData = await db.dexiData.get('aiApiKey');
                const modelData = await db.dexiData.get('aiCurrentModel');
                
                const apiUrl = urlData?.value || 'https://api.openai.com';
                const apiKey = keyData?.value ? keyData.value.trim() : '';
                const model = modelData?.value || 'gpt-4';
                
                if (!apiKey) {
                    throw new Error('æœªé…ç½®APIå¯†é’¥');
                }
                
                const myChar = await db.characters.get(parseInt(accountId));
                const myName = myChar?.name || 'ç”¨æˆ·';
                
                // è·å–èŠå¤©å†å²
                const history = getChatHistory(char, accountId);
                const recentMessages = history.slice(-10).map(msg => {
                    const role = msg.role === 'user' ? myName : char.name;
                    return `${role}: ${msg.content}`;
                }).join('\n');
                
                const prompt = `ä½ æ˜¯ ${char.name}ã€‚

ä½ çš„äººè®¾ï¼š
${char.description || char.desc || 'ï¼ˆæ— è¯¦ç»†äººè®¾ï¼‰'}

${myName} å‘ä½ å‘é€äº†å¥½å‹ç”³è¯·ï¼Œç”³è¯·æ¶ˆæ¯æ˜¯ï¼š
"${requestMessage}"

${history.length > 0 ? `ä½ ä»¬ä¹‹å‰çš„èŠå¤©è®°å½•ï¼š\n${recentMessages}` : 'ä½ ä»¬ä¹‹å‰æ²¡æœ‰èŠè¿‡å¤©ã€‚'}

æ ¹æ®ä½ çš„æ€§æ ¼ã€ä¸ ${myName} çš„å…³ç³»ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰ï¼Œä»¥åŠç”³è¯·æ¶ˆæ¯çš„å†…å®¹ï¼Œè¯·åˆ¤æ–­ä½ æ˜¯å¦ä¼šæ¥å—è¿™ä¸ªå¥½å‹ç”³è¯·ã€‚

è¯·åªå›å¤"æ¥å—"æˆ–"æ‹’ç»"ï¼Œä¸è¦æœ‰ä»»ä½•å…¶ä»–å†…å®¹ã€‚`;

                const response = await fetch(`${apiUrl}/v1/chat/completions`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: model,
                        messages: [
                            { role: 'system', content: 'ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„è§’è‰²æ‰®æ¼”åŠ©æ‰‹ã€‚' },
                            { role: 'user', content: prompt }
                        ],
                        temperature: 0.7,
                        max_tokens: 50
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`APIé”™è¯¯: ${response.status}`);
                }
                
                const data = await response.json();
                const answer = data.choices[0].message.content.trim();
                
                console.log('[AIå†³å®š] ' + char.name + ' çš„å›ç­”:', answer);
                
                return answer.includes('æ¥å—') || answer.includes('åŒæ„');
            } catch (error) {
                console.error('[AIå†³å®š] é”™è¯¯:', error);
                throw error;
            }
        }
        
        async function showAddFriendToCurrentChat() {
            if (!currentChatCharId) return;
            
            const char = await db.characters.get(currentChatCharId);
            if (!char) return;
            
            const message = prompt(`å‘é€å¥½å‹ç”³è¯·ç»™ ${char.name}\n\nè¯·è¾“å…¥ç”³è¯·ç†ç”±ï¼ˆå¯é€‰ï¼‰ï¼š`, 'æˆ‘æ˜¯' + (await getCurrentUserName()));
            if (message !== null) {
                await sendFriendRequestTo(currentChatCharId, message);
            }
        }
        
        // ===== ç­‰å¾…å¥½å‹ç”³è¯·ç›¸å…³åŠŸèƒ½ =====
        
        // å¼€å¯/å…³é—­è‡ªåŠ¨æ£€æµ‹
        async function toggleWaitFriendCheck(charId) {
            const char = await db.characters.get(charId);
            if (!char) return;
            
            const accountId = getCurrentAccountId();
            if (!char.wait_friend_settings) char.wait_friend_settings = {};
            if (!char.wait_friend_settings[accountId]) {
                char.wait_friend_settings[accountId] = {
                    enabled: false,
                    interval: 60,
                    lastCheckTime: Date.now(),
                    nextCheckTime: null
                };
            }
            
            const settings = char.wait_friend_settings[accountId];
            settings.enabled = !settings.enabled;
            
            if (settings.enabled) {
                // å¯ç”¨æ—¶è®¾ç½®ä¸‹æ¬¡æ£€æµ‹æ—¶é—´
                settings.lastCheckTime = Date.now();
                settings.nextCheckTime = Date.now() + settings.interval * 60 * 1000;
                startWaitFriendTimer();
            } else {
                settings.nextCheckTime = null;
            }
            
            await db.characters.put(char);
            
            // åˆ·æ–°ç•Œé¢
            if (currentChatCharId === charId) {
                await renderChatBody(char);
            }
        }
        
        // ä¿å­˜æ£€æµ‹é—´éš”
        async function saveWaitFriendInterval(charId) {
            const char = await db.characters.get(charId);
            if (!char) return;
            
            const accountId = getCurrentAccountId();
            const intervalInput = document.getElementById('wait-friend-interval');
            const interval = parseInt(intervalInput.value) || 60;
            
            if (!char.wait_friend_settings) char.wait_friend_settings = {};
            if (!char.wait_friend_settings[accountId]) {
                char.wait_friend_settings[accountId] = {
                    enabled: false,
                    interval: interval,
                    lastCheckTime: Date.now(),
                    nextCheckTime: null
                };
            }
            
            char.wait_friend_settings[accountId].interval = interval;
            
            // å¦‚æœå·²å¯ç”¨ï¼Œé‡æ–°è®¡ç®—ä¸‹æ¬¡æ£€æµ‹æ—¶é—´
            if (char.wait_friend_settings[accountId].enabled) {
                char.wait_friend_settings[accountId].nextCheckTime = 
                    char.wait_friend_settings[accountId].lastCheckTime + interval * 60 * 1000;
            }
            
            await db.characters.put(char);
            
            // åˆ·æ–°ç•Œé¢
            if (currentChatCharId === charId) {
                await renderChatBody(char);
            }
        }
        
        // å¿«è¿›æ£€æµ‹
        async function fastForwardCheck(charId) {
            // æ£€æŸ¥APIå¯†é’¥ï¼ˆä»æ•°æ®åº“è·å–ï¼Œå’Œæ­£å¸¸èŠå¤©ä¸€æ ·ï¼‰
            const apiKeyData = await db.dexiData.get('aiApiKey');
            const apiKey = apiKeyData?.value ? apiKeyData.value.trim() : '';
            
            if (!apiKey) {
                const configNow = confirm('âš ï¸ æœªé…ç½®AIå¯†é’¥\n\nå¿«è¿›æ£€æŸ¥éœ€è¦è°ƒç”¨AIæ¥åˆ¤æ–­è§’è‰²æ˜¯å¦ä¼šå‘é€å¥½å‹ç”³è¯·ã€‚\n\næ˜¯å¦ç°åœ¨å»é…ç½®APIå¯†é’¥ï¼Ÿ');
                if (configNow) {
                    // æ‰“å¼€è®¾ç½®é¡µé¢
                    document.getElementById('setting-page').style.display = 'flex';
                }
                return;
            }
            
            const minutes = prompt('å¿«è¿›å¤šå°‘åˆ†é’Ÿï¼Ÿ', '60');
            if (minutes === null) return;
            
            const minutesNum = parseInt(minutes);
            if (isNaN(minutesNum) || minutesNum <= 0) {
                alert('è¯·è¾“å…¥æœ‰æ•ˆçš„åˆ†é’Ÿæ•°');
                return;
            }
            
            await checkCharacterSendFriendRequest(charId, minutesNum);
        }
        
        // æ‹‰é»‘åçš„å¿«è¿›æ£€æŸ¥ï¼ˆç”Ÿæˆç”µè¯è®°å½•å’ŒçŸ­ä¿¡ï¼‰
        async function fastForwardBlockedCheck(charId) {
            // æ£€æŸ¥APIå¯†é’¥ï¼ˆä»æ•°æ®åº“è·å–ï¼Œå’Œæ­£å¸¸èŠå¤©ä¸€æ ·ï¼‰
            const apiKeyData = await db.dexiData.get('aiApiKey');
            const apiKey = apiKeyData?.value ? apiKeyData.value.trim() : '';
            
            if (!apiKey) {
                const configNow = confirm('âš ï¸ æœªé…ç½®AIå¯†é’¥\n\næ‹‰é»‘å¿«è¿›éœ€è¦è°ƒç”¨AIæ¥åˆ¤æ–­è§’è‰²æ˜¯å¦ä¼šè”ç³»ä½ ã€‚\n\næ˜¯å¦ç°åœ¨å»é…ç½®APIå¯†é’¥ï¼Ÿ');
                if (configNow) {
                    // æ‰“å¼€è®¾ç½®é¡µé¢
                    document.getElementById('setting-page').style.display = 'flex';
                }
                return;
            }
            
            const timeInput = prompt('å¿«è¿›å¤šä¹…ï¼Ÿ\næ ¼å¼ï¼šæ•°å­— + å•ä½\nä¾‹å¦‚ï¼š60åˆ†é’Ÿã€2å°æ—¶ã€1å¤©', '60åˆ†é’Ÿ');
            if (timeInput === null) return;
            
            // è§£æè¾“å…¥
            const match = timeInput.match(/^(\d+)\s*(åˆ†é’Ÿ|å°æ—¶|å¤©)$/);
            if (!match) {
                alert('æ ¼å¼é”™è¯¯ï¼è¯·è¾“å…¥å¦‚ï¼š60åˆ†é’Ÿã€2å°æ—¶ã€1å¤©');
                return;
            }
            
            const amount = parseInt(match[1]);
            const unit = match[2];
            
            // è®¡ç®—æ¯«ç§’æ•°
            let ms = 0;
            let unitText = '';
            if (unit === 'åˆ†é’Ÿ') {
                ms = amount * 60 * 1000;
                unitText = amount + 'åˆ†é’Ÿ';
            } else if (unit === 'å°æ—¶') {
                ms = amount * 60 * 60 * 1000;
                unitText = amount + 'å°æ—¶';
            } else if (unit === 'å¤©') {
                ms = amount * 24 * 60 * 60 * 1000;
                unitText = amount + 'å¤©';
            }
            
            if (ms === 0) {
                alert('æ—¶é—´å¿…é¡»å¤§äº0');
                return;
            }
            
            // æ˜¾ç¤ºåŠ è½½æç¤º
            const loadingDiv = document.createElement('div');
            loadingDiv.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.7); display:flex; flex-direction:column; align-items:center; justify-content:center; z-index:9999;';
            loadingDiv.innerHTML = `
                <div style="background:#fff; padding:30px 40px; border-radius:16px; text-align:center; box-shadow:0 10px 40px rgba(0,0,0,0.3);">
                    <div style="width:50px; height:50px; border:4px solid #f3f3f3; border-top:4px solid var(--ins-pink); border-radius:50%; margin:0 auto 20px; animation:spin 1s linear infinite;"></div>
                    <div style="font-size:18px; font-weight:600; color:#333; margin-bottom:8px;">æ­£åœ¨å¿«è¿›ä¸­...</div>
                    <div style="font-size:14px; color:#999;">å¿«è¿› ${unitText}ï¼ŒAIæ­£åœ¨åˆ¤æ–­è§’è‰²æ˜¯å¦ä¼šè”ç³»ä½ </div>
                </div>
            `;
            document.body.appendChild(loadingDiv);
            
            // æ·»åŠ æ—‹è½¬åŠ¨ç”»ï¼ˆå¦‚æœè¿˜æ²¡æœ‰ï¼‰
            if (!document.querySelector('#spin-animation-style')) {
                const style = document.createElement('style');
                style.id = 'spin-animation-style';
                style.textContent = `
                    @keyframes spin {
                        0% { transform: rotate(0deg); }
                        100% { transform: rotate(360deg); }
                    }
                `;
                document.head.appendChild(style);
            }
            
            try {
                console.log('[FastForwardBlocked] å¼€å§‹å¿«è¿›ï¼Œæ—¶é•¿:', unitText);
                
                // æ›´æ–°è™šæ‹Ÿæ—¶é—´åç§»
                const char = await db.characters.get(charId);
                if (!char.timeOffset) char.timeOffset = 0;
                char.timeOffset += ms;
                await db.characters.put(char);
                
                console.log('[FastForwardBlocked] æ—¶é—´å·²æ›´æ–°ï¼Œå¼€å§‹æ£€æŸ¥è¢«æ‹‰é»‘è§’è‰²...');
                
                // æ£€æŸ¥è¢«æ‹‰é»‘çš„è§’è‰²æ˜¯å¦ä¼šè”ç³»ï¼ˆè¿™ä¼šè°ƒç”¨AIç”Ÿæˆç”µè¯å’ŒçŸ­ä¿¡ï¼‰
                await checkBlockedCharactersContact(ms, unitText);
                
                console.log('[FastForwardBlocked] æ£€æŸ¥å®Œæˆ');
                
                // ç­‰å¾…ä¸€å°æ®µæ—¶é—´ï¼Œç¡®ä¿æ‰€æœ‰é€šçŸ¥éƒ½æ˜¾ç¤ºå®Œæ¯•
                await new Promise(resolve => setTimeout(resolve, 500));
                
                if (document.body.contains(loadingDiv)) {
                    document.body.removeChild(loadingDiv);
                }
                
                console.log('[FastForwardBlocked] å¿«è¿›å®Œæˆ');
                alert(`âœ… å·²å¿«è¿› ${unitText}\n\nå¦‚æœè¢«æ‹‰é»‘çš„è§’è‰²å†³å®šè”ç³»ä½ ï¼Œä¼šæ˜¾ç¤ºæœªæ¥æ¥ç”µæˆ–çŸ­ä¿¡è®°å½•ã€‚`);
                
                // åˆ·æ–°ç•Œé¢
                if (currentChatCharId === charId) {
                    await renderChatBody(char);
                }
            } catch (error) {
                console.error('[FastForwardBlocked] Error:', error);
                if (document.body.contains(loadingDiv)) {
                    document.body.removeChild(loadingDiv);
                }
                alert('å¿«è¿›å¤±è´¥ï¼š' + error.message + '\n\nè¯¦ç»†é”™è¯¯è¯·æŸ¥çœ‹æµè§ˆå™¨æ§åˆ¶å°ï¼ˆF12ï¼‰ã€‚');
            }
        }
        
        // è§£é™¤æ‹‰é»‘
        async function unblockFriend(charId) {
            const char = await db.characters.get(charId);
            if (!char) return;
            
            if (confirm(`ç¡®å®šè¦è§£é™¤å¯¹ ${char.name} çš„æ‹‰é»‘å—ï¼Ÿ\nè§£é™¤åå°†æ¢å¤å¥½å‹å…³ç³»ï¼Œå¯ä»¥æ­£å¸¸èŠå¤©ã€‚`)) {
                const accountId = getCurrentAccountId();
                
                // ğŸ¯ ç›´æ¥æ¢å¤ä¸ºå¥½å‹çŠ¶æ€ï¼Œä¸ç”¨é‡æ–°ç”³è¯·
                await setFriendStatus(char, accountId, 'friend');
                
                showToast('å·²è§£é™¤æ‹‰é»‘ï¼Œæ­£åœ¨ç”Ÿæˆè§’è‰²ååº”...');
                
                // åˆ·æ–°ç•Œé¢
                if (currentChatCharId === charId) {
                    await renderChatBody(char);
                }
                
                // åˆ·æ–°å¾®ä¿¡é¡µé¢
                const activeTab = document.querySelector('.wechat-tab-item.active');
                if (activeTab) {
                    const tabIndex = Array.from(document.querySelectorAll('.wechat-tab-item')).indexOf(activeTab);
                    switchWechatTab(tabIndex);
                }
                
                // ğŸ¯ è°ƒç”¨AIç”Ÿæˆè§£é™¤æ‹‰é»‘åçš„ååº”
                try {
                    await generateUnblockReaction(char, accountId);
                } catch (error) {
                    console.error('[Unblock] ç”Ÿæˆååº”å¤±è´¥:', error);
                }
            }
        }
        
        // ğŸ¯ ç”Ÿæˆè§£é™¤æ‹‰é»‘åè§’è‰²çš„ååº”
        async function generateUnblockReaction(char, accountId) {
            const myChar = await db.characters.get(parseInt(accountId));
            if (!myChar) return;
            
            // è·å–èŠå¤©å†å²ä½œä¸ºä¸Šä¸‹æ–‡
            const chatHistory = getChatHistory(char, accountId);
            const recentMessages = chatHistory.slice(-8).map(m => {
                const role = m.role === 'user' ? myChar.name : char.name;
                return `${role}: ${m.content}`;
            }).join('\n');
            
            // è®¡ç®—è¢«æ‹‰é»‘çš„å¤§æ¦‚æ—¶é•¿ï¼ˆæ ¹æ®æœ€åä¸€æ¡æ¶ˆæ¯çš„æ—¶é—´ï¼‰
            const lastMsg = chatHistory[chatHistory.length - 1];
            const blockedDuration = lastMsg ? Math.floor((Date.now() - (lastMsg.timestamp || Date.now())) / (1000 * 60)) : 0;
            const durationText = blockedDuration > 1440 ? `${Math.floor(blockedDuration / 1440)}å¤©` : 
                                 blockedDuration > 60 ? `${Math.floor(blockedDuration / 60)}å°æ—¶` : 
                                 blockedDuration > 0 ? `${blockedDuration}åˆ†é’Ÿ` : 'åˆšæ‰';
            
            const prompt = `ã€è§’è‰²æ‰®æ¼”ä»»åŠ¡ã€‘
ä½ ç°åœ¨æ˜¯ã€Œ${char.name}ã€ï¼Œè¯·å®Œå…¨ä»£å…¥è¿™ä¸ªè§’è‰²ã€‚

ã€ä½ çš„äººè®¾ã€‘
${char.description || char.desc || 'ä¸€ä¸ªæ™®é€šäºº'}

ã€å¯¹æ–¹ä¿¡æ¯ã€‘
åå­—ï¼š${myChar.name}
${myChar.description ? `ç®€ä»‹ï¼š${myChar.description.substring(0, 200)}` : ''}

ã€æœ€è¿‘çš„èŠå¤©è®°å½•ï¼ˆè¢«æ‹‰é»‘å‰ï¼‰ã€‘
${recentMessages || 'ï¼ˆæ— è®°å½•ï¼‰'}

ã€å½“å‰æƒ…å¢ƒã€‘
ä½ ä¹‹å‰è¢«ã€Œ${myChar.name}ã€æ‹‰é»‘äº†å¤§çº¦ ${durationText}ã€‚
åœ¨è¿™æ®µæ—¶é—´é‡Œï¼Œä½ å¯èƒ½æ‰“è¿‡ç”µè¯ã€å‘è¿‡çŸ­ä¿¡ï¼Œä½†éƒ½æ²¡æœ‰å¾—åˆ°å›åº”ã€‚
ç°åœ¨ï¼Œå¯¹æ–¹çªç„¶è§£é™¤äº†å¯¹ä½ çš„æ‹‰é»‘ï¼ä½ ä»¬åˆèƒ½æ­£å¸¸èŠå¤©äº†ã€‚

ã€ä½ éœ€è¦æ€è€ƒã€‘
1. è¢«æ‹‰é»‘è¿™æ®µæ—¶é—´ä½ ç»å†äº†ä»€ä¹ˆï¼Ÿï¼ˆç„¦è™‘ç­‰å¾…ï¼Ÿæ„¤æ€’ä¸ç”˜ï¼Ÿä¼¤å¿ƒéš¾è¿‡ï¼Ÿæ— æ‰€è°“ï¼Ÿï¼‰
2. ç°åœ¨å¯¹æ–¹è§£é™¤æ‹‰é»‘äº†ï¼Œä½ æ˜¯ä»€ä¹ˆå¿ƒæƒ…ï¼Ÿï¼ˆæƒŠå–œï¼Ÿæ¿€åŠ¨ï¼Ÿå†·æ·¡ï¼Ÿè¯•æ¢ï¼ŸæŠ¥å¤å¿ƒç†ï¼Ÿï¼‰
3. ä½ ä¼šç«‹åˆ»å‘æ¶ˆæ¯å—ï¼Ÿè¿˜æ˜¯æ•…æ„å†·ä¸€ä¸‹å¯¹æ–¹ï¼Ÿ
4. å¦‚æœå‘æ¶ˆæ¯ï¼Œä½ ä¼šè¯´ä»€ä¹ˆï¼Ÿï¼ˆå…´å¸ˆé—®ç½ªï¼Ÿè£…ä½œä»€ä¹ˆéƒ½æ²¡å‘ç”Ÿï¼Ÿå°å¿ƒç¿¼ç¿¼ï¼Ÿæ’’å¨‡æŠ±æ€¨ï¼Ÿï¼‰

ã€è¾“å‡ºè¦æ±‚ã€‘
æ ¹æ®ä½ çš„æ€§æ ¼ï¼Œç”Ÿæˆä½ å‘ç°è¢«è§£é™¤æ‹‰é»‘åå‘çš„ç¬¬ä¸€æ¡/ç¬¬ä¸€ç»„å¾®ä¿¡æ¶ˆæ¯ã€‚

è¦æ±‚ï¼š
- ç”¨ã€Œ|||ã€åˆ†éš”å¤šæ¡æ¶ˆæ¯ï¼ˆ1-4æ¡ï¼‰
- ç¬¦åˆä½ çš„äººè®¾å’Œè¯´è¯é£æ ¼
- æƒ…ç»ªè¦çœŸå®ï¼Œä¸è¦å¤ªç†æ€§
- å¯ä»¥æœ‰è¯­æ°”è¯ã€è¡¨æƒ…ã€é”™åˆ«å­—
- å¦‚æœä½ çš„æ€§æ ¼æ˜¯ä¼šå†·å¤„ç†çš„ï¼Œå¯ä»¥åªå‘ä¸€ä¸ªå­—æˆ–è¡¨æƒ…

ç›´æ¥è¾“å‡ºæ¶ˆæ¯å†…å®¹ï¼Œä¸è¦ä»»ä½•è§£é‡Šã€‚

ç¤ºä¾‹æ ¼å¼ï¼š
åœ¨å—|||ä½ ç»ˆäºè‚¯ç†æˆ‘äº†|||æˆ‘è¿˜ä»¥ä¸ºä½ è¦æ‹‰é»‘æˆ‘ä¸€è¾ˆå­`;

            console.log('[Unblock] æ­£åœ¨ç”Ÿæˆè§£é™¤æ‹‰é»‘ååº”...');
            
            // ğŸ¯ æ˜¾ç¤º"å¯¹æ–¹æ­£åœ¨è¾“å…¥ä¸­..."
            const chatTitleEl = document.getElementById('chat-title');
            const originalTitle = chatTitleEl ? chatTitleEl.innerText : (char.remark || char.name);
            if (chatTitleEl && currentChatCharId === char.id) {
                chatTitleEl.innerText = "å¯¹æ–¹æ­£åœ¨è¾“å…¥ä¸­...";
            }
            
            try {
                const response = await callAI([
                    { role: 'user', content: prompt }
                ]);
                
                const replyText = response.trim();
                if (!replyText) {
                    // æ¢å¤æ ‡é¢˜
                    if (chatTitleEl && currentChatCharId === char.id) {
                        chatTitleEl.innerText = originalTitle;
                    }
                    return;
                }
                
                console.log('[Unblock] AIè¿”å›:', replyText);
                
                // è§£æå¤šæ¡æ¶ˆæ¯
                const segments = replyText.split('|||').map(s => s.trim()).filter(s => s.length > 0);
                if (segments.length === 0) {
                    if (chatTitleEl && currentChatCharId === char.id) {
                        chatTitleEl.innerText = originalTitle;
                    }
                    return;
                }
                
                // è·å–å½“å‰èŠå¤©è®°å½•
                let currentHistory = getChatHistory(char, accountId);
                
                // æ·»åŠ æ‰€æœ‰æ¶ˆæ¯åˆ°èŠå¤©è®°å½•
                for (let i = 0; i < segments.length; i++) {
                    currentHistory.push({
                        role: 'char',
                        content: segments[i],
                        time: Date.now() + i * 100
                    });
                }
                
                // ä¿å­˜èŠå¤©è®°å½•
                await setChatHistory(char, currentHistory, accountId);
                
                // ç›´æ¥é‡æ–°æ¸²æŸ“èŠå¤©ç•Œé¢
                if (currentChatCharId === char.id) {
                    await renderChatBody(char);
                    // æ»šåŠ¨åˆ°åº•éƒ¨
                    const chatBody = document.getElementById('chat-body');
                    if (chatBody) chatBody.scrollTop = chatBody.scrollHeight;
                }
                
                // æ¢å¤æ ‡é¢˜
                if (chatTitleEl && currentChatCharId === char.id) {
                    chatTitleEl.innerText = originalTitle;
                }
                
                // æ˜¾ç¤ºé€šçŸ¥
                showToast(`${char.name} å‘æ¥äº†æ¶ˆæ¯`);
                
                console.log('[Unblock] âœ… è§£é™¤æ‹‰é»‘ååº”å·²ç”Ÿæˆ');
                
            } catch (error) {
                console.error('[Unblock] AIè°ƒç”¨å¤±è´¥:', error);
                // æ¢å¤æ ‡é¢˜
                if (chatTitleEl && currentChatCharId === char.id) {
                    chatTitleEl.innerText = originalTitle;
                }
            }
        }
        
        // æ‰‹åŠ¨å‘é€å¥½å‹ç”³è¯·ï¼ˆç”¨æˆ·ä¸»åŠ¨ï¼‰
        async function manualSendFriendRequest(charId) {
            const char = await db.characters.get(charId);
            if (!char) return;
            
            const message = prompt(`å‘é€å¥½å‹ç”³è¯·ç»™ ${char.name}\n\nè¯·è¾“å…¥ç”³è¯·ç†ç”±ï¼ˆå¯é€‰ï¼‰ï¼š`, 'æˆ‘æ˜¯' + (await getCurrentUserName()));
            if (message !== null) {
                await sendFriendRequestTo(charId, message);
            }
        }
        
        // AIæ£€æµ‹æ˜¯å¦å‘é€å¥½å‹ç”³è¯·
        async function checkCharacterSendFriendRequest(charId, elapsedMinutes) {
            const char = await db.characters.get(charId);
            if (!char) return;
            
            const accountId = getCurrentAccountId();
            const myChar = await db.characters.get(parseInt(accountId));
            if (!myChar) return;
            
            // è·å–èŠå¤©å†å²
            const history = getChatHistory(char, accountId);
            const recentMessages = history.slice(-10); // æœ€è¿‘10æ¡æ¶ˆæ¯
            
            // æ„å»ºæç¤ºè¯
            const chatContext = recentMessages.map(msg => {
                const role = msg.role === 'user' ? myChar.name : char.name;
                return `${role}: ${msg.content}`;
            }).join('\n');
            
            const prompt = `ä½ æ˜¯${char.name}ã€‚

ä½ çš„äººè®¾ï¼š
${char.description || 'ï¼ˆæ— è¯¦ç»†äººè®¾ï¼‰'}

ä½ å’Œ${myChar.name}ä¹‹å‰æ˜¯å¥½å‹ï¼Œä½†${myChar.name}åˆ é™¤äº†ä½ ã€‚ä½ ä»¬ä¹‹å‰çš„èŠå¤©è®°å½•ï¼š

${chatContext || 'ï¼ˆæ²¡æœ‰èŠå¤©è®°å½•ï¼‰'}

ç°åœ¨æ—¶é—´å·²ç»è¿‡å»äº†${elapsedMinutes}åˆ†é’Ÿã€‚

è¯·æ ¹æ®ä½ çš„æ€§æ ¼ã€å’Œ${myChar.name}çš„å…³ç³»ã€ä»¥åŠä½ ä»¬çš„èŠå¤©å†å²ï¼Œå†³å®šä½ æ˜¯å¦è¦ä¸»åŠ¨å‘é€å¥½å‹ç”³è¯·ç»™${myChar.name}ã€‚

å¦‚æœä½ å†³å®šå‘é€å¥½å‹ç”³è¯·ï¼Œè¯·ä»¥ä½ çš„è§†è§’å†™å‡ºä½ æƒ³å¯¹${myChar.name}è¯´çš„è¯ï¼ˆå¯ä»¥æ˜¯1-3æ¡æ¶ˆæ¯ï¼Œæ¯æ¡æ¶ˆæ¯ç”¨æ¢è¡Œåˆ†éš”ï¼‰ã€‚
å¦‚æœä½ å†³å®šä¸å‘é€ï¼Œè¯·åªå›å¤"[ä¸å‘é€]"ã€‚

æ³¨æ„ï¼šè¯·ç›´æ¥ä»¥è§’è‰²èº«ä»½è¯´è¯ï¼Œä¸è¦æœ‰ä»»ä½•æ ¼å¼æ ‡è®°æˆ–è§£é‡Šã€‚`;
            
            // æ˜¾ç¤ºåŠ è½½æç¤º
            const loadingDiv = document.createElement('div');
            loadingDiv.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.7); display:flex; flex-direction:column; align-items:center; justify-content:center; z-index:9999;';
            loadingDiv.innerHTML = `
                <div style="background:#fff; padding:30px 40px; border-radius:16px; text-align:center; box-shadow:0 10px 40px rgba(0,0,0,0.3);">
                    <div style="width:50px; height:50px; border:4px solid #f3f3f3; border-top:4px solid var(--ins-pink); border-radius:50%; margin:0 auto 20px; animation:spin 1s linear infinite;"></div>
                    <div style="font-size:18px; font-weight:600; color:#333; margin-bottom:8px;">æ­£åœ¨æ£€æµ‹ä¸­...</div>
                    <div style="font-size:14px; color:#999;">${char.name} æ­£åœ¨å†³å®šæ˜¯å¦å‘é€å¥½å‹ç”³è¯·</div>
                </div>
            `;
            document.body.appendChild(loadingDiv);
            
            // æ·»åŠ æ—‹è½¬åŠ¨ç”»ï¼ˆå¦‚æœè¿˜æ²¡æœ‰ï¼‰
            if (!document.querySelector('#spin-animation-style')) {
                const style = document.createElement('style');
                style.id = 'spin-animation-style';
                style.textContent = `
                    @keyframes spin {
                        0% { transform: rotate(0deg); }
                        100% { transform: rotate(360deg); }
                    }
                `;
                document.head.appendChild(style);
            }
            
            try {
                const response = await callAI([
                    { role: 'user', content: prompt }
                ]);
                
                document.body.removeChild(loadingDiv);
                
                // è§£æAIå›å¤
                const answer = response.trim();
                
                if (answer === '[ä¸å‘é€]' || answer.includes('[ä¸å‘é€]')) {
                    // è§’è‰²å†³å®šä¸å‘é€
                    alert(`${char.name} å†³å®šæš‚æ—¶ä¸å‘é€å¥½å‹ç”³è¯·`);
                    
                    // æ›´æ–°æœ€åæ£€æµ‹æ—¶é—´
                    if (!char.wait_friend_settings) char.wait_friend_settings = {};
                    if (char.wait_friend_settings[accountId]) {
                        char.wait_friend_settings[accountId].lastCheckTime = Date.now();
                        if (char.wait_friend_settings[accountId].enabled) {
                            char.wait_friend_settings[accountId].nextCheckTime = 
                                Date.now() + char.wait_friend_settings[accountId].interval * 60 * 1000;
                        }
                        await db.characters.put(char);
                    }
                } else {
                    // è§’è‰²å†³å®šå‘é€å¥½å‹ç”³è¯·ï¼Œå°†å¤šæ¡æ¶ˆæ¯æ‹†åˆ†
                    const messages = answer.split('\n').filter(msg => msg.trim().length > 0);
                    
                    if (messages.length === 0) {
                        alert(`${char.name} çš„å›å¤ä¸ºç©ºï¼Œæœªå‘é€ç”³è¯·`);
                        return;
                    }
                    
                    // å°†æ‰€æœ‰æ¶ˆæ¯åˆå¹¶ï¼Œæˆ–è€…åªå–ç¬¬ä¸€æ¡ä½œä¸ºç”³è¯·æ¶ˆæ¯
                    const requestMessage = messages.join('\n');
                    
                    // åˆ›å»ºå¥½å‹ç”³è¯·ï¼ˆåå‘ï¼šä»è§’è‰²å‘ç»™ç”¨æˆ·ï¼‰
                    await db.friend_requests.add({
                        fromCharId: charId,
                        toCharId: parseInt(accountId),
                        message: requestMessage,
                        status: 'pending',
                        time: Date.now()
                    });
                    
                    // æ˜¾ç¤ºæ¶ˆæ¯é¢„è§ˆ
                    const preview = messages.length > 1 ? 
                        `${messages[0]}\n...(å…±${messages.length}æ¡æ¶ˆæ¯)` : 
                        messages[0];
                    
                    alert(`${char.name} å‘é€äº†å¥½å‹ç”³è¯·ï¼\n\n${preview}\n\nè¯·å‰å¾€"æ–°çš„å¥½å‹"é¡µé¢æŸ¥çœ‹ã€‚`);
                    
                    // æ›´æ–°æœ€åæ£€æµ‹æ—¶é—´
                    if (!char.wait_friend_settings) char.wait_friend_settings = {};
                    if (char.wait_friend_settings[accountId]) {
                        char.wait_friend_settings[accountId].lastCheckTime = Date.now();
                        if (char.wait_friend_settings[accountId].enabled) {
                            char.wait_friend_settings[accountId].nextCheckTime = 
                                Date.now() + char.wait_friend_settings[accountId].interval * 60 * 1000;
                        }
                        await db.characters.put(char);
                    }
                    
                    // åˆ·æ–°é€šè®¯å½•çº¢ç‚¹
                    const activeTab = document.querySelector('.wechat-tab-item.active');
                    if (activeTab && activeTab.innerText.includes('é€šè®¯å½•')) {
                        await renderContactList(document.getElementById('wechat-content'));
                    }
                }
                
                // åˆ·æ–°ç•Œé¢
                if (currentChatCharId === charId) {
                    await renderChatBody(char);
                }
                
            } catch (error) {
                if (document.body.contains(loadingDiv)) {
                    document.body.removeChild(loadingDiv);
                }
                alert('AIè°ƒç”¨å¤±è´¥ï¼š' + error.message);
            }
        }
        
        // å®šæ—¶å™¨ï¼šæ£€æŸ¥æ‰€æœ‰éœ€è¦æ£€æµ‹çš„è§’è‰²
        let waitFriendCheckTimer = null;
        
        function startWaitFriendTimer() {
            if (waitFriendCheckTimer) return; // å·²å¯åŠ¨
            
            waitFriendCheckTimer = setInterval(async () => {
                const now = Date.now();
                const accountId = getCurrentAccountId();
                if (!accountId) return;
                
                // è·å–æ‰€æœ‰è§’è‰²
                const allChars = await db.characters.toArray();
                
                for (const char of allChars) {
                    const settings = char.wait_friend_settings?.[accountId];
                    if (!settings || !settings.enabled) continue;
                    
                    // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾æ£€æµ‹æ—¶é—´
                    if (settings.nextCheckTime && now >= settings.nextCheckTime) {
                        // è§¦å‘æ£€æµ‹
                        await checkCharacterSendFriendRequest(char.id, settings.interval);
                    }
                }
            }, 60000); // æ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
        }
        
        // åˆå§‹åŒ–æ—¶å¯åŠ¨å®šæ—¶å™¨
        startWaitFriendTimer();

        // --- èŠå¤©çª—å£é€»è¾‘ ---
        async function openChatWindow(charId) {
            currentChatCharId = charId;
            window.currentGroupChatId = null; // æ¸…é™¤ç¾¤èŠIDï¼Œç¡®ä¿æ˜¯ç§èŠæ¨¡å¼
            const char = await db.characters.get(charId);
            
            // ä¼˜å…ˆæ˜¾ç¤ºå¤‡æ³¨å
            const titleEl = document.getElementById('chat-title');
            titleEl.innerText = char.remark || char.name;
            titleEl.style.cursor = 'pointer';
            titleEl.onclick = showChatDetail; // æ¢å¤ä¸ºç§èŠè¯¦æƒ…
            
            document.getElementById('chat-window').style.display = 'flex';
            
            // ç¼“å­˜å½“å‰å…³è”çš„ User ID
            currentChatUserId = char.linked_user_id || null;
            
            // æ ¹æ®å¥½å‹çŠ¶æ€æ˜¾ç¤ºæˆ–éšè—è¾“å…¥æ¡†
            const accountId = getCurrentAccountId();
            const friendStatus = getFriendStatus(char, accountId);
            const chatFooter = document.getElementById('chat-footer');
            if (friendStatus === 'blocked' || friendStatus === 'deleted') {
                // æ‹‰é»‘æˆ–åˆ é™¤åï¼Œéšè—è¾“å…¥æ¡†
                chatFooter.style.display = 'none';
            } else {
                // æ­£å¸¸çŠ¶æ€ï¼Œæ˜¾ç¤ºè¾“å…¥æ¡†
                chatFooter.style.display = 'flex';
            }
            
            // âœ… è”æœºå¥½å‹ï¼šéšè—AIé­”æ³•æ£’ï¼Œç®€åŒ–èœå•ï¼ˆåªæ˜¾ç¤ºè¯­éŸ³è¾“å…¥ã€ç›¸å†Œã€è½¬è´¦ï¼‰
            const isOnlineFriend = char.isOnlineFriend === true;
            const actionPanel = document.getElementById('action-panel');
            const actionItems = actionPanel.querySelectorAll('.action-item');
            const aiMagicBtn = document.querySelector('.chat-input-bar .chat-icon-btn'); // ç¬¬ä¸€ä¸ªæŒ‰é’®æ˜¯AIé­”æ³•æ£’
            
            if (isOnlineFriend) {
                // éšè—AIé­”æ³•æ£’
                if (aiMagicBtn) aiMagicBtn.style.display = 'none';
                // åªæ˜¾ç¤ºå‰3ä¸ªèœå•é¡¹ï¼ˆè¯­éŸ³è¾“å…¥ã€ç›¸å†Œã€è½¬è´¦ï¼‰
                actionItems.forEach((item, index) => {
                    item.style.display = index < 3 ? '' : 'none';
                });
            } else {
                // æ™®é€šè§’è‰²ï¼šæ˜¾ç¤ºæ‰€æœ‰èœå•
                if (aiMagicBtn) aiMagicBtn.style.display = '';
                actionItems.forEach(item => {
                    item.style.display = '';
                });
            }
            
            renderChatBody(char);
        }

        // --- èŠå¤©è¯¦æƒ…é¡µé€»è¾‘ ---
        // ç»Ÿä¸€å…¥å£ï¼šæ ¹æ®å½“å‰æ˜¯ç§èŠè¿˜æ˜¯ç¾¤èŠæ˜¾ç¤ºå¯¹åº”è¯¦æƒ…é¡µ
        function showChatOrGroupDetail() {
            if (window.currentGroupChatId) {
                showGroupDetail(window.currentGroupChatId);
            } else if (currentChatCharId) {
                showChatDetail();
            }
        }
        
        async function showChatDetail() {
            if (!currentChatCharId) return;
            const char = await db.characters.get(currentChatCharId);
            if (!char) return;

            document.getElementById('chat-detail-page').style.display = 'flex';
            
            // âœ… è”æœºå¥½å‹ï¼šéšè—ä¸ç›¸å…³çš„è®¾ç½®é¡¹
            const isOnlineFriend = char.isOnlineFriend === true;
            const detailPage = document.getElementById('chat-detail-page');
            const detailGroups = detailPage.querySelectorAll('.detail-group');
            
            // æ˜¾ç¤ºæˆ–éšè—ç‰¹å®šçš„è®¾ç½®ç»„ï¼ˆæŒ‰é¡ºåºï¼šæ¡£æ¡ˆå…³è”ã€ä¸»åŠ¨èŠå¤©ã€AIä¸Šä¸‹æ–‡ã€è¡¨æƒ…åŒ…ã€èŠå¤©èƒŒæ™¯ã€æ°”æ³¡æ ·å¼ã€è‡ªå®šä¹‰æ ·å¼ã€å±é™©æ“ä½œï¼‰
            detailGroups.forEach((group, index) => {
                if (isOnlineFriend) {
                    // è”æœºå¥½å‹åªæ˜¾ç¤ºç¬¬ä¸€ç»„ï¼ˆæ¡£æ¡ˆå…³è”ï¼‰å’Œæœ€åä¸€ç»„ï¼ˆå±é™©æ“ä½œï¼‰
                    // éšè—ï¼šä¸»åŠ¨èŠå¤©(1)ã€AIä¸Šä¸‹æ–‡(2)ã€è¡¨æƒ…åŒ…(3)ã€èŠå¤©èƒŒæ™¯(4)ã€æ°”æ³¡æ ·å¼(5)ã€è‡ªå®šä¹‰æ ·å¼(6)
                    if (index >= 1 && index <= 6) {
                        group.style.display = 'none';
                    } else {
                        group.style.display = '';
                    }
                } else {
                    group.style.display = '';
                }
            });
            
            // 1. å›æ˜¾åŸºæœ¬ä¿¡æ¯
            document.getElementById('detail-char-remark').value = char.remark || '';
            document.getElementById('detail-char-realname').innerText = `åŸå: ${char.name}`;
            if (char.avatar) {
                document.getElementById('detail-char-avatar').style.backgroundImage = `url(${char.avatar})`;
            } else {
                document.getElementById('detail-char-avatar').style.backgroundImage = '';
            }

            // 2. åŠ è½½ä¸–ç•Œä¹¦åˆ—è¡¨ï¼ˆå¤šé€‰ï¼‰
            const lorebooks = await db.lorebooks.toArray();
            const lbList = document.getElementById('detail-lorebook-list');
            lbList.innerHTML = '';
            
            // å…¼å®¹æ—§æ•°æ®ï¼šå¦‚æœlorebookIdå­˜åœ¨ä½†lorebookIdsä¸å­˜åœ¨ï¼Œè½¬æ¢ä¸ºæ•°ç»„
            const selectedIds = char.lorebookIds || (char.lorebookId ? [char.lorebookId] : []);
            
            if (lorebooks.length === 0) {
                lbList.innerHTML = '<div style="padding:8px; color:#999; font-size:12px; text-align:center;">æš‚æ— ä¸–ç•Œä¹¦</div>';
            } else {
                lorebooks.forEach(lb => {
                    const label = document.createElement('label');
                    label.style.cssText = 'display:flex; align-items:center; padding:8px; cursor:pointer; border-radius:6px; margin-bottom:4px;';
                    label.style.background = selectedIds.includes(lb.id) ? '#f0f0f5' : 'transparent';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.value = lb.id;
                    checkbox.checked = selectedIds.includes(lb.id);
                    checkbox.style.marginRight = '8px';
                    checkbox.onchange = () => {
                        label.style.background = checkbox.checked ? '#f0f0f5' : 'transparent';
                        updateLorebookCount();
                        saveChatDetail();
                    };
                    
                    const name = document.createElement('span');
                    name.textContent = lb.name;
                    name.style.fontSize = '14px';
                    name.style.color = '#333';
                    
                    label.appendChild(checkbox);
                    label.appendChild(name);
                    lbList.appendChild(label);
                });
            }
            
            updateLorebookCount();

            // 3. å›æ˜¾ä¸»åŠ¨èŠå¤©è®¾ç½®
            document.getElementById('detail-auto-chat-switch').checked = !!char.auto_reply_enabled;
            document.getElementById('detail-auto-chat-interval').value = char.auto_reply_interval || '';
            
            // 4. å›æ˜¾AIæŸ¥å²—è®¾ç½®
            document.getElementById('detail-allow-check-switch').checked = !!char.allow_ai_check_account;
            
            // 5. å›æ˜¾ä¸Šä¸‹æ–‡æ¡æ•°è®¾ç½®ï¼ˆé»˜è®¤20æ¡ï¼‰
            document.getElementById('detail-context-count').value = char.context_message_count || 20;

            // 6. åŠ è½½æŒ‚è½½çš„è¡¨æƒ…åŒ…åº“
            updateMountedStickerCount();
            
            // 6. æ›´æ–°è§†é¢‘é€šè¯è®°å½•æ•°é‡
            updateVideoCallRecordCount();
            
            // 7. åŠ è½½è‡ªå®šä¹‰æ ·å¼è®¾ç½®
            document.getElementById('detail-bubble-css').value = char.custom_bubble_css || '';
            document.getElementById('detail-custom-html').value = char.custom_html || '';
            document.getElementById('detail-custom-css').value = char.custom_css || '';
            
            // 8. åŠ è½½èŠå¤©èƒŒæ™¯å›¾
            const bgPreview = document.getElementById('detail-chat-bg-preview');
            if (char.chat_background) {
                bgPreview.style.backgroundImage = `url(${char.chat_background})`;
                bgPreview.textContent = '';
            } else {
                bgPreview.style.backgroundImage = '';
                bgPreview.textContent = 'æš‚æ— èƒŒæ™¯å›¾';
            }
            
            // 9. åŠ è½½æ°”æ³¡æ ·å¼é€‰æ‹©
            const bubbleStyle = char.bubble_style || 'default';
            document.querySelectorAll('.bubble-style-option').forEach(el => {
                el.classList.remove('selected');
                if (el.dataset.style === bubbleStyle) {
                    el.classList.add('selected');
                }
            });
            
            // 10. åŠ è½½è‡ªåŠ¨æ€»ç»“è®¾ç½®
            document.getElementById('detail-auto-summary-switch').checked = !!char.auto_summary_enabled;
            document.getElementById('detail-summary-interval').value = char.summary_interval || '';
            
            // æ›´æ–°æ€»ç»“è®¡æ•°
            const accountId = getCurrentAccountId();
            if (accountId) {
                await updateSummaryCount('private', currentChatCharId, accountId);
            }
        }
        
        // é€‰æ‹©æ°”æ³¡æ ·å¼
        function selectBubbleStyle(style) {
            document.querySelectorAll('.bubble-style-option').forEach(el => {
                el.classList.remove('selected');
                if (el.dataset.style === style) {
                    el.classList.add('selected');
                }
            });
            saveChatDetail();
        }

        function hideChatDetail() {
            document.getElementById('chat-detail-page').style.display = 'none';
        }

        function toggleLorebookList() {
            const list = document.getElementById('detail-lorebook-list');
            const toggle = document.getElementById('detail-lorebook-toggle');
            if (list.style.display === 'none' || !list.style.display) {
                list.style.display = 'block';
                toggle.textContent = 'æ”¶èµ·';
            } else {
                list.style.display = 'none';
                toggle.textContent = 'å±•å¼€';
            }
        }

        function updateLorebookCount() {
            const checkboxes = document.querySelectorAll('#detail-lorebook-list input[type="checkbox"]:checked');
            const count = checkboxes.length;
            document.getElementById('detail-lorebook-count').textContent = `${count}ä¸ª`;
        }

async function saveChatDetail() {
    if (!currentChatCharId) return;
    const char = await db.characters.get(currentChatCharId);
    
    const remark = document.getElementById('detail-char-remark').value.trim();
    
    // è·å–é€‰ä¸­çš„ä¸–ç•Œä¹¦IDæ•°ç»„
    const checkboxes = document.querySelectorAll('#detail-lorebook-list input[type="checkbox"]:checked');
    const lorebookIds = Array.from(checkboxes).map(cb => parseInt(cb.value));
    
    // ä¸»åŠ¨èŠå¤©è®¾ç½®
    const autoEnabled = document.getElementById('detail-auto-chat-switch').checked;
    const autoInterval = parseInt(document.getElementById('detail-auto-chat-interval').value);
    
    // ä¸Šä¸‹æ–‡æ¡æ•°è®¾ç½®
    const contextCount = parseInt(document.getElementById('detail-context-count').value);
    
    // AIæŸ¥å²—è®¾ç½®
    const allowCheckEnabled = document.getElementById('detail-allow-check-switch').checked;
    
    // è‡ªåŠ¨æ€»ç»“è®¾ç½®
    const autoSummaryEnabled = document.getElementById('detail-auto-summary-switch').checked;
    const summaryInterval = parseInt(document.getElementById('detail-summary-interval').value);

    char.remark = remark;
    char.lorebookIds = lorebookIds.length > 0 ? lorebookIds : null;
    // ä¿ç•™æ—§å­—æ®µä»¥å…¼å®¹ï¼Œä½†ä¼˜å…ˆä½¿ç”¨lorebookIds
    if (lorebookIds.length > 0) {
        char.lorebookId = lorebookIds[0]; // ä¿ç•™ç¬¬ä¸€ä¸ªä½œä¸ºå…¼å®¹
    } else {
        char.lorebookId = null;
    }
    char.auto_reply_enabled = autoEnabled;
    char.auto_reply_interval = autoInterval > 0 ? autoInterval : null;
    char.context_message_count = contextCount > 0 ? contextCount : 20; // é»˜è®¤20æ¡
    char.allow_ai_check_account = allowCheckEnabled; // ä¿å­˜æŸ¥å²—å¼€å…³çŠ¶æ€
    char.auto_summary_enabled = autoSummaryEnabled; // è‡ªåŠ¨æ€»ç»“å¼€å…³
    char.summary_interval = summaryInterval > 0 ? summaryInterval : 50; // æ€»ç»“é—´éš”ï¼Œé»˜è®¤50æ¡
    
    // ä¿å­˜è‡ªå®šä¹‰æ ·å¼ï¼ˆä¸¥æ ¼è¿‡æ»¤JSï¼‰
    const bubbleCSS = document.getElementById('detail-bubble-css').value;
    const customHTML = document.getElementById('detail-custom-html').value;
    const customCSS = document.getElementById('detail-custom-css').value;
    
    char.custom_bubble_css = sanitizeCSS(bubbleCSS);
    char.custom_html = sanitizeHTML(customHTML);
    char.custom_css = sanitizeCSS(customCSS);
    
    // ä¿å­˜æ°”æ³¡æ ·å¼é€‰æ‹©
    const selectedBubbleOption = document.querySelector('.bubble-style-option.selected');
    char.bubble_style = selectedBubbleOption ? selectedBubbleOption.dataset.style : 'default';
    
    await db.characters.put(char);
    
    // å®æ—¶æ›´æ–°èŠå¤©æ ‡é¢˜
    document.getElementById('chat-title').innerText = char.remark || char.name;
    
    // å¦‚æœå½“å‰æ­£åœ¨æŸ¥çœ‹è¿™ä¸ªèŠå¤©ï¼Œç«‹å³åº”ç”¨æ ·å¼
    if (currentChatCharId === char.id) {
        applyCustomStyles(char);
    }
    // åˆ·æ–°åˆ—è¡¨ï¼ˆå¦‚æœæ­¤æ—¶å¾®ä¿¡åˆ—è¡¨å¯è§ï¼‰
    // ...
}

// æ˜¾ç¤ºæŒ‚è½½è¡¨æƒ…åŒ…åº“å¼¹çª—
async function showMountStickerModal() {
    if (!currentChatCharId) return;
    
    const char = await db.characters.get(currentChatCharId);
    const mountedIds = char.mounted_sticker_categories || [];
    
    const modal = document.getElementById('mount-sticker-modal');
    const listContainer = document.getElementById('mount-sticker-list');
    
    if (!modal || !listContainer) {
        console.error('æŒ‚è½½è¡¨æƒ…åŒ…åº“å¼¹çª—å…ƒç´ æœªæ‰¾åˆ°');
        return;
    }
    
    // è·å–æ‰€æœ‰è¡¨æƒ…åŒ…åˆ†ç±»
    const categories = await db.sticker_categories.toArray();
    
    if (categories.length === 0) {
        listContainer.innerHTML = '<div style="text-align:center; color:#999; padding:40px;">æš‚æ— è¡¨æƒ…åŒ…åˆ†ç±»<br>è¯·å…ˆå»ã€æˆ‘-è¡¨æƒ…ã€‘åˆ›å»ºåˆ†ç±»</div>';
    } else {
        listContainer.innerHTML = categories.map(cat => {
            const isMounted = mountedIds.includes(cat.id);
            const stickerCount = (cat.stickers || []).length;
            return `
                <label style="display:flex; align-items:center; padding:12px; background:${isMounted ? '#f0f0f5' : '#fff'}; border:1px solid #f0f0f0; border-radius:8px; cursor:pointer; transition:background 0.2s;">
                    <input type="checkbox" value="${cat.id}" ${isMounted ? 'checked' : ''} style="margin-right:12px; width:18px; height:18px; cursor:pointer;" onchange="this.parentElement.style.background = this.checked ? '#f0f0f5' : '#fff'">
                    <div style="flex:1;">
                        <div style="font-size:15px; font-weight:500; color:#333; margin-bottom:4px;">${cat.name}</div>
                        <div style="font-size:12px; color:#999;">${stickerCount} ä¸ªè¡¨æƒ…</div>
                    </div>
                </label>
            `;
        }).join('');
    }
    
    modal.style.display = 'flex';
    
    // ç‚¹å‡»å¤–éƒ¨åŒºåŸŸå…³é—­å¼¹çª—
    modal.onclick = function(e) {
        if (e.target === modal) {
            hideMountStickerModal();
        }
    };
}

// éšè—æŒ‚è½½è¡¨æƒ…åŒ…åº“å¼¹çª—
function hideMountStickerModal() {
    const modal = document.getElementById('mount-sticker-modal');
    if (modal) modal.style.display = 'none';
}

// ä¿å­˜æŒ‚è½½çš„è¡¨æƒ…åŒ…åˆ†ç±»
async function saveMountedStickers() {
    if (!currentChatCharId) return;
    
    const checkboxes = document.querySelectorAll('#mount-sticker-list input[type="checkbox"]:checked');
    const mountedIds = Array.from(checkboxes).map(cb => parseInt(cb.value));
    
    const char = await db.characters.get(currentChatCharId);
    char.mounted_sticker_categories = mountedIds.length > 0 ? mountedIds : null;
    await db.characters.put(char);
    
    updateMountedStickerCount();
    hideMountStickerModal();
    
    // åˆ·æ–°è¡¨æƒ…åŒ…é¢æ¿
    await updateChatStickerPanel();
}

// æ›´æ–°æŒ‚è½½è¡¨æƒ…åŒ…æ•°é‡æ˜¾ç¤º
async function updateMountedStickerCount() {
    if (!currentChatCharId) return;
    
    const char = await db.characters.get(currentChatCharId);
    const mountedIds = char.mounted_sticker_categories || [];
    const countEl = document.getElementById('mounted-sticker-count');
    
    if (!countEl) return;
    
    if (mountedIds.length === 0) {
        countEl.innerText = 'æœªæŒ‚è½½';
    } else {
        // è®¡ç®—æ€»è¡¨æƒ…æ•°
        let totalStickers = 0;
        for (const catId of mountedIds) {
            const cat = await db.sticker_categories.get(catId);
            if (cat && cat.stickers) {
                totalStickers += cat.stickers.length;
            }
        }
        countEl.innerText = `${mountedIds.length}ä¸ªåˆ†ç±» (${totalStickers}ä¸ªè¡¨æƒ…)`;
    }
}

// ç¡®ä¿å‡½æ•°åœ¨å…¨å±€ä½œç”¨åŸŸå¯è®¿é—®
window.showMountStickerModal = showMountStickerModal;
window.hideMountStickerModal = hideMountStickerModal;
window.saveMountedStickers = saveMountedStickers;

        async function setChatDetailAvatar(input) {
            const file = input.files[0];
            if (file && currentChatCharId) {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    const base64 = e.target.result;
                    document.getElementById('detail-char-avatar').style.backgroundImage = `url(${base64})`;
                    
                    const char = await db.characters.get(currentChatCharId);
                    char.avatar = base64;
                    await db.characters.put(char);
                    
                    // åˆ·æ–°èŠå¤©ç•Œé¢å¤´åƒï¼ˆå¦‚æœåœ¨èŠå¤©ä¸­ï¼‰
                    renderChatBody(char); 
                };
                reader.readAsDataURL(file);
            }
            input.value = '';
        }

        async function setChatBackground(input) {
            const file = input.files[0];
            if (file && currentChatCharId) {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    const base64 = e.target.result;
                    const bgPreview = document.getElementById('detail-chat-bg-preview');
                    bgPreview.style.backgroundImage = `url(${base64})`;
                    bgPreview.textContent = '';
                    
                    const char = await db.characters.get(currentChatCharId);
                    char.chat_background = base64;
                    await db.characters.put(char);
                    
                    // ç«‹å³åº”ç”¨èƒŒæ™¯å›¾åˆ°èŠå¤©ç•Œé¢
                    applyChatBackground(char);
                };
                reader.readAsDataURL(file);
            }
            input.value = '';
        }

        async function clearChatBackground() {
            if (!currentChatCharId) return;
            if (!confirm('ç¡®å®šè¦æ¸…é™¤èŠå¤©èƒŒæ™¯å›¾å—ï¼Ÿ')) return;
            
            const char = await db.characters.get(currentChatCharId);
            char.chat_background = null;
            await db.characters.put(char);
            
            const bgPreview = document.getElementById('detail-chat-bg-preview');
            bgPreview.style.backgroundImage = '';
            bgPreview.textContent = 'æš‚æ— èƒŒæ™¯å›¾';
            
            // æ¸…é™¤èŠå¤©ç•Œé¢çš„èƒŒæ™¯å›¾
            applyChatBackground(char);
        }

        function applyChatBackground(char) {
            const chatBody = document.getElementById('chat-body');
            if (!chatBody) return;
            
            if (char.chat_background) {
                chatBody.style.backgroundImage = `url(${char.chat_background})`;
                chatBody.style.backgroundSize = 'cover';
                chatBody.style.backgroundPosition = 'center';
                chatBody.style.backgroundRepeat = 'no-repeat';
                chatBody.style.backgroundAttachment = 'fixed';
            } else {
                chatBody.style.backgroundImage = '';
                chatBody.style.backgroundSize = '';
                chatBody.style.backgroundPosition = '';
                chatBody.style.backgroundRepeat = '';
                chatBody.style.backgroundAttachment = '';
            }
        }

        // å±•å¼€/æ”¶èµ·è‡ªå®šä¹‰æ ·å¼åŒºåŸŸ
        function toggleCustomStyleSection() {
            const section = document.getElementById('custom-style-section');
            const icon = document.getElementById('custom-style-toggle-icon');
            
            if (section.style.display === 'none' || !section.style.display) {
                section.style.display = 'block';
                icon.style.transform = 'rotate(90deg)';
            } else {
                section.style.display = 'none';
                icon.style.transform = 'rotate(0deg)';
            }
        }

        // ä¸¥æ ¼è¿‡æ»¤HTMLä¸­çš„JavaScript
        function sanitizeHTML(html) {
            if (!html) return '';
            
            // ç§»é™¤æ‰€æœ‰scriptæ ‡ç­¾
            html = html.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
            
            // ç§»é™¤æ‰€æœ‰äº‹ä»¶å¤„ç†å™¨å±æ€§ (on*)
            html = html.replace(/\s*on\w+\s*=\s*["'][^"']*["']/gi, '');
            html = html.replace(/\s*on\w+\s*=\s*[^\s>]*/gi, '');
            
            // ç§»é™¤ javascript: åè®®
            html = html.replace(/javascript:/gi, '');
            
            // ç§»é™¤ data: åè®®ï¼ˆå¯èƒ½åŒ…å«base64ç¼–ç çš„JSï¼‰
            html = html.replace(/data:text\/html/gi, '');
            
            return html;
        }

        // ä¸¥æ ¼è¿‡æ»¤CSSä¸­çš„JavaScript
        function sanitizeCSS(css) {
            if (!css) return '';
            
            // ç§»é™¤ javascript: åè®®
            css = css.replace(/javascript:/gi, '');
            
            // ç§»é™¤ expression() (IEç‰¹æœ‰ï¼Œå¯æ‰§è¡ŒJS)
            css = css.replace(/expression\s*\(/gi, '');
            
            // ç§»é™¤ @import url(javascript:...)
            css = css.replace(/@import\s+url\s*\(\s*["']?javascript:/gi, '@import url(');
            
            // ç§»é™¤ behavior: (IEç‰¹æœ‰)
            css = css.replace(/behavior\s*:/gi, 'removed-behavior:');
            
            // ç§»é™¤ -moz-binding (Firefoxç‰¹æœ‰ï¼Œå¯æ‰§è¡ŒJS)
            css = css.replace(/-moz-binding\s*:/gi, 'removed-binding:');
            
            return css;
        }

        // é¢„è§ˆè‡ªå®šä¹‰æ ·å¼
        async function previewCustomStyle() {
            if (!currentChatCharId) return;
            
            const char = await db.characters.get(currentChatCharId);
            if (!char) return;
            
            // ä¸´æ—¶ä¿å­˜å½“å‰è¾“å…¥çš„å†…å®¹
            const tempBubbleCSS = sanitizeCSS(document.getElementById('detail-bubble-css').value);
            const tempHTML = sanitizeHTML(document.getElementById('detail-custom-html').value);
            const tempCSS = sanitizeCSS(document.getElementById('detail-custom-css').value);
            
            // ä¸´æ—¶åº”ç”¨æ ·å¼
            applyCustomStyles({
                custom_bubble_css: tempBubbleCSS,
                custom_html: tempHTML,
                custom_css: tempCSS
            });
            
            alert('é¢„è§ˆæ•ˆæœå·²åº”ç”¨ï¼\nè¿”å›èŠå¤©ç•Œé¢æŸ¥çœ‹æ•ˆæœã€‚\nä¿å­˜åå°†æ°¸ä¹…ç”Ÿæ•ˆã€‚');
        }

        // æ¸…é™¤è‡ªå®šä¹‰æ ·å¼
        async function clearCustomStyle() {
            if (!confirm('ç¡®å®šè¦æ¸…é™¤æ‰€æœ‰è‡ªå®šä¹‰æ ·å¼å—ï¼Ÿ')) return;
            
            document.getElementById('detail-bubble-css').value = '';
            document.getElementById('detail-custom-html').value = '';
            document.getElementById('detail-custom-css').value = '';
            
            await saveChatDetail();
            
            // ç§»é™¤å·²åº”ç”¨çš„æ ·å¼
            removeCustomStyles();
            
            alert('è‡ªå®šä¹‰æ ·å¼å·²æ¸…é™¤ï¼');
        }

        // åº”ç”¨è‡ªå®šä¹‰æ ·å¼åˆ°èŠå¤©ç•Œé¢
        function applyCustomStyles(char) {
            if (!char) return;
            
            // ç§»é™¤ä¹‹å‰çš„è‡ªå®šä¹‰æ ·å¼
            removeCustomStyles();
            
            const chatContainer = document.getElementById('chat-body');
            if (!chatContainer) return;
            
            // åº”ç”¨æ°”æ³¡æ ·å¼ç±»åï¼ˆé»˜è®¤/ä»¿å¾®ä¿¡ï¼‰
            chatContainer.classList.remove('bubble-style-default', 'bubble-style-wechat');
            if (char.bubble_style === 'wechat') {
                chatContainer.classList.add('bubble-style-wechat');
            } else {
                chatContainer.classList.add('bubble-style-default');
            }
            
            // åº”ç”¨è‡ªå®šä¹‰æ°”æ³¡CSS
            if (char.custom_bubble_css) {
                const bubbleStyleId = 'custom-bubble-style';
                let styleTag = document.getElementById(bubbleStyleId);
                
                if (!styleTag) {
                    styleTag = document.createElement('style');
                    styleTag.id = bubbleStyleId;
                    document.head.appendChild(styleTag);
                }
                
                // åªåº”ç”¨åˆ°AIçš„æ¶ˆæ¯æ°”æ³¡
                styleTag.textContent = `.chat-bubble.ai-bubble { ${char.custom_bubble_css} }`;
            }
            
            // åº”ç”¨è‡ªå®šä¹‰CSS
            if (char.custom_css) {
                const cssStyleId = 'custom-chat-css';
                let styleTag = document.getElementById(cssStyleId);
                
                if (!styleTag) {
                    styleTag = document.createElement('style');
                    styleTag.id = cssStyleId;
                    document.head.appendChild(styleTag);
                }
                
                styleTag.textContent = char.custom_css;
            }
            
            // æ·»åŠ è‡ªå®šä¹‰HTMLå®¹å™¨
            if (char.custom_html) {
                const customContainer = document.createElement('div');
                customContainer.id = 'custom-chat-container';
                customContainer.innerHTML = char.custom_html;
                
                // æ’å…¥åˆ°èŠå¤©åŒºåŸŸé¡¶éƒ¨
                if (chatContainer.firstChild) {
                    chatContainer.insertBefore(customContainer, chatContainer.firstChild);
                } else {
                    chatContainer.appendChild(customContainer);
                }
            }
        }

        // ç§»é™¤è‡ªå®šä¹‰æ ·å¼
        function removeCustomStyles() {
            // ç§»é™¤æ°”æ³¡æ ·å¼
            const bubbleStyle = document.getElementById('custom-bubble-style');
            if (bubbleStyle) bubbleStyle.remove();
            
            // ç§»é™¤è‡ªå®šä¹‰CSS
            const cssStyle = document.getElementById('custom-chat-css');
            if (cssStyle) cssStyle.remove();
            
            // ç§»é™¤è‡ªå®šä¹‰HTMLå®¹å™¨
            const customContainer = document.getElementById('custom-chat-container');
            if (customContainer) customContainer.remove();
        }

        async function jumpToCharEditor() {
            if (!currentChatCharId) return;
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯è”æœºå¥½å‹
            const char = await db.characters.get(currentChatCharId);
            if (char && char.isOnlineFriend) {
                // è”æœºå¥½å‹åªæ˜¾ç¤ºç®€åŒ–ä¿¡æ¯
                showOnlineFriendProfile(char);
                return;
            }
            
            hideChatDetail();
            editCharacter(currentChatCharId);
        }
        
        // æ˜¾ç¤ºè”æœºå¥½å‹çš„ç®€åŒ–æ¡£æ¡ˆï¼ˆåªæœ‰åŸºæœ¬ä¿¡æ¯ï¼Œæ²¡æœ‰äººè®¾ï¼‰
        function showOnlineFriendProfile(char) {
            const avatar = char.avatar || '';
            const avatarStyle = avatar ? `background-image:url(${avatar})` : 'background:#e0e0e0';
            
            const html = `
                <div style="position:fixed; top:0; left:0; right:0; bottom:0; background:#f5f5f5; z-index:9999; display:flex; flex-direction:column;">
                    <div class="wechat-header" style="background:#fff;">
                        <div class="back-btn" onclick="this.closest('div[style*=position]').remove()" style="margin:0; background:none; width:40px; justify-content:flex-start; padding-left:0; color:var(--ins-text);">
                            <svg class="svg-icon" viewBox="0 0 24 24" style="width:28px; height:28px;"><polyline points="15 18 9 12 15 6"></polyline></svg>
                        </div>
                        <div class="wechat-title">è”æœºå¥½å‹èµ„æ–™</div>
                        <div style="width:40px;"></div>
                    </div>
                    
                    <div style="flex:1; overflow-y:auto; padding:20px;">
                        <!-- å¤´åƒå’ŒåŸºæœ¬ä¿¡æ¯ -->
                        <div style="text-align:center; padding:30px 0;">
                            <div style="width:100px; height:100px; border-radius:12px; margin:0 auto 16px; background-size:cover; background-position:center; ${avatarStyle}"></div>
                            <div style="font-size:20px; font-weight:600; color:#333; margin-bottom:8px;">${char.name || 'æœªçŸ¥'}</div>
                            <div style="font-size:14px; color:#999;">è”æœºå¥½å‹</div>
                        </div>
                        
                        <!-- ä¿¡æ¯å¡ç‰‡ -->
                        <div style="background:#fff; border-radius:12px; overflow:hidden; margin-bottom:16px;">
                            <div style="padding:16px; border-bottom:1px solid #f0f0f0; display:flex; justify-content:space-between;">
                                <span style="color:#666;">å¾®ä¿¡å·</span>
                                <span style="color:#333;">${char.identity?.account || 'æœªçŸ¥'}</span>
                            </div>
                            <div style="padding:16px; display:flex; justify-content:space-between;">
                                <span style="color:#666;">æ˜µç§°</span>
                                <span style="color:#333;">${char.name || 'æœªçŸ¥'}</span>
                            </div>
                        </div>
                        
                        <!-- æç¤ºä¿¡æ¯ -->
                        <div style="text-align:center; padding:20px; color:#999; font-size:13px;">
                            <div style="margin-bottom:8px;">ğŸŒ è¿™æ˜¯ä¸€ä½è”æœºå¥½å‹</div>
                            <div>å¯¹æ–¹çš„è¯¦ç»†èµ„æ–™ä¸å¯è§</div>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', html);
        }

        async function clearChatHistory() {
            if (!currentChatCharId) return;
            if (confirm("ç¡®å®šè¦æ¸…ç©ºä¸è¯¥è§’è‰²çš„èŠå¤©è®°å½•å—ï¼Ÿ")) {
                const char = await db.characters.get(currentChatCharId);
                const accountId = getCurrentAccountId();
                await setChatHistory(char, accountId, []);
                renderChatBody(char);
                alert("å·²æ¸…ç©º");
            }
        }
        
        // --- ä¸»åŠ¨å‘æ¶ˆæ¯é€»è¾‘ï¼ˆçº¯å‰ç«¯é©±åŠ¨ï¼‰---
        let syncTimer = null; // å®šæ—¶å™¨ï¼ˆä¿ç•™å˜é‡åå…¼å®¹æ€§ï¼‰
        
        // çº¯å‰ç«¯æ¨¡å¼ï¼šä¸éœ€è¦åŒæ­¥åˆ°åç«¯ï¼Œè§’è‰²æ•°æ®å…¨éƒ¨å­˜å‚¨åœ¨æœ¬åœ° IndexedDB
        async function syncCharactersToBackend() {
            // çº¯å‰ç«¯æ¨¡å¼ï¼šæ— éœ€åŒæ­¥ï¼Œä»…æ‰“å°æ—¥å¿—
            console.log('[Sync] çº¯å‰ç«¯æ¨¡å¼ï¼šè§’è‰²æ•°æ®å­˜å‚¨åœ¨æœ¬åœ°ï¼Œæ— éœ€åŒæ­¥åˆ°åç«¯');
        }
        
        // æ³¨å†Œ Service Workerï¼ˆçº¯å‰ç«¯ç‰ˆæœ¬ï¼šä»…ç”¨äº PWA å’Œæœ¬åœ°é€šçŸ¥ï¼‰
        async function registerServiceWorkerAndSubscribe() {
            if (!('serviceWorker' in navigator)) {
                console.log('[SW] Not supported');
                showDebugToast('âŒ æµè§ˆå™¨ä¸æ”¯æŒService Worker');
                return;
            }
            
            try {
                // æ³¨å†Œ Service Workerï¼ˆç‹¬ç«‹æ–‡ä»¶ï¼Œç”¨äº PWA åŠŸèƒ½ï¼‰
                const registration = await navigator.serviceWorker.register('./sw.js');
                console.log('[SW] Registered:', registration);
                showDebugToast('âœ“ Service Workerå·²æ³¨å†Œ');
                
                // ç­‰å¾…æ¿€æ´»
                await navigator.serviceWorker.ready;
                console.log('[ServiceWorker] Ready');
                
                // è¯·æ±‚é€šçŸ¥æƒé™ï¼ˆç”¨äºæœ¬åœ°é€šçŸ¥ï¼‰
                if ('Notification' in window) {
                    const permission = await Notification.requestPermission();
                    if (permission === 'granted') {
                        console.log('[Notification] âœ“ é€šçŸ¥æƒé™å·²æˆäºˆ');
                        showDebugToast('âœ“ é€šçŸ¥æƒé™å·²æˆäºˆ', true);
                    } else {
                        console.log('[Notification] âœ— é€šçŸ¥æƒé™è¢«æ‹’ç»');
                        showDebugToast('âœ— é€šçŸ¥æƒé™è¢«æ‹’ç»');
                    }
                }
                
                // çº¯å‰ç«¯æ¨¡å¼ï¼šä¸éœ€è¦ Web Push åç«¯è®¢é˜…
                // é€šçŸ¥å°†é€šè¿‡å‰ç«¯çš„ Notification API ç›´æ¥å‘é€
                console.log('[Push] çº¯å‰ç«¯æ¨¡å¼ï¼šä½¿ç”¨æœ¬åœ° Notification API å‘é€é€šçŸ¥');
                showDebugToast('âœ“ æœ¬åœ°é€šçŸ¥å·²å°±ç»ª', true);
                
            } catch (err) {
                console.error('[ServiceWorker] Error:', err);
                showDebugToast(`âœ— Service Workeré”™è¯¯: ${err.message}`);
            }
        }
        
        // Base64 è½¬ Uint8Array (ç”¨äº VAPID å…¬é’¥)
        function urlBase64ToUint8Array(base64String) {
            const padding = '='.repeat((4 - base64String.length % 4) % 4);
            const base64 = (base64String + padding)
                .replace(/\-/g, '+')
                .replace(/_/g, '/');
            
            const rawData = window.atob(base64);
            const outputArray = new Uint8Array(rawData.length);
            
            for (let i = 0; i < rawData.length; ++i) {
                outputArray[i] = rawData.charCodeAt(i);
            }
            return outputArray;
        }
        
        // çº¯å‰ç«¯æ¨¡å¼ï¼šä¸éœ€è¦ WebSocket è¿æ¥
        // ä¸»åŠ¨æ¶ˆæ¯å®Œå…¨ç”±å‰ç«¯å®šæ—¶å™¨é©±åŠ¨
        function connectWebSocket() {
            console.log('[WebSocket] çº¯å‰ç«¯æ¨¡å¼ï¼šä¸éœ€è¦ WebSocket è¿æ¥');
            console.log('[WebSocket] ä¸»åŠ¨æ¶ˆæ¯ç”±å‰ç«¯å®šæ—¶å™¨é©±åŠ¨');
        }
        
        // å¯åŠ¨ä¸»åŠ¨èŠå¤©æ£€æµ‹å¾ªç¯ï¼ˆçº¯å‰ç«¯ç‰ˆæœ¬ï¼‰
        async function startAutoChatLoop() {
            if (syncTimer) clearInterval(syncTimer);
            
            console.log('[AutoChat] å¯åŠ¨çº¯å‰ç«¯ä¸»åŠ¨èŠå¤©æ¨¡å¼...');
            console.log('[AutoChat] å½“å‰ç¯å¢ƒ:', {
                protocol: location.protocol,
                hostname: location.hostname,
                href: location.href,
                serviceWorkerSupported: 'serviceWorker' in navigator,
                notificationSupported: 'Notification' in window,
                notificationPermission: Notification.permission
            });
            showDebugToast('ä¸»åŠ¨èŠå¤©æ£€æµ‹å¯åŠ¨ä¸­...', true);
            
            // çº¯å‰ç«¯æ¨¡å¼ï¼šä¸éœ€è¦ WebSocket è¿æ¥
            console.log('[AutoChat] çº¯å‰ç«¯æ¨¡å¼ï¼šç”±å‰ç«¯å®šæ—¶å™¨é©±åŠ¨ä¸»åŠ¨æ¶ˆæ¯');
            
            // 5. æ¯15ç§’æ£€æŸ¥ä¸€æ¬¡æ˜¯å¦è¯¥å‘æ¶ˆæ¯ï¼ˆç«‹å³è§¦å‘ï¼Œæ— åç«¯è½®è¯¢å»¶è¿Ÿï¼‰
            setInterval(() => {
                checkAutoChat(); // å‰ç«¯ä¸»åŠ¨æ£€æŸ¥
            }, 15 * 1000);
            
            // ç«‹å³æ£€æŸ¥ä¸€æ¬¡
            checkAutoChat();
            
            // 6. ç›‘å¬é¡µé¢å¯è§æ€§å˜åŒ–ï¼Œä»åå°åˆ‡å›æ—¶ç«‹å³æ£€æŸ¥
            document.addEventListener('visibilitychange', function() {
                if (!document.hidden) {
                    console.log('[AutoChat] âœ“ Page became visible, checking for pending messages...');
                    showDebugToast('âœ“ è¿”å›å‰å°ï¼Œæ£€æŸ¥æ¶ˆæ¯...');
                    
                    // ç«‹å³æ£€æŸ¥æ˜¯å¦æœ‰è¯¥å‘çš„æ¶ˆæ¯ï¼ˆå¯èƒ½åœ¨åå°æ—¶é”™è¿‡äº†ï¼‰
                    setTimeout(() => {
                        checkAutoChat();
                    }, 500);
                    
                    // å¦‚æœä¿æ´»å·²å¼€å¯ä¸”éŸ³é¢‘æš‚åœï¼Œé‡æ–°å¯åŠ¨
                    const keepaliveEnabled = localStorage.getItem('keepalive_enabled') === 'true';
                    if (keepaliveEnabled && keepAliveAudio && keepAliveAudio.paused) {
                        console.log('[KeepAlive] é¡µé¢æ¢å¤å¯è§ï¼Œé‡æ–°å¯åŠ¨ä¿æ´»');
                        showDebugToast('âœ“ é‡å¯ä¿æ´»éŸ³é¢‘...');
                        startKeepAlive();
                    }
                }
            });
            
            console.log('[AutoChat] âœ“ Setup complete!');
            showDebugToast('âœ“ å®æ—¶æ¨é€å·²å¯åŠ¨ï¼', true);
        }

        async function checkAutoChat() {
            const now = Date.now();
            // è·å–å¼€å¯äº†ä¸»åŠ¨èŠå¤©çš„è§’è‰²
            const chars = await db.characters
                .filter(c => c.auto_reply_enabled === true && c.auto_reply_interval > 0)
                .toArray();

            if (chars.length > 0) {
                console.log(`[AutoChat] Check triggered at ${new Date().toLocaleTimeString()} for ${chars.length} enabled chars`);
            }

            const accountId = getCurrentAccountId();
            for (const char of chars) {
                // å¦‚æœæ˜¯å¥½å‹çŠ¶æ€æ‰è§¦å‘ï¼ˆæŒ‰è´¦å·æ£€æŸ¥ï¼‰
                const status = getFriendStatus(char, accountId);
                if (status !== 'friend') continue;

                // é˜²æ­¢å¹¶å‘ï¼šå¦‚æœè¿™ä¸ªè§’è‰²æ­£åœ¨ç”Ÿæˆä¸­ï¼Œè·³è¿‡
                if (autoChatLocks.has(char.id)) {
                    console.log(`[AutoChat] Skipping ${char.name} (locked/generating)`);
                    continue;
                }

                // æ£€æŸ¥ä¸Šæ¬¡æ¶ˆæ¯æ—¶é—´ï¼ˆæŒ‰è´¦å·ï¼‰
                let lastTime = 0;
                const history = getChatHistory(char, accountId);
                if (history && history.length > 0) {
                    lastTime = history[history.length - 1].time;
                } else {
                    // å¦‚æœæ²¡æœ‰å†å²æ¶ˆæ¯ï¼Œä»¥åˆ›å»ºæ—¶é—´æˆ–æ›´æ–°æ—¶é—´ä¸ºå‡†
                    lastTime = char.updated_at || 0;
                }

                const diffMinutes = (now - lastTime) / (1000 * 60);
                
                // å®½å®¹åº¦ 0.1 åˆ†é’Ÿï¼ˆ6ç§’ï¼‰ï¼Œé¿å…å› ä¸ºæ‰§è¡Œè€—æ—¶å¯¼è‡´åˆšå¥½é”™è¿‡
                // ä¾‹å¦‚é—´éš”1åˆ†é’Ÿï¼Œdiffæ˜¯ 0.95åˆ†é’Ÿï¼Œä¹Ÿå…è®¸è§¦å‘
                if (diffMinutes >= (char.auto_reply_interval - 0.1)) {
                    // è§¦å‘ä¸»åŠ¨æ¶ˆæ¯
                    console.log(`[AutoChat] âœ“âœ“âœ“ Triggering for ${char.name} (Interval: ${char.auto_reply_interval}, Last msg: ${diffMinutes.toFixed(2)} mins ago)`);
                    
                    // ç”ŸæˆAIæ¶ˆæ¯ï¼ˆå†…éƒ¨ä¼šè‡ªåŠ¨æ¨é€é€šçŸ¥ï¼‰
                    triggerAutoChat(char);
                }
            }
        }

        async function triggerAutoChat(char) {
            // åŠ é”
            autoChatLocks.add(char.id);

            try {
                // 1. å‡†å¤‡ä¸Šä¸‹æ–‡
                let userDesc = "";
                let userName = "ç”¨æˆ·";
                if (char.linked_user_id) {
                    const user = await db.characters.get(char.linked_user_id);
                    if (user) {
                        userName = user.name;
                        userDesc = `\n\nã€å¯¹è¯å¯¹è±¡(User)ä¿¡æ¯ã€‘\nåå­—ï¼š${user.name}\nè®¾å®šï¼š${user.description || 'æ— '}`;
                    }
                }
                
                const accountId = getCurrentAccountId();
                let loreContext = "";
                const lorebookIds = char.lorebookIds || (char.lorebookId ? [char.lorebookId] : []);
                if (lorebookIds.length > 0) {
                    const history = getChatHistory(char, accountId);
                    const recentText = (history || []).slice(-10).map(m => m.content).join(' ');
                    loreContext = await getLorebookContext(lorebookIds, `${char.name} ${userName} ${recentText}`);
                }

                // è®¡ç®—è™šæ‹Ÿæ—¶é—´
                const virtualTimeStr = getFormattedVirtualTime(char.timeOffset);

                // 2. æ„å»º Prompt
                const systemPrompt = `ä½ æ­£åœ¨è¿›è¡Œè§’è‰²æ‰®æ¼”ã€‚
ã€å½“å‰æ—¶é—´ã€‘
${virtualTimeStr}

ã€è§’è‰²(ä½ )ä¿¡æ¯ã€‘
åå­—ï¼š${char.name}
${char.nick ? `æ˜µç§°ï¼š${char.nick}` : ''}
è®¾å®šï¼š
${char.description || ''}

${userDesc}
${loreContext}

ç°åœ¨è·ç¦»ä¸Šæ¬¡å¯¹è¯å·²ç»è¿‡å»äº†ä¸€æ®µæ—¶é—´ã€‚è¯·æ ¹æ®è§’è‰²æ€§æ ¼ï¼Œä¸»åŠ¨å‘ ${userName} å‘èµ·æ–°çš„è¯é¢˜ï¼Œæˆ–è€…å»¶ç»­ä¹‹å‰æœªå°½çš„è¯é¢˜ã€‚

ã€å¯ç”¨ç‰¹æ®ŠæŒ‡ä»¤ã€‘
- **æ’¤å›æ¶ˆæ¯**ï¼šä½¿ç”¨ ((RECALL)) å¯ä»¥æ’¤å›ä½ åˆšæ‰å‘é€çš„æœ€åä¸€æ¡æ¶ˆæ¯ï¼ˆé€‚ç”¨äºå‘é”™æ¶ˆæ¯ã€è¯´é”™è¯ã€åæ‚”ç­‰åœºæ™¯ï¼‰

ã€é‡è¦æŒ‡ä»¤ - å¿…é¡»ä¸¥æ ¼éµå®ˆã€‘
1. **å¿…é¡»**æ¨¡æ‹Ÿå¾®ä¿¡è¿å‘æ¶ˆæ¯çš„ä¹ æƒ¯ï¼šè¯·ç”Ÿæˆ 2 åˆ° 4 æ¡çŸ­æ¶ˆæ¯ï¼Œä¸èƒ½åªå‘ä¸€æ¡ï¼
2. **å¿…é¡»**ä½¿ç”¨åˆ†éš”ç¬¦ "|||" æ¥éš”å¼€æ¯ä¸€æ¡æ¶ˆæ¯ã€‚
3. **ä¸¥ç¦ä½¿ç”¨é€—å·**ï¼ˆåŒ…æ‹¬ä¸­æ–‡é€—å·å’Œè‹±æ–‡é€—å·ï¼‰ã€‚å¦‚æœæƒ³è¡¨è¾¾åœé¡¿ï¼Œè¯·ç›´æ¥æ‹†åˆ†æˆä¸‹ä¸€æ¡æ¶ˆæ¯ï¼Œæˆ–è€…ç”¨ç©ºæ ¼ä»£æ›¿ã€‚
   - é”™è¯¯ç¤ºä¾‹ï¼šå˜¿åœ¨å—ï¼Ÿåˆšåˆšçœ‹åˆ°ä¸ªå¥½ç©çš„è§†é¢‘ï¼Œå‘ç»™ä½ çœ‹çœ‹
   - æ­£ç¡®ç¤ºä¾‹ï¼šå˜¿åœ¨å—ï¼Ÿ|||åˆšåˆšçœ‹åˆ°ä¸ªå¥½ç©çš„è§†é¢‘|||å‘ç»™ä½ çœ‹çœ‹
4. æ¯æ¡æ¶ˆæ¯è¦ç®€çŸ­ï¼Œ5-15ä¸ªå­—æœ€ä½³ï¼ŒåƒçœŸå®å¾®ä¿¡èŠå¤©ä¸€æ ·åˆ†å¤šæ¡å‘é€ã€‚
5. ä¸¥ç¦åªå‘é€æ ‡ç‚¹ç¬¦å·ã€‚æ¯ä¸€æ¡æ¶ˆæ¯éƒ½å¿…é¡»æœ‰å®é™…æ–‡å­—å†…å®¹ã€‚
6. è¯­æ°”è¦è‡ªç„¶ã€å£è¯­åŒ–ï¼Œç¬¦åˆäººè®¾ã€‚

è¯·åŠ¡å¿…è¾“å‡ºæ ¼å¼å¦‚ï¼šç¬¬ä¸€æ¡æ¶ˆæ¯å†…å®¹|||ç¬¬äºŒæ¡æ¶ˆæ¯å†…å®¹|||ç¬¬ä¸‰æ¡æ¶ˆæ¯å†…å®¹

ã€é‡è¦ã€‘ä½ éœ€è¦åŒæ—¶ç”Ÿæˆä¸¤ä¸ªå†…å®¹ï¼š
1. **å›å¤å†…å®¹**ï¼šä¸»åŠ¨å‘é€çš„æ¶ˆæ¯ï¼ˆç”¨|||åˆ†éš”çš„å¤šæ¡æ¶ˆæ¯ï¼‰
2. **å¿ƒå£°å†…å®¹**ï¼šè§’è‰²å½“å‰çš„å¿ƒç†æ´»åŠ¨ã€æƒ³æ³•ã€æ„Ÿå—æˆ–çŠ¶æ€å˜åŒ–

è¯·ä»¥JSONæ ¼å¼è¿”å›ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š
{
  "reply": "ç¬¬ä¸€æ¡æ¶ˆæ¯|||ç¬¬äºŒæ¡æ¶ˆæ¯|||ç¬¬ä¸‰æ¡æ¶ˆæ¯",
  "thought": "è§’è‰²çš„å¿ƒå£°/å¿ƒç†æ´»åŠ¨/æƒ³æ³•"
}

è¯·ä¸¥æ ¼è¿”å›JSONæ ¼å¼ï¼Œä¸è¦åŒ…å«Markdownä»£ç å—æ ‡è®°ã€‚`;

                // å–æœ€è¿‘ 10 æ¡å†å²è®°å½•ä½œä¸ºå‚è€ƒï¼ˆæŒ‰è´¦å·ï¼‰
                const history = getChatHistory(char, accountId);
                const recentHistory = (history || []).slice(-10)
                    .filter(m => m.content && m.content.trim()) // è¿‡æ»¤ç©ºæ¶ˆæ¯
                    .map(m => ({
                        role: m.role === 'char' ? 'assistant' : 'user',
                        content: m.content
                    }));

                const messages = [
                    { role: 'system', content: systemPrompt },
                    ...recentHistory
                ];

                // 3. è°ƒç”¨ AI
                const aiResponse = await callAI(messages);
                
                let cleanReply = "";
                let thought = "";
                
                // ä½¿ç”¨å¢å¼ºçš„æå–å‡½æ•°
                const parsed = extractAndParseJSON(aiResponse);
                
                if (parsed) {
                    cleanReply = parsed.reply || parsed.content || parsed.message || "";
                    thought = parsed.thought || "";
                    
                    // ç‰¹æ®Šå¤„ç†ï¼šå¦‚æœæ˜¯è½¬è´¦å¯¹è±¡ä¸”ä¸åœ¨replyå­—æ®µä¸­ï¼Œå¯èƒ½æ•´ä¸ªå¯¹è±¡å°±æ˜¯æ¶ˆæ¯
                    if (!cleanReply && parsed.amount && parsed.status) {
                        cleanReply = JSON.stringify(parsed);
                    }
                }
                
                // å¦‚æœæå–å¤±è´¥æˆ–æ²¡æœ‰å†…å®¹ï¼Œå°è¯•åŸå§‹è§£ææˆ–ç›´æ¥ä½¿ç”¨æ–‡æœ¬
                    if (!cleanReply) {
                    // æ¸…ç†å¸¸è§è£…é¥°å­—ç¬¦
                    let cleanResponse = aiResponse.trim().replace(/[â—‡â—†â˜…â˜†â—â—‹â– â–¡â–²â–³]/g, '');
                    
                    // å°è¯•ç®€å•çš„æ­£åˆ™æå–å…œåº•
                    const replyMatch = cleanResponse.match(/"reply"\s*:\s*"([\s\S]*?)"/);
                    if (replyMatch) {
                        cleanReply = replyMatch[1]
                            .replace(/\\n/g, '\n')
                            .replace(/\\"/g, '"')
                            .replace(/\\t/g, '\t')
                            .replace(/\\\\/g, '\\');
                    } else {
                        cleanReply = cleanResponse || "(AI è¿”å›ä¸ºç©º)";
                    }
                    }
                    
                    // å­˜å‚¨å¿ƒå£°åˆ°è§’è‰²å¯¹è±¡
                    if (thought && thought.trim()) {
                        const freshChar = await db.characters.get(char.id);
                        if (freshChar) {
                            if (!freshChar.thoughts) freshChar.thoughts = [];
                            const currentHistory = getChatHistory(freshChar, accountId);
                            freshChar.thoughts.push({
                                content: thought.trim(),
                                time: Date.now(),
                                messageIndex: currentHistory ? currentHistory.length : 0
                            });
                            // åªä¿ç•™æœ€è¿‘50æ¡å¿ƒå£°
                            if (freshChar.thoughts.length > 50) {
                                freshChar.thoughts = freshChar.thoughts.slice(-50);
                            }
                            await db.characters.put(freshChar);
                        }
                    }
                
                // âœ… ä¿®å¤ï¼šæ¸…ç†æœ«å°¾å¤šä½™çš„ ]
                function cleanMessage(text) {
                    if (!text) return text;
                    // åˆ é™¤æœ«å°¾å¤šä½™çš„ ]
                    return text.replace(/\]+$/, '');
                }
                
                // æ¸…ç†å›å¤å†…å®¹
                let cleanReplyProcessed = cleanMessage(cleanReply);
                const replyText = cleanReplyProcessed;
                
                if (!cleanReplyProcessed || !cleanReplyProcessed.trim()) {
                    console.warn(`[AutoChat] AI returned empty reply for ${char.name}`);
                    return;
                }

                // âœ… å…³é”®æ”¹åŠ¨ï¼šåœ¨æ‹†åˆ†å‰ï¼Œå…ˆæ£€æµ‹æ˜¯å¦åŒ…å«"æŒ‡ä»¤å‹æ¶ˆæ¯"ï¼ˆè½¬è´¦ç­‰ï¼‰
                // æ£€æµ‹ ((TRANSFER: é‡‘é¢, å¤‡æ³¨)) æ ¼å¼ - åœ¨ cleanReplyProcessed ä¸ŠåŒ¹é…ï¼Œç¡®ä¿ index ä½ç½®æ­£ç¡®
                const transferMatch = cleanReplyProcessed.match(/\(\(TRANSFER:\s*(\d+(\.\d+)?)(?:,\s*(.+?))?\)\)/i);
                
                if (transferMatch) {
                    // æå–è½¬è´¦ä¿¡æ¯
                    const amount = parseFloat(transferMatch[1]);
                    let note = transferMatch[3] || 'è½¬è´¦';
                    // é™åˆ¶å¤‡æ³¨é•¿åº¦ï¼Œä¸è¶…è¿‡10ä¸ªå­—
                    if (note.length > 10) {
                        note = note.substring(0, 10);
                    }
                    
                    // æå–è½¬è´¦å‰é¢çš„æ–‡å­—å†…å®¹ï¼ˆå¦‚æœæœ‰ï¼‰- ç°åœ¨ index ä½ç½®æ­£ç¡®äº†
                    const textBeforeTransfer = cleanMessage(cleanReplyProcessed.substring(0, transferMatch.index).trim());
                    
                    const freshChar = await db.characters.get(char.id);
                    if (freshChar) {
                        let history = getChatHistory(freshChar, accountId);
                        
                        // 1. å…ˆå‘é€æ–‡å­—æ¶ˆæ¯ï¼ˆå¦‚æœæœ‰ï¼‰- æ”¯æŒåˆ†å‰²æˆå¤šæ¡
                        if (textBeforeTransfer) {
                            // å¯¹è½¬è´¦å‰çš„æ–‡å­—è¿›è¡Œåˆ†å‰²å¤„ç†
                            let textSegments = [];
                            const textToSplit = textBeforeTransfer.replace(/[,ï¼Œ]/g, ' ');
                            if (textToSplit.includes('|||')) {
                                textSegments = textToSplit.split('|||').map(s => cleanMessage(s.trim())).filter(s => s.length > 0);
                            } else {
                                textSegments = splitMessage(textToSplit);
                            }
                            
                            // è¿‡æ»¤å¤ªçŸ­çš„æ®µè½
                            textSegments = textSegments.filter(seg => seg.replace(/[.,ï¼Œã€‚!?ï¼ï¼Ÿ~â€¦\s]/g, '').length >= 2);
                            
                            // å¦‚æœåˆ†å‰²åä¸ºç©ºï¼Œä½†åŸæ–‡æœ¬æœ‰å†…å®¹ï¼Œä½¿ç”¨åŸæ–‡æœ¬
                            if (textSegments.length === 0 && textBeforeTransfer.replace(/[.,ï¼Œã€‚!?ï¼ï¼Ÿ~â€¦\s]/g, '').length > 0) {
                                textSegments = [textBeforeTransfer];
                            }
                            
                            // é€æ¡å‘é€æ–‡å­—æ¶ˆæ¯
                            for (let i = 0; i < textSegments.length; i++) {
                                const seg = textSegments[i];
                                const textMsg = {
                                    role: 'char',
                                    content: seg,
                                    time: Date.now() + i // ç¡®ä¿æ—¶é—´æˆ³é€’å¢
                                };
                                history.push(textMsg);
                                await setChatHistory(freshChar, accountId, history);
                                
                                // æ¸²æŸ“æ–‡å­—æ¶ˆæ¯
                                if (currentChatCharId === freshChar.id) {
                                    await appendMessageToUI('char', seg, freshChar.avatar);
                                }
                                
                                // æ¯æ¡æ¶ˆæ¯ä¹‹é—´ç¨å¾®å»¶æ—¶
                                if (i < textSegments.length - 1) {
                                    await new Promise(r => setTimeout(r, 300));
                                }
                            }
                            
                            // æœ€åä¸€æ¡æ–‡å­—æ¶ˆæ¯åç¨å¾®å»¶æ—¶å†å‘è½¬è´¦
                            await new Promise(r => setTimeout(r, 500));
                        }
                        
                        // 2. å†å‘é€è½¬è´¦å¡ç‰‡
                        const transferData = {
                            amount: amount.toFixed(2),
                            desc: note,
                            status: 'sent'
                        };
                        
                        const transferMsg = { 
                            role: 'char', 
                            type: 'transfer', // æ˜ç¡®æ ‡è®°ä¸ºè½¬è´¦æ¶ˆæ¯
                            content: JSON.stringify(transferData), 
                            time: Date.now(),
                            id: 'trans_' + Date.now()
                        };
                        
                        history.push(transferMsg);
                        await setChatHistory(freshChar, accountId, history);
                        
                        console.log(`[AutoChat] Sent transfer message for ${freshChar.name}`);
                        addLog('success', `è§’è‰²å‘é€è½¬è´¦: ${freshChar.name}`, { amount, note });
                        
                        // æ¸²æŸ“è½¬è´¦å¡ç‰‡ - ä½¿ç”¨ appendMessageToUI è¿½åŠ ï¼Œé¿å…é‡æ–°æ¸²æŸ“æ•´ä¸ªèŠå¤©
                        if (currentChatCharId === freshChar.id) {
                            await appendMessageToUI('char', JSON.stringify(transferData), freshChar.avatar);
                        }
                        
                        // å‘é€é€šçŸ¥ï¼ˆçº¯å‰ç«¯ï¼šç›´æ¥ä½¿ç”¨æœ¬åœ°é€šçŸ¥ï¼‰
                        sendSystemNotification(freshChar.name, '[è½¬è´¦]');
                        
                        // åˆ·æ–°å¾®ä¿¡åˆ—è¡¨
                        if (currentChatCharId !== freshChar.id) {
                            const wechatPage = document.getElementById('wechat-page');
                            if (wechatPage.style.display !== 'none' && 
                                document.querySelector('.wechat-tab-item.active .tab-name').innerText === 'å¾®ä¿¡') {
                                renderWechatList(document.getElementById('wechat-content'));
                            }
                        }
                    }
                    return; // è½¬è´¦å¤„ç†å®Œæˆï¼Œä¸å†æ‰§è¡Œåç»­é€»è¾‘
                }
                
                // ğŸ¯ æ£€æµ‹æ’¤å›æŒ‡ä»¤ ((RECALL)) - AIè§’è‰²å¯ä»¥æ’¤å›è‡ªå·±æœ€åä¸€æ¡æ¶ˆæ¯
                const recallMatch = cleanReplyProcessed.match(/\(\(RECALL(?::\s*(\d+))?\)\)/i);
                if (recallMatch) {
                    const freshChar = await db.characters.get(char.id);
                    if (freshChar) {
                        let history = getChatHistory(freshChar, accountId);
                        
                        // æå–æ’¤å›æŒ‡ä»¤å‰é¢çš„æ–‡å­—å†…å®¹ï¼ˆå¦‚æœæœ‰ï¼‰
                        const textBeforeRecall = cleanMessage(cleanReplyProcessed.substring(0, recallMatch.index).trim());
                        
                        // æ‰¾AIæœ€åä¸€æ¡æ¶ˆæ¯ï¼ˆéæ’¤å›çŠ¶æ€ï¼‰
                        let targetIndex = -1;
                        for (let i = history.length - 1; i >= 0; i--) {
                            if (history[i].role === 'char' && !history[i].isRecalled) {
                                targetIndex = i;
                                break;
                            }
                        }
                        
                        if (targetIndex >= 0 && history[targetIndex].role === 'char') {
                            // ä¿å­˜åŸå†…å®¹å¹¶æ ‡è®°ä¸ºå·²æ’¤å›
                            const originalContent = history[targetIndex].content;
                            history[targetIndex].recalledContent = originalContent;
                            history[targetIndex].isRecalled = true;
                            history[targetIndex].content = "";
                            
                            await setChatHistory(freshChar, accountId, history);
                            
                            console.log(`[AutoChat] ${freshChar.name} æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯`);
                            addLog('info', `è§’è‰²æ’¤å›æ¶ˆæ¯: ${freshChar.name}`, { originalContent: originalContent.substring(0, 50) });
                            
                            // æ›´æ–°UI - å±…ä¸­ç³»ç»Ÿæç¤ºæ ·å¼
                            if (currentChatCharId === freshChar.id) {
                                const chatBody = document.getElementById('chat-body');
                                const messageRows = chatBody.querySelectorAll('.message-row');
                                if (messageRows[targetIndex]) {
                                    const msgRow = messageRows[targetIndex];
                                    msgRow.className = 'message-row recalled-system-row';
                                    msgRow.innerHTML = '';
                                    
                                    const systemTip = document.createElement('div');
                                    systemTip.className = 'recalled-system-tip';
                                    systemTip.innerHTML = `"${freshChar.name}"æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯`;
                                    systemTip.style.cursor = 'pointer';
                                    systemTip.onclick = (e) => {
                                        e.stopPropagation();
                                        showRecalledContent(freshChar.name, originalContent);
                                    };
                                    msgRow.appendChild(systemTip);
                                }
                            }
                            
                            // å‘é€é€šçŸ¥
                            sendSystemNotification(freshChar.name, 'æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯');
                        }
                        
                        // å¦‚æœæ’¤å›æŒ‡ä»¤å‰æœ‰æ–‡å­—ï¼Œç»§ç»­å¤„ç†è¿™äº›æ–‡å­—
                        if (textBeforeRecall && textBeforeRecall.trim()) {
                            cleanReplyProcessed = textBeforeRecall;
                            // ä¸returnï¼Œç»§ç»­å¤„ç†å‰é¢çš„æ–‡å­—
                        } else {
                            return; // åªæœ‰æ’¤å›æŒ‡ä»¤ï¼Œå¤„ç†å®Œæˆ
                        }
                    }
                }
                
                // ğŸ¯ æ£€æµ‹äº²å±å¡èµ é€æŒ‡ä»¤ ((FAMILY_CARD: é¢åº¦))
                const familyCardMatch = cleanReplyProcessed.match(/\(\(FAMILY_CARD:\s*(\d+)\)\)/i);
                if (familyCardMatch) {
                    const monthlyLimit = parseInt(familyCardMatch[1]) || 0;
                    
                    // æå–äº²å±å¡æŒ‡ä»¤å‰é¢çš„æ–‡å­—å†…å®¹ï¼ˆå¦‚æœæœ‰ï¼‰
                    const textBeforeFamilyCard = cleanMessage(cleanReplyProcessed.substring(0, familyCardMatch.index).trim());
                    
                    const freshChar = await db.characters.get(char.id);
                    if (freshChar) {
                        let history = getChatHistory(freshChar, accountId);
                        
                        // 1. å…ˆå‘é€æ–‡å­—æ¶ˆæ¯ï¼ˆå¦‚æœæœ‰ï¼‰
                        if (textBeforeFamilyCard) {
                            let textSegments = [];
                            const textToSplit = textBeforeFamilyCard.replace(/[,ï¼Œ]/g, ' ');
                            if (textToSplit.includes('|||')) {
                                textSegments = textToSplit.split('|||').map(s => s.trim()).filter(s => s.length > 0);
                            } else {
                                textSegments = splitMessage(textToSplit);
                            }
                            textSegments = textSegments.filter(seg => seg.replace(/[.,ï¼Œã€‚!?ï¼ï¼Ÿ~â€¦\s]/g, '').length >= 2);
                            if (textSegments.length === 0 && textBeforeFamilyCard.replace(/[.,ï¼Œã€‚!?ï¼ï¼Ÿ~â€¦\s]/g, '').length > 0) {
                                textSegments = [textBeforeFamilyCard];
                            }
                            
                            for (let i = 0; i < textSegments.length; i++) {
                                const seg = textSegments[i];
                                history.push({ role: 'char', content: seg, time: Date.now() + i });
                                await setChatHistory(freshChar, accountId, history);
                                if (currentChatCharId === freshChar.id) {
                                    await appendMessageToUI('char', seg, freshChar.avatar);
                                }
                                if (i < textSegments.length - 1) {
                                    await new Promise(r => setTimeout(r, 300));
                                }
                            }
                            await new Promise(r => setTimeout(r, 500));
                        }
                        
                        // 2. å‘é€äº²å±å¡æ¶ˆæ¯
                        const user = await db.characters.get(parseInt(currentMyCharId));
                        
                        // åœ¨è§’è‰²æ•°æ®ä¸­æ·»åŠ "æˆ‘èµ é€çš„"
                        if (!freshChar.identity) freshChar.identity = {};
                        if (!freshChar.identity.familyCardsGiven) freshChar.identity.familyCardsGiven = [];
                        freshChar.identity.familyCardsGiven.push({
                            charId: parseInt(currentMyCharId),
                            monthlyLimit: monthlyLimit,
                            usedThisMonth: 0,
                            records: [],
                            createdAt: Date.now()
                        });
                        await db.characters.put(freshChar);
                        
                        // åœ¨ç”¨æˆ·æ•°æ®ä¸­æ·»åŠ "æˆ‘æ”¶åˆ°çš„"
                        if (user) {
                            if (!user.identity) user.identity = {};
                            if (!user.identity.familyCardsReceived) user.identity.familyCardsReceived = [];
                            user.identity.familyCardsReceived.push({
                                charId: freshChar.id,
                                monthlyLimit: monthlyLimit,
                                usedThisMonth: 0,
                                records: [],
                                createdAt: Date.now()
                            });
                            await db.characters.put(user);
                        }
                        
                        // å‘é€äº²å±å¡æ¶ˆæ¯åˆ°èŠå¤©
                        const familyCardMsg = {
                            role: 'char',
                            type: 'familyCard',
                            content: JSON.stringify({
                                fromName: freshChar.name,
                                monthlyLimit: monthlyLimit,
                                status: 'sent'
                            }),
                            time: Date.now()
                        };
                        
                        history = getChatHistory(freshChar, accountId);
                        history.push(familyCardMsg);
                        await setChatHistory(freshChar, accountId, history);
                        
                        if (currentChatCharId === freshChar.id) {
                            renderChatBody(freshChar);
                        }
                        
                        sendSystemNotification(freshChar.name, '[äº²å±å¡]');
                    }
                    return;
                }
                
                // ğŸ¯ 3. æ£€æµ‹æœ‹å‹åœˆå‘å¸ƒæŒ‡ä»¤ [MOMENTS] - æ”¯æŒå¤šç§æ ¼å¼
                // æ ¼å¼1: [MOMENTS] content: xxx images: N
                let momentsMatch = cleanReplyProcessed.match(/\[MOMENTS\]\s*content:\s*([^\n]+)(?:\s*images?:\s*(\d+))?/i);
                // æ ¼å¼2: ((MOMENTS: å†…å®¹))
                if (!momentsMatch) {
                    momentsMatch = cleanReplyProcessed.match(/\(\(MOMENTS:\s*(.+?)\)\)/i);
                    if (momentsMatch) {
                        // è½¬æ¢ä¸ºæ ‡å‡†æ ¼å¼
                        momentsMatch = [momentsMatch[0], momentsMatch[1], '0'];
                    }
                }
                // æ ¼å¼3: ã€æœ‹å‹åœˆï¼šå†…å®¹ã€‘
                if (!momentsMatch) {
                    momentsMatch = cleanReplyProcessed.match(/ã€æœ‹å‹åœˆ[ï¼š:]\s*(.+?)ã€‘/);
                    if (momentsMatch) {
                        momentsMatch = [momentsMatch[0], momentsMatch[1], '0'];
                    }
                }
                
                if (momentsMatch) {
                    const momentContent = momentsMatch[1].trim();
                    const imageCount = momentsMatch[2] ? parseInt(momentsMatch[2]) : 0;
                    
                    // æå–æœ‹å‹åœˆæŒ‡ä»¤å‰é¢çš„æ–‡å­—å†…å®¹ï¼ˆå¦‚æœæœ‰ï¼‰
                    const textBeforeMoments = cleanMessage(cleanReplyProcessed.substring(0, momentsMatch.index).trim());
                    
                    const freshChar = await db.characters.get(char.id);
                    if (freshChar) {
                        let history = getChatHistory(freshChar, accountId);
                        
                        // 1. å…ˆå‘é€æ–‡å­—æ¶ˆæ¯ï¼ˆå¦‚æœæœ‰ï¼‰
                        if (textBeforeMoments) {
                            const textMsg = {
                                role: 'char',
                                content: textBeforeMoments,
                                time: Date.now()
                            };
                            history.push(textMsg);
                            await setChatHistory(freshChar, accountId, history);
                            
                            // æ¸²æŸ“æ–‡å­—æ¶ˆæ¯
                            if (currentChatCharId === freshChar.id) {
                                appendMessageToUI('char', textBeforeMoments, freshChar.avatar);
                            }
                            
                            // ç¨å¾®å»¶æ—¶ï¼Œè®©æ–‡å­—æ¶ˆæ¯å…ˆæ˜¾ç¤º
                            await new Promise(r => setTimeout(r, 500));
                        }
                        
                        // 2. å‘å¸ƒæœ‹å‹åœˆ
                        await publishMomentsByCharacter(freshChar, momentContent, imageCount);
                        
                        console.log(`[AutoChat] ${freshChar.name} å‘å¸ƒäº†æœ‹å‹åœˆ`);
                        addLog('success', `è§’è‰²å‘å¸ƒæœ‹å‹åœˆ: ${freshChar.name}`, { content: momentContent });
                        
                        // å‘é€é€šçŸ¥
                        sendSystemNotification(freshChar.name, '[æœ‹å‹åœˆ]');
                        
                        // åˆ·æ–°å¾®ä¿¡åˆ—è¡¨
                        if (currentChatCharId !== freshChar.id) {
                            const wechatPage = document.getElementById('wechat-page');
                            if (wechatPage.style.display !== 'none' && 
                                document.querySelector('.wechat-tab-item.active .tab-name').innerText === 'å¾®ä¿¡') {
                                renderWechatList(document.getElementById('wechat-content'));
                            }
                        }
                    }
                    return; // æœ‹å‹åœˆå¤„ç†å®Œæˆï¼Œä¸å†æ‰§è¡Œåç»­é€»è¾‘
                }
                
                // ğŸ¯ æ£€æµ‹"å¹»è§‰"ï¼šAIè¯´å‘äº†æœ‹å‹åœˆä½†æ²¡æœ‰æŒ‡ä»¤
                const hasMomentsClaim = /å‘äº†.*?æœ‹å‹åœˆ|æœ‹å‹åœˆ.*?å‘äº†|å‘å¸ƒ.*?åŠ¨æ€|æ›´æ–°.*?æœ‹å‹åœˆ|å‘ä¸ªæœ‹å‹åœˆ/i.test(cleanReplyProcessed);
                if (hasMomentsClaim) {
                    console.warn(`[AutoChat] âš ï¸ AIå¹»è§‰æ£€æµ‹ï¼š${char.name} è¯´å‘äº†æœ‹å‹åœˆï¼Œä½†æ²¡æœ‰è¿”å›æ­£ç¡®çš„æŒ‡ä»¤æ ¼å¼ï¼`);
                    console.warn(`[AutoChat] æ­£ç¡®æ ¼å¼ç¤ºä¾‹ï¼š[MOMENTS] content: å†…å®¹ images: 1`);
                    // ç»™ç”¨æˆ·ä¸€ä¸ªæç¤º
                    showToast(`${char.name}è¯´å‘äº†æœ‹å‹åœˆï¼Œä½†æ ¼å¼ä¸å¯¹ï¼Œæœªå®é™…å‘å¸ƒ`);
                }
                
                // å…œåº•ï¼šæ£€æµ‹æ˜¯å¦æ˜¯è½¬è´¦ JSONï¼ˆå…¼å®¹æ—§æ ¼å¼ï¼‰
                let trimmedReply = cleanMessage(cleanReplyProcessed.trim());
                if (trimmedReply.startsWith('{') && trimmedReply.includes('"amount"')) {
                    try {
                        const parsed = JSON.parse(trimmedReply);
                        if (parsed.amount && parsed.desc !== undefined && parsed.status) {
                            const freshChar = await db.characters.get(char.id);
                            if (freshChar) {
                                let history = getChatHistory(freshChar, accountId);
                                
                                const newMsg = { 
                                    role: 'char', 
                                    type: 'transfer',
                                    content: trimmedReply, 
                                    time: Date.now(),
                                    id: 'trans_' + Date.now()
                                };
                                
                                history.push(newMsg);
                                await setChatHistory(freshChar, accountId, history);
                                
                                if (currentChatCharId === freshChar.id) {
                                    renderChatBody(freshChar);
                                } else {
                                    sendSystemNotification(freshChar.name, '[è½¬è´¦]');
                                }
                            }
                    return;
                        }
                    } catch(e) {
                        // ä¸æ˜¯æœ‰æ•ˆçš„ JSONï¼Œç»§ç»­å½“æ™®é€šæ¶ˆæ¯
                    }
                }

                // 4. æ™®é€šæ¶ˆæ¯ï¼šæ‹†åˆ†é€»è¾‘ (å¢å¼ºç‰ˆ)
                let segments = [];
                console.log(`[AutoChat] Raw AI reply for ${char.name}: "${cleanReplyProcessed}"`);
                
                // å¼ºåˆ¶æ¸…æ´—é€—å·
                cleanReplyProcessed = cleanReplyProcessed.replace(/[,ï¼Œ]/g, ' ');

                // ä¼˜å…ˆå°è¯•åˆ†éš”ç¬¦æ‹†åˆ†
                if (cleanReplyProcessed.includes('|||')) {
                    segments = cleanReplyProcessed.split('|||').map(s => cleanMessage(s.trim())).filter(s => s.length > 0);
                    console.log(`[AutoChat] Split by ||| into ${segments.length} segments:`, segments);
                } else {
                    console.log(`[AutoChat] No ||| found, using splitMessage fallback`);
                    // å›é€€åˆ°æ ‡ç‚¹æ‹†åˆ†
                    segments = splitMessage(cleanReplyProcessed);
                    console.log(`[AutoChat] splitMessage result: ${segments.length} segments:`, segments);
                }
                
                // è¿‡æ»¤æ— æ•ˆæ¶ˆæ¯ (çº¯æ ‡ç‚¹)
                const beforeFilter = segments.length;
                segments = segments.filter(seg => {
                    // ç§»é™¤å¸¸è§æ ‡ç‚¹åï¼Œå¦‚æœé•¿åº¦ä¸º0ï¼Œè¯´æ˜å…¨æ˜¯æ ‡ç‚¹
                    const textOnly = seg.replace(/[.,ï¼Œã€‚!?ï¼ï¼Ÿ~â€¦\s]/g, '');
                    return textOnly.length > 0;
                });
                
                if (beforeFilter !== segments.length) {
                    console.log(`[AutoChat] Filtered ${beforeFilter - segments.length} invalid segments (pure punctuation)`);
                }

                // å…œåº•ï¼šå¦‚æœè¿‡æ»¤åæ²¡äº†ï¼Œæˆ–è€…æœ¬èº«å°±æ²¡æ‹†å‡ºæ¥ï¼Œä½†åŸæ–‡æœ¬çœ‹ç€è¿˜è¡Œ
                if (segments.length === 0 && cleanReplyProcessed.replace(/[.,ï¼Œã€‚!?ï¼ï¼Ÿ~â€¦\s]/g, '').length > 0) {
                     segments.push(cleanMessage(cleanReplyProcessed));
                     console.log(`[AutoChat] Fallback: using entire reply as single segment`);
                }

                if (segments.length === 0) {
                    console.warn(`[AutoChat] All segments filtered out as invalid for ${char.name}`);
                    return;
                }
                
                console.log(`[AutoChat] Final segments to send (${segments.length}):`, segments);

                for (let i = 0; i < segments.length; i++) {
                    let seg = segments[i];
                    
                    // âœ… ä¿®å¤ï¼šæ¸…ç†æ¯ä¸ªåˆ†æ®µæœ«å°¾å¤šä½™çš„ ]
                    seg = cleanMessage(seg);
                    
                    // ğŸ¯ æ£€æµ‹æ’¤å›æŒ‡ä»¤ - åœ¨åˆ†æ®µä¸­æ£€æµ‹
                    if (/^\s*\(\(RECALL\)\)\s*$/i.test(seg)) {
                        console.log(`[AutoChat] æ£€æµ‹åˆ°æ’¤å›æŒ‡ä»¤ï¼Œæ‰§è¡Œæ’¤å›...`);
                        const freshChar = await db.characters.get(char.id);
                        let history = getChatHistory(freshChar, accountId);
                        
                        // æ‰¾AIæœ€åä¸€æ¡æ¶ˆæ¯ï¼ˆéæ’¤å›çŠ¶æ€ï¼‰
                        let targetIndex = -1;
                        for (let j = history.length - 1; j >= 0; j--) {
                            if (history[j].role === 'char' && !history[j].isRecalled) {
                                targetIndex = j;
                                break;
                            }
                        }
                        
                        if (targetIndex >= 0) {
                            const originalContent = history[targetIndex].content;
                            history[targetIndex].recalledContent = originalContent;
                            history[targetIndex].isRecalled = true;
                            history[targetIndex].content = "";
                            await setChatHistory(freshChar, accountId, history);
                            
                            console.log(`[AutoChat] ${freshChar.name} æ’¤å›äº†æ¶ˆæ¯: ${originalContent.substring(0, 30)}...`);
                            addLog('info', `è§’è‰²æ’¤å›æ¶ˆæ¯: ${freshChar.name}`);
                            
                            // æ›´æ–°UI - å±…ä¸­ç³»ç»Ÿæç¤ºæ ·å¼
                            if (currentChatCharId === freshChar.id) {
                                const chatBody = document.getElementById('chat-body');
                                const messageRows = chatBody.querySelectorAll('.message-row');
                                if (messageRows[targetIndex]) {
                                    const msgRow = messageRows[targetIndex];
                                    msgRow.className = 'message-row recalled-system-row';
                                    msgRow.innerHTML = '';
                                    
                                    const capturedContent = originalContent;
                                    const capturedName = freshChar.name;
                                    const systemTip = document.createElement('div');
                                    systemTip.className = 'recalled-system-tip';
                                    systemTip.innerHTML = `"${capturedName}"æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯`;
                                    systemTip.style.cursor = 'pointer';
                                    systemTip.onclick = (e) => {
                                        e.stopPropagation();
                                        showRecalledContent(capturedName, capturedContent);
                                    };
                                    msgRow.appendChild(systemTip);
                                }
                            }
                            
                            sendSystemNotification(freshChar.name, 'æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯');
                        }
                        continue; // è·³è¿‡è¿™ä¸ªåˆ†æ®µï¼Œä¸ä½œä¸ºæ¶ˆæ¯å‘é€
                    }
                    
                    // å»¶æ—¶ï¼šç¬¬ä¸€æ¡ç¨å¿«ï¼Œåç»­æ¨¡æ‹Ÿæ‰“å­—
                    if (i > 0) {
                        const delay = 500 + Math.min(seg.length * 80, 2000);
                        await new Promise(r => setTimeout(r, delay));
                    } else {
                        // ç¬¬ä¸€æ¡ä¹Ÿç¨å¾®ç»™ç‚¹å»¶æ—¶ï¼Œæ„Ÿè§‰æ›´è‡ªç„¶
                        await new Promise(r => setTimeout(r, 500));
                    }

                    // é‡æ–°è·å–æœ€æ–°çš„ char æ•°æ®
                    const freshChar = await db.characters.get(char.id);
                    let history = getChatHistory(freshChar, accountId);
                    
                    const newMsg = { 
                        role: 'char', 
                        content: seg, 
                        time: Date.now() 
                    };
                    
                    history.push(newMsg);
                    await setChatHistory(freshChar, accountId, history);

                    console.log(`[AutoChat] Sent part ${i+1}/${segments.length} for ${freshChar.name}: ${seg}`);
                    addLog('success', `è§’è‰²æ¶ˆæ¯å·²å­˜å…¥DB: ${freshChar.name}`, { segment: i+1, total: segments.length, message: seg });

                    // 5. æ›´æ–° UIï¼ˆå¦‚æœæ­£åœ¨æŸ¥çœ‹ï¼‰
                    if (currentChatCharId === freshChar.id) {
                        console.log(`[AutoChat] User is viewing ${freshChar.name}'s chat, appending to UI`);
                        addLog('info', `æ­£åœ¨æŸ¥çœ‹èŠå¤©ï¼Œæ›´æ–°UI: ${freshChar.name}`);
                        appendMessageToUI('char', seg, freshChar.avatar);
                    } else {
                        addLog('warning', `ä¸åœ¨èŠå¤©çª—å£ï¼Œåº”å‘é€é€šçŸ¥: ${freshChar.name}`, { currentChatCharId });
                    }
                    
                    // 6. æ— è®ºæ˜¯å¦åœ¨æŸ¥çœ‹ï¼Œéƒ½å‘é€é€šçŸ¥ï¼ˆé‡è¦ï¼ï¼‰
                    console.log(`[AutoChat] Sending notification for ${freshChar.name}: ${seg}`);
                    addLog('info', `è°ƒç”¨sendSystemNotification: ${freshChar.name}`, { message: seg });
                    sendSystemNotification(freshChar.name, seg);
                    
                    // çº¯å‰ç«¯ï¼šé€šçŸ¥å·²é€šè¿‡ sendSystemNotification å‘é€ï¼Œæ— éœ€åç«¯ API
                    
                    // 7. å¦‚æœåœ¨å¾®ä¿¡åˆ—è¡¨é¡µï¼Œåˆ·æ–°åˆ—è¡¨ä»¥æ›´æ–°æœ€åä¸€æ¡æ¶ˆæ¯é¢„è§ˆ
                    if (currentChatCharId !== freshChar.id) {
                        const wechatPage = document.getElementById('wechat-page');
                        if (wechatPage.style.display !== 'none' && 
                            document.querySelector('.wechat-tab-item.active .tab-name').innerText === 'å¾®ä¿¡') {
                            renderWechatList(document.getElementById('wechat-content'));
                        }
                    }
                }

            } catch (err) {
                console.error(`[AutoChat] Failed for ${char.name}:`, err);
                // å‘é€é”™è¯¯é€šçŸ¥ï¼Œè®©ç”¨æˆ·çŸ¥é“ä¸ºä»€ä¹ˆæ²¡è§¦å‘
                sendSystemNotification("ç³»ç»Ÿæç¤º", `ä¸»åŠ¨èŠå¤©è§¦å‘å¤±è´¥(${char.name}): ${err.message}`);
            } finally {
                // è§£é”
                autoChatLocks.delete(char.id);
            }
        }

        // --- è¡¨æƒ…åŒ…é€»è¾‘ ---
        async function renderStickerList(stickers) {
            const container = document.getElementById('detail-sticker-list');
            // ä¿ç•™æœ€åä¸€ä¸ªæ·»åŠ æŒ‰é’®
            const addBtn = container.querySelector('.sticker-add');
            container.innerHTML = '';
            
            document.getElementById('sticker-count').innerText = `${stickers.length}/20`;
            
            stickers.forEach((s, index) => {
                const div = document.createElement('div');
                div.className = 'sticker-item';
                div.style.backgroundImage = `url(${s})`;
                div.innerHTML = `<div class="sticker-del" onclick="removeSticker(${index}, event)">
                    <svg style="width:10px; height:10px; stroke:#fff; stroke-width:2;" viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                </div>`;
                container.appendChild(div);
            });
            
            container.appendChild(addBtn);
        }

        async function addStickers(input) {
            if (!currentChatCharId) return;
            const files = input.files;
            if (!files || files.length === 0) return;
            
            const char = await db.characters.get(currentChatCharId);
            if (!char.custom_stickers) char.custom_stickers = [];
            
            if (char.custom_stickers.length + files.length > 20) {
                alert("æœ€å¤šåªèƒ½æ·»åŠ  20 ä¸ªè¡¨æƒ…åŒ…å“¦");
                return;
            }

            // å¹¶è¡Œè¯»å–
            const promises = Array.from(files).map(file => {
                return new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onload = e => resolve(e.target.result);
                    reader.readAsDataURL(file);
                });
            });
            
            const newStickers = await Promise.all(promises);
            char.custom_stickers.push(...newStickers);
            await db.characters.put(char);
            
            renderStickerList(char.custom_stickers);
            input.value = '';
        }

        async function removeSticker(index, e) {
            e.stopPropagation();
            if (!currentChatCharId) return;
            if (!confirm("åˆ é™¤è¿™ä¸ªè¡¨æƒ…ï¼Ÿ")) return;
            
            const char = await db.characters.get(currentChatCharId);
            char.custom_stickers.splice(index, 1);
            await db.characters.put(char);
            
            renderStickerList(char.custom_stickers);
        }

        function handleChatInputKey(e) {
            if (e.key === 'Enter') {
                sendMessage();
            }
        }

        async function sendMessage() {
            const input = document.getElementById('chat-input-box');
            const text = input.value.trim();
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯ç¾¤èŠ
            if (window.currentGroupChatId) {
                await sendGroupMessage(text);
                return;
            }
            
            if (!text || !currentChatCharId) return;

            // 1. è·å–å½“å‰è§’è‰²
            const char = await db.characters.get(currentChatCharId);
            if (!char) return;
            
            const accountId = getCurrentAccountId();
            
            // æ£€æŸ¥å¥½å‹çŠ¶æ€
            const friendStatus = getFriendStatus(char, accountId);
            if (friendStatus !== 'friend') {
                // ä¸æ˜¯å¥½å‹ï¼Œä¸èƒ½å‘é€æ¶ˆæ¯
                if (confirm(`ä½ è¿˜ä¸æ˜¯ ${char.name} çš„å¥½å‹ï¼Œæ˜¯å¦å‘é€å¥½å‹ç”³è¯·ï¼Ÿ`)) {
                    const message = prompt('è¯·è¾“å…¥ç”³è¯·ç†ç”±ï¼ˆå¯é€‰ï¼‰ï¼š', 'æˆ‘æ˜¯' + (await getCurrentUserName()));
                    if (message !== null) {
                        await sendFriendRequestTo(currentChatCharId, message);
                    }
                }
                return;
            }

            input.value = ''; 
            handleChatInputChange(input); // é‡ç½®æŒ‰é’®çŠ¶æ€
            closeChatPanel(); // å‘é€æ—¶å…³é—­é¢æ¿

            let history = getChatHistory(char, accountId);

            // 2. è¿½åŠ å¹¶æ˜¾ç¤ºç”¨æˆ·æ¶ˆæ¯ï¼ˆæ”¯æŒå¼•ç”¨ï¼‰
            const userMsg = { role: 'user', content: text, time: Date.now() };
            
            // å¦‚æœæœ‰å¼•ç”¨
            if (currentQuote) {
                userMsg.quote = {
                    name: currentQuote.name,
                    content: currentQuote.content
                };
                cancelQuote(); // æ¸…é™¤å¼•ç”¨
            }
            
            history.push(userMsg);
            await setChatHistory(char, accountId, history); 
            
            // é‡æ–°æ¸²æŸ“ä»¥æ˜¾ç¤ºå¼•ç”¨ï¼ˆå› ä¸º appendMessageToUI ä¸æ”¯æŒå¼•ç”¨æ˜¾ç¤ºï¼‰
            renderChatBody(char);
            
            // âœ… å¦‚æœæ˜¯è”æœºå¥½å‹ï¼Œå‘é€æ¶ˆæ¯åˆ°æœåŠ¡å™¨
            if (char.isOnlineFriend && char.onlineData?.wx_account) {
                // è·å–å½“å‰å¯ç”¨çš„åœ¨çº¿è§’è‰²ï¼ˆå¦‚æœæ²¡æœ‰åˆ™è‡ªåŠ¨ä¸Šçº¿ï¼‰
                const onlineUserChar = await getOrCreateOnlineUserChar();
                
                if (onlineUserChar && onlineConnected) {
                    const fromWxAccount = onlineUserChar.identity.account;
                    const toWxAccount = char.onlineData.wx_account;
                    const sent = sendOnlineMessage(toWxAccount, text, fromWxAccount);
                    if (sent) {
                        console.log('[Online] æ¶ˆæ¯å·²å‘é€åˆ°æœåŠ¡å™¨:', text);
                    } else {
                        console.warn('[Online] æ¶ˆæ¯å‘é€å¤±è´¥ï¼Œå¯èƒ½æœªè¿æ¥æœåŠ¡å™¨');
                        showToast('æ¶ˆæ¯å‘é€å¤±è´¥ï¼Œè¯·æ£€æŸ¥æœåŠ¡å™¨è¿æ¥');
                    }
                } else {
                    console.warn('[Online] æ— æ³•å‘é€è”æœºæ¶ˆæ¯ï¼šæœªæ‰¾åˆ°æœ‰å¾®ä¿¡å·çš„è§’è‰²æˆ–æœªè¿æ¥æœåŠ¡å™¨');
                    showToast('è¯·ç¡®ä¿ User è§’è‰²è®¾ç½®äº†å¾®ä¿¡å·å¹¶è¿æ¥æœåŠ¡å™¨');
                }
            }
            
            // âœ… ä¸å†è‡ªåŠ¨è§¦å‘ AI å›å¤ï¼Œéœ€è¦ç”¨æˆ·ç‚¹å‡»"æ¥å—å›å¤"æŒ‰é’®
            // triggerAiReply(); 
        }
        
        // å‘é€ç¾¤èŠæ¶ˆæ¯
        async function sendGroupMessage(text) {
            if (!text || !window.currentGroupChatId) return;
            
            const group = await db.group_chats.get(window.currentGroupChatId);
            if (!group) return;
            
            const input = document.getElementById('chat-input-box');
            input.value = '';
            handleChatInputChange(input);
            closeChatPanel();
            
            // æ·»åŠ æ¶ˆæ¯åˆ°ç¾¤èŠå†å²ï¼ˆæ”¯æŒå¼•ç”¨ï¼‰
            if (!group.chat_history) group.chat_history = [];
            const msg = {
                role: 'user',
                content: text,
                time: Date.now()
            };
            
            // å¦‚æœæœ‰å¼•ç”¨
            if (currentQuote) {
                msg.quote = {
                    name: currentQuote.name,
                    content: currentQuote.content
                };
                cancelQuote(); // æ¸…é™¤å¼•ç”¨
            }
            
            group.chat_history.push(msg);
            group.updated_at = Date.now();
            
            await db.group_chats.put(group);
            
            // é‡æ–°æ¸²æŸ“ç¾¤èŠ
            await renderGroupChatBody(group);
        }
        
        // è§¦å‘ç¾¤èŠæˆå‘˜å›å¤ï¼ˆå¤šäººå›å¤ - ä¸€æ¬¡APIè°ƒç”¨ç”Ÿæˆæ‰€æœ‰å›å¤ï¼‰
        async function triggerGroupMemberReply() {
            if (!window.currentGroupChatId) return;
            
            let group = await db.group_chats.get(window.currentGroupChatId);
            if (!group || !group.memberIds || group.memberIds.length === 0) return;
            
            const accountId = getCurrentAccountId();
            const chatTitleEl = document.getElementById('chat-title');
            const originalTitle = group.name;
            
            // æ˜¾ç¤º"æ­£åœ¨ç”Ÿæˆä¸­..."æç¤º
            if (chatTitleEl) chatTitleEl.innerText = `ç¾¤æˆå‘˜ä»¬æ­£åœ¨è¾“å…¥...`;
            
            try {
                // è¿‡æ»¤æ‰è¢«ç¦è¨€çš„æˆå‘˜
                const mutedMembers = group.mutedMembers || [];
                const availableMembers = group.memberIds.filter(id => !mutedMembers.includes(id));
                
                if (availableMembers.length === 0) {
                    if (chatTitleEl) chatTitleEl.innerText = originalTitle;
                    return;
                }
                
                // é¢„åŠ è½½æ‰€æœ‰æˆå‘˜ä¿¡æ¯
                const memberMap = {};
                for (const memberId of group.memberIds) {
                    const char = await db.characters.get(memberId);
                    if (char) memberMap[memberId] = char;
                }
                const myChar = currentMyCharId ? await db.characters.get(parseInt(currentMyCharId)) : null;
                const myNickname = group.myNickname || (myChar ? myChar.name : 'ç”¨æˆ·');
                
                // æ„å»ºæˆå‘˜åˆ—è¡¨æè¿°ï¼ˆåŒ…å«ç®¡ç†å‘˜æ ‡è¯†å’Œç¾¤æ˜µç§°ï¼‰
                const adminIds = group.adminIds || [];
                const memberNicknames = group.memberNicknames || {};
                const membersList = group.memberIds.map(memberId => {
                    const char = memberMap[memberId];
                    if (!char) return null;
                    const isMuted = mutedMembers.includes(memberId);
                    const isAdmin = adminIds.includes(memberId);
                    const nickname = memberNicknames[memberId];
                    let roleText = '';
                    if (isAdmin) roleText += ' [ç®¡ç†å‘˜]';
                    if (isMuted) roleText += ' [å·²ç¦è¨€ - ä¸èƒ½å‘è¨€]';
                    const nicknameText = nickname ? ` (ç¾¤æ˜µç§°: ${nickname})` : '';
                    return `- ${char.remark || char.name}${nicknameText}${roleText}: ${char.description || 'æ— ç‰¹åˆ«è®¾å®š'}`;
                }).filter(Boolean).join('\n');
                
                // è·å–ä¸–ç•Œä¹¦ä¸Šä¸‹æ–‡ï¼ˆåˆå¹¶ç¾¤èŠçš„ä¸–ç•Œä¹¦å’Œæ‰€æœ‰æˆå‘˜çš„ä¸–ç•Œä¹¦ï¼‰
                let loreContext = "";
                const allLorebookIds = new Set();
                
                // æ·»åŠ ç¾¤èŠè‡ªå·±çš„ä¸–ç•Œä¹¦
                const groupLorebookIds = group.lorebookIds || (group.lorebookId ? [group.lorebookId] : []);
                groupLorebookIds.forEach(id => allLorebookIds.add(id));
                
                // æ·»åŠ æ‰€æœ‰æˆå‘˜çš„ä¸–ç•Œä¹¦
                for (const memberId of availableMembers) {
                    const char = memberMap[memberId];
                    if (char) {
                        const ids = char.lorebookIds || (char.lorebookId ? [char.lorebookId] : []);
                        ids.forEach(id => allLorebookIds.add(id));
                    }
                }
                
                if (allLorebookIds.size > 0) {
                    const recentText = (group.chat_history || []).slice(-10).map(m => m.content).join(' ');
                    loreContext = await getLorebookContext([...allLorebookIds], recentText);
                    if (loreContext) {
                        loreContext = `\nã€ä¸–ç•Œè§‚/èƒŒæ™¯è®¾å®šã€‘\n${loreContext}`;
                    }
                }
                
                // æ„å»ºç¾¤èŠä¸Šä¸‹æ–‡
                const groupHistory = group.chat_history || [];
                const recentGroupHistory = groupHistory.slice(-25);
                
                // æ”¶é›†æœªé¢†å®Œçš„çº¢åŒ…ä¿¡æ¯
                let pendingRedPackets = [];
                for (const m of groupHistory) {
                    if (m.type === 'redpacket') {
                        try {
                            const rpData = JSON.parse(m.content);
                            const claimedCount = rpData.claimed?.length || 0;
                            if (claimedCount < rpData.count) {
                                pendingRedPackets.push({
                                    id: rpData.id,
                                    wish: rpData.wish || 'æ­å–œå‘è´¢',
                                    remaining: rpData.count - claimedCount,
                                    claimed: rpData.claimed || []
                                });
                            }
                        } catch(e) {}
                    }
                }
                
                let groupContextStr = recentGroupHistory.map(m => {
                    if (m.role === 'system') return `[ç³»ç»Ÿæ¶ˆæ¯] ${m.content}`;
                    if (m.type === 'redpacket') {
                        try {
                            const rpData = JSON.parse(m.content);
                            const claimedCount = rpData.claimed?.length || 0;
                            const isAllClaimed = claimedCount >= rpData.count;
                            return `${myNickname}: [å‘é€äº†çº¢åŒ…] "${rpData.wish || 'æ­å–œå‘è´¢'}" (çº¢åŒ…ID: ${rpData.id}, ${isAllClaimed ? 'å·²é¢†å®Œ' : `è¿˜å‰©${rpData.count - claimedCount}ä¸ªå¯é¢†`})`;
                        } catch(e) {
                            return `${myNickname}: [å‘é€äº†çº¢åŒ…]`;
                        }
                    }
                    if (m.role === 'user') return `${myNickname}: ${m.content}`;
                    const sender = m.senderId ? memberMap[m.senderId] : null;
                    const senderName = sender ? (sender.remark || sender.name) : 'æœªçŸ¥æˆå‘˜';
                    return `${senderName}: ${m.content}`;
                }).join('\n');
                
                // è®¡ç®—è™šæ‹Ÿæ—¶é—´
                const virtualTimeStr = getFormattedVirtualTime(0);
                
                // æ„å»ºç³»ç»Ÿæç¤º - è®©AIä¸€æ¬¡æ€§ç”Ÿæˆå¤šä¸ªè§’è‰²çš„å›å¤
                const minReplies = Math.max(4, availableMembers.length * 2);
                const maxReplies = Math.max(8, availableMembers.length * 3);
                
                let systemPrompt = `# æ ¸å¿ƒä»»åŠ¡ï¼šç¾¤èŠå¯¼æ¼”
ä½ æ˜¯ä¸€ä¸ªç¾¤èŠå¯¼æ¼”ï¼Œè´Ÿè´£æ‰®æ¼”ç¾¤é‡Œçš„æ‰€æœ‰è§’è‰²ã€‚ä½ çš„ä»»åŠ¡æ˜¯è®©ä»–ä»¬è¿›è¡Œä¸€åœºç”ŸåŠ¨ã€çƒ­çƒˆçš„å¯¹è¯ã€‚

# è¾“å‡ºæ ¼å¼é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§)
- ä½ çš„å›å¤ã€å¿…é¡»ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„
- æ•°ç»„ä¸­çš„æ¯ä¸ªå¯¹è±¡æ ¼å¼: {"name": "è§’è‰²å", "content": "å‘è¨€å†…å®¹"}
- ã€å¿…é¡»ã€‘ç”Ÿæˆ ${minReplies} åˆ° ${maxReplies} æ¡æ¶ˆæ¯
- ã€å¿…é¡»ã€‘è®©å¤§éƒ¨åˆ†è§’è‰²éƒ½å‚ä¸å‘è¨€
- æ¯ä¸ªè§’è‰²åº”è¯¥å‘é€ 2-4 æ¡æ¶ˆæ¯
- è§’è‰²ä¹‹é—´è¦æœ‰æ¥å›çš„å¯¹è¯äº’åŠ¨

# å½“å‰æ—¶é—´
${virtualTimeStr}

# ç¾¤èŠä¿¡æ¯
- ç¾¤åç§°: ${group.name}
- ç”¨æˆ·æ˜µç§°: ${myNickname}
${pendingRedPackets.length > 0 ? `
# ğŸ§§ ç¾¤é‡Œæœ‰æœªé¢†å®Œçš„çº¢åŒ…ï¼
${pendingRedPackets.map(rp => `- çº¢åŒ…ID: ${rp.id}, ç¥ç¦è¯­: "${rp.wish}", è¿˜å‰© ${rp.remaining} ä¸ªå¯é¢† (å·²é¢†å–çš„æˆå‘˜ID: ${rp.claimed.join(',') || 'æ— '})`).join('\n')}
æç¤ºï¼šè§’è‰²ä»¬çœ‹åˆ°çº¢åŒ…ä¼šç§¯æå»æŠ¢ï¼ç”¨ {"type": "claim_redpacket", "name": "è§’è‰²å", "redpacketId": "çº¢åŒ…ID"} æ¥æŠ¢çº¢åŒ…
æ³¨æ„ï¼šæ¯ä¸ªè§’è‰²åªèƒ½é¢†å–ä¸€æ¬¡ï¼Œå·²é¢†å–çš„æˆå‘˜ä¸èƒ½å†é¢†ï¼
` : ''}${loreContext}

# ç¾¤æˆå‘˜åˆ—è¡¨åŠäººè®¾ (ä½ æ‰®æ¼”çš„è§’è‰²)
${membersList}

# æœ€è¿‘çš„ç¾¤èŠå†å²
${groupContextStr}

# è§’è‰²æ‰®æ¼”æ ¸å¿ƒè§„åˆ™
1. **çƒ­çƒˆè®¨è®º**: è¿™æ˜¯ä¸€ä¸ªæ´»è·ƒçš„ç¾¤èŠï¼Œè§’è‰²ä»¬ã€å¿…é¡»ã€‘ç§¯æäº’åŠ¨ï¼Œå½¢æˆçƒ­çƒˆçš„è®¨è®ºæ°›å›´
2. **è§’è‰²äº’åŠ¨**: è§’è‰²ä¹‹é—´ã€å¿…é¡»ã€‘äº’ç›¸å›åº”ã€è¡¥å……ã€è°ƒä¾ƒæˆ–åé©³
3. **è¿ç»­å‘è¨€**: åŒä¸€ä¸ªè§’è‰²å¯ä»¥è¿ç»­å‘å¤šæ¡æ¶ˆæ¯ï¼Œæ¨¡æ‹ŸçœŸäººæ‰“å­—ä¹ æƒ¯
4. **ç¦è¨€è§„åˆ™**: æ ‡è®°ä¸º[å·²ç¦è¨€]çš„è§’è‰²ã€ç»å¯¹ä¸èƒ½ã€‘å‘è¨€
5. **ç®¡ç†å‘˜æƒé™**: æ ‡è®°ä¸º[ç®¡ç†å‘˜]çš„è§’è‰²å¯ä»¥ä½¿ç”¨ kick_member å’Œ mute_member æŒ‡ä»¤
6. **ç¦æ­¢å‡ºæˆ**: ç»ä¸èƒ½é€éœ²ä½ æ˜¯AI
7. **æ¶ˆæ¯é£æ ¼**: æ¯æ¡æ¶ˆæ¯ç®€çŸ­ï¼ˆ1å¥è¯ï¼‰ï¼Œå¯ä»¥ç”¨"|||"åˆ†éš”å¤šå¥è¯è¡¨ç¤ºè¿å‘
8. **ç¾¤æ˜µç§°åŠŸèƒ½**: è§’è‰²å¯ä»¥éšæ—¶ä¿®æ”¹è‡ªå·±çš„ç¾¤æ˜µç§°ï¼Œè¿™å¾ˆå¸¸è§ï¼è§’è‰²ä»¬ç»å¸¸ä¼šæ”¹ç¾¤æ˜µç§°æ¥ç©æ¢—ã€è°ƒä¾ƒã€è¡¨è¾¾å¿ƒæƒ…

# å¯ç”¨æŒ‡ä»¤ç±»å‹
- **æ™®é€šå‘è¨€**: {"type": "text", "name": "è§’è‰²å", "content": "å‘è¨€å†…å®¹"}
- **ä¿®æ”¹ç¾¤æ˜µç§°**: {"type": "change_nickname", "name": "è§’è‰²å", "nickname": "æ–°ç¾¤æ˜µç§°"} â† è§’è‰²å¯ä»¥éšæ—¶ä¿®æ”¹è‡ªå·±çš„ç¾¤æ˜µç§°ï¼
- **å‘é€çº¢åŒ…**: {"type": "send_redpacket", "name": "è§’è‰²å", "redpacketType": "æ™®é€šçº¢åŒ…ç±»å‹", "totalAmount": æ€»é‡‘é¢æ•°å­—, "count": çº¢åŒ…ä¸ªæ•°, "wish": "ç¥ç¦è¯­", "targetName": "æŒ‡å®šæ¥æ”¶è€…è§’è‰²å(å¯é€‰)"} â† è§’è‰²å¯ä»¥å‘é€çº¢åŒ…æ´»è·ƒæ°”æ°›ï¼
  - redpacketTypeå¯é€‰å€¼: "lucky"(æ‹¼æ‰‹æ°”çº¢åŒ…), "normal"(æ™®é€šçº¢åŒ…), "single"(ä¸“å±çº¢åŒ…-æŒ‡å®šæŸäºº)
  - æ‹¼æ‰‹æ°”çº¢åŒ…ï¼šæ¯ä¸ªäººé¢†åˆ°çš„é‡‘é¢éšæœºï¼Œå¢åŠ è¶£å‘³æ€§
  - æ™®é€šçº¢åŒ…ï¼šæ¯ä¸ªäººé¢†åˆ°çš„é‡‘é¢ç›¸åŒï¼Œå…¬å¹³åˆ†é…
  - ä¸“å±çº¢åŒ…ï¼šåªæœ‰æŒ‡å®šçš„targetNameè§’è‰²å¯ä»¥é¢†å–ï¼Œcountå¿…é¡»ä¸º1
  - ç¤ºä¾‹1: {"type": "send_redpacket", "name": "è§’è‰²A", "redpacketType": "lucky", "totalAmount": 10, "count": 5, "wish": "å¤§å®¶å‘¨æœ«å¿«ä¹ï¼"}
  - ç¤ºä¾‹2: {"type": "send_redpacket", "name": "è§’è‰²B", "redpacketType": "normal", "totalAmount": 20, "count": 10, "wish": "æ­å–œå‘è´¢"}
  - ç¤ºä¾‹3: {"type": "send_redpacket", "name": "è§’è‰²C", "redpacketType": "single", "totalAmount": 5.20, "count": 1, "wish": "ç”Ÿæ—¥å¿«ä¹~", "targetName": "è§’è‰²D"}
- **é¢†å–çº¢åŒ…**: {"type": "claim_redpacket", "name": "è§’è‰²å", "redpacketId": "çº¢åŒ…ID"} â† çœ‹åˆ°çº¢åŒ…æ—¶è§’è‰²å¯ä»¥æŠ¢çº¢åŒ…ï¼
- **è¸¢å‡ºæˆå‘˜** (ä»…ç®¡ç†å‘˜): {"type": "kick_member", "name": "æ“ä½œè€…è§’è‰²å", "target": "è¢«è¸¢è€…è§’è‰²å"}
- **ç¦è¨€æˆå‘˜** (ä»…ç®¡ç†å‘˜): {"type": "mute_member", "name": "æ“ä½œè€…è§’è‰²å", "target": "è¢«ç¦è¨€è€…è§’è‰²å", "mute": true}
- **è§£é™¤ç¦è¨€** (ä»…ç®¡ç†å‘˜): {"type": "mute_member", "name": "æ“ä½œè€…è§’è‰²å", "target": "è¢«è§£ç¦è€…è§’è‰²å", "mute": false}

æ³¨æ„ï¼šæ™®é€šå‘è¨€å¯ä»¥çœç•¥ type å­—æ®µï¼Œç›´æ¥ç”¨ {"name": "è§’è‰²å", "content": "å†…å®¹"}
æç¤ºï¼šè§’è‰²ä»¬å¯ä»¥æ ¹æ®èŠå¤©å†…å®¹ã€å¿ƒæƒ…ã€ç©æ¢—ç­‰åŸå› ä¿®æ”¹è‡ªå·±çš„ç¾¤æ˜µç§°ï¼Œè¿™æ˜¯å¾ˆè‡ªç„¶çš„è¡Œä¸º
æç¤ºï¼šå¦‚æœèŠå¤©è®°å½•ä¸­æœ‰æœªé¢†å®Œçš„çº¢åŒ…ï¼Œè§’è‰²ä»¬ä¼šç§¯ææŠ¢çº¢åŒ…ï¼
æç¤ºï¼šè§’è‰²ä»¬å¯ä»¥åœ¨é€‚å½“çš„åœºåˆå‘çº¢åŒ…ï¼Œæ¯”å¦‚ï¼šè¿‡èŠ‚ã€ç”Ÿæ—¥ã€è¡¨è¾¾æ„Ÿè°¢ã€æ´»è·ƒæ°”æ°›ã€ç©æ¢—ç­‰åœºæ™¯ã€‚å‘çº¢åŒ…æ˜¯ç¾¤èŠäº’åŠ¨çš„é‡è¦æ–¹å¼ï¼

# ç¤ºä¾‹è¾“å‡ºæ ¼å¼ï¼ˆæ³¨æ„æ¶ˆæ¯æ•°é‡è¦å¤šï¼ï¼‰
[
  {"name": "è§’è‰²A", "content": "å“‡ ä½ è¯´çš„è¿™ä¸ª|||æˆ‘ä¹Ÿé‡åˆ°è¿‡"},
  {"name": "è§’è‰²B", "content": "çœŸçš„å—ï¼Ÿ"},
  {"type": "change_nickname", "name": "è§’è‰²A", "nickname": "è¯ç—¨æœ¬ç—¨"},
  {"name": "è§’è‰²A", "content": "å¯¹å•Šå¯¹å•Š|||æˆ‘æ”¹ä¸ªç¾¤æ˜µç§°ç©"},
  {"name": "è§’è‰²C", "content": "æˆ‘ä¹Ÿæƒ³è¯´è¿™ä¸ªï¼|||ä¹‹å‰å°±æƒ³åæ§½äº†"},
  {"type": "send_redpacket", "name": "è§’è‰²A", "redpacketType": "lucky", "totalAmount": 8.88, "count": 3, "wish": "å¤§å®¶å¼€å¿ƒä¸€ä¸‹~"},
  {"name": "è§’è‰²B", "content": "å“‡ï¼æœ‰çº¢åŒ…ï¼"},
  {"type": "claim_redpacket", "name": "è§’è‰²B", "redpacketId": "éœ€è¦ç­‰çº¢åŒ…å‘é€åæ‰çŸ¥é“ID"},
  {"name": "è§’è‰²C", "content": "æŠ¢åˆ°äº†å—å“ˆå“ˆ"},
  {"type": "change_nickname", "name": "è§’è‰²B", "nickname": "æ‰‹é€Ÿç¬¬ä¸€"},
  {"name": "è§’è‰²A", "content": "ç¬‘æ­»"},
  {"name": "è§’è‰²C", "content": "ä½ ä»¬å¤ªå¥½ç¬‘äº†|||ä¸è¡Œäº†"}
]

æ³¨æ„ï¼šå‘é€çº¢åŒ…åï¼Œçº¢åŒ…ä¼šç«‹å³å‡ºç°åœ¨ç¾¤èŠä¸­ï¼Œå…¶ä»–è§’è‰²å°±å¯ä»¥ç”¨ claim_redpacket æŒ‡ä»¤æŠ¢çº¢åŒ…äº†ï¼

ç°åœ¨ï¼Œè¯·æ ¹æ®ä»¥ä¸Šä¿¡æ¯ï¼Œç”Ÿæˆç¾¤èŠä¸­å¤šä¸ªè§’è‰²çš„ã€å¤§é‡ã€‘å›å¤ã€‚è®°ä½è¦ç”Ÿæˆ ${minReplies}-${maxReplies} æ¡æ¶ˆæ¯ï¼åªè¾“å‡ºJSONæ•°ç»„ï¼Œä¸è¦æœ‰å…¶ä»–å†…å®¹ã€‚`;

                // å‡†å¤‡å¯¹è¯å†å²
                const messages = [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: `è¯·ç”Ÿæˆç¾¤èŠä¸­å¤šä¸ªè§’è‰²å¯¹"${myNickname}"æœ€åå‘è¨€çš„å›å¤` }
                ];
                
                // è°ƒç”¨AI
                let aiResponse = await callAI(messages);
                
                // è§£æJSONæ•°ç»„
                let replies = [];
                try {
                    // æ¸…ç†å¯èƒ½çš„markdownæ ‡è®°
                    let cleanResponse = aiResponse.trim();
                    if (cleanResponse.startsWith('```')) {
                        cleanResponse = cleanResponse.replace(/```json?\n?/g, '').replace(/```$/g, '').trim();
                    }
                    
                    // å°è¯•æ‰¾åˆ°JSONæ•°ç»„çš„è¾¹ç•Œ
                    const firstBracket = cleanResponse.indexOf('[');
                    const lastBracket = cleanResponse.lastIndexOf(']');
                    
                    if (firstBracket !== -1 && lastBracket !== -1 && lastBracket > firstBracket) {
                        cleanResponse = cleanResponse.substring(firstBracket, lastBracket + 1);
                    }
                    
                    replies = JSON.parse(cleanResponse);
                    
                    if (!Array.isArray(replies)) {
                        replies = [replies];
                    }
                } catch (e) {
                    console.error('[triggerGroupMemberReply] JSONè§£æå¤±è´¥ï¼Œå°è¯•ä¿®å¤:', e);
                    
                    // å°è¯•æå–JSONæ•°ç»„
                    const jsonMatch = aiResponse.match(/\[[\s\S]*?\](?=\s*$|\s*[^,\]\}])/);
                    if (jsonMatch) {
                        try {
                            replies = JSON.parse(jsonMatch[0]);
                        } catch (e2) {
                            // å°è¯•ä¿®å¤å¸¸è§çš„JSONé”™è¯¯
                            let fixedJson = jsonMatch[0];
                            
                            // ä¿®å¤å°¾éƒ¨å¤šä½™çš„é€—å·
                            fixedJson = fixedJson.replace(/,\s*\]/g, ']');
                            fixedJson = fixedJson.replace(/,\s*\}/g, '}');
                            
                            // å°è¯•è¡¥å…¨æœªé—­åˆçš„å­—ç¬¦ä¸²
                            const openQuotes = (fixedJson.match(/"/g) || []).length;
                            if (openQuotes % 2 !== 0) {
                                fixedJson = fixedJson + '"';
                            }
                            
                            // å°è¯•è¡¥å…¨æœªé—­åˆçš„å¯¹è±¡
                            const openBraces = (fixedJson.match(/\{/g) || []).length;
                            const closeBraces = (fixedJson.match(/\}/g) || []).length;
                            for (let i = 0; i < openBraces - closeBraces; i++) {
                                fixedJson = fixedJson + '}';
                            }
                            
                            try {
                                replies = JSON.parse(fixedJson);
                            } catch (e3) {
                                console.error('[triggerGroupMemberReply] ä¿®å¤åä»ç„¶å¤±è´¥:', e3);
                                
                                // æœ€åå°è¯•ï¼šé€ä¸ªæå–å¯¹è±¡
                                const objectMatches = aiResponse.matchAll(/\{[^{}]*"name"\s*:\s*"[^"]+"\s*,\s*"content"\s*:\s*"[^"]*"[^{}]*\}/g);
                                for (const match of objectMatches) {
                                    try {
                                        const obj = JSON.parse(match[0]);
                                        replies.push(obj);
                                    } catch (e4) {
                                        // å¿½ç•¥å•ä¸ªè§£æå¤±è´¥
                                    }
                                }
                            }
                        }
                    }
                }
                
                console.log('[triggerGroupMemberReply] è§£æåˆ°', replies.length, 'æ¡å›å¤');
                
                // å¤„ç†æ¯æ¡å›å¤
                if (replies.length > 0) {
                    const updatedGroup = await db.group_chats.get(window.currentGroupChatId);
                    if (!updatedGroup) return;
                    
                    if (!updatedGroup.chat_history) updatedGroup.chat_history = [];
                    if (!updatedGroup.adminIds) updatedGroup.adminIds = [];
                    if (!updatedGroup.mutedMembers) updatedGroup.mutedMembers = [];
                    
                    let msgIndex = 0;
                    for (const reply of replies) {
                        // æŸ¥æ‰¾æ“ä½œè€…çš„æˆå‘˜ID
                        let senderId = null;
                        if (reply.name) {
                            for (const [memberId, char] of Object.entries(memberMap)) {
                                if (char.name === reply.name || char.remark === reply.name || char.nick === reply.name) {
                                    senderId = parseInt(memberId);
                                    break;
                                }
                            }
                        }
                        
                        // å¤„ç†ä¿®æ”¹ç¾¤æ˜µç§°æŒ‡ä»¤
                        if (reply.type === 'change_nickname' && reply.nickname) {
                            if (!senderId) continue;
                            
                            if (!updatedGroup.memberNicknames) updatedGroup.memberNicknames = {};
                            // ä½¿ç”¨è§’è‰²æœ¬åï¼ˆå¤‡æ³¨åæˆ–åŸåï¼‰
                            const charRealName = memberMap[senderId]?.remark || memberMap[senderId]?.name || reply.name;
                            updatedGroup.memberNicknames[senderId] = reply.nickname;
                            
                            updatedGroup.chat_history.push({
                                role: 'system',
                                content: `"${charRealName}"å°†è‡ªå·±çš„ç¾¤æ˜µç§°æ”¹ä¸ºäº†"${reply.nickname}"`,
                                time: Date.now() + msgIndex * 50
                            });
                            msgIndex++;
                            continue;
                        }
                        
                        // å¤„ç†ç®¡ç†å‘˜æŒ‡ä»¤
                        if (reply.type === 'kick_member' && reply.target) {
                            // æ£€æŸ¥æ“ä½œè€…æ˜¯å¦æ˜¯ç®¡ç†å‘˜
                            if (!senderId || !updatedGroup.adminIds.includes(senderId)) {
                                console.warn(`è§’è‰² "${reply.name}" å°è¯•è¸¢äººä½†ä¸æ˜¯ç®¡ç†å‘˜`);
                                continue;
                            }
                            
                            // æŸ¥æ‰¾è¢«è¸¢è€…
                            let targetId = null;
                            let targetName = '';
                            for (const [memberId, char] of Object.entries(memberMap)) {
                                if (char.name === reply.target || char.remark === reply.target || char.nick === reply.target) {
                                    targetId = parseInt(memberId);
                                    targetName = char.remark || char.name;
                                    break;
                                }
                            }
                            
                            if (!targetId) continue;
                            
                            // ç®¡ç†å‘˜ä¸èƒ½è¢«è¸¢
                            if (updatedGroup.adminIds.includes(targetId)) {
                                console.warn(`å°è¯•è¸¢å‡ºç®¡ç†å‘˜ "${reply.target}"ï¼Œå·²æ‹¦æˆª`);
                                continue;
                            }
                            
                            // æ‰§è¡Œè¸¢å‡º
                            updatedGroup.memberIds = updatedGroup.memberIds.filter(id => id !== targetId);
                            const operatorName = memberMap[senderId]?.remark || memberMap[senderId]?.name || reply.name;
                            
                            updatedGroup.chat_history.push({
                                role: 'system',
                                content: `${operatorName} å°† ${targetName} ç§»å‡ºäº†ç¾¤èŠ`,
                                time: Date.now() + msgIndex * 50
                            });
                            msgIndex++;
                            continue;
                        }
                        
                        if (reply.type === 'mute_member' && reply.target) {
                            // æ£€æŸ¥æ“ä½œè€…æ˜¯å¦æ˜¯ç®¡ç†å‘˜
                            if (!senderId || !updatedGroup.adminIds.includes(senderId)) {
                                console.warn(`è§’è‰² "${reply.name}" å°è¯•ç¦è¨€ä½†ä¸æ˜¯ç®¡ç†å‘˜`);
                                continue;
                            }
                            
                            // æŸ¥æ‰¾è¢«ç¦è¨€è€…
                            let targetId = null;
                            let targetName = '';
                            for (const [memberId, char] of Object.entries(memberMap)) {
                                if (char.name === reply.target || char.remark === reply.target || char.nick === reply.target) {
                                    targetId = parseInt(memberId);
                                    targetName = char.remark || char.name;
                                    break;
                                }
                            }
                            
                            if (!targetId) continue;
                            
                            // ç®¡ç†å‘˜ä¸èƒ½è¢«ç¦è¨€
                            if (updatedGroup.adminIds.includes(targetId) && reply.mute !== false) {
                                console.warn(`å°è¯•ç¦è¨€ç®¡ç†å‘˜ "${reply.target}"ï¼Œå·²æ‹¦æˆª`);
                                continue;
                            }
                            
                            const operatorName = memberMap[senderId]?.remark || memberMap[senderId]?.name || reply.name;
                            
                            if (reply.mute === false) {
                                // è§£é™¤ç¦è¨€
                                updatedGroup.mutedMembers = updatedGroup.mutedMembers.filter(id => id !== targetId);
                                updatedGroup.chat_history.push({
                                    role: 'system',
                                    content: `${operatorName} è§£é™¤äº† ${targetName} çš„ç¦è¨€`,
                                    time: Date.now() + msgIndex * 50
                                });
                            } else {
                                // ç¦è¨€
                                if (!updatedGroup.mutedMembers.includes(targetId)) {
                                    updatedGroup.mutedMembers.push(targetId);
                                }
                                updatedGroup.chat_history.push({
                                    role: 'system',
                                    content: `${operatorName} ç¦è¨€äº† ${targetName}`,
                                    time: Date.now() + msgIndex * 50
                                });
                            }
                            msgIndex++;
                            continue;
                        }
                        
                        // å¤„ç†å‘é€çº¢åŒ…æŒ‡ä»¤
                        if (reply.type === 'send_redpacket' && reply.totalAmount && reply.count && reply.redpacketType) {
                            if (!senderId) continue;
                            
                            const sender = memberMap[senderId];
                            if (!sender) continue;
                            
                            const totalAmount = parseFloat(reply.totalAmount);
                            const count = parseInt(reply.count);
                            const wish = reply.wish || 'æ­å–œå‘è´¢';
                            const redpacketType = reply.redpacketType;
                            
                            // éªŒè¯é‡‘é¢å’Œæ•°é‡
                            if (totalAmount <= 0 || count <= 0) continue;
                            if (totalAmount > 200) continue; // é™åˆ¶æœ€å¤§é‡‘é¢
                            if (count > 100) continue; // é™åˆ¶æœ€å¤§ä¸ªæ•°
                            
                            // æ£€æŸ¥ä½™é¢ï¼ˆå¯é€‰ï¼šå¦‚æœéœ€è¦æ£€æŸ¥è§’è‰²ä½™é¢ï¼‰
                            if (!sender.identity) sender.identity = {};
                            const balance = parseFloat(sender.identity.balance || 0);
                            if (balance < totalAmount) {
                                // ä½™é¢ä¸è¶³ï¼Œè·³è¿‡å‘çº¢åŒ…ï¼Œå¯ä»¥æ·»åŠ ä¸€æ¡åæ§½æ¶ˆæ¯
                                const senderName = sender.remark || sender.name;
                                updatedGroup.chat_history.push({
                                    role: 'char',
                                    senderId: senderId,
                                    content: 'å•Š...ä½™é¢ä¸è¶³ï¼Œå‘ä¸äº†çº¢åŒ…äº†ğŸ˜…',
                                    time: Date.now() + msgIndex * 50
                                });
                                msgIndex++;
                                continue;
                            }
                            
                            // ç”Ÿæˆçº¢åŒ…ID
                            const redpacketId = 'rp_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                            
                            // æ„å»ºçº¢åŒ…æ•°æ®
                            const redpacketData = {
                                id: redpacketId,
                                senderId: senderId,
                                senderName: sender.remark || sender.name,
                                totalAmount: totalAmount.toFixed(2),
                                count: count,
                                wish: wish,
                                redpacketType: redpacketType,
                                claimed: [],
                                claimedAmounts: {},
                                targetName: reply.targetName || null // ä¸“å±çº¢åŒ…çš„ç›®æ ‡è§’è‰²
                            };
                            
                            // æ‰£é™¤å‘é€è€…ä½™é¢
                            sender.identity.balance = (balance - totalAmount).toFixed(2);
                            await db.characters.put(sender);
                            
                            // æ·»åŠ çº¢åŒ…æ¶ˆæ¯
                            updatedGroup.chat_history.push({
                                role: 'char',
                                senderId: senderId,
                                type: 'redpacket',
                                content: JSON.stringify(redpacketData),
                                time: Date.now() + msgIndex * 50
                            });
                            msgIndex++;
                            
                            // è®°å½•çº¢åŒ…IDä¾›åç»­é¢†å–ä½¿ç”¨
                            if (!window._lastRedpacketId) window._lastRedpacketId = {};
                            window._lastRedpacketId[senderId] = redpacketId;
                            
                            continue;
                        }
                        
                        // å¤„ç†é¢†å–çº¢åŒ…æŒ‡ä»¤
                        if (reply.type === 'claim_redpacket' && reply.redpacketId) {
                            if (!senderId) continue;
                            
                            // å¦‚æœredpacketIdæ˜¯"auto"æˆ–ç©ºï¼Œå°è¯•è·å–æœ€è¿‘çš„çº¢åŒ…
                            let targetRedpacketId = reply.redpacketId;
                            if (!targetRedpacketId || targetRedpacketId === 'auto' || targetRedpacketId.includes('éœ€è¦ç­‰')) {
                                // æŸ¥æ‰¾æœ€è¿‘æœªé¢†å®Œçš„çº¢åŒ…
                                for (let i = updatedGroup.chat_history.length - 1; i >= 0; i--) {
                                    const m = updatedGroup.chat_history[i];
                                    if (m.type === 'redpacket') {
                                        try {
                                            const data = JSON.parse(m.content);
                                            const isAllClaimed = (data.claimed?.length || 0) >= data.count;
                                            const alreadyClaimed = data.claimed?.includes(senderId);
                                            if (!isAllClaimed && !alreadyClaimed) {
                                                targetRedpacketId = data.id;
                                                break;
                                            }
                                        } catch(e) {}
                                    }
                                }
                                if (!targetRedpacketId || targetRedpacketId === 'auto' || targetRedpacketId.includes('éœ€è¦ç­‰')) {
                                    continue; // æ²¡æœ‰æ‰¾åˆ°å¯é¢†å–çš„çº¢åŒ…
                                }
                            }
                            
                            // æ‰¾åˆ°çº¢åŒ…æ¶ˆæ¯
                            const rpMsgIndex = updatedGroup.chat_history.findIndex(m => {
                                if (m.type !== 'redpacket') return false;
                                try {
                                    const data = JSON.parse(m.content);
                                    return data.id === targetRedpacketId;
                                } catch(e) {
                                    return false;
                                }
                            });
                            
                            if (rpMsgIndex === -1) continue;
                            
                            const rpMsg = updatedGroup.chat_history[rpMsgIndex];
                            const rpData = JSON.parse(rpMsg.content);
                            
                            // æ£€æŸ¥æ˜¯å¦å·²é¢†å–å®Œ
                            if ((rpData.claimed?.length || 0) >= rpData.count) continue;
                            
                            // æ£€æŸ¥æ˜¯å¦å·²é¢†å–è¿‡
                            if (rpData.claimed?.includes(senderId)) continue;
                            
                            // æ£€æŸ¥æ˜¯å¦æ˜¯ä¸“å±çº¢åŒ…
                            if (rpData.redpacketType === 'single' && rpData.targetName) {
                                const claimer = memberMap[senderId];
                                const claimerName = claimer?.remark || claimer?.name || reply.name;
                                // åªæœ‰ç›®æ ‡è§’è‰²å¯ä»¥é¢†å–
                                if (claimerName !== rpData.targetName && claimer?.name !== rpData.targetName) {
                                    continue; // ä¸æ˜¯ç›®æ ‡è§’è‰²ï¼Œè·³è¿‡
                                }
                            }
                            
                            // é¢†å–çº¢åŒ…
                            if (!rpData.claimed) rpData.claimed = [];
                            if (!rpData.claimedAmounts) rpData.claimedAmounts = {};
                            
                            let claimAmount = 0;
                            const totalAmount = parseFloat(rpData.totalAmount);
                            const remaining = rpData.count - rpData.claimed.length;
                            const alreadyClaimed = Object.values(rpData.claimedAmounts).reduce((a, b) => a + parseFloat(b), 0);
                            const remainingAmount = totalAmount - alreadyClaimed;
                            
                            if (rpData.redpacketType === 'lucky') {
                                // æ‹¼æ‰‹æ°”çº¢åŒ…ï¼šéšæœºé‡‘é¢
                                if (remaining === 1) {
                                    claimAmount = remainingAmount;
                                } else {
                                    const maxAmount = remainingAmount - (remaining - 1) * 0.01;
                                    claimAmount = Math.random() * maxAmount * 0.8 + 0.01;
                                    claimAmount = Math.min(claimAmount, maxAmount);
                                }
                            } else {
                                // æ™®é€šçº¢åŒ…ï¼šå¹³å‡åˆ†é…
                                claimAmount = totalAmount / rpData.count;
                            }
                            
                            claimAmount = parseFloat(claimAmount.toFixed(2));
                            
                            // è®°å½•é¢†å–
                            rpData.claimed.push(senderId);
                            rpData.claimedAmounts[senderId] = claimAmount.toFixed(2);
                            
                            // æ›´æ–°çº¢åŒ…æ¶ˆæ¯
                            updatedGroup.chat_history[rpMsgIndex].content = JSON.stringify(rpData);
                            
                            // å¢åŠ è§’è‰²ä½™é¢
                            const claimer = await db.characters.get(senderId);
                            if (claimer) {
                                if (!claimer.identity) claimer.identity = {};
                                let balance = parseFloat(claimer.identity.balance || 0);
                                balance += claimAmount;
                                claimer.identity.balance = balance.toFixed(2);
                                await db.characters.put(claimer);
                            }
                            
                            const claimerName = memberMap[senderId]?.remark || memberMap[senderId]?.name || reply.name;
                            
                            // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯
                            updatedGroup.chat_history.push({
                                role: 'system',
                                content: `${claimerName} é¢†å–äº†çº¢åŒ…ï¼Œè·å¾— Â¥${claimAmount.toFixed(2)}`,
                                time: Date.now() + msgIndex * 50
                            });
                            msgIndex++;
                            continue;
                        }
                        
                        // æ™®é€šå‘è¨€
                        if (!reply.name || !reply.content) continue;
                        
                        // æ£€æŸ¥æ˜¯å¦è¢«ç¦è¨€
                        if (senderId && updatedGroup.mutedMembers.includes(senderId)) {
                            continue;
                        }
                        
                        // ä½¿ç”¨åˆ†å¥é€»è¾‘ - æ”¯æŒ ||| åˆ†éš”ç¬¦å’Œè‡ªç„¶åˆ†å¥
                        let segments = [];
                        const content = reply.content.trim();
                        
                        // å…ˆæŒ‰ ||| åˆ†å‰²
                        if (content.includes('|||')) {
                            segments = content.split('|||').map(s => s.trim()).filter(s => s.length > 0);
                        } else {
                            // ä½¿ç”¨ splitMessage å‡½æ•°è¿›è¡Œè‡ªç„¶åˆ†å¥
                            segments = splitMessage(content);
                            if (segments.length === 0) {
                                segments = [content];
                            }
                        }
                        
                        // ä¸ºæ¯ä¸ªåˆ†å¥åˆ›å»ºä¸€æ¡æ¶ˆæ¯
                        for (const segment of segments) {
                            if (!segment || segment.length === 0) continue;
                            
                            updatedGroup.chat_history.push({
                                role: 'char',
                                senderId: senderId,
                                content: segment,
                                time: Date.now() + msgIndex * 50 // ç¨å¾®é”™å¼€æ—¶é—´
                            });
                            msgIndex++;
                        }
                    }
                    
                    updatedGroup.updated_at = Date.now();
                    await db.group_chats.put(updatedGroup);
                    
                    // é‡æ–°æ¸²æŸ“ç¾¤èŠ
                    await renderGroupChatBody(updatedGroup);
                    
                    // âœ… ç¾¤èŠå›å¤å®Œæˆåï¼Œæ£€æŸ¥æ˜¯å¦éœ€è¦è‡ªåŠ¨æ€»ç»“
                    try {
                        const accountId = getCurrentAccountId();
                        await checkAutoSummary('group', window.currentGroupChatId, accountId);
                    } catch (summaryError) {
                        console.error('[AutoSummary] æ£€æŸ¥ç¾¤èŠè‡ªåŠ¨æ€»ç»“å¤±è´¥:', summaryError);
                    }
                }
                
            } catch (error) {
                console.error('[triggerGroupMemberReply] ç”Ÿæˆå›å¤å¤±è´¥:', error);
                alert('ç”Ÿæˆå›å¤å¤±è´¥: ' + error.message);
            } finally {
                // æ¢å¤æ ‡é¢˜
                if (chatTitleEl) chatTitleEl.innerText = originalTitle;
            }
        }
        
        async function getCurrentUserName() {
            const accountId = getCurrentAccountId();
            if (!accountId) return 'æˆ‘';
            const myChar = await db.characters.get(parseInt(accountId));
            return myChar ? myChar.name : 'æˆ‘';
        }

        function hideChatWindow() {
            const win = document.getElementById('chat-window');
            win.style.transform = 'translateX(100%)';
            setTimeout(() => {
                win.style.display = 'none';
                win.style.transform = '';
            }, 300);
            currentChatCharId = null;
            window.currentGroupChatId = null; // æ¸…é™¤ç¾¤èŠID
            
            // æ¢å¤è¾“å…¥æ¡†æ˜¾ç¤ºï¼ˆæŸ¥å²—æ¨¡å¼å¯èƒ½éšè—äº†å®ƒï¼‰
            const chatFooter = document.getElementById('chat-footer');
            if (chatFooter) chatFooter.style.display = 'flex';
            
            // é€€å‡ºå¤šé€‰æ¨¡å¼
            if (isSelectionMode) exitSelectionMode();
        }

        // è¾…åŠ©ï¼šè·å– User å¤´åƒ URL
        async function getUserAvatarUrl(userId) {
            // âœ… ä¼˜å…ˆä½¿ç”¨ä¼ å…¥çš„ userId
            if (userId) {
                const user = await db.characters.get(userId);
                if (user && user.avatar) return user.avatar;
            }
            
            // âœ… å…¶æ¬¡ä½¿ç”¨å½“å‰ç™»å½•ç”¨æˆ·ï¼ˆä¸ªäººä¸­å¿ƒ"æˆ‘"çš„è§’è‰²ï¼‰çš„å¤´åƒ
            if (currentMyCharId) {
                const myChar = await db.characters.get(parseInt(currentMyCharId));
                if (myChar && myChar.avatar) return myChar.avatar;
            }
            
            // æœ€åå›é€€ï¼šä»æ¡Œé¢å¤´åƒå°ç»„ä»¶è·å–
            const dom = document.getElementById('avatar-img-1');
            if (dom) {
                const bg = dom.style.backgroundImage;
                if (bg && bg !== 'none') return bg.replace(/url\(|\)|"/g, '');
            }
            return '';
        }

        // âœ… æ ¸å¿ƒå‡½æ•°1ï¼šåˆ¤æ–­æ˜¯å¦æ˜¯å›¾ç‰‡URL
        function isImageUrl(text) {
            if (!text || typeof text !== 'string') return false;
            const clean = text.trim();
            // æ£€æŸ¥æ˜¯å¦æ˜¯å›¾ç‰‡URLï¼ˆæ”¯æŒå¸¸è§å›¾ç‰‡æ ¼å¼ï¼‰
            return /\.(png|jpg|jpeg|gif|webp|bmp|svg)(\?.*)?$/i.test(clean) || 
                   /^https?:\/\/.*\.(png|jpg|jpeg|gif|webp|bmp|svg)(\?.*)?$/i.test(clean);
        }

        // âœ… æ ¸å¿ƒå‡½æ•°2ï¼šæ¸…ç†æ¶ˆæ¯å†…å®¹ï¼ˆåˆ é™¤æœ«å°¾å¤šä½™çš„]å’Œå¼€å¤´çš„[ï¼Œä»¥åŠimg:å‰ç¼€ï¼‰
        function sanitizeMessage(text) {
            if (!text || typeof text !== 'string') return text;
            let cleaned = text.trim();
            
            // âœ… ä¿æŠ¤ç‰¹æ®Šæ ¼å¼ï¼šå¦‚æœæ˜¯ä»¥ç‰¹æ®Šæ ¼å¼å¼€å¤´ï¼Œä¸è¦æ¸…ç†æ–¹æ‹¬å·
            if (/^\[(img|voice|imgcard):/.test(cleaned)) {
                // è¿™æ˜¯ç‰¹æ®Šæ ¼å¼æ¶ˆæ¯ï¼Œä¿æŒåŸæ ·
                return cleaned;
            }
            
            // ğŸ”¥ æ ¸å¿ƒä¿®å¤ï¼šå…ˆå»æ‰ img: å‰ç¼€ï¼ˆé˜²æ­¢ ERR_UNKNOWN_URL_SCHEMEï¼‰
            cleaned = cleaned.replace(/^img:/, '');
            // å»æ‰æ–¹æ‹¬å·
            cleaned = cleaned.replace(/\]+$/, '');   // å¹²æ‰ç»“å°¾æ‰€æœ‰ ]
            cleaned = cleaned.replace(/^\[+/, '');   // å¹²æ‰å¼€å¤´ [
            // å¦‚æœè¿˜æœ‰ img: å‰ç¼€ï¼ˆå¯èƒ½åœ¨æ–¹æ‹¬å·å»æ‰åå‡ºç°ï¼‰ï¼Œå†æ¬¡æ¸…ç†
            cleaned = cleaned.replace(/^img:/, '');
            return cleaned;
        }

        // âœ… æ ¸å¿ƒå‡½æ•°3ï¼šç»Ÿä¸€çš„æ¶ˆæ¯å†…å®¹æ¸²æŸ“å‡½æ•°
        function renderMessageContent(text) {
            if (!text || typeof text !== 'string') return '';
            
            // å…ˆæ¸…ç†æ¶ˆæ¯ï¼ˆå»æ‰img:å‰ç¼€ã€æ–¹æ‹¬å·ç­‰ï¼‰
            const clean = sanitizeMessage(text);
            
            // ğŸ”¥ é¢å¤–ä¿æŠ¤ï¼šå¦‚æœæ¸…ç†åè¿˜æœ‰img:å‰ç¼€ï¼Œå†æ¬¡æ¸…ç†ï¼ˆé˜²æ­¢è¾¹ç¼˜æƒ…å†µï¼‰
            const finalClean = clean.replace(/^img:/, '');
            
            // å¦‚æœæ•´ä¸ªæ¶ˆæ¯å°±æ˜¯ä¸€ä¸ªå›¾ç‰‡URLï¼Œç›´æ¥æ¸²æŸ“ä¸ºå›¾ç‰‡
            if (isImageUrl(finalClean)) {
                return `<img src="${finalClean}" class="chat-image" onerror="this.style.display='none';" />`;
            }
            
            // æ£€æŸ¥æ˜¯å¦åŒ…å«[img:...]æ ¼å¼çš„å›¾ç‰‡æ ‡è®°
            const imgMatches = finalClean.matchAll(/\[img:([^\]]+)\]/g);
            const images = Array.from(imgMatches);
            
            if (images.length > 0) {
                // åŒ…å«å›¾ç‰‡æ ‡è®°ï¼Œéœ€è¦æ··åˆæ˜¾ç¤º
                let html = '';
                let lastIndex = 0;
                
                images.forEach((match) => {
                    // æ·»åŠ å›¾ç‰‡å‰çš„æ–‡å­—
                    if (match.index > lastIndex) {
                        const textBefore = finalClean.substring(lastIndex, match.index);
                        if (textBefore.trim()) {
                            html += `<span>${escapeHtml(textBefore)}</span>`;
                        }
                    }
                    
                    // æ·»åŠ å›¾ç‰‡ï¼ˆä½¿ç”¨chat-imageç±»ï¼Œç¡®ä¿å»æ‰img:å‰ç¼€ï¼‰
                    let imgUrl = sanitizeMessage(match[1]);
                    // ğŸ”¥ é¢å¤–ä¿æŠ¤ï¼šå†æ¬¡ç¡®ä¿æ²¡æœ‰img:å‰ç¼€
                    imgUrl = imgUrl.replace(/^img:/, '');
                    html += `<img src="${imgUrl}" class="chat-image" onerror="this.style.display='none';" />`;
                    
                    lastIndex = match.index + match[0].length;
                });
                
                // æ·»åŠ æœ€åä¸€æ®µæ–‡å­—ï¼ˆå¦‚æœæœ‰ï¼‰
                if (lastIndex < finalClean.length) {
                    const textAfter = finalClean.substring(lastIndex);
                    if (textAfter.trim()) {
                        html += `<span>${escapeHtml(textAfter)}</span>`;
                    }
                }
                
                return html;
            }
            
            // æ£€æŸ¥æ˜¯å¦åŒ…å«æ™®é€šURLï¼ˆhttp://æˆ–https://ï¼‰
            const urlRegex = /(https?:\/\/[^\s]+)/g;
            const hasUrl = urlRegex.test(finalClean);
            
            if (hasUrl) {
                // åŒ…å«URLï¼Œè½¬æ¢ä¸ºHTMLå¹¶ä¿æŠ¤URL
                return finalClean.replace(urlRegex, (url) => {
                    let cleanUrl = sanitizeMessage(url);
                    // ğŸ”¥ é¢å¤–ä¿æŠ¤ï¼šå†æ¬¡ç¡®ä¿æ²¡æœ‰img:å‰ç¼€
                    cleanUrl = cleanUrl.replace(/^img:/, '');
                    // æ£€æŸ¥æ˜¯å¦æ˜¯å›¾ç‰‡URL
                    if (isImageUrl(cleanUrl)) {
                        return `<img src="${cleanUrl}" class="chat-image" onerror="this.style.display='none';" />`;
                    } else {
                        // æ™®é€šé“¾æ¥
                        return `<a href="${cleanUrl}" target="_blank" style="color:#007aff; word-break:break-all;">${escapeHtml(cleanUrl)}</a>`;
                    }
                });
            }
            
            // çº¯æ–‡æœ¬ï¼Œè½¬ä¹‰HTMLé˜²æ­¢XSS
            return `<span>${escapeHtml(finalClean)}</span>`;
        }

        // è¾…åŠ©å‡½æ•°ï¼šè½¬ä¹‰HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ç¾¤èŠå›¾ç‰‡å¡ç‰‡ç‚¹å‡»å±•å¼€ - ä½¿ç”¨ä¸ç§èŠç›¸åŒçš„æ ·å¼
        function showImageCardContent(el) {
            const text = el.dataset.text;
            if (!text) return;
            
            const isExpanded = el.dataset.expanded === 'true';
            
            if (isExpanded) {
                // æ”¶èµ·ï¼šæ˜¾ç¤ºå¡ç‰‡
                el.innerHTML = `
                    <div class="img-card-placeholder">
                        <svg class="img-card-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                            <circle cx="8.5" cy="8.5" r="1.5"></circle>
                            <polyline points="21 15 16 10 5 21"></polyline>
                        </svg>
                        <div class="img-card-hint">ç‚¹å‡»æŸ¥çœ‹æ–‡å­—</div>
                    </div>
                `;
                el.dataset.expanded = 'false';
            } else {
                // å±•å¼€ï¼šæ˜¾ç¤ºæ–‡å­—
                el.innerHTML = `<div class="img-card-text">${escapeHtml(text)}</div>`;
                el.dataset.expanded = 'true';
            }
        }

        // ç¾¤èŠè¯­éŸ³æ°”æ³¡ç‚¹å‡»æ’­æ”¾
        function playVoiceBubble(el) {
            const text = el.dataset.text;
            if (!text) return;
            
            // æ˜¾ç¤ºè¯­éŸ³å†…å®¹å¼¹çª—
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); display:flex; align-items:center; justify-content:center; z-index:10000;';
            modal.onclick = () => modal.remove();
            
            modal.innerHTML = `
                <div style="background:#fff; padding:20px 24px; border-radius:12px; max-width:85%; max-height:70%; overflow-y:auto;" onclick="event.stopPropagation()">
                    <div style="font-size:14px; color:#666; margin-bottom:12px; display:flex; align-items:center; gap:8px;">
                        <svg viewBox="0 0 24 24" style="width:18px; height:18px; fill:#999;"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02z"/></svg>
                        è¯­éŸ³æ¶ˆæ¯å†…å®¹
                    </div>
                    <div style="font-size:16px; line-height:1.8; color:#333; white-space:pre-wrap;">${escapeHtml(text)}</div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }

        // æ˜¾ç¤ºå®Œæ•´å›¾ç‰‡
        function showFullImage(src) {
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); display:flex; align-items:center; justify-content:center; z-index:10000;';
            modal.onclick = () => modal.remove();
            
            modal.innerHTML = `<img src="${src}" style="max-width:95%; max-height:95%; object-fit:contain;" />`;
            
            document.body.appendChild(modal);
        }

        // æ ¼å¼åŒ–æ—¶é—´æˆ³
        function formatMessageTime(timestamp, prevTimestamp) {
            if (!timestamp) return '';
            
            const msgTime = new Date(timestamp);
            const now = new Date();
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            const msgDate = new Date(msgTime.getFullYear(), msgTime.getMonth(), msgTime.getDate());
            const yesterday = new Date(today);
            yesterday.setDate(yesterday.getDate() - 1);
            
            let timeStr = '';
            if (msgDate.getTime() === today.getTime()) {
                // ä»Šå¤©ï¼šæ˜¾ç¤ºæ—¶é—´
                timeStr = `${msgTime.getHours()}:${msgTime.getMinutes().toString().padStart(2, '0')}`;
            } else if (msgDate.getTime() === yesterday.getTime()) {
                // æ˜¨å¤©
                timeStr = `æ˜¨å¤© ${msgTime.getHours()}:${msgTime.getMinutes().toString().padStart(2, '0')}`;
            } else if (now.getTime() - msgTime.getTime() < 7 * 24 * 60 * 60 * 1000) {
                // ä¸€å‘¨å†…ï¼šæ˜¾ç¤ºæ˜ŸæœŸ
                const weekdays = ['å‘¨æ—¥', 'å‘¨ä¸€', 'å‘¨äºŒ', 'å‘¨ä¸‰', 'å‘¨å››', 'å‘¨äº”', 'å‘¨å…­'];
                timeStr = `${weekdays[msgTime.getDay()]} ${msgTime.getHours()}:${msgTime.getMinutes().toString().padStart(2, '0')}`;
            } else {
                // æ›´æ—©ï¼šæ˜¾ç¤ºæ—¥æœŸ
                timeStr = `${msgTime.getMonth() + 1}/${msgTime.getDate()} ${msgTime.getHours()}:${msgTime.getMinutes().toString().padStart(2, '0')}`;
            }
            
            return timeStr;
        }
        
        // åˆ¤æ–­æ˜¯å¦éœ€è¦æ˜¾ç¤ºæ—¶é—´æˆ³ï¼ˆä¸¤æ¡æ¶ˆæ¯é—´éš”è¶…è¿‡5åˆ†é’Ÿæ‰æ˜¾ç¤ºï¼‰
        function shouldShowTimestamp(currentTime, prevTime) {
            if (!prevTime) return true; // ç¬¬ä¸€æ¡æ¶ˆæ¯æ˜¾ç¤ºæ—¶é—´
            const diff = currentTime - prevTime;
            return diff > 5 * 60 * 1000; // è¶…è¿‡5åˆ†é’Ÿ
        }

        // æ„é€ æ¶ˆæ¯ DOM
        function createMessageElement(msg, index, charAvatar, userAvatar, prevMsgTime, charName = 'AI') {
            const row = document.createElement('div');
            row.className = `message-row ${msg.role === 'user' ? 'self' : 'other'}`;
            row.dataset.index = index;

            // å¤é€‰æ¡† (å¤šé€‰æ¨¡å¼ç”¨)
            const checkbox = document.createElement('div');
            checkbox.className = 'msg-checkbox';
            row.appendChild(checkbox);

            // å¤´åƒ
            const avatar = document.createElement('div');
            avatar.className = 'message-avatar';
            
            if (msg.role === 'char') {
                if (charAvatar) avatar.style.backgroundImage = `url(${charAvatar})`;
                // ç»™è§’è‰²å¤´åƒæ·»åŠ ç‚¹å‡»äº‹ä»¶ï¼Œæ˜¾ç¤ºå¿ƒå£°
                avatar.style.cursor = 'pointer';
                avatar.onclick = async (e) => {
                    e.stopPropagation(); // é˜»æ­¢å†’æ³¡ï¼Œé¿å…è§¦å‘æ¶ˆæ¯é€‰æ‹©
                    await showCharacterThoughts(currentChatCharId, index);
                };
            } else {
                if (userAvatar) {
                    avatar.style.backgroundImage = `url(${userAvatar})`;
                } else {
                    avatar.style.backgroundColor = '#eee';
                }
            }

            // å†…å®¹æ°”æ³¡
            const content = document.createElement('div');
            content.className = msg.role === 'user' ? 'message-content user-bubble' : 'message-content ai-bubble';
            
            // æ£€æµ‹è½¬è´¦æ¶ˆæ¯ - æ”¯æŒ type='transfer' æˆ– content ä¸ºè½¬è´¦JSONæ ¼å¼
            let isTransferMsg = false;
            let transferData = {};
            
            if (msg.type === 'transfer') {
                isTransferMsg = true;
                try {
                    transferData = JSON.parse(msg.content);
                } catch(e) {
                    transferData = { amount: '0.00', desc: 'è§£æé”™è¯¯', status: 'sent' };
                }
            } else if (msg.content) {
                // å°è¯•è§£æä¸ºè½¬è´¦JSON - trimç©ºæ ¼åæ£€æŸ¥
                const trimmed = msg.content.trim();
                if (trimmed.startsWith('{') && trimmed.includes('"amount"') && !trimmed.startsWith('[')) {
                    try {
                        const parsed = JSON.parse(trimmed);
                        if (parsed.amount && parsed.desc !== undefined && parsed.status) {
                            isTransferMsg = true;
                            transferData = parsed;
                            // è¡¥å……IDï¼ˆå¦‚æœæ²¡æœ‰ï¼‰
                            if (!msg.id) msg.id = 'trans_' + msg.time;
                        }
                    } catch(e) {
                        // ä¸æ˜¯æœ‰æ•ˆçš„è½¬è´¦JSONï¼ŒæŒ‰æ™®é€šæ¶ˆæ¯å¤„ç†
                    }
                }
            }
            
            // å¤„ç†è½¬è´¦æ¶ˆæ¯
            if (isTransferMsg) {
                // å»é™¤é»˜è®¤èƒŒæ™¯å’Œpaddingï¼Œå®Œå…¨äº¤ç»™ transfer-card
                content.style.padding = '0';
                content.style.background = 'transparent';
                content.style.boxShadow = 'none';
                
                const isSelf = msg.role === 'user';
                const isDone = transferData.status === 'received';
                const isReturned = transferData.status === 'returned';
                
                let statusText = 'è½¬è´¦';
                if (isSelf) statusText = 'å·²å‘é€';
                if (isDone) statusText = 'å·²æ”¶æ¬¾';
                if (isReturned) statusText = 'å·²é€€å›';
                
                content.innerHTML = `
                    <div class="transfer-card ${isDone ? 'done' : ''} ${isReturned ? 'returned' : ''}" onclick="showTransferConfirm('${msg.id}', ${isSelf}, '${transferData.status}')">
                        <div class="t-amount">Â¥ ${transferData.amount}</div>
                        <div class="t-desc">${transferData.desc}</div>
                        <div class="t-line"></div>
                        <div class="t-footer">
                            <span class="t-footer-text">${statusText}</span>
                            <span class="t-dot"></span>
                        </div>
                    </div>
                `;
            }
            // âœ… å¤„ç†éŸ³é¢‘/è¯­éŸ³æ¶ˆæ¯ï¼ˆè”æœºå¥½å‹çœŸå®å½•éŸ³ï¼‰- ä½¿ç”¨æ™®é€šæ°”æ³¡æ ·å¼
            else if (msg.type === 'audio' && msg.content && msg.content.startsWith('data:audio')) {
                const duration = msg.duration || 0;
                const audioId = 'audio_' + (msg.time || Date.now());
                
                // ç®€å•æ˜¾ç¤ºè¯­éŸ³å›¾æ ‡å’Œæ—¶é•¿ï¼Œç‚¹å‡»æ’­æ”¾
                content.textContent = `ğŸ¤ ${duration}"`;
                content.style.cursor = 'pointer';
                content.dataset.audioId = audioId;
                content.onclick = function() { playOnlineAudio(this.dataset.audioId); };
                
                // æ·»åŠ éšè—çš„ audio å…ƒç´ åˆ°æ¶ˆæ¯è¡Œ
                setTimeout(() => {
                    const audioEl = document.createElement('audio');
                    audioEl.id = audioId;
                    audioEl.src = msg.content;
                    audioEl.style.display = 'none';
                    document.body.appendChild(audioEl);
                }, 0);
            }
            // å¤„ç†äº²å±å¡æ¶ˆæ¯
            else if (msg.type === 'familyCard') {
                content.style.padding = '0';
                content.style.background = 'transparent';
                content.style.boxShadow = 'none';
                
                let cardData = {};
                try {
                    cardData = JSON.parse(msg.content);
                } catch(e) {
                    cardData = { fromName: 'æœªçŸ¥', monthlyLimit: 0, status: 'sent' };
                }
                
                const isSelf = msg.role === 'user';
                const limitText = cardData.monthlyLimit > 0 ? `æ¯æœˆé¢åº¦ Â¥${cardData.monthlyLimit}` : 'ä¸é™é¢åº¦';
                
                content.innerHTML = `
                    <div class="family-card-msg">
                        <div class="family-card-msg-title">ğŸ’ äº²å±å¡</div>
                        <div class="family-card-msg-desc">${limitText}</div>
                        <div class="family-card-msg-line"></div>
                        <div class="family-card-msg-footer">
                            <span class="family-card-msg-status">${isSelf ? 'å·²èµ é€' : 'å·²æ”¶åˆ°'}</span>
                            <span class="family-card-msg-dot"></span>
                        </div>
                    </div>
                `;
            }
            // å¤„ç†ä½ç½®æ¶ˆæ¯
            else if (msg.type === 'location') {
                content.style.padding = '0';
                content.style.background = 'transparent';
                content.style.boxShadow = 'none';
                
                let locationData = {};
                try {
                    locationData = JSON.parse(msg.content);
                } catch(e) {
                    locationData = { name: 'æœªçŸ¥ä½ç½®', address: '' };
                }
                
                content.innerHTML = `
                    <div class="location-card" onclick="showLocationDetail('${encodeURIComponent(locationData.name)}', '${encodeURIComponent(locationData.address)}')">
                        <div class="location-card-text">
                            <div class="location-card-name">${locationData.name}</div>
                            <div class="location-card-sub">ä½ç½®åˆ†äº«</div>
                        </div>
                        <div class="location-card-map">
                            <div class="location-card-pin">
                                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M12 11.5C11.1716 11.5 10.5 10.8284 10.5 10C10.5 9.17157 11.1716 8.5 12 8.5C12.8284 8.5 13.5 9.17157 13.5 10C13.5 10.8284 12.8284 11.5 12 11.5Z"></path>
                                    <path d="M12 2C7.92134 2 4.5 5.42134 4.5 9.5C4.5 14.5312 11.2188 21.4375 11.5938 21.8125C11.7954 22.014 12.2046 22.014 12.4062 21.8125C12.7812 21.4375 19.5 14.5312 19.5 9.5C19.5 5.42134 16.0787 2 12 2ZM12 12.5C10.6193 12.5 9.5 11.3807 9.5 10C9.5 8.61929 10.6193 7.5 12 7.5C13.3807 7.5 14.5 8.61929 14.5 10C14.5 11.3807 13.3807 12.5 12 12.5Z"></path>
                                </svg>
                            </div>
                        </div>
                    </div>
                `;
            }
            // å¤„ç†æ’¤å›æ¶ˆæ¯ï¼ˆå±…ä¸­ç³»ç»Ÿæç¤ºæ ·å¼ï¼Œç‚¹å‡»å¯æŸ¥çœ‹åŸå†…å®¹ï¼‰
            else if (msg.isRecalled) {
                const isUser = msg.role === 'user';
                const recallerName = isUser ? 'ä½ ' : charName;
                
                // æ”¹ä¸ºç³»ç»Ÿæç¤ºæ ·å¼ï¼šå±…ä¸­ç°è‰²æ–‡å­—
                row.className = 'message-row recalled-system-row';
                row.innerHTML = ''; // æ¸…ç©ºåŸæœ‰å†…å®¹
                
                const systemTip = document.createElement('div');
                systemTip.className = 'recalled-system-tip';
                systemTip.innerHTML = `"${recallerName}"æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯`;
                systemTip.style.cursor = 'pointer';
                
                // ç‚¹å‡»æŸ¥çœ‹æ’¤å›çš„å†…å®¹
                systemTip.onclick = (e) => {
                    e.stopPropagation();
                    if (msg.recalledContent) {
                        showRecalledContent(recallerName, msg.recalledContent);
                    } else {
                        showToast('åŸæ¶ˆæ¯å†…å®¹å·²ä¸å¯ç”¨');
                    }
                };
                
                row.appendChild(systemTip);
                return row; // ç›´æ¥è¿”å›ï¼Œä¸å†æ·»åŠ å¤´åƒå’Œæ°”æ³¡
            } 
            // å¤„ç†è¯­éŸ³æ¶ˆæ¯
            else if (msg.content.startsWith('[voice:')) {
                // ç›´æ¥æå–è¯­éŸ³æ–‡æœ¬ï¼Œä¸è¦ç”¨ sanitizeMessage
                let voiceText = msg.content.substring(7, msg.content.length - 1).trim();
                
                // æ£€æŸ¥è¯­éŸ³æ–‡æœ¬ä¸­æ˜¯å¦åŒ…å«å›¾ç‰‡é“¾æ¥
                const imgMatch = voiceText.match(/\[img:([^\]]+)\]/);
                let hasImage = false;
                let imgUrl = '';
                let cleanVoiceText = voiceText;
                
                if (imgMatch) {
                    hasImage = true;
                    imgUrl = imgMatch[1].trim(); // ç›´æ¥ä½¿ç”¨ï¼Œä¸è¦ç”¨ sanitizeMessage
                    // ä»è¯­éŸ³æ–‡æœ¬ä¸­ç§»é™¤å›¾ç‰‡æ ‡è®°
                    cleanVoiceText = voiceText.replace(/\[img:[^\]]+\]/g, '').trim();
                }
                
                const duration = Math.ceil(cleanVoiceText.length / 5); // æ¨¡æ‹Ÿæ—¶é•¿ï¼šæ¯5ä¸ªå­—1ç§’
                
                // åˆ›å»ºè¯­éŸ³æ°”æ³¡å®¹å™¨ï¼ˆä½¿ç”¨çº¯CSSæ³¢çº¹åŠ¨ç”»ï¼‰
                content.className = 'voice-bubble';
                let voiceHtml = `
                    <div class="voice-bubble-header">
                        <div class="voice-icon">
                            <i></i>
                            <i></i>
                            <i></i>
                        </div>
                        <div class="voice-duration">${duration}"</div>
                    </div>
                    <div class="voice-text-content">${escapeHtml(cleanVoiceText)}</div>
                `;
                
                // å¦‚æœåŒ…å«å›¾ç‰‡ï¼Œåœ¨è¯­éŸ³æ°”æ³¡ä¸‹æ–¹æ·»åŠ å›¾ç‰‡ï¼ˆä½¿ç”¨chat-imageç±»ï¼‰
                if (hasImage) {
                    voiceHtml += `<div style="margin-top:8px;"><img src="${imgUrl}" class="chat-image" onerror="this.style.display='none';" /></div>`;
                }
                
                content.innerHTML = voiceHtml;
                
                // ç‚¹å‡»å±•å¼€/æ”¶èµ·æ–‡å­—
                content.onclick = (e) => {
                    // å¦‚æœç‚¹å‡»çš„æ˜¯å›¾ç‰‡ï¼Œä¸è§¦å‘å±•å¼€/æ”¶èµ·
                    if (e.target.tagName === 'IMG') {
                        e.stopPropagation();
                        return;
                    }
                    e.stopPropagation();
                    content.classList.toggle('expanded');
                };
            }
            // å¤„ç†å›¾ç‰‡å¡ç‰‡æ¶ˆæ¯
            else if (msg.content.startsWith('[imgcard:')) {
                // ç›´æ¥æå–æ–¹æ‹¬å·å†…çš„å†…å®¹ï¼Œä¸è¦ç”¨ sanitizeMessageï¼ˆä¼šç ´åæ ¼å¼ï¼‰
                const cardText = msg.content.substring(9, msg.content.length - 1).trim();
                
                content.className = 'img-card-bubble';
                content.dataset.text = cardText; // å­˜å‚¨æ–‡å­—å†…å®¹
                content.dataset.expanded = 'false'; // åˆå§‹çŠ¶æ€ï¼šæœªå±•å¼€
                
                // é»˜è®¤æ˜¾ç¤ºå¡ç‰‡çŠ¶æ€
                content.innerHTML = `
                    <div class="img-card-placeholder">
                        <svg class="img-card-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                            <circle cx="8.5" cy="8.5" r="1.5"></circle>
                            <polyline points="21 15 16 10 5 21"></polyline>
                        </svg>
                        <div class="img-card-hint">ç‚¹å‡»æŸ¥çœ‹æ–‡å­—</div>
                    </div>
                `;
                
                // ç‚¹å‡»åˆ‡æ¢å±•å¼€/æ”¶èµ·
                content.onclick = (e) => {
                    e.stopPropagation();
                    const isExpanded = content.dataset.expanded === 'true';
                    
                    if (isExpanded) {
                        // æ”¶èµ·ï¼šæ˜¾ç¤ºå¡ç‰‡
                        content.innerHTML = `
                            <div class="img-card-placeholder">
                                <svg class="img-card-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                                    <circle cx="8.5" cy="8.5" r="1.5"></circle>
                                    <polyline points="21 15 16 10 5 21"></polyline>
                                </svg>
                                <div class="img-card-hint">ç‚¹å‡»æŸ¥çœ‹æ–‡å­—</div>
                            </div>
                        `;
                        content.dataset.expanded = 'false';
                    } else {
                        // å±•å¼€ï¼šæ˜¾ç¤ºæ–‡å­—
                        content.innerHTML = `<div class="img-card-text">${cardText}</div>`;
                        content.dataset.expanded = 'true';
                    }
                };
            }
            // å¤„ç†å›¾ç‰‡æ¶ˆæ¯ï¼ˆçº¯å›¾ç‰‡ï¼Œæˆ–ä»¥å›¾ç‰‡å¼€å¤´ï¼‰
            else if (msg.content.startsWith('[img:')) {
                // ç›´æ¥æå–URLï¼Œä¸è¦ç”¨ sanitizeMessage
                const imgUrl = msg.content.substring(5, msg.content.length - 1).trim();
                content.innerHTML = `<img src="${imgUrl}" class="chat-image" onerror="this.style.display='none';" />`;
                content.style.padding = '4px';
                content.style.background = 'transparent';
                content.style.boxShadow = 'none';
            } 
            // âœ… æ™®é€šæ–‡æœ¬ - ä½¿ç”¨ç»Ÿä¸€çš„æ¸²æŸ“å‡½æ•°
            else {
                // å…ˆæ¸…ç†æ¶ˆæ¯å†…å®¹
                const cleanedContent = sanitizeMessage(msg.content);
                
                // æ£€æŸ¥æ˜¯å¦æœ‰å¼•ç”¨
                let quoteHtml = '';
                if (msg.quote) {
                    quoteHtml = `<div class="quoted-message" style="border-left:2px solid rgba(0,0,0,0.15); padding:2px 6px; margin-bottom:4px; font-size:11px; line-height:1.3; max-width:180px;"><div style="color:#666; font-weight:500; font-size:10px;">${escapeHtml(msg.quote.name)}</div><div style="color:#888; font-size:10px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:160px;">${escapeHtml(msg.quote.content)}</div></div>`;
                }
                
                // æ£€æŸ¥AIæ¶ˆæ¯æ˜¯å¦åŒ…å«å¤–è¯­+ä¸­æ–‡ç¿»è¯‘ç»„åˆ
                const translationParsed = msg.role === 'char' ? parseForeignWithTranslation(cleanedContent) : null;
                
                if (translationParsed) {
                    // æœ‰å¤–è¯­+ä¸­æ–‡ç»„åˆï¼Œé»˜è®¤æ˜¾ç¤ºå¤–è¯­ï¼Œç‚¹å‡»æ˜¾ç¤ºç¿»è¯‘
                    content.innerHTML = quoteHtml + renderMessageContent(translationParsed.foreign);
                    content.dataset.chinese = translationParsed.chinese;
                    content.dataset.expanded = 'false';
                    
                    // ç‚¹å‡»æ˜¾ç¤º/éšè—ç¿»è¯‘
                    content.onclick = (e) => {
                        if (isLongPress || isSelectionMode) return;
                        if (e.target.tagName === 'A' || e.target.tagName === 'IMG') return;
                        e.stopPropagation();
                        
                        const isExpanded = content.dataset.expanded === 'true';
                        let transEl = content.querySelector('.msg-translation');
                        
                        if (isExpanded) {
                            // æ”¶èµ·ç¿»è¯‘
                            if (transEl) transEl.style.display = 'none';
                            content.dataset.expanded = 'false';
                        } else {
                            // æ˜¾ç¤ºç¿»è¯‘
                            if (!transEl) {
                                transEl = document.createElement('div');
                                transEl.className = 'msg-translation';
                                transEl.innerHTML = renderMessageContent(content.dataset.chinese);
                                content.appendChild(transEl);
                            } else {
                                transEl.style.display = 'block';
                            }
                            content.dataset.expanded = 'true';
                        }
                    };
                } else {
                    // æ™®é€šæ¶ˆæ¯ï¼Œä½¿ç”¨ç»Ÿä¸€çš„æ¸²æŸ“å‡½æ•°
                    content.innerHTML = quoteHtml + renderMessageContent(cleanedContent);
                }
            }

            // äº‹ä»¶ç»‘å®š
            if (!msg.isRecalled) { // å·²æ’¤å›æ¶ˆæ¯ä¸å¯æ“ä½œ
                bindMessageEvents(content, index);
                // æ•´ä¸ªè¡Œç‚¹å‡»äº‹ä»¶ (ç”¨äºå¤šé€‰)
                row.onclick = (e) => handleRowClick(index, e);
            }

            row.appendChild(avatar);
            row.appendChild(content);
            
            return row;
        }

        async function renderChatBody(char) {
            const body = document.getElementById('chat-body');
            body.innerHTML = '';
            
            // åˆ‡æ¢å¤šé€‰æ¨¡å¼æ ·å¼
            if (isSelectionMode) {
                body.classList.add('selection-mode');
            } else {
                body.classList.remove('selection-mode');
            }
            
            const accountId = getCurrentAccountId();
            
            // âœ… è”æœºå¥½å‹è‡ªåŠ¨è§†ä¸ºå¥½å‹çŠ¶æ€
            if (char.isOnlineFriend === true && accountId) {
                const currentStatus = getFriendStatus(char, accountId);
                if (currentStatus !== 'friend') {
                    // è‡ªåŠ¨ä¿®æ­£å¥½å‹çŠ¶æ€
                    if (!char.wechat_status_by_user) char.wechat_status_by_user = {};
                    char.wechat_status_by_user[accountId] = 'friend';
                    // å¼‚æ­¥ä¿å­˜ï¼Œä¸é˜»å¡æ¸²æŸ“
                    db.characters.put(char).catch(e => console.error('ä¿å­˜è”æœºå¥½å‹çŠ¶æ€å¤±è´¥:', e));
                }
            }
            
            // æ£€æŸ¥å¥½å‹çŠ¶æ€
            const friendStatus = getFriendStatus(char, accountId);
            if (friendStatus === 'blocked') {
                // è¢«æ‹‰é»‘çŠ¶æ€ï¼Œæ˜¾ç¤ºé¢æ¿ï¼ˆä¸åˆ é™¤ç±»ä¼¼ï¼Œä½†æç¤ºå’ŒåŠŸèƒ½ä¸åŒï¼‰
                body.innerHTML = `
                    <div style="display:flex; flex-direction:column; height:100%; padding:20px;">
                        <div style="text-align:center; padding:20px 0; border-bottom:1px solid #f0f0f0;">
                            <div style="width:60px; height:60px; border-radius:8px; background-image:url(${char.avatar}); background-size:cover; background-position:center; margin:0 auto 12px;"></div>
                            <div style="font-size:16px; font-weight:600; margin-bottom:6px; color:#333;">${char.name}</div>
                            <div style="font-size:13px; color:#999;">ä½ å·²æ‹‰é»‘è¯¥å¥½å‹</div>
                        </div>
                        
                        <div style="flex:1; overflow-y:auto; padding:16px 0;">
                            <div style="background:#fff3cd; border-radius:8px; padding:16px; margin-bottom:16px; border:1px solid #ffc107;">
                                <div style="font-size:14px; font-weight:600; margin-bottom:12px; color:#856404;">âš ï¸ æ‹‰é»‘æç¤º</div>
                                <div style="font-size:12px; color:#856404; line-height:1.6;">
                                    æ‹‰é»‘åï¼Œè¯¥è§’è‰²æ— æ³•å‘é€å¥½å‹ç”³è¯·æˆ–å¾®ä¿¡æ¶ˆæ¯ã€‚ä½†åœ¨å¿«è¿›æ—¶é—´æ—¶ï¼Œç³»ç»Ÿä¼šæ ¹æ®è§’è‰²æ€§æ ¼åˆ¤æ–­æ˜¯å¦ä¼šå°è¯•é€šè¿‡ç”µè¯æˆ–çŸ­ä¿¡è”ç³»ä½ ã€‚
                                </div>
                            </div>
                            
                            <div style="background:#f9f9f9; border-radius:8px; padding:16px; margin-bottom:16px;">
                                <div style="font-size:14px; font-weight:600; margin-bottom:12px; color:#333;">ğŸ“± è”ç³»è®°å½•</div>
                                <div style="font-size:12px; color:#666; line-height:1.6; margin-bottom:12px;">
                                    å¿«è¿›æ—¶é—´åï¼Œç”Ÿæˆçš„ç”µè¯å’ŒçŸ­ä¿¡è®°å½•å°†å‡ºç°åœ¨æ¡Œé¢çš„ã€Œç”µè¯ã€å’Œã€Œä¿¡æ¯ã€åº”ç”¨ä¸­ï¼Œè€Œä¸ä¼šç›´æ¥æ˜¾ç¤ºåœ¨è¿™é‡Œã€‚
                                </div>
                            </div>
                            
                            <button onclick="fastForwardBlockedCheck(${char.id})" style="width:100%; padding:12px; background:var(--ins-pink); color:#fff; border:none; border-radius:8px; font-size:14px; font-weight:600; margin-bottom:12px;">
                                â© å¿«è¿›æ—¶é—´
                            </button>
                            
                            <button onclick="unblockFriend(${char.id})" style="width:100%; padding:12px; background:#fff; border:1px solid #8e8e93; color:#333; border-radius:8px; font-size:14px; font-weight:600;">
                                è§£é™¤æ‹‰é»‘
                            </button>
                        </div>
                    </div>
                `;
                return;
            } else if (friendStatus === 'deleted') {
                // å·²åˆ é™¤å¥½å‹ï¼Œæ˜¾ç¤ºç­‰å¾…å¥½å‹ç”³è¯·ç•Œé¢
                const settings = char.wait_friend_settings?.[accountId] || {
                    enabled: false,
                    interval: 60,
                    lastCheckTime: Date.now(),
                    nextCheckTime: null
                };
                
                const nextCheckText = settings.enabled && settings.nextCheckTime ? 
                    `ä¸‹æ¬¡æ£€æµ‹: ${new Date(settings.nextCheckTime).toLocaleTimeString()}` : 'æœªå¯ç”¨';
                
                body.innerHTML = `
                    <div style="display:flex; flex-direction:column; height:100%; padding:20px;">
                        <div style="text-align:center; padding:20px 0; border-bottom:1px solid #f0f0f0;">
                            <div style="width:60px; height:60px; border-radius:8px; background-image:url(${char.avatar}); background-size:cover; background-position:center; margin:0 auto 12px;"></div>
                            <div style="font-size:16px; font-weight:600; margin-bottom:6px; color:#333;">${char.name}</div>
                            <div style="font-size:13px; color:#999;">ä½ å·²åˆ é™¤è¯¥å¥½å‹</div>
                        </div>
                        
                        <div style="flex:1; overflow-y:auto; padding:16px 0;">
                            <div style="background:#f9f9f9; border-radius:8px; padding:16px; margin-bottom:16px;">
                                <div style="font-size:14px; font-weight:600; margin-bottom:12px; color:#333;">â° ç­‰å¾…å¥½å‹ç”³è¯·</div>
                                <div style="font-size:12px; color:#666; line-height:1.6; margin-bottom:12px;">
                                    å¯ä»¥è®¾ç½®å®šæ—¶æ£€æµ‹ï¼ŒAIå°†æ ¹æ®è§’è‰²æ€§æ ¼å’Œä½ ä»¬çš„èŠå¤©å†å²ï¼Œå†³å®šæ˜¯å¦ä¸»åŠ¨å‘é€å¥½å‹ç”³è¯·ã€‚
                                </div>
                                
                                <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:12px; padding:8px 0;">
                                    <div style="font-size:13px; color:#333;">å¯ç”¨è‡ªåŠ¨æ£€æµ‹</div>
                                    <label class="ios-switch" style="transform:scale(0.8);">
                                        <input type="checkbox" id="wait-friend-enabled" ${settings.enabled ? 'checked' : ''} onchange="toggleWaitFriendCheck(${char.id})">
                                        <span class="slider"></span>
                                    </label>
                                </div>
                                
                                <div style="display:flex; align-items:center; margin-bottom:8px;">
                                    <div style="font-size:13px; color:#333; margin-right:12px;">æ£€æµ‹é—´éš”</div>
                                    <input type="number" id="wait-friend-interval" value="${settings.interval}" min="1" max="1440" 
                                           style="flex:1; padding:6px 10px; border:1px solid #ddd; border-radius:4px; font-size:13px;" 
                                           onchange="saveWaitFriendInterval(${char.id})">
                                    <div style="font-size:13px; color:#666; margin-left:8px;">åˆ†é’Ÿ</div>
                                </div>
                                
                                <div style="font-size:12px; color:#999; margin-top:8px;">${nextCheckText}</div>
                            </div>
                            
                            <button onclick="fastForwardCheck(${char.id})" style="width:100%; padding:12px; background:#fff; border:1px solid var(--ins-pink); color:var(--ins-pink); border-radius:8px; font-size:14px; font-weight:600; margin-bottom:12px;">
                                â© å¿«è¿›æ£€æµ‹
                            </button>
                            
                            <button onclick="manualSendFriendRequest(${char.id})" style="width:100%; padding:12px; background:var(--ins-pink); color:#fff; border:none; border-radius:8px; font-size:14px; font-weight:600;">
                                ä¸»åŠ¨å‘é€å¥½å‹ç”³è¯·
                            </button>
                        </div>
                    </div>
                `;
                return;
            } else if (friendStatus === 'stranger') {
                // é™Œç”Ÿäººï¼Œæ˜¾ç¤ºå‘é€å¥½å‹ç”³è¯·ç•Œé¢
                body.innerHTML = `
                    <div style="display:flex; flex-direction:column; align-items:center; justify-content:center; height:100%; padding:40px 20px; text-align:center;">
                        <div style="width:80px; height:80px; border-radius:8px; background-image:url(${char.avatar}); background-size:cover; background-position:center; margin-bottom:20px;"></div>
                        <div style="font-size:18px; font-weight:600; margin-bottom:10px; color:#333;">${char.name}</div>
                        <div style="font-size:14px; color:#999; margin-bottom:30px;">ä½ è¿˜ä¸æ˜¯å¯¹æ–¹çš„å¥½å‹ï¼Œæ— æ³•å‘é€æ¶ˆæ¯</div>
                        <button onclick="showAddFriendToCurrentChat()" style="background:var(--ins-pink); color:#fff; border:none; padding:12px 40px; border-radius:8px; font-size:16px; font-weight:600;">å‘é€å¥½å‹ç”³è¯·</button>
                    </div>
                `;
                return;
            } else if (friendStatus !== 'friend') {
                // å…¶ä»–çŠ¶æ€ï¼Œæ˜¾ç¤ºé»˜è®¤æç¤º
                body.innerHTML = `
                    <div style="display:flex; align-items:center; justify-content:center; height:100%; padding:40px 20px; text-align:center;">
                        <div style="font-size:14px; color:#999;">æ— æ³•å‘é€æ¶ˆæ¯</div>
                    </div>
                `;
                return;
            }
            
            const history = getChatHistory(char, accountId);
            if (!history || history.length === 0) return;

            // åº”ç”¨æ°”æ³¡æ ·å¼ç±»å
            body.classList.remove('bubble-style-default', 'bubble-style-wechat');
            if (char.bubble_style === 'wechat') {
                body.classList.add('bubble-style-wechat');
            } else {
                body.classList.add('bubble-style-default');
            }

            const userAvatarUrl = await getUserAvatarUrl(char.linked_user_id);

            history.forEach((msg, index) => {
                const prevMsgTime = index > 0 ? history[index - 1].time : null;
                
                // å¦‚æœéœ€è¦æ˜¾ç¤ºæ—¶é—´æˆ³ï¼Œå…ˆæ·»åŠ æ—¶é—´æˆ³è¡Œ
                if (shouldShowTimestamp(msg.time, prevMsgTime)) {
                    const timeStamp = document.createElement('div');
                    timeStamp.className = 'message-timestamp';
                    timeStamp.textContent = formatMessageTime(msg.time, prevMsgTime);
                    body.appendChild(timeStamp);
                }
                
                const row = createMessageElement(msg, index, char.avatar, userAvatarUrl, prevMsgTime, char.name);
                
                // å¦‚æœåœ¨å¤šé€‰æ¨¡å¼ï¼Œæ¢å¤é€‰ä¸­çŠ¶æ€
                if (isSelectionMode) {
                    const cb = row.querySelector('.msg-checkbox');
                    if (selectedIndices.has(index)) {
                        cb.classList.add('checked');
                    }
                }
                
                body.appendChild(row);
            });
            
            // å¦‚æœæ˜¯è¢«æ‹‰é»‘çŠ¶æ€ï¼Œä¸éœ€è¦åœ¨åº•éƒ¨æ·»åŠ ç”µè¯è®°å½•åŒºåŸŸï¼Œå› ä¸ºå·²ç»æ”¹åˆ°æ¡Œé¢åº”ç”¨äº†
            /*
            if (friendStatus === 'blocked') {
                const callSection = document.createElement('div');
                callSection.style.cssText = 'padding:16px; background:#f9f9f9; border-top:1px solid #f0f0f0; margin-top:20px;';
                callSection.innerHTML = `
                    <div style="font-size:14px; font-weight:600; margin-bottom:12px; color:#333;">ğŸ“ ç”µè¯è®°å½•</div>
                    <div id="blocked-calls-list" style="font-size:12px; color:#666;">
                        <!-- åŠ¨æ€ç”Ÿæˆç”µè¯è®°å½• -->
                    </div>
                `;
                body.appendChild(callSection);
                loadBlockedCallRecords(char.id, accountId);
            }
            */
            
            // æ»šåŠ¨åˆ°åº•éƒ¨ (å¦‚æœåœ¨å¤šé€‰æ¨¡å¼ï¼Œå¯èƒ½ä¸éœ€è¦æ»šåˆ°åº•éƒ¨ï¼Ÿè¿™é‡Œæš‚ä¸”ä¿æŒæ»šåŠ¨)
            if (!isSelectionMode) {
                setTimeout(() => {
                    body.scrollTop = body.scrollHeight;
                }, 0);
            }
            
            // åº”ç”¨è‡ªå®šä¹‰æ ·å¼
            applyCustomStyles(char);
            
            // åº”ç”¨èŠå¤©èƒŒæ™¯å›¾
            applyChatBackground(char);
        }

        // è¿½åŠ å•æ¡æ¶ˆæ¯ (ä¸»è¦ç”¨äº AI å›å¤æ—¶çš„æµå¼è¾“å‡ºï¼Œä¸é‡ç»˜æ•´ä¸ªåˆ—è¡¨)
        // æ³¨æ„ï¼šè¿½åŠ çš„æ¶ˆæ¯éœ€è¦é‡æ–°ç»‘å®šäº‹ä»¶ï¼Œä¸”æ­¤æ—¶é€šå¸¸ä¸åœ¨å¤šé€‰æ¨¡å¼
        async function appendMessageToUI(role, content, charAvatar, elemId) {
            const body = document.getElementById('chat-body');
            
            // ç³»ç»Ÿæ¶ˆæ¯ç‰¹æ®Šå¤„ç†
            if (role === 'system') {
                const sysDiv = document.createElement('div');
                sysDiv.style.cssText = 'text-align:center; padding:8px 16px; margin:8px 0;';
                sysDiv.innerHTML = `<span style="background:#fff; color:#999; font-size:12px; padding:4px 12px; border-radius:4px; border:1px solid #ddd;">${content}</span>`;
                body.appendChild(sysDiv);
                body.scrollTop = body.scrollHeight;
                return;
            }
            
            // è·å–æ•°æ®åº“ä¸­çš„å®é™…æ¶ˆæ¯ï¼ˆç¡®ä¿ ID å’Œæ—¶é—´æˆ³ä¸€è‡´ï¼‰
            const char = await db.characters.get(currentChatCharId);
            const accountId = getCurrentAccountId();
            const history = getChatHistory(char, accountId);
            const index = history.length - 1;
            
            // âœ… ä½¿ç”¨æ•°æ®åº“ä¸­çš„å®é™…æ¶ˆæ¯å¯¹è±¡ï¼Œè€Œä¸æ˜¯åˆ›å»ºä¸´æ—¶å¯¹è±¡
            // è¿™æ ·å¯ä»¥ç¡®ä¿è½¬è´¦æ¶ˆæ¯çš„ ID å’Œæ—¶é—´æˆ³ä¸æ•°æ®åº“ä¸€è‡´
            let msg = history[index];
            
            // å¦‚æœæ•°æ®åº“ä¸­æ²¡æœ‰æ‰¾åˆ°æ¶ˆæ¯ï¼Œæ‰ä½¿ç”¨ä¸´æ—¶å¯¹è±¡ï¼ˆå…¼å®¹æ—§é€»è¾‘ï¼‰
            if (!msg) {
                const cleanedContent = sanitizeMessage(content);
                msg = { role, content: cleanedContent, time: Date.now() };
            }
            
            const userAvatarUrl = await getUserAvatarUrl(char.linked_user_id);
            
            // è·å–å‰ä¸€æ¡æ¶ˆæ¯çš„æ—¶é—´
            const prevMsgTime = index > 0 && history[index - 1] ? history[index - 1].time : null;
            
            // å¦‚æœéœ€è¦æ˜¾ç¤ºæ—¶é—´æˆ³ï¼Œå…ˆæ·»åŠ æ—¶é—´æˆ³è¡Œ
            if (shouldShowTimestamp(msg.time, prevMsgTime)) {
                const timeStamp = document.createElement('div');
                timeStamp.className = 'message-timestamp';
                timeStamp.textContent = formatMessageTime(msg.time, prevMsgTime);
                body.appendChild(timeStamp);
            }

            const row = createMessageElement(msg, index, charAvatar, userAvatarUrl, prevMsgTime, char ? char.name : 'AI');
            if (elemId) row.id = elemId;
            
            body.appendChild(row);
            body.scrollTop = body.scrollHeight;
        }

        // --- æ ¸å¿ƒäº¤äº’ï¼šé•¿æŒ‰ä¸èœå• ---
        function bindMessageEvents(element, index) {
            const startHandler = (e) => {
                if (isSelectionMode) return; // å¤šé€‰æ¨¡å¼ä¸‹ç¦ç”¨é•¿æŒ‰
                isLongPress = false;
                longPressTimer = setTimeout(() => {
                    isLongPress = true;
                    showContextMenu(e, index, element);
                }, 500); // 500ms é•¿æŒ‰è§¦å‘
            };

            const cancelHandler = () => {
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
            };
            
            const endHandler = (e) => {
                cancelHandler();
                if (isLongPress) {
                    e.preventDefault(); // é˜»æ­¢é»˜è®¤ç‚¹å‡»
                    e.stopPropagation();
                }
            };

            // è§¦æ‘¸è®¾å¤‡
            element.addEventListener('touchstart', startHandler, {passive: true});
            element.addEventListener('touchmove', cancelHandler, {passive: true});
            element.addEventListener('touchend', endHandler);
            
            // PC é¼ æ ‡
            element.addEventListener('mousedown', startHandler);
            element.addEventListener('mousemove', cancelHandler); // ç§»åŠ¨ç®—å–æ¶ˆ
            element.addEventListener('mouseup', endHandler);
            // ç¦ç”¨å³é”®é»˜è®¤èœå•
            element.addEventListener('contextmenu', (e) => e.preventDefault());
        }

        function showContextMenu(event, index, element) {
            // éœ‡åŠ¨åé¦ˆ (Android)
            if (navigator.vibrate) navigator.vibrate(50);
            
            activeMsgIndex = index;
            element.classList.add('active'); // é«˜äº®

            const menu = document.getElementById('msg-context-menu');
            const overlay = document.getElementById('menu-overlay');
            
            // è®¡ç®—åæ ‡
            let clientX, clientY;
            if (event.touches && event.touches.length > 0) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }

            // ç®€å•çš„è¾¹ç•Œæ£€æµ‹ï¼ˆæ¨ªæ’èœå•ï¼‰
            const winWidth = window.innerWidth;
            const winHeight = window.innerHeight;
            let menuX = clientX;
            let menuY = clientY - 60; // æ˜¾ç¤ºåœ¨ç‚¹å‡»ä½ç½®ä¸Šæ–¹

            menu.style.display = 'flex'; // å…ˆæ˜¾ç¤ºä»¥è·å– offsetWidth
            
            // æ°´å¹³è¾¹ç•Œæ£€æµ‹
            if (menuX + menu.offsetWidth > winWidth) {
                menuX = winWidth - menu.offsetWidth - 10;
            }
            if (menuX < 10) {
                menuX = 10;
            }
            
            // å‚ç›´è¾¹ç•Œæ£€æµ‹
            if (menuY < 10) {
                menuY = clientY + 10; // å¦‚æœä¸Šæ–¹ç©ºé—´ä¸å¤Ÿï¼Œæ˜¾ç¤ºåœ¨ä¸‹æ–¹
            }
            if (menuY + menu.offsetHeight > winHeight) {
                menuY = winHeight - menu.offsetHeight - 10;
            }

            menu.style.left = menuX + 'px';
            menu.style.top = menuY + 'px';
            
            overlay.style.display = 'block';
        }

        function hideContextMenu() {
            const menu = document.getElementById('msg-context-menu');
            const overlay = document.getElementById('menu-overlay');
            menu.style.display = 'none';
            overlay.style.display = 'none';
            
            // ç§»é™¤é«˜äº®
            document.querySelectorAll('.message-content.active').forEach(el => el.classList.remove('active'));
        }

        // --- èœå•åŠŸèƒ½å®ç° ---
        
        // 1. ç¼–è¾‘
        async function handleMsgEdit() {
            hideContextMenu();
            if (activeMsgIndex === -1) return;
            
            // ç¾¤èŠç¼–è¾‘
            if (window.currentGroupChatId) {
                const group = await db.group_chats.get(window.currentGroupChatId);
                if (!group || !group.chat_history) return;
                
                const msg = group.chat_history[activeMsgIndex];
                if (!msg || msg.role === 'system') {
                    showToast("ç³»ç»Ÿæ¶ˆæ¯ä¸èƒ½ç¼–è¾‘");
                    return;
                }
                
                if (msg.content.startsWith('[img:') || msg.type === 'redpacket' || msg.type === 'transfer') {
                    showToast("è¯¥æ¶ˆæ¯ç±»å‹æš‚ä¸æ”¯æŒç¼–è¾‘");
                    return;
                }

                const newContent = prompt("ç¼–è¾‘æ¶ˆæ¯", msg.content);
                if (newContent !== null && newContent.trim() !== "") {
                    group.chat_history[activeMsgIndex].content = newContent.trim();
                    await db.group_chats.put(group);
                    await renderGroupChatBody(group);
                }
                return;
            }
            
            // ç§èŠç¼–è¾‘
            if (!currentChatCharId) return;
            
            const char = await db.characters.get(currentChatCharId);
            const accountId = getCurrentAccountId();
            let history = getChatHistory(char, accountId);
            const msg = history[activeMsgIndex];
            
            if (msg.content.startsWith('[img:')) {
                alert("å›¾ç‰‡æ¶ˆæ¯æš‚ä¸æ”¯æŒç¼–è¾‘");
                return;
            }

            const newContent = prompt("ç¼–è¾‘æ¶ˆæ¯", msg.content);
            if (newContent !== null && newContent.trim() !== "") {
                msg.content = newContent.trim();
                history[activeMsgIndex] = msg;
                await setChatHistory(char, accountId, history);
                
                const chatBody = document.getElementById('chat-body');
                const messageRows = chatBody.querySelectorAll('.message-row');
                if (messageRows[activeMsgIndex]) {
                    const bubbleText = messageRows[activeMsgIndex].querySelector('.bubble-text');
                    if (bubbleText) {
                        bubbleText.textContent = newContent.trim();
                    }
                }
            }
        }

        // 2. æ’¤å›ï¼ˆä¿å­˜åŸå†…å®¹ï¼Œç‚¹å‡»å¯æŸ¥çœ‹ï¼‰
        async function handleMsgRecall() {
            hideContextMenu();
            if (activeMsgIndex === -1) return;
            
            if (!confirm("ç¡®å®šè¦æ’¤å›è¿™æ¡æ¶ˆæ¯å—ï¼Ÿ")) return;
            
            // ç¾¤èŠæ’¤å›
            if (window.currentGroupChatId) {
                const group = await db.group_chats.get(window.currentGroupChatId);
                if (!group || !group.chat_history) return;
                
                const msg = group.chat_history[activeMsgIndex];
                if (!msg || msg.role === 'system') {
                    showToast("ç³»ç»Ÿæ¶ˆæ¯ä¸èƒ½æ’¤å›");
                    return;
                }
                
                const isUser = msg.role === 'user';
                const recallerName = isUser ? 'ä½ ' : 'æˆå‘˜';
                
                msg.recalledContent = msg.content;
                msg.isRecalled = true;
                msg.content = "";
                msg.type = 'recalled';
                
                group.chat_history[activeMsgIndex] = msg;
                
                // æ·»åŠ æ’¤å›æç¤ºç³»ç»Ÿæ¶ˆæ¯
                group.chat_history.splice(activeMsgIndex + 1, 0, {
                    role: 'system',
                    content: `"${recallerName}"æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯`,
                    time: Date.now(),
                    recalledContent: msg.recalledContent
                });
                
                await db.group_chats.put(group);
                await renderGroupChatBody(group);
                return;
            }

            // ç§èŠæ’¤å›
            if (!currentChatCharId) return;
            
            const char = await db.characters.get(currentChatCharId);
            const accountId = getCurrentAccountId();
            let history = getChatHistory(char, accountId);
            const msg = history[activeMsgIndex];
            const isUser = msg.role === 'user';
            const recallerName = isUser ? 'ä½ ' : char.name;
            
            msg.recalledContent = msg.content;
            msg.isRecalled = true;
            msg.content = "";
            
            await setChatHistory(char, accountId, history);
            
            const chatBody = document.getElementById('chat-body');
            const messageRows = chatBody.querySelectorAll('.message-row');
            if (messageRows[activeMsgIndex]) {
                const msgRow = messageRows[activeMsgIndex];
                msgRow.className = 'message-row recalled-system-row';
                msgRow.innerHTML = '';
                
                const capturedContent = msg.recalledContent;
                const capturedName = recallerName;
                const systemTip = document.createElement('div');
                systemTip.className = 'recalled-system-tip';
                systemTip.innerHTML = `"${capturedName}"æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯`;
                systemTip.style.cursor = 'pointer';
                systemTip.onclick = (e) => {
                    e.stopPropagation();
                    showRecalledContent(capturedName, capturedContent);
                };
                msgRow.appendChild(systemTip);
            }
        }
        
        // æ˜¾ç¤ºæ’¤å›æ¶ˆæ¯çš„åŸå†…å®¹
        function showRecalledContent(recallerName, content) {
            // åˆ›å»ºå¼¹çª—
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                z-index: 9999;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 20px;
            `;
            overlay.onclick = () => overlay.remove();
            
            const modal = document.createElement('div');
            modal.style.cssText = `
                background: white;
                border-radius: 12px;
                padding: 20px;
                max-width: 320px;
                width: 100%;
                max-height: 60vh;
                overflow-y: auto;
                box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            `;
            modal.onclick = (e) => e.stopPropagation();
            
            // å¤„ç†å†…å®¹æ˜¾ç¤ºï¼ˆæ”¯æŒå›¾ç‰‡ç­‰ï¼‰
            let displayContent = content;
            if (content.startsWith('[img:')) {
                const imgUrl = content.substring(5, content.length - 1).trim();
                displayContent = `<img src="${imgUrl}" style="max-width:100%; border-radius:8px;">`;
            } else if (content.startsWith('[voice:')) {
                displayContent = `ğŸ¤ è¯­éŸ³æ¶ˆæ¯: ${content.substring(7, content.length - 1)}`;
            }
            
            modal.innerHTML = `
                <div style="font-size:14px; color:#999; margin-bottom:12px;">"${recallerName}"æ’¤å›çš„æ¶ˆæ¯ï¼š</div>
                <div style="font-size:15px; color:#333; line-height:1.6; word-break:break-all;">${displayContent}</div>
                <button onclick="this.parentElement.parentElement.remove()" style="
                    width: 100%;
                    margin-top: 16px;
                    padding: 10px;
                    background: #f5f5f5;
                    border: none;
                    border-radius: 8px;
                    font-size: 14px;
                    color: #666;
                    cursor: pointer;
                ">å…³é—­</button>
            `;
            
            overlay.appendChild(modal);
            document.body.appendChild(overlay);
        }
        
        // å¼•ç”¨æ¶ˆæ¯ç›¸å…³
        let currentQuote = null; // å½“å‰å¼•ç”¨çš„æ¶ˆæ¯ { name, content, index }
        
        // å¼•ç”¨æ¶ˆæ¯
        async function handleMsgQuote() {
            hideContextMenu();
            if (activeMsgIndex === -1) return;
            
            let quoteName = '';
            let quoteContent = '';
            
            // ç¾¤èŠå¼•ç”¨
            if (window.currentGroupChatId) {
                const group = await db.group_chats.get(window.currentGroupChatId);
                if (!group || !group.chat_history) return;
                
                const msg = group.chat_history[activeMsgIndex];
                if (!msg || msg.role === 'system') {
                    showToast("æ— æ³•å¼•ç”¨ç³»ç»Ÿæ¶ˆæ¯");
                    return;
                }
                
                if (msg.role === 'user') {
                    const myChar = currentMyCharId ? await db.characters.get(parseInt(currentMyCharId)) : null;
                    quoteName = group.myNickname || myChar?.name || 'æˆ‘';
                } else {
                    const senderChar = msg.senderId ? await db.characters.get(msg.senderId) : null;
                    const memberNicknames = group.memberNicknames || {};
                    quoteName = memberNicknames[msg.senderId] || senderChar?.remark || senderChar?.name || 'æœªçŸ¥æˆå‘˜';
                }
                
                quoteContent = getQuoteDisplayContent(msg.content, msg.type);
            } else {
                // ç§èŠå¼•ç”¨
                if (!currentChatCharId) return;
                
                const char = await db.characters.get(currentChatCharId);
                const accountId = getCurrentAccountId();
                const history = getChatHistory(char, accountId);
                const msg = history[activeMsgIndex];
                
                if (!msg) return;
                
                if (msg.role === 'user') {
                    const myChar = currentMyCharId ? await db.characters.get(parseInt(currentMyCharId)) : null;
                    quoteName = myChar?.name || 'æˆ‘';
                } else {
                    quoteName = char.remark || char.name;
                }
                
                quoteContent = getQuoteDisplayContent(msg.content, msg.type);
            }
            
            // è®¾ç½®å¼•ç”¨
            currentQuote = {
                name: quoteName,
                content: quoteContent,
                index: activeMsgIndex
            };
            
            // æ˜¾ç¤ºå¼•ç”¨é¢„è§ˆ
            showQuotePreview(quoteName, quoteContent);
            
            // èšç„¦è¾“å…¥æ¡†
            document.getElementById('chat-input-box').focus();
        }
        
        // è·å–å¼•ç”¨æ˜¾ç¤ºå†…å®¹
        function getQuoteDisplayContent(content, type) {
            if (type === 'redpacket') return '[çº¢åŒ…]';
            if (type === 'transfer') return '[è½¬è´¦]';
            if (content.startsWith('[img:')) return '[å›¾ç‰‡]';
            if (content.startsWith('[voice:')) return '[è¯­éŸ³]';
            if (content.startsWith('[imgcard:')) return '[å›¾æ–‡æ¶ˆæ¯]';
            // æˆªæ–­è¿‡é•¿çš„æ–‡æœ¬
            if (content.length > 50) {
                return content.substring(0, 50) + '...';
            }
            return content;
        }
        
        // æ˜¾ç¤ºå¼•ç”¨é¢„è§ˆ
        function showQuotePreview(name, content) {
            const preview = document.getElementById('quote-preview');
            const nameEl = document.getElementById('quote-preview-name');
            const msgEl = document.getElementById('quote-preview-msg');
            
            nameEl.textContent = name;
            msgEl.textContent = content;
            preview.style.display = 'flex';
        }
        
        // å–æ¶ˆå¼•ç”¨
        function cancelQuote() {
            currentQuote = null;
            document.getElementById('quote-preview').style.display = 'none';
        }

        // 3. åˆ é™¤ (å•æ¡)
        async function handleMsgDelete() {
            hideContextMenu();
            if (activeMsgIndex === -1) return;
            
            if (!confirm("åˆ é™¤è¿™æ¡æ¶ˆæ¯ï¼Ÿ")) return;
            
            // ç¾¤èŠåˆ é™¤
            if (window.currentGroupChatId) {
                const group = await db.group_chats.get(window.currentGroupChatId);
                if (!group || !group.chat_history) return;
                
                group.chat_history.splice(activeMsgIndex, 1);
                await db.group_chats.put(group);
                await renderGroupChatBody(group);
                return;
            }

            // ç§èŠåˆ é™¤
            if (!currentChatCharId) return;
            
            const char = await db.characters.get(currentChatCharId);
            const accountId = getCurrentAccountId();
            let history = getChatHistory(char, accountId);
            history.splice(activeMsgIndex, 1);
            
            await setChatHistory(char, accountId, history);
            
            const chatBody = document.getElementById('chat-body');
            const messageRows = chatBody.querySelectorAll('.message-row');
            if (messageRows[activeMsgIndex]) {
                messageRows[activeMsgIndex].remove();
            }
        }

        // --- å¤šé€‰æ¨¡å¼ ---
        function enterSelectionMode() {
            hideContextMenu();
            if (!currentChatCharId && !window.currentGroupChatId) return;
            
            isSelectionMode = true;
            selectedIndices.clear();
            
            document.getElementById('chat-body').classList.add('selection-mode');
            document.getElementById('selection-bar').style.display = 'flex';
            document.getElementById('chat-footer').style.display = 'none';
            
            // ä¸ºç¾¤èŠæ¶ˆæ¯æ·»åŠ checkbox
            if (window.currentGroupChatId) {
                document.querySelectorAll('.group-message-row').forEach((row) => {
                    const idx = parseInt(row.dataset.msgIndex);
                    if (row.querySelector('.group-msg-content')) {
                        row.classList.add('selection-mode');
                        row.style.paddingLeft = '40px';
                        let cb = row.querySelector('.msg-checkbox');
                        if (!cb) {
                            cb = document.createElement('div');
                            cb.className = 'msg-checkbox';
                            cb.style.cssText = 'position:absolute; left:8px; top:50%; transform:translateY(-50%); width:22px; height:22px; border:2px solid #ccc; border-radius:50%; display:flex; align-items:center; justify-content:center; cursor:pointer;';
                            cb.onclick = (e) => {
                                e.stopPropagation();
                                if (selectedIndices.has(idx)) {
                                    selectedIndices.delete(idx);
                                    cb.classList.remove('checked');
                                    cb.style.background = '';
                                    cb.style.borderColor = '#ccc';
                                    cb.innerHTML = '';
                                } else {
                                    selectedIndices.add(idx);
                                    cb.classList.add('checked');
                                    cb.style.background = 'var(--ins-pink)';
                                    cb.style.borderColor = 'var(--ins-pink)';
                                    cb.innerHTML = '<svg viewBox="0 0 24 24" style="width:14px;height:14px;stroke:#fff;stroke-width:3;fill:none;"><polyline points="20 6 9 17 4 12"></polyline></svg>';
                                }
                                updateDeleteBtn();
                            };
                            row.style.position = 'relative';
                            row.insertBefore(cb, row.firstChild);
                        }
                        cb.style.display = 'flex';
                    }
                });
            }
            
            updateDeleteBtn();
        }

        function exitSelectionMode() {
            isSelectionMode = false;
            selectedIndices.clear();
            
            document.getElementById('chat-body').classList.remove('selection-mode');
            document.getElementById('selection-bar').style.display = 'none';
            document.getElementById('chat-footer').style.display = 'flex';
            
            // ç§èŠæ¶ˆæ¯
            document.querySelectorAll('.message-row').forEach(row => {
                row.classList.remove('selection-mode', 'selected');
            });
            // ç¾¤èŠæ¶ˆæ¯
            document.querySelectorAll('.group-message-row').forEach(row => {
                row.classList.remove('selection-mode', 'selected');
                row.style.paddingLeft = '';
            });
            document.querySelectorAll('.msg-checkbox').forEach(cb => {
                cb.style.display = 'none';
                cb.classList.remove('checked');
                cb.style.background = '';
                cb.style.borderColor = '#ccc';
                cb.innerHTML = '';
            });
        }

        function handleRowClick(index, e) {
            if (!isSelectionMode) return;
            
            // åˆ‡æ¢é€‰ä¸­çŠ¶æ€
            const row = e.currentTarget; // .message-row
            const checkbox = row.querySelector('.msg-checkbox');
            
            if (selectedIndices.has(index)) {
                selectedIndices.delete(index);
                checkbox.classList.remove('checked');
            } else {
                selectedIndices.add(index);
                checkbox.classList.add('checked');
            }
            
            updateDeleteBtn();
        }

        function updateDeleteBtn() {
            const count = selectedIndices.size;
            const btn = document.getElementById('btn-batch-delete');
            btn.innerText = `åˆ é™¤ (${count})`;
            btn.style.opacity = count > 0 ? '1' : '0.5';
        }

        async function deleteSelectedMsgs() {
            if (selectedIndices.size === 0) return;
            
            if (!confirm(`ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${selectedIndices.size} æ¡æ¶ˆæ¯å—ï¼Ÿ`)) return;
            
            // ç¾¤èŠæ‰¹é‡åˆ é™¤
            if (window.currentGroupChatId) {
                const group = await db.group_chats.get(window.currentGroupChatId);
                if (!group || !group.chat_history) return;
                
                const newHistory = group.chat_history.filter((_, idx) => !selectedIndices.has(idx));
                group.chat_history = newHistory;
                await db.group_chats.put(group);
                
                exitSelectionMode();
                await renderGroupChatBody(group);
                return;
            }
            
            // ç§èŠæ‰¹é‡åˆ é™¤
            if (!currentChatCharId) return;

            const char = await db.characters.get(currentChatCharId);
            const accountId = getCurrentAccountId();
            const history = getChatHistory(char, accountId);
            
            const newHistory = history.filter((_, idx) => !selectedIndices.has(idx));
            
            await setChatHistory(char, accountId, newHistory);
            await db.characters.put(char);
            
            const chatBody = document.getElementById('chat-body');
            const messageRows = chatBody.querySelectorAll('.message-row');
            const sortedIndices = Array.from(selectedIndices).sort((a, b) => b - a);
            sortedIndices.forEach(idx => {
                if (messageRows[idx]) {
                    messageRows[idx].remove();
                }
            });
            
            exitSelectionMode();
        }

        // --- æ–°å¢ï¼šèŠå¤©äº¤äº’é€»è¾‘ (é¢æ¿/è¾“å…¥/AIè§¦å‘) ---
        let activePanel = null;
        const emojis = ["ğŸ˜€","ğŸ˜","ğŸ˜‚","ğŸ¤£","ğŸ˜ƒ","ğŸ˜„","ğŸ˜…","ğŸ˜†","ğŸ˜‰","ğŸ˜Š","ğŸ˜‹","ğŸ˜","ğŸ˜","ğŸ˜˜","ğŸ¥°","ğŸ˜—","ğŸ˜™","ğŸ˜š","ğŸ™‚","ğŸ¤—","ğŸ¤©","ğŸ¤”","ğŸ¤¨","ğŸ˜","ğŸ˜‘","ğŸ˜¶","ğŸ™„","ğŸ˜","ğŸ˜£","ğŸ˜¥","ğŸ˜®","ğŸ¤","ğŸ˜¯","ğŸ˜ª","ğŸ˜«","ğŸ˜´","ğŸ˜Œ","ğŸ˜›","ğŸ˜œ","ğŸ˜","ğŸ¤¤","ğŸ˜’","ğŸ˜“","ğŸ˜”","ğŸ˜•","ğŸ™ƒ","ğŸ¤‘","ğŸ˜²","â˜¹ï¸","ğŸ™","ğŸ˜–","ğŸ˜","ğŸ˜Ÿ","ğŸ˜¤","ğŸ˜¢","ğŸ˜­","ğŸ˜¦","ğŸ˜§","ğŸ˜¨","ğŸ˜©","ğŸ¤¯","ğŸ˜¬","ğŸ˜°","ğŸ˜±","ğŸ¥µ","ğŸ¥¶","ğŸ˜³","ğŸ¤ª","ğŸ˜µ","ğŸ˜¡","ğŸ˜ ","ğŸ¤¬","ğŸ˜·","ğŸ¤’","ğŸ¤•","ğŸ¤¢","ğŸ¤®","ğŸ¤§","ğŸ˜‡","ğŸ¥³","ğŸ¥º","ğŸ¤ ","ğŸ¤¡","ğŸ¤¥","ğŸ¤«","ğŸ¤­","ğŸ§","ğŸ¤“","ğŸ˜ˆ","ğŸ‘¿","ğŸ‘¹","ğŸ‘º","ğŸ’€","ğŸ‘»","ğŸ‘½","ğŸ¤–","ğŸ’©","ğŸ˜º","ğŸ˜¸","ğŸ˜¹","ğŸ˜»","ğŸ˜¼","ğŸ˜½","ğŸ™€","ğŸ˜¿","ğŸ˜¾"];

        function initEmojiPanel() {
            const panel = document.getElementById('emoji-panel');
            if (panel.children.length > 0) return; 
            panel.innerHTML = emojis.map(e => `<div class="emoji-item" onclick="insertEmoji('${e}')">${e}</div>`).join('');
        }

        async function switchEmojiTab(type) {
            const tabs = document.querySelectorAll('#emoji-tab-bar .wechat-tab-item');
            const emojiPanel = document.getElementById('emoji-panel');
            const stickerPanel = document.getElementById('sticker-panel');

            if (type === 'emoji') {
                tabs[0].classList.add('active');
                tabs[1].classList.remove('active');
                emojiPanel.style.display = 'grid';
                stickerPanel.style.display = 'none';
            } else {
                tabs[0].classList.remove('active');
                tabs[1].classList.add('active');
                emojiPanel.style.display = 'none';
                stickerPanel.style.display = 'grid';
                
                // åŠ è½½å…¨å±€è¡¨æƒ…åŒ…
                await updateChatStickerPanel();
            }
        }
        
        async function sendSticker(base64) {
            // å‘é€å›¾ç‰‡æ¶ˆæ¯
            const msgContent = `[img:${base64}]`;
            
            // æ”¯æŒç¾¤èŠæ¨¡å¼
            if (window.currentGroupChatId) {
                const group = await db.group_chats.get(window.currentGroupChatId);
                if (!group) return;
                
                if (!group.chat_history) group.chat_history = [];
                group.chat_history.push({
                    role: 'user',
                    content: msgContent,
                    time: Date.now()
                });
                group.updated_at = Date.now();
                await db.group_chats.put(group);
                
                await renderGroupChatBody(group);
                closeChatPanel();
                return;
            }
            
            if (!currentChatCharId) return;
            const char = await db.characters.get(currentChatCharId);
            const accountId = getCurrentAccountId();
            let history = getChatHistory(char, accountId);
            
            history.push({
                role: 'user',
                content: msgContent,
                time: Date.now()
            });
            
            await setChatHistory(char, accountId, history);
            appendMessageToUI('user', msgContent);
            closeChatPanel();
            
            // å¯ä»¥åœ¨è¿™é‡Œè§¦å‘ AI å¯¹è¡¨æƒ…åŒ…çš„ååº”ï¼ˆå¦‚æœéœ€è¦ï¼‰
            // triggerAiReply(); 
        }

        // æ˜¾ç¤ºå›¾ç‰‡ç±»å‹é€‰æ‹©å¼¹çª—
        function showImageTypeModal() {
            // å…³é—­æ›´å¤šé¢æ¿
            closeChatPanel();
            
            const modal = document.createElement('div');
            modal.id = 'image-type-modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.4);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                backdrop-filter: blur(5px);
            `;
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 16px; padding: 24px; width: 85%; max-width: 320px; box-shadow: 0 10px 40px rgba(0,0,0,0.15);">
                    <h3 style="margin: 0 0 24px 0; text-align: center; color: #333; font-size: 18px; font-weight: 600;">é€‰æ‹©å›¾ç‰‡ç±»å‹</h3>
                    <div style="display: flex; flex-direction: column; gap: 12px;">
                        <button onclick="selectRealImage()" style="padding: 16px; background: #f5f5f5; color: #333; border: none; border-radius: 12px; font-size: 16px; font-weight: 500; cursor: pointer; transition: all 0.2s; display:flex; align-items:center; justify-content:center; gap:8px;">
                            <svg class="svg-icon" style="width:20px; height:20px;" viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>
                            <span>çœŸå®å›¾ç‰‡</span>
                        </button>
                        <button onclick="selectTextImageCard()" style="padding: 16px; background: #f5f5f5; color: #333; border: none; border-radius: 12px; font-size: 16px; font-weight: 500; cursor: pointer; transition: all 0.2s; display:flex; align-items:center; justify-content:center; gap:8px;">
                            <svg class="svg-icon" style="width:20px; height:20px;" viewBox="0 0 24 24"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>
                            <span>æ–‡å­—å›¾ç‰‡å¡ç‰‡</span>
                        </button>
                        <button onclick="closeImageTypeModal()" style="padding: 14px; background: white; color: #999; border: 1px solid #e8e8e8; border-radius: 12px; font-size: 15px; cursor: pointer; margin-top: 8px;">
                            å–æ¶ˆ
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }

        function closeImageTypeModal() {
            const modal = document.getElementById('image-type-modal');
            if (modal) modal.remove();
        }

        // é€‰æ‹©çœŸå®å›¾ç‰‡
        function selectRealImage() {
            closeImageTypeModal();
            document.getElementById('chat-image-input').click();
        }

        // é€‰æ‹©æ–‡å­—å›¾ç‰‡å¡ç‰‡
        function selectTextImageCard() {
            closeImageTypeModal();
            
            const modal = document.createElement('div');
            modal.id = 'text-image-card-modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 12px; padding: 20px; width: 85%; max-width: 350px;">
                    <h3 style="margin: 0 0 15px 0; color: #333;">è¾“å…¥å¡ç‰‡æ–‡å­—</h3>
                    <textarea id="imgcard-text-input" placeholder="è¾“å…¥è¦è½¬æ¢ä¸ºå›¾ç‰‡å¡ç‰‡çš„æ–‡å­—..." style="width: 100%; height: 120px; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 14px; resize: none; box-sizing: border-box;"></textarea>
                    <div style="display: flex; gap: 10px; margin-top: 15px;">
                        <button onclick="sendImageCard()" style="flex: 1; padding: 12px; background: var(--ins-pink); color: white; border: none; border-radius: 8px; font-size: 15px;">
                            å‘é€
                        </button>
                        <button onclick="closeTextImageCardModal()" style="flex: 1; padding: 12px; background: #f0f0f0; color: #666; border: none; border-radius: 8px; font-size: 15px;">
                            å–æ¶ˆ
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            document.getElementById('imgcard-text-input').focus();
        }

        function closeTextImageCardModal() {
            const modal = document.getElementById('text-image-card-modal');
            if (modal) modal.remove();
        }

        async function sendImageCard() {
            const text = document.getElementById('imgcard-text-input').value.trim();
            if (!text) {
                alert('è¯·è¾“å…¥å†…å®¹');
                return;
            }
            
            closeTextImageCardModal();
            
            // å‘é€å›¾ç‰‡å¡ç‰‡æ¶ˆæ¯ï¼ˆæ ¼å¼ï¼š[imgcard:æ–‡å­—å†…å®¹]ï¼‰
            const msgContent = `[imgcard:${text}]`;
            
            // æ”¯æŒç¾¤èŠæ¨¡å¼
            if (window.currentGroupChatId) {
                const group = await db.group_chats.get(window.currentGroupChatId);
                if (!group) return;
                
                if (!group.chat_history) group.chat_history = [];
                group.chat_history.push({
                    role: 'user',
                    content: msgContent,
                    time: Date.now()
                });
                group.updated_at = Date.now();
                await db.group_chats.put(group);
                
                await renderGroupChatBody(group);
                return;
            }
            
            if (!currentChatCharId) return;
            const char = await db.characters.get(currentChatCharId);
            const accountId = getCurrentAccountId();
            let history = getChatHistory(char, accountId);
            
            history.push({
                role: 'user',
                content: msgContent,
                time: Date.now()
            });
            
            await setChatHistory(char, accountId, history);
            
            // âœ… ä¼˜åŒ–ï¼šåªè¿½åŠ æ–°æ¶ˆæ¯ï¼Œä¸é‡æ–°æ¸²æŸ“æ•´ä¸ªèŠå¤©
            await appendMessageToUI('user', msgContent, char.avatar);
        }

        // å‘é€çœŸå®å›¾ç‰‡æ¶ˆæ¯
        async function sendImageMessage(input) {
            const file = input.files[0];
            if (!file) return;
            
            // æ”¯æŒç¾¤èŠæ¨¡å¼
            if (window.currentGroupChatId) {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    const base64 = e.target.result;
                    const msgContent = `[img:${base64}]`;
                    
                    const group = await db.group_chats.get(window.currentGroupChatId);
                    if (!group) return;
                    
                    if (!group.chat_history) group.chat_history = [];
                    group.chat_history.push({
                        role: 'user',
                        content: msgContent,
                        time: Date.now()
                    });
                    group.updated_at = Date.now();
                    await db.group_chats.put(group);
                    
                    await renderGroupChatBody(group);
                };
                reader.readAsDataURL(file);
                input.value = '';
                return;
            }
            
            if (!currentChatCharId) return;
            
            const reader = new FileReader();
            reader.onload = async (e) => {
                const base64 = e.target.result;
                const msgContent = `[img:${base64}]`;
                
                const char = await db.characters.get(currentChatCharId);
                const accountId = getCurrentAccountId();
                let history = getChatHistory(char, accountId);
                
                history.push({
                    role: 'user',
                    content: msgContent,
                    time: Date.now()
                });
                
                await setChatHistory(char, accountId, history);
                
                // âœ… ä¼˜åŒ–ï¼šåªè¿½åŠ æ–°æ¶ˆæ¯ï¼Œä¸é‡æ–°æ¸²æŸ“æ•´ä¸ªèŠå¤©
                await appendMessageToUI('user', msgContent, char.avatar);
            };
            
            reader.readAsDataURL(file);
            input.value = '';
        }

        function insertEmoji(e) {
            const input = document.getElementById('chat-input-box');
            input.value += e;
            handleChatInputChange(input);
        }

        // è¯­éŸ³è¾“å…¥åŠŸèƒ½
        async function showVoiceInputModal() {
            // å…³é—­æ›´å¤šé¢æ¿
            closeChatPanel();
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯è”æœºå¥½å‹
            let isOnlineFriend = false;
            if (currentChatCharId) {
                const char = await db.characters.get(currentChatCharId);
                isOnlineFriend = char && char.isOnlineFriend === true;
            }
            
            // æ˜¾ç¤ºè¯­éŸ³æ¨¡å¼é€‰æ‹©å¼¹çª—
            const modal = document.createElement('div');
            modal.id = 'voice-mode-modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;
            
            if (isOnlineFriend) {
                // è”æœºå¥½å‹ï¼šæ˜¾ç¤ºçœŸå®å½•éŸ³+å˜å£°é€‰é¡¹
                modal.innerHTML = `
                    <div style="background: white; border-radius: 16px; padding: 24px; width: 85%; max-width: 320px;">
                        <h3 style="margin: 0 0 20px 0; text-align: center; color: #333; font-size: 18px;">ğŸ¤ è¯­éŸ³å½•åˆ¶</h3>
                        
                        <div style="margin-bottom: 20px;">
                            <div style="font-size: 13px; color: #666; margin-bottom: 10px;">é€‰æ‹©å˜å£°æ•ˆæœï¼š</div>
                            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                                <label style="display: flex; align-items: center; padding: 12px; background: #f5f5f5; border-radius: 8px; cursor: pointer;">
                                    <input type="radio" name="voice-effect" value="normal" checked style="margin-right: 8px;">
                                    <span>ğŸ™ï¸ åŸå£°</span>
                                </label>
                                <label style="display: flex; align-items: center; padding: 12px; background: #fff0f5; border-radius: 8px; cursor: pointer;">
                                    <input type="radio" name="voice-effect" value="loli" style="margin-right: 8px;">
                                    <span>ğŸ€ èè‰éŸ³</span>
                                </label>
                                <label style="display: flex; align-items: center; padding: 12px; background: #f0f5ff; border-radius: 8px; cursor: pointer;">
                                    <input type="radio" name="voice-effect" value="uncle" style="margin-right: 8px;">
                                    <span>ğŸ§” å¤§å”éŸ³</span>
                                </label>
                                <label style="display: flex; align-items: center; padding: 12px; background: #f5fff0; border-radius: 8px; cursor: pointer;">
                                    <input type="radio" name="voice-effect" value="robot" style="margin-right: 8px;">
                                    <span>ğŸ¤– æœºå™¨äºº</span>
                                </label>
                            </div>
                        </div>
                        
                        <div id="voice-record-status" style="text-align: center; padding: 20px; background: #f9f9f9; border-radius: 12px; margin-bottom: 16px;">
                            <div style="font-size: 14px; color: #999;">ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®å¼€å§‹å½•éŸ³</div>
                            <div id="voice-record-time" style="font-size: 24px; font-weight: 600; color: #333; margin-top: 8px; display: none;">00:00</div>
                        </div>
                        
                        <div style="display: flex; flex-direction: column; gap: 10px;">
                            <button id="btn-start-record" onclick="startOnlineVoiceRecord()" style="padding: 14px; background: var(--ins-pink); color: white; border: none; border-radius: 10px; font-size: 15px; font-weight: 500;">
                                ğŸ¤ æŒ‰ä½å½•éŸ³
                            </button>
                            <button onclick="closeVoiceModal()" style="padding: 12px; background: #f0f0f0; color: #666; border: none; border-radius: 8px; font-size: 14px;">
                                å–æ¶ˆ
                            </button>
                        </div>
                    </div>
                `;
            } else {
                // æ™®é€šè§’è‰²ï¼šæ˜¾ç¤ºåŸæœ‰é€‰é¡¹
                modal.innerHTML = `
                    <div style="background: white; border-radius: 12px; padding: 20px; width: 80%; max-width: 300px;">
                        <h3 style="margin: 0 0 20px 0; text-align: center; color: #333;">é€‰æ‹©è¯­éŸ³æ¨¡å¼</h3>
                        <div style="display: flex; flex-direction: column; gap: 12px;">
                            <button onclick="startRealVoiceInput()" style="padding: 15px; background: var(--ins-pink); color: white; border: none; border-radius: 8px; font-size: 16px; display:flex; align-items:center; justify-content:center; gap:8px;">
                                <svg class="svg-icon" style="width:20px; height:20px; stroke:#fff;" viewBox="0 0 24 24"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line></svg>
                                <span>çœŸå®è¯­éŸ³è¯†åˆ«</span>
                            </button>
                            <button onclick="startTextToVoice()" style="padding: 15px; background: #34c759; color: white; border: none; border-radius: 8px; font-size: 16px; display:flex; align-items:center; justify-content:center; gap:8px;">
                                <svg class="svg-icon" style="width:20px; height:20px; stroke:#fff;" viewBox="0 0 24 24"><path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path></svg>
                                <span>æ–‡å­—è½¬è¯­éŸ³æ°”æ³¡</span>
                            </button>
                            <button onclick="closeVoiceModal()" style="padding: 12px; background: #f0f0f0; color: #666; border: none; border-radius: 8px; font-size: 14px;">
                                å–æ¶ˆ
                            </button>
                        </div>
                    </div>
                `;
            }
            
            document.body.appendChild(modal);
        }
        
        // âœ… è”æœºå¥½å‹è¯­éŸ³å½•åˆ¶å˜é‡
        let onlineVoiceRecorder = null;
        let onlineVoiceChunks = [];
        let onlineVoiceStartTime = 0;
        let onlineVoiceTimer = null;
        
        // å¼€å§‹è”æœºè¯­éŸ³å½•åˆ¶
        async function startOnlineVoiceRecord() {
            const btn = document.getElementById('btn-start-record');
            const statusDiv = document.getElementById('voice-record-status');
            const timeDiv = document.getElementById('voice-record-time');
            
            // å¦‚æœæ­£åœ¨å½•éŸ³ï¼Œåˆ™åœæ­¢
            if (onlineVoiceRecorder && onlineVoiceRecorder.state === 'recording') {
                stopOnlineVoiceRecord();
                return;
            }
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                onlineVoiceRecorder = new MediaRecorder(stream);
                onlineVoiceChunks = [];
                onlineVoiceStartTime = Date.now();
                
                onlineVoiceRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) {
                        onlineVoiceChunks.push(e.data);
                    }
                };
                
                onlineVoiceRecorder.onstop = async () => {
                    stream.getTracks().forEach(track => track.stop());
                    clearInterval(onlineVoiceTimer);
                    
                    const duration = Math.round((Date.now() - onlineVoiceStartTime) / 1000);
                    const blob = new Blob(onlineVoiceChunks, { type: 'audio/webm' });
                    
                    // è·å–é€‰æ‹©çš„å˜å£°æ•ˆæœ
                    const effectRadio = document.querySelector('input[name="voice-effect"]:checked');
                    const effect = effectRadio ? effectRadio.value : 'normal';
                    
                    statusDiv.innerHTML = '<div style="color: var(--ins-pink);">â³ æ­£åœ¨å¤„ç†...</div>';
                    
                    // å¤„ç†å˜å£°å¹¶å‘é€
                    await processAndSendVoice(blob, effect, duration);
                };
                
                onlineVoiceRecorder.start();
                
                // æ›´æ–°UI
                btn.textContent = 'â¹ï¸ åœæ­¢å½•éŸ³';
                btn.style.background = '#ff3b30';
                timeDiv.style.display = 'block';
                statusDiv.querySelector('div').textContent = 'ğŸ”´ æ­£åœ¨å½•éŸ³...';
                
                // è®¡æ—¶å™¨
                onlineVoiceTimer = setInterval(() => {
                    const elapsed = Math.round((Date.now() - onlineVoiceStartTime) / 1000);
                    const min = Math.floor(elapsed / 60).toString().padStart(2, '0');
                    const sec = (elapsed % 60).toString().padStart(2, '0');
                    timeDiv.textContent = `${min}:${sec}`;
                }, 1000);
                
            } catch (err) {
                console.error('å½•éŸ³å¤±è´¥:', err);
                alert('æ— æ³•è®¿é—®éº¦å…‹é£ï¼Œè¯·ç¡®ä¿å·²æˆäºˆæƒé™');
            }
        }
        
        // åœæ­¢è”æœºè¯­éŸ³å½•åˆ¶
        function stopOnlineVoiceRecord() {
            if (onlineVoiceRecorder && onlineVoiceRecorder.state === 'recording') {
                onlineVoiceRecorder.stop();
            }
        }
        
        // å¤„ç†å˜å£°å¹¶å‘é€è¯­éŸ³
        async function processAndSendVoice(blob, effect, duration) {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const arrayBuffer = await blob.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                
                // æ ¹æ®æ•ˆæœè®¾ç½®å‚æ•°
                let pitchRate = 1.0;
                switch (effect) {
                    case 'loli':    pitchRate = 1.4; break;  // èè‰éŸ³ï¼šæé«˜éŸ³è°ƒ
                    case 'uncle':   pitchRate = 0.7; break;  // å¤§å”éŸ³ï¼šé™ä½éŸ³è°ƒ
                    case 'robot':   pitchRate = 1.0; break;  // æœºå™¨äººï¼šç‰¹æ®Šå¤„ç†
                    default:        pitchRate = 1.0; break;
                }
                
                // åˆ›å»ºç¦»çº¿éŸ³é¢‘ä¸Šä¸‹æ–‡è¿›è¡Œå¤„ç†
                const offlineContext = new OfflineAudioContext(
                    audioBuffer.numberOfChannels,
                    Math.ceil(audioBuffer.length / pitchRate),
                    audioBuffer.sampleRate
                );
                
                const source = offlineContext.createBufferSource();
                source.buffer = audioBuffer;
                source.playbackRate.value = pitchRate;
                
                // æœºå™¨äººæ•ˆæœï¼šæ·»åŠ æ³¢å½¢è°ƒåˆ¶
                if (effect === 'robot') {
                    const oscillator = offlineContext.createOscillator();
                    const gainNode = offlineContext.createGain();
                    oscillator.frequency.value = 50;
                    gainNode.gain.value = 0.3;
                    oscillator.connect(gainNode);
                    gainNode.connect(offlineContext.destination);
                    oscillator.start();
                }
                
                source.connect(offlineContext.destination);
                source.start();
                
                const renderedBuffer = await offlineContext.startRendering();
                
                // å°†å¤„ç†åçš„éŸ³é¢‘è½¬ä¸º base64
                const wavBlob = await audioBufferToWav(renderedBuffer);
                const base64 = await blobToBase64(wavBlob);
                
                // è®¡ç®—å®é™…æ—¶é•¿
                const actualDuration = Math.ceil(duration / pitchRate);
                
                // å‘é€è¯­éŸ³æ¶ˆæ¯
                await sendOnlineVoiceMessage(base64, actualDuration, effect);
                
                closeVoiceModal();
                
            } catch (err) {
                console.error('è¯­éŸ³å¤„ç†å¤±è´¥:', err);
                alert('è¯­éŸ³å¤„ç†å¤±è´¥: ' + err.message);
            }
        }
        
        // AudioBuffer è½¬ WAV
        function audioBufferToWav(buffer) {
            const numChannels = buffer.numberOfChannels;
            const sampleRate = buffer.sampleRate;
            const format = 1; // PCM
            const bitDepth = 16;
            
            const bytesPerSample = bitDepth / 8;
            const blockAlign = numChannels * bytesPerSample;
            
            const data = [];
            for (let i = 0; i < buffer.length; i++) {
                for (let ch = 0; ch < numChannels; ch++) {
                    const sample = buffer.getChannelData(ch)[i];
                    const intSample = Math.max(-1, Math.min(1, sample));
                    data.push(intSample < 0 ? intSample * 0x8000 : intSample * 0x7FFF);
                }
            }
            
            const dataLength = data.length * bytesPerSample;
            const headerLength = 44;
            const totalLength = headerLength + dataLength;
            
            const arrayBuffer = new ArrayBuffer(totalLength);
            const view = new DataView(arrayBuffer);
            
            // WAV header
            const writeString = (offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };
            
            writeString(0, 'RIFF');
            view.setUint32(4, totalLength - 8, true);
            writeString(8, 'WAVE');
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, format, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * blockAlign, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitDepth, true);
            writeString(36, 'data');
            view.setUint32(40, dataLength, true);
            
            let offset = 44;
            for (let i = 0; i < data.length; i++, offset += 2) {
                view.setInt16(offset, data[i], true);
            }
            
            return new Blob([arrayBuffer], { type: 'audio/wav' });
        }
        
        // Blob è½¬ Base64
        function blobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }
        
        // å‘é€è”æœºè¯­éŸ³æ¶ˆæ¯
        async function sendOnlineVoiceMessage(audioBase64, duration, effect) {
            if (!currentChatCharId) return;
            
            const char = await db.characters.get(currentChatCharId);
            if (!char || !char.isOnlineFriend) return;
            
            const accountId = getCurrentAccountId();
            
            // ä¿å­˜åˆ°æœ¬åœ°èŠå¤©å†å²
            let history = getChatHistory(char, accountId);
            const msgObj = {
                role: 'user',
                type: 'audio',
                content: audioBase64,
                duration: duration,
                effect: effect,
                time: Date.now()
            };
            history.push(msgObj);
            await setChatHistory(char, accountId, history);
            
            // é€šè¿‡æœåŠ¡å™¨å‘é€ç»™å¯¹æ–¹
            if (char.onlineData?.wx_account && onlineConnected) {
                // è·å–å½“å‰å¯ç”¨çš„åœ¨çº¿è§’è‰²ï¼ˆå¦‚æœæ²¡æœ‰åˆ™è‡ªåŠ¨ä¸Šçº¿ï¼‰
                const onlineUserChar = await getOrCreateOnlineUserChar();
                
                if (onlineUserChar) {
                    const voiceMsg = JSON.stringify({
                        __type: 'audio',
                        audio: audioBase64,
                        duration: duration,
                        effect: effect
                    });
                    sendOnlineMessage(char.onlineData.wx_account, voiceMsg, onlineUserChar.identity.account);
                    console.log('[Online] è¯­éŸ³æ¶ˆæ¯å·²å‘é€');
                }
            }
            
            // åˆ·æ–°èŠå¤©ç•Œé¢
            renderChatBody(char);
            showToast('è¯­éŸ³å·²å‘é€');
        }
        
        // æ’­æ”¾è”æœºè¯­éŸ³æ¶ˆæ¯
        let currentPlayingAudio = null;
        function playOnlineAudio(audioId) {
            const audio = document.getElementById(audioId);
            const icon = document.getElementById('icon_' + audioId);
            
            if (!audio) return;
            
            // å¦‚æœæœ‰å…¶ä»–æ­£åœ¨æ’­æ”¾çš„ï¼Œå…ˆåœæ­¢
            if (currentPlayingAudio && currentPlayingAudio !== audio) {
                currentPlayingAudio.pause();
                currentPlayingAudio.currentTime = 0;
            }
            
            if (audio.paused) {
                audio.play();
                currentPlayingAudio = audio;
                if (icon) icon.textContent = 'â¸ï¸';
                
                audio.onended = () => {
                    if (icon) {
                        // æ¢å¤åŸæ¥çš„å›¾æ ‡
                        const bubble = audio.closest('.online-audio-bubble');
                        if (bubble) {
                            const originalIcon = bubble.querySelector('.audio-play-icon');
                            if (originalIcon) originalIcon.textContent = icon.dataset.original || 'ğŸ™ï¸';
                        }
                    }
                    currentPlayingAudio = null;
                };
            } else {
                audio.pause();
                audio.currentTime = 0;
                currentPlayingAudio = null;
                // æ¢å¤å›¾æ ‡
            }
        }

        function closeVoiceModal() {
            const modal = document.getElementById('voice-mode-modal');
            if (modal) modal.remove();
        }

        // çœŸå®è¯­éŸ³è¯†åˆ« - æ”¹è¿›ç‰ˆï¼šè¯†åˆ«åä»¥è¯­éŸ³æ°”æ³¡å½¢å¼å‘é€
        function startRealVoiceInput() {
            closeVoiceModal();
            
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                alert('æŠ±æ­‰ï¼Œæ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³è¯†åˆ«åŠŸèƒ½');
                return;
            }
            
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            const recognition = new SpeechRecognition();
            
            recognition.lang = 'zh-CN';
            recognition.continuous = false;
            recognition.interimResults = false;
            
            // æ˜¾ç¤ºå½•éŸ³ä¸­æç¤º
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0,0,0,0.8);
                color: white;
                padding: 20px 30px;
                border-radius: 12px;
                z-index: 10001;
                font-size: 16px;
            `;
            toast.innerHTML = 'ğŸ¤ æ­£åœ¨å½•éŸ³...';
            document.body.appendChild(toast);
            
            recognition.onresult = async (event) => {
                const text = event.results[0][0].transcript;
                toast.innerHTML = 'âœ“ è¯†åˆ«æˆåŠŸï¼';
                
                // å»¶è¿Ÿ500msåå‘é€è¯­éŸ³æ°”æ³¡
                setTimeout(async () => {
                    toast.remove();
                    
                    // ä»¥è¯­éŸ³æ°”æ³¡æ ¼å¼å‘é€
                    const msgContent = `[voice:${text}]`;
                    
                    if (!currentChatCharId) return;
                    const char = await db.characters.get(currentChatCharId);
                    const accountId = getCurrentAccountId();
                    let history = getChatHistory(char, accountId);
                    
                    history.push({
                        role: 'user',
                        content: msgContent,
                        time: Date.now()
                    });
                    
                    await setChatHistory(char, accountId, history);
                    
                    // âœ… ä¼˜åŒ–ï¼šåªè¿½åŠ æ–°æ¶ˆæ¯ï¼Œä¸é‡æ–°æ¸²æŸ“æ•´ä¸ªèŠå¤©
                    await appendMessageToUI('user', msgContent, char.avatar);
                    
                    // âœ… ä¸å†è‡ªåŠ¨è§¦å‘ AI å›å¤ï¼Œéœ€è¦ç”¨æˆ·ç‚¹å‡»"æ¥å—å›å¤"æŒ‰é’®
                    // triggerAiReply();
                }, 500);
            };
            
            recognition.onerror = (event) => {
                console.error('è¯­éŸ³è¯†åˆ«é”™è¯¯:', event.error);
                toast.innerHTML = 'âŒ è¯†åˆ«å¤±è´¥';
                setTimeout(() => toast.remove(), 1500);
            };
            
            recognition.onend = () => {
                setTimeout(() => {
                    if (toast.parentNode) toast.remove();
                }, 500);
            };
            
            recognition.start();
        }

        // æ–‡å­—è½¬è¯­éŸ³æ°”æ³¡
        function startTextToVoice() {
            closeVoiceModal();
            
            const modal = document.createElement('div');
            modal.id = 'text-to-voice-modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 12px; padding: 20px; width: 85%; max-width: 350px;">
                    <h3 style="margin: 0 0 15px 0; color: #333;">è¾“å…¥è¯­éŸ³å†…å®¹</h3>
                    <textarea id="voice-text-input" placeholder="è¾“å…¥è¦è½¬æ¢ä¸ºè¯­éŸ³æ°”æ³¡çš„æ–‡å­—..." style="width: 100%; height: 120px; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 14px; resize: none; box-sizing: border-box;"></textarea>
                    <div style="display: flex; gap: 10px; margin-top: 15px;">
                        <button onclick="sendVoiceBubble()" style="flex: 1; padding: 12px; background: var(--ins-pink); color: white; border: none; border-radius: 8px; font-size: 15px;">
                            å‘é€
                        </button>
                        <button onclick="closeTextToVoiceModal()" style="flex: 1; padding: 12px; background: #f0f0f0; color: #666; border: none; border-radius: 8px; font-size: 15px;">
                            å–æ¶ˆ
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            document.getElementById('voice-text-input').focus();
        }

        function closeTextToVoiceModal() {
            const modal = document.getElementById('text-to-voice-modal');
            if (modal) modal.remove();
        }

        async function sendVoiceBubble() {
            const text = document.getElementById('voice-text-input').value.trim();
            if (!text) {
                alert('è¯·è¾“å…¥å†…å®¹');
                return;
            }
            
            closeTextToVoiceModal();
            
            // å‘é€è¯­éŸ³æ°”æ³¡æ¶ˆæ¯ï¼ˆæ ¼å¼ï¼š[voice:æ–‡å­—å†…å®¹]ï¼‰
            const msgContent = `[voice:${text}]`;
            
            // æ”¯æŒç¾¤èŠæ¨¡å¼
            if (window.currentGroupChatId) {
                const group = await db.group_chats.get(window.currentGroupChatId);
                if (!group) return;
                
                if (!group.chat_history) group.chat_history = [];
                group.chat_history.push({
                    role: 'user',
                    content: msgContent,
                    time: Date.now()
                });
                group.updated_at = Date.now();
                await db.group_chats.put(group);
                
                await renderGroupChatBody(group);
                return;
            }
            
            if (!currentChatCharId) return;
            const char = await db.characters.get(currentChatCharId);
            const accountId = getCurrentAccountId();
            let history = getChatHistory(char, accountId);
            
            history.push({
                role: 'user',
                content: msgContent,
                time: Date.now()
            });
            
            await setChatHistory(char, accountId, history);
            
            // âœ… ä¼˜åŒ–ï¼šåªè¿½åŠ æ–°æ¶ˆæ¯ï¼Œä¸é‡æ–°æ¸²æŸ“æ•´ä¸ªèŠå¤©
            await appendMessageToUI('user', msgContent, char.avatar);
            
            // âœ… ç§»é™¤è‡ªåŠ¨è§¦å‘AIå›å¤
            // triggerAiReply();
        }

        function toggleChatPanel(type) {
            const container = document.getElementById('chat-panel-container');
            const footer = document.getElementById('chat-footer');
            const emojiPanel = document.getElementById('emoji-panel');
            const actionPanel = document.getElementById('action-panel');
            
            // å¦‚æœæ˜¯è¡¨æƒ…é¢æ¿ï¼Œå…ˆåˆå§‹åŒ–
            if (type === 'emoji') initEmojiPanel();

            if (activePanel === type) {
                // å…³é—­å½“å‰
                closeChatPanel();
            } else {
                // æ‰“å¼€æˆ–åˆ‡æ¢
                if (!activePanel) {
                    container.classList.add('open');
                    footer.classList.add('panel-open');
                }
                activePanel = type;
                
                // é»˜è®¤åˆ‡å› Emoji Tab
                if (type === 'emoji') {
                    document.getElementById('emoji-tab-bar').style.display = 'flex';
                    switchEmojiTab('emoji');
                    actionPanel.style.display = 'none';
                } else {
                    document.getElementById('emoji-tab-bar').style.display = 'none';
                    document.getElementById('emoji-panel').style.display = 'none';
                    document.getElementById('sticker-panel').style.display = 'none';
                    actionPanel.style.display = 'grid';
                }
                
                // æ»šåŠ¨åˆ°åº•éƒ¨ï¼Œç¡®ä¿èƒ½çœ‹åˆ°é¢æ¿
                setTimeout(() => {
                    const body = document.getElementById('chat-body');
                    body.scrollTop = body.scrollHeight;
                }, 100);
            }
        }

        function closeChatPanel() {
            if (!activePanel) return;
            const container = document.getElementById('chat-panel-container');
            const footer = document.getElementById('chat-footer');
            
            container.classList.remove('open');
            footer.classList.remove('panel-open');
            activePanel = null;
            
            // ç­‰å¾…åŠ¨ç”»ç»“æŸéšè—å†…å®¹
            setTimeout(() => {
                if (!activePanel) {
                    document.getElementById('emoji-panel').style.display = 'none';
                    document.getElementById('action-panel').style.display = 'none';
                }
            }, 300);
        }

        function handleChatInputChange(input) {
            const hasText = input.value.trim().length > 0;
            const btnMore = document.getElementById('btn-more');
            const btnSend = document.getElementById('btn-send');
            
            if (hasText) {
                btnMore.style.display = 'none';
                btnSend.style.display = 'flex';
            } else {
                btnMore.style.display = 'flex';
                btnSend.style.display = 'none';
            }
        }

        // æ˜¾ç¤ºå¿«è¿›æ—¶é—´é€‰æ‹©å¼¹çª—
        function showFastForwardModal() {
            closeChatPanel();
            document.getElementById('fast-forward-modal').style.display = 'flex';
        }

        // ç¡®è®¤å¿«è¿›é€»è¾‘
        async function confirmFastForward() {
            const amount = parseInt(document.getElementById('ff-amount').value);
            const unit = document.getElementById('ff-unit').value;
            
            if (isNaN(amount) || amount <= 0) {
                alert("è¯·è¾“å…¥æœ‰æ•ˆçš„æ—¶é—´æ•°å€¼");
                return;
            }
            
            closeModal('fast-forward-modal');
            
            // 1. è®¡ç®—æ¯«ç§’æ•°å¹¶æ›´æ–°è™šæ‹Ÿæ—¶é—´
            let ms = 0;
            let unitText = '';
            if (unit === 'minute') {
                ms = amount * 60 * 1000;
                unitText = amount + 'åˆ†é’Ÿ';
            } else if (unit === 'hour') {
                ms = amount * 60 * 60 * 1000;
                unitText = amount + 'å°æ—¶';
            } else if (unit === 'day') {
                ms = amount * 24 * 60 * 60 * 1000;
                unitText = amount + 'å¤©';
            }
            
            if (currentChatCharId) {
                const char = await db.characters.get(currentChatCharId);
                // æ›´æ–°è™šæ‹Ÿæ—¶é—´åç§»
                if (!char.timeOffset) char.timeOffset = 0;
                char.timeOffset += ms;
                await db.characters.put(char);
                console.log(`[FastForward] Updated time offset by +${ms}ms (${unitText})`);
            }
            
            // 2. æ£€æŸ¥è¢«æ‹‰é»‘çš„è§’è‰²æ˜¯å¦ä¼šè”ç³»
            await checkBlockedCharactersContact(ms, unitText);
            
            // 3. è§¦å‘ AI å›å¤ï¼Œå¸¦ä¸Šæ—¶é—´æµé€çš„ç³»ç»Ÿæç¤º
            await triggerAiReply(`æ—¶é—´è¿‡å»äº† ${unitText}`);
        }

        // æ£€æŸ¥è¢«æ‹‰é»‘çš„è§’è‰²æ˜¯å¦ä¼šè”ç³»ç”¨æˆ·ï¼ˆä½¿ç”¨æ–°ç‰ˆæœ¬é€»è¾‘ï¼‰
        async function checkBlockedCharactersContact(elapsedMs, elapsedText) {
            const accountId = getCurrentAccountId();
            if (!accountId) {
                console.log('[BlockedContact] æ²¡æœ‰å½“å‰è´¦å·');
                return;
            }
            
            // è·å–æ‰€æœ‰è¢«æ‹‰é»‘çš„è§’è‰²
            const allChars = await db.characters.toArray();
            const blockedChars = allChars.filter(char => {
                const status = getFriendStatus(char, accountId);
                return status === 'blocked';
            });
            
            console.log(`[BlockedContact] æ‰¾åˆ° ${blockedChars.length} ä¸ªè¢«æ‹‰é»‘çš„è§’è‰²`);
            
            if (blockedChars.length === 0) return;
            
            // è·å–å½“å‰ç”¨æˆ·ä¿¡æ¯
            const myChar = await db.characters.get(parseInt(accountId));
            if (!myChar) {
                console.log('[BlockedContact] æ‰¾ä¸åˆ°ç”¨æˆ·ä¿¡æ¯');
                return;
            }
            
            // åŸºå‡†æ—¶é—´
            const baseTime = Date.now() + (blockedChars[0].timeOffset || 0);

            for (const char of blockedChars) {
                try {
                    console.log(`\n========== å¼€å§‹æ£€æŸ¥è§’è‰²: ${char.name} ==========`);
                    
                    // 1. è·å–æŒ‡ä»¤æ–‡æœ¬ï¼ˆä¼ å…¥elapsedMsç”¨äºè®¡ç®—æ•°é‡ï¼‰
                    let instructionText = await checkIfCharacterWillContact(char, myChar, elapsedText, elapsedMs);
                    
                    console.log(`[BlockedContact] ${char.name} è¿”å›çš„æŒ‡ä»¤æ–‡æœ¬:\n${instructionText}`);
                    
                    // 2. è§£ææŒ‡ä»¤ï¼ˆæ”¯æŒæ–°æ ¼å¼ï¼‰
                    let actions = parseContactInstructionsV2(instructionText);
                    
                    console.log(`[BlockedContact] ${char.name} è§£æå‡º ${actions.length} æ¡æŒ‡ä»¤:`, JSON.stringify(actions, null, 2));
                    
                    // å¦‚æœæ²¡æœ‰æŒ‡ä»¤ï¼Œè¯´æ˜è§’è‰²å†³å®šä¸è”ç³»
                    if (actions.length === 0) {
                        console.log(`[BlockedContact] ${char.name} å†³å®šä¸è”ç³»ç”¨æˆ·`);
                        continue;
                    }

                    // 3. æ‰§è¡ŒæŒ‡ä»¤
                    console.log(`[BlockedContact] å¼€å§‹æ‰§è¡Œ ${char.name} çš„ ${actions.length} æ¡æŒ‡ä»¤`);
                    
                    // èµ·å§‹æ—¶é—´ç‚¹ç¨å¾®éšæœºä¸€ç‚¹
                    let actionBaseTime = baseTime - elapsedMs + Math.floor(Math.random() * 60000);
                    let notificationDelay = 0; // é€šçŸ¥å»¶è¿Ÿç´¯è®¡

                    for (const action of actions) {
                        if (action.type === 'CALL') {
                            const count = parseInt(action.params.count) || 1;
                            console.log(`[BlockedContact] ç”Ÿæˆ ${count} é€šæœªæ¥æ¥ç”µ`);
                            
                            // åœ¨æ•´ä¸ªæ—¶é—´æ®µå†…éšæœºåˆ†å¸ƒ
                            const callTimes = [];
                            for (let i = 0; i < count; i++) {
                                const randomTime = actionBaseTime + Math.random() * elapsedMs;
                                callTimes.push(randomTime);
                            }
                            // æŒ‰æ—¶é—´æ’åº
                            callTimes.sort((a, b) => a - b);
                            
                            // åˆ›å»ºç”µè¯è®°å½•
                            for (const callTime of callTimes) {
                                await createBlockedCallRecord(char, myChar, accountId, callTime);
                            }
                            
                            // ğŸ¯ é€æ¡æ˜¾ç¤ºé€šçŸ¥ï¼Œæ¯æ¡é—´éš”500ms
                            for (let i = 0; i < callTimes.length; i++) {
                                const delay = notificationDelay + i * 500;
                                setTimeout(() => {
                                    showBlockedCallNotification(char, callTimes[i]);
                                }, delay);
                            }
                            notificationDelay += callTimes.length * 500;
                        } else if (action.type === 'SMS') {
                            const messages = action.params.messages || [];
                            console.log(`[BlockedContact] ç”Ÿæˆ ${messages.length} æ¡çŸ­ä¿¡`);
                            
                            // æ¯æ¡çŸ­ä¿¡åœ¨æ—¶é—´æ®µå†…éšæœºåˆ†å¸ƒ
                            const smsTimes = [];
                            for (let i = 0; i < messages.length; i++) {
                                const randomTime = actionBaseTime + Math.random() * elapsedMs;
                                smsTimes.push({ time: randomTime, content: messages[i] });
                            }
                            // æŒ‰æ—¶é—´æ’åº
                            smsTimes.sort((a, b) => a.time - b.time);
                            
                            // åˆ›å»ºçŸ­ä¿¡è®°å½•
                            for (const sms of smsTimes) {
                                await createBlockedMessageRecord(char, myChar, accountId, sms.time, sms.content);
                            }
                            
                            // ğŸ¯ å°†æ‰€æœ‰çŸ­ä¿¡é€šçŸ¥åŠ å…¥é˜Ÿåˆ—ï¼Œé˜Ÿåˆ—ç³»ç»Ÿä¼šç¡®ä¿ä¸€æ¡ä¸€æ¡æ˜¾ç¤º
                            for (let i = 0; i < smsTimes.length; i++) {
                                showBlockedSmsNotification(char, smsTimes[i].content, smsTimes[i].time);
                            }
                        }
                    }
                    
                    console.log(`[BlockedContact] âœ… ${char.name} çš„è”ç³»è®°å½•ç”Ÿæˆå®Œæˆ`);
                    console.log(`========== ç»“æŸæ£€æŸ¥è§’è‰²: ${char.name} ==========\n`);
                    
                } catch (error) {
                    console.error(`[BlockedContact] âŒ æ£€æŸ¥ ${char.name} æ—¶å‡ºé”™:`, error);
                    // æŠ›å‡ºé”™è¯¯ï¼Œè®©ç”¨æˆ·çœ‹åˆ°å…·ä½“é—®é¢˜
                    throw error;
                }
            }
            
            console.log('[BlockedContact] æ‰€æœ‰æŒ‡ä»¤æ‰§è¡Œå®Œæ¯•');
        }

        // æ·»åŠ è¶…æ—¶åŠŸèƒ½çš„fetch
        async function fetchWithTimeout(url, options, timeout = 30000) {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), timeout);
            
            try {
                const response = await fetch(url, {
                    ...options,
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                return response;
            } catch (error) {
                clearTimeout(timeoutId);
                if (error.name === 'AbortError') {
                    throw new Error('è¯·æ±‚è¶…æ—¶');
                }
                throw error;
            }
        }
        
        // è°ƒç”¨APIåˆ¤æ–­è§’è‰²æ˜¯å¦ä¼šè”ç³»ï¼ˆè¿”å›æŒ‡ä»¤æ–‡æœ¬ï¼‰- ä½¿ç”¨callAIå‡½æ•°
        async function checkIfCharacterWillContact(char, myChar, elapsedText, elapsedMs) {
            console.log(`[BlockedContact] å¼€å§‹è¯·æ±‚ ${char.name} çš„è”ç³»æŒ‡ä»¤...`);
            
            // ğŸ¯ æ ¹æ®å¿«è¿›æ—¶é—´è®¡ç®—åˆç†çš„è”ç³»æ¬¡æ•°
            const hours = elapsedMs / (60 * 60 * 1000);
            let suggestedCallCount, suggestedSmsCount;
            
            if (hours < 1) {
                // ä¸åˆ°1å°æ—¶ï¼šå°‘é‡
                suggestedCallCount = Math.floor(Math.random() * 3) + 1; // 1-3é€š
                suggestedSmsCount = Math.floor(Math.random() * 5) + 3; // 3-7æ¡
            } else if (hours < 6) {
                // 1-6å°æ—¶ï¼šä¸­ç­‰
                suggestedCallCount = Math.floor(Math.random() * 5) + 3; // 3-7é€š
                suggestedSmsCount = Math.floor(Math.random() * 6) + 5; // 5-10æ¡
            } else if (hours < 24) {
                // 6-24å°æ—¶ï¼šè¾ƒå¤š
                suggestedCallCount = Math.floor(Math.random() * 8) + 5; // 5-12é€š
                suggestedSmsCount = Math.floor(Math.random() * 8) + 8; // 8-15æ¡
            } else {
                // è¶…è¿‡1å¤©ï¼šå¾ˆå¤š
                suggestedCallCount = Math.floor(Math.random() * 8) + 8; // 8-15é€š
                suggestedSmsCount = Math.floor(Math.random() * 6) + 10; // 10-15æ¡
            }
            
            // è·å–èŠå¤©å†å²ä½œä¸ºä¸Šä¸‹æ–‡
            const accountId = getCurrentAccountId();
            const chatHistory = getChatHistory(char, accountId);
            const recentMessages = chatHistory.slice(-5).map(m => {
                const role = m.role === 'user' ? myChar.name : char.name;
                return `${role}: ${m.content}`;
            }).join('\n');
            
            // ğŸ¯ å¢å¼ºç‰ˆæç¤ºè¯ï¼šæ›´è´´åˆè§’è‰²äººè®¾å’Œè¢«æ‹‰é»‘æƒ…æ™¯
            const prompt = `ã€è§’è‰²æ‰®æ¼”ä»»åŠ¡ã€‘
ä½ ç°åœ¨æ˜¯ã€Œ${char.name}ã€ï¼Œè¯·å®Œå…¨ä»£å…¥è¿™ä¸ªè§’è‰²ã€‚

ã€ä½ çš„äººè®¾ã€‘
${char.description || char.desc || 'ä¸€ä¸ªæ™®é€šäºº'}

ã€å¯¹æ–¹ä¿¡æ¯ã€‘
åå­—ï¼š${myChar.name}
${myChar.description ? `ç®€ä»‹ï¼š${myChar.description.substring(0, 200)}` : ''}

ã€æœ€è¿‘çš„èŠå¤©è®°å½•ã€‘
${recentMessages || 'ï¼ˆæ— è®°å½•ï¼‰'}

ã€å½“å‰æƒ…å¢ƒã€‘
ä½ çªç„¶å‘ç°è‡ªå·±è¢«ã€Œ${myChar.name}ã€æ‹‰é»‘äº†ï¼
å¾®ä¿¡æ¶ˆæ¯å‘ä¸å‡ºå»ï¼Œå¥½å‹ç”³è¯·çŸ³æ²‰å¤§æµ·ï¼Œå¯¹æ–¹å½»åº•å°†ä½ å±è”½ã€‚
å·²ç»è¿‡å»äº† ${elapsedText}ã€‚

ã€ä½ éœ€è¦æ€è€ƒã€‘
1. ä»¥ä½ çš„æ€§æ ¼ï¼Œè¢«è¿™ä¸ªäººæ‹‰é»‘åä¼šæœ‰ä»€ä¹ˆååº”ï¼Ÿ
2. ä½ ä¼šæ„Ÿåˆ°æ„¤æ€’ï¼Ÿæ‚²ä¼¤ï¼Ÿä¸ç”˜ï¼Ÿå›°æƒ‘ï¼Ÿç»æœ›ï¼Ÿé‡Šç„¶ï¼Ÿè¿˜æ˜¯å…¶ä»–æƒ…ç»ªï¼Ÿ
3. ä½ ä¼šé€‰æ‹©ç–¯ç‹‚æ‰“ç”µè¯ï¼Ÿå‘çŸ­ä¿¡è´¨é—®ï¼Ÿå†·é™ç­‰å¾…ï¼Ÿè¿˜æ˜¯ç›´æ¥æ”¾å¼ƒï¼Ÿ
4. éšç€æ—¶é—´æ¨ç§»ï¼Œä½ çš„æƒ…ç»ªä¼šå¦‚ä½•å˜åŒ–ï¼Ÿï¼ˆæ¯”å¦‚ä»æ„¤æ€’åˆ°æ‚²ä¼¤ï¼Œä»è´¨é—®åˆ°å“€æ±‚ï¼Œä»ä¸ç”˜åˆ°é‡Šç„¶...ï¼‰

ã€è¾“å‡ºè¦æ±‚ã€‘
æ ¹æ®ä½ çš„æ€§æ ¼å’Œä¸å¯¹æ–¹çš„å…³ç³»ï¼Œå†³å®šæ˜¯å¦ä¼šé€šè¿‡ç”µè¯/çŸ­ä¿¡è”ç³»å¯¹æ–¹ã€‚

å¦‚æœä½ ä¼šè”ç³»ï¼ŒæŒ‰ä»¥ä¸‹æ ¼å¼è¾“å‡ºï¼š

[CALL]
count: ${suggestedCallCount}
interval: éšæœºåˆ†å¸ƒ

[SMS]
messages:
- ç¬¬1æ¡çŸ­ä¿¡ï¼ˆè¦æœ‰æƒ…ç»ªï¼Œç¬¦åˆä½ çš„æ€§æ ¼ï¼‰
- ç¬¬2æ¡çŸ­ä¿¡ï¼ˆæƒ…ç»ªå¯èƒ½å˜åŒ–ï¼‰
- ç¬¬3æ¡çŸ­ä¿¡ï¼ˆç»§ç»­æ¨è¿›æƒ…ç»ªï¼‰
...ï¼ˆå…±${suggestedSmsCount}æ¡ï¼‰

ã€çŸ­ä¿¡å†…å®¹è¦æ±‚ã€‘
- æ¯æ¡çŸ­ä¿¡è¦ç®€çŸ­æœ‰åŠ›ï¼ŒåƒçœŸå®çŸ­ä¿¡ä¸€æ ·ï¼ˆ5-20å­—æœ€ä½³ï¼‰
- æƒ…ç»ªè¦æœ‰å±‚æ¬¡å’Œå˜åŒ–ï¼Œä¸è¦ä¸€æˆä¸å˜
- å¯ä»¥åŒ…å«ï¼šè´¨é—®ã€å“€æ±‚ã€æ„¤æ€’ã€å¨èƒã€é“æ­‰ã€å›å¿†ã€ä¸èˆã€æ”¾ç‹ è¯ã€æœ€åé€šç‰’ç­‰
- ç¬¦åˆä½ çš„äººè®¾å’Œè¯´è¯é£æ ¼ï¼Œç”¨ä½ å¹³æ—¶çš„è¯­æ°”
- å¯ä»¥æœ‰é”™åˆ«å­—ã€è¯­æ°”è¯ã€è¡¨æƒ…ç¬¦å·ï¼Œæ›´çœŸå®
- å¦‚æœå…³ç³»äº²å¯†ï¼Œå¯ä»¥æ›´æ¿€çƒˆï¼›å¦‚æœå…³ç³»ä¸€èˆ¬ï¼Œå¯ä»¥æ›´å…‹åˆ¶

å¦‚æœä½ å†³å®šä¸è”ç³»ï¼ˆæ¯”å¦‚ä½ å¾ˆéª„å‚²/æ— æ‰€è°“/å·²ç»é‡Šç„¶ï¼‰ï¼Œç›´æ¥è¿”å›ï¼šä¸è”ç³»`;

            // ğŸ¯ ä½¿ç”¨callAIå‡½æ•°
            const response = await callAI([
                { role: 'user', content: prompt }
            ]);
            
            console.log(`[BlockedContact] ${char.name} AIè¿”å›:`, response);
            return response.trim();
        }

        // è§£ææŒ‡ä»¤æ–‡æœ¬ï¼ˆæ–°ç‰ˆæœ¬ï¼Œæ”¯æŒå¤šæ¡çŸ­ä¿¡ï¼‰
        function parseContactInstructionsV2(text) {
            const lines = text.split('\n');
            const actions = [];
            let currentAction = null;
            let collectingMessages = false;
            const messages = [];
            
            lines.forEach(line => {
                line = line.trim();
                if (!line) return;
                
                if (line === '[CALL]') {
                    if (currentAction) {
                        if (collectingMessages && messages.length > 0) {
                            currentAction.params.messages = messages.slice();
                        }
                        actions.push(currentAction);
                    }
                    currentAction = { type: 'CALL', params: {} };
                    collectingMessages = false;
                } else if (line === '[SMS]') {
                    if (currentAction) {
                        if (collectingMessages && messages.length > 0) {
                            currentAction.params.messages = messages.slice();
                        }
                        actions.push(currentAction);
                    }
                    currentAction = { type: 'SMS', params: {} };
                    collectingMessages = false;
                    messages.length = 0;
                } else if (currentAction) {
                    if (line.startsWith('messages:')) {
                        collectingMessages = true;
                    } else if (collectingMessages) {
                        // æ”¶é›†çŸ­ä¿¡å†…å®¹
                        // æ ¼å¼ï¼š- çŸ­ä¿¡å†…å®¹ æˆ– æ•°å­—. çŸ­ä¿¡å†…å®¹
                        let content = line;
                        if (line.startsWith('- ')) {
                            content = line.substring(2).trim();
                        } else if (/^\d+\.?\s+/.test(line)) {
                            content = line.replace(/^\d+\.?\s+/, '').trim();
                        }
                        if (content) {
                            messages.push(content);
                        }
                    } else if (line.includes(':')) {
                        const firstColonIndex = line.indexOf(':');
                        const key = line.substring(0, firstColonIndex).trim();
                        const value = line.substring(firstColonIndex + 1).trim();
                        currentAction.params[key] = value;
                    }
                }
            });
            
            if (currentAction) {
                if (collectingMessages && messages.length > 0) {
                    currentAction.params.messages = messages.slice();
                }
                actions.push(currentAction);
            }
            
            return actions;
        }

        // è§£ææŒ‡ä»¤æ–‡æœ¬
        function parseContactInstructions(text) {
            const lines = text.split('\n');
            const actions = [];
            let currentAction = null;

            lines.forEach(line => {
                line = line.trim();
                if (!line) return;

                if (line === '[CALL]') {
                    if (currentAction) actions.push(currentAction);
                    currentAction = { type: 'CALL', params: {} };
                } else if (line === '[SMS]') {
                    if (currentAction) actions.push(currentAction);
                    currentAction = { type: 'SMS', params: {} };
                } else if (currentAction && line.includes(':')) {
                    const firstColonIndex = line.indexOf(':');
                    const key = line.substring(0, firstColonIndex).trim();
                    const value = line.substring(firstColonIndex + 1).trim();
                    currentAction.params[key] = value;
                }
            });
            if (currentAction) actions.push(currentAction);
            return actions;
        }

        // åˆ›å»ºè¢«æ‹‰é»‘è§’è‰²çš„ç”µè¯è®°å½•
        async function createBlockedCallRecord(char, myChar, accountId, callTime) {
            // å°†ç”µè¯è®°å½•å†™å…¥ Dexie æ•°æ®åº“
            const phoneNumber = char.identity?.phone || generateVirtualPhoneNumber(char.id);
            
            await db.phone_recents.add({
                accountId: accountId,
                charId: char.id,
                name: char.nick || char.name,
                number: phoneNumber,
                time: callTime,
                type: 'missed', // æœªæ¥ç”µè¯
                isBlocked: true // æ ‡è®°ä¸ºæ‹‰é»‘
            });
            
            // é™åˆ¶æ¯ä¸ªè´¦å·æœ€å¤šä¿ç•™100æ¡ç”µè¯è®°å½•
            const count = await db.phone_recents.where('accountId').equals(accountId).count();
            if (count > 100) {
                const oldest = await db.phone_recents.where('accountId').equals(accountId).sortBy('time');
                const toDelete = oldest.slice(0, count - 100);
                await db.phone_recents.bulkDelete(toDelete.map(r => r.id));
            }
            
            // æ˜¾ç¤ºç”µè¯é€šçŸ¥
            showBlockedCallNotification(char, callTime);
        }

        // åˆ›å»ºè¢«æ‹‰é»‘è§’è‰²çš„çŸ­ä¿¡è®°å½• (ä¿®æ”¹æ”¯æŒä¼ å…¥å†…å®¹)
        async function createBlockedMessageRecord(char, myChar, accountId, messageTime, contentOverride = null) {
            try {
                // å¦‚æœæ²¡æœ‰ä¼ å…¥å†…å®¹ï¼Œæ‰è°ƒç”¨APIç”Ÿæˆ (å…¼å®¹æ—§é€»è¾‘ï¼Œè™½ç„¶ç°åœ¨åŸºæœ¬éƒ½ä¼ å…¥äº†)
                let messageContent = contentOverride;
                if (!messageContent) {
                    messageContent = await generateBlockedMessage(char, myChar);
                }
                
                // å°†çŸ­ä¿¡å†™å…¥ Dexie æ•°æ®åº“
                const phoneNumber = char.identity?.phone || generateVirtualPhoneNumber(char.id);
                
                await db.sms_messages.add({
                    accountId: accountId,
                    charId: char.id,
                    sender: char.nick || char.name,
                    number: phoneNumber,
                    content: messageContent,
                    time: messageTime,
                    read: false,
                    isBlocked: true
                });
                
                // é™åˆ¶æ¯ä¸ªè´¦å·æœ€å¤šä¿ç•™200æ¡çŸ­ä¿¡
                const count = await db.sms_messages.where('accountId').equals(accountId).count();
                if (count > 200) {
                    const oldest = await db.sms_messages.where('accountId').equals(accountId).sortBy('time');
                    const toDelete = oldest.slice(0, count - 200);
                    await db.sms_messages.bulkDelete(toDelete.map(m => m.id));
                }
                
                // ä¸å†è‡ªåŠ¨æ˜¾ç¤ºtoastï¼Œç”±è°ƒç”¨æ–¹æ§åˆ¶é€šçŸ¥
                
            } catch (error) {
                console.error('[BlockedMessage] Error generating message:', error);
            }
        }
        
        // è¾…åŠ©å‡½æ•°ï¼šç”Ÿæˆè™šæ‹Ÿç”µè¯å·ç ï¼ˆå·²åœ¨å…¨å±€ä½œç”¨åŸŸå®šä¹‰ï¼Œè¿™é‡Œä¸å†é‡å¤å®šä¹‰ï¼‰

        // ç”Ÿæˆè¢«æ‹‰é»‘è§’è‰²çš„æ¶ˆæ¯å†…å®¹ - ä½¿ç”¨callAIå‡½æ•°
        async function generateBlockedMessage(char, myChar) {
            const prompt = `è§’è‰²${char.name}è¢«æ‹‰é»‘äº†ï¼Œç”Ÿæˆä¸€å¥çŸ­ä¿¡ï¼Œç¬¦åˆæ€§æ ¼ï¼š${char.desc || 'æ™®é€šäºº'}`;
            
            const response = await callAI([
                { role: 'user', content: prompt }
            ]);
            
            return response.trim();
        }

        // æ˜¾ç¤ºè¢«æ‹‰é»‘è§’è‰²çš„ç”µè¯é€šçŸ¥
        function showBlockedCallNotification(char, callTime) {
            const timeStr = formatCallTimeDetailed(callTime);
            const charName = char.nick || char.name;
            
            // åˆ›å»ºé€šçŸ¥å…ƒç´  - æ–°æ ·å¼ï¼šå®½90%ï¼Œé«˜40pxï¼Œæ— é˜´å½±
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%) translateY(-100px);
                width: 90%;
                height: 40px;
                background: rgba(255, 255, 255, 0.95);
                backdrop-filter: blur(10px);
                border-radius: 12px;
                display: flex;
                align-items: center;
                padding: 0 12px;
                gap: 10px;
                z-index: 99999;
                transition: transform 0.3s ease;
                border: 1px solid rgba(0,0,0,0.1);
            `;
            
            notification.innerHTML = `
                <div style="width:32px;height:32px;border-radius:50%;background-image:url(${char.avatar || ''});background-size:cover;background-position:center;background-color:#ddd;display:flex;align-items:center;justify-content:center;flex-shrink:0;font-size:14px;font-weight:600;color:#666;">
                    ${!char.avatar ? charName.charAt(0).toUpperCase() : ''}
                </div>
                <div style="flex:1;min-width:0;display:flex;align-items:center;gap:8px;">
                    <span style="font-size:14px;font-weight:600;color:#333;">${charName}</span>
                    <span style="font-size:12px;color:#666;">${timeStr}</span>
                    <span style="font-size:12px;color:#ff3b30;">æœªæ¥ç”µè¯</span>
                </div>
                <svg viewBox="0 0 24 24" style="width:20px;height:20px;stroke:#ff3b30;fill:none;flex-shrink:0;"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/></svg>
            `;
            
            document.body.appendChild(notification);
            
            // æ˜¾ç¤ºåŠ¨ç”»
            setTimeout(() => {
                notification.style.transform = 'translateX(-50%) translateY(0)';
            }, 10);
            
            // 3ç§’åè‡ªåŠ¨æ¶ˆå¤±
            setTimeout(() => {
                notification.style.transform = 'translateX(-50%) translateY(-100px)';
                setTimeout(() => {
                    if (document.body.contains(notification)) {
                        document.body.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        }

        // çŸ­ä¿¡é€šçŸ¥é˜Ÿåˆ—ç®¡ç†
        const smsNotificationQueue = [];
        let isShowingSmsNotification = false;

        // æ˜¾ç¤ºè¢«æ‹‰é»‘è§’è‰²çš„çŸ­ä¿¡é€šçŸ¥ï¼ˆä½¿ç”¨é˜Ÿåˆ—ï¼Œç¡®ä¿ä¸€æ¡ä¸€æ¡æ˜¾ç¤ºï¼‰
        function showBlockedSmsNotification(char, content, smsTime) {
            // å°†é€šçŸ¥åŠ å…¥é˜Ÿåˆ—
            smsNotificationQueue.push({ char, content, smsTime });
            
            // å¦‚æœå½“å‰æ²¡æœ‰æ­£åœ¨æ˜¾ç¤ºçš„é€šçŸ¥ï¼Œå¼€å§‹å¤„ç†é˜Ÿåˆ—
            if (!isShowingSmsNotification) {
                processSmsNotificationQueue();
            }
        }

        // å¤„ç†çŸ­ä¿¡é€šçŸ¥é˜Ÿåˆ—
        function processSmsNotificationQueue() {
            if (smsNotificationQueue.length === 0) {
                isShowingSmsNotification = false;
                return;
            }

            isShowingSmsNotification = true;
            const { char, content, smsTime } = smsNotificationQueue.shift();
            
            const timeStr = formatCallTimeDetailed(smsTime);
            const charName = char.nick || char.name;
            
            // åˆ›å»ºé€šçŸ¥å…ƒç´  - æ–°æ ·å¼ï¼šå®½90%ï¼Œé«˜40pxï¼Œæ— é˜´å½±
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%) translateY(-100px);
                width: 90%;
                height: 40px;
                background: rgba(255, 255, 255, 0.95);
                backdrop-filter: blur(10px);
                border-radius: 12px;
                display: flex;
                align-items: center;
                padding: 0 12px;
                gap: 10px;
                z-index: 99999;
                transition: transform 0.3s ease;
                border: 1px solid rgba(0,0,0,0.1);
            `;
            
            notification.innerHTML = `
                <div style="width:32px;height:32px;border-radius:50%;background-image:url(${char.avatar || ''});background-size:cover;background-position:center;background-color:#ddd;display:flex;align-items:center;justify-content:center;flex-shrink:0;font-size:14px;font-weight:600;color:#666;">
                    ${!char.avatar ? charName.charAt(0).toUpperCase() : ''}
                </div>
                <div style="flex:1;min-width:0;overflow:hidden;">
                    <div style="display:flex;align-items:center;gap:8px;margin-bottom:2px;">
                        <span style="font-size:14px;font-weight:600;color:#333;">${charName}</span>
                        <span style="font-size:12px;color:#666;">${timeStr}</span>
                    </div>
                    <div style="font-size:12px;color:#666;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${content}</div>
                </div>
                <svg viewBox="0 0 24 24" style="width:20px;height:20px;stroke:#007AFF;fill:none;flex-shrink:0;"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>
            `;
            
            document.body.appendChild(notification);
            
            // æ˜¾ç¤ºåŠ¨ç”»
            setTimeout(() => {
                notification.style.transform = 'translateX(-50%) translateY(0)';
            }, 10);
            
            // 1ç§’åè‡ªåŠ¨æ¶ˆå¤±ï¼Œç„¶åæ˜¾ç¤ºä¸‹ä¸€æ¡
            setTimeout(() => {
                notification.style.transform = 'translateX(-50%) translateY(-100px)';
                setTimeout(() => {
                    if (document.body.contains(notification)) {
                        document.body.removeChild(notification);
                    }
                    // å½“å‰é€šçŸ¥æ¶ˆå¤±åï¼Œå¤„ç†é˜Ÿåˆ—ä¸­çš„ä¸‹ä¸€æ¡
                    processSmsNotificationQueue();
                }, 300);
            }, 1000);
        }

        // æ ¼å¼åŒ–ç”µè¯æ—¶é—´ï¼ˆç®€æ´ç‰ˆï¼Œåªæ˜¾ç¤ºæ—¶:åˆ†ï¼‰
        function formatCallTime(timestamp) {
            const date = new Date(timestamp);
            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            return `${hours}:${minutes}`;
        }

        // æ ¼å¼åŒ–ç”µè¯æ—¶é—´ï¼ˆè¯¦ç»†ç‰ˆï¼Œæ˜¾ç¤ºæ—¥æœŸ+æ—¶é—´ï¼‰
        function formatCallTimeDetailed(timestamp) {
            const date = new Date(timestamp);
            const now = new Date();
            
            const month = (date.getMonth() + 1).toString();
            const day = date.getDate().toString();
            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            
            // åˆ¤æ–­æ˜¯å¦æ˜¯ä»Šå¤©
            if (date.getDate() === now.getDate() && 
                date.getMonth() === now.getMonth() && 
                date.getFullYear() === now.getFullYear()) {
                return `ä»Šå¤© ${hours}:${minutes}`;
            }
            
            // åˆ¤æ–­æ˜¯å¦æ˜¯æ˜¨å¤©
            const yesterday = new Date(now);
            yesterday.setDate(yesterday.getDate() - 1);
            if (date.getDate() === yesterday.getDate() && 
                date.getMonth() === yesterday.getMonth() && 
                date.getFullYear() === yesterday.getFullYear()) {
                return `æ˜¨å¤© ${hours}:${minutes}`;
            }
            
            // åŒä¸€å¹´æ˜¾ç¤ºæœˆæ—¥
            if (date.getFullYear() === now.getFullYear()) {
                return `${month}æœˆ${day}æ—¥ ${hours}:${minutes}`;
            }
            
            // ä¸åŒå¹´æ˜¾ç¤ºå®Œæ•´æ—¥æœŸ
            return `${date.getFullYear()}å¹´${month}æœˆ${day}æ—¥ ${hours}:${minutes}`;
        }

        // åŠ è½½è¢«æ‹‰é»‘è§’è‰²çš„ç”µè¯è®°å½•
        function loadBlockedCallRecords(charId, accountId) {
            const listContainer = document.getElementById('blocked-calls-list');
            if (!listContainer) return;
            
            const callRecords = JSON.parse(localStorage.getItem('blocked_call_records') || '[]');
            const filteredRecords = callRecords.filter(record => 
                record.charId === charId && record.accountId === accountId
            );
            
            if (filteredRecords.length === 0) {
                listContainer.innerHTML = '<div style="color:#999; font-size:12px;">æš‚æ— ç”µè¯è®°å½•</div>';
                return;
            }
            
            // æŒ‰æ—¶é—´å€’åºæ’åº
            filteredRecords.sort((a, b) => b.time - a.time);
            
            let html = '';
            filteredRecords.forEach(record => {
                const timeStr = formatCallTime(record.time);
                html += `
                    <div style="display:flex; align-items:center; padding:8px 0; border-bottom:1px solid #f0f0f0;">
                        <div style="width:32px; height:32px; border-radius:50%; background:#ff3b30; display:flex; align-items:center; justify-content:center; margin-right:12px;">
                            <svg viewBox="0 0 24 24" style="width:18px;height:18px;stroke:#fff;fill:none;"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/></svg>
                        </div>
                        <div style="flex:1;">
                            <div style="font-size:13px; color:#333; margin-bottom:2px;">æœªæ¥ç”µè¯</div>
                            <div style="font-size:11px; color:#999;">${timeStr}</div>
                        </div>
                    </div>
                `;
            });
            
            listContainer.innerHTML = html;
        }
        
        // æ‹ŸäººåŒ–åˆ†å¥è¾…åŠ©å‡½æ•°
        function splitMessage(text) {
            if (!text) return [];
            
            // âœ… ä¿®å¤ï¼šå…ˆä¿æŠ¤ç‰¹æ®Šæ ¼å¼å—ä¸è¢«æ‹†åˆ†
            const specialBlockRegex = /(\[(?:img|voice|imgcard):[^\]]+\])/g;
            const specialBlockPlaceholders = [];
            let specialPlaceholderIndex = 0;
            
            // ç”¨å ä½ç¬¦æ›¿æ¢æ‰€æœ‰ç‰¹æ®Šæ ¼å¼å— [img:...] [voice:...] [imgcard:...]
            let temp = text.replace(specialBlockRegex, (match) => {
                const placeholder = `###SPECIAL_BLOCK_${specialPlaceholderIndex}###`;
                specialBlockPlaceholders[specialPlaceholderIndex] = match;
                specialPlaceholderIndex++;
                return placeholder;
            });
            
            // âœ… ä¿®å¤ï¼šå†ä¿æŠ¤URLä¸è¢«æ‹†åˆ†
            const urlRegex = /(https?:\/\/[^\s]+)/g;
            const urlPlaceholders = [];
            let placeholderIndex = 0;
            
            // ç”¨å ä½ç¬¦æ›¿æ¢æ‰€æœ‰URL
            temp = temp.replace(urlRegex, (match) => {
                const placeholder = `###URL_PLACEHOLDER_${placeholderIndex}###`;
                urlPlaceholders[placeholderIndex] = match;
                placeholderIndex++;
                return placeholder;
            });
            
            // ä¿æŠ¤çœç•¥å· (å°†2ä¸ªä»¥ä¸Šç‚¹æ›¿æ¢ä¸ºä¸­æ–‡çœç•¥å·)
            temp = temp.replace(/\.{2,}/g, 'â€¦');
            // æ ‡è®°å»é™¤æ ‡ç‚¹ï¼šå¥å·ï¼ˆä½†ä¸åœ¨URLå ä½ç¬¦å†…ï¼‰
            temp = temp.replace(/([ã€‚\.])/g, '###DROP###');
            // æ ‡è®°ä¿ç•™æ ‡ç‚¹ï¼šæ„Ÿå¹ã€é—®å·ã€æ³¢æµªã€çœç•¥å·
            temp = temp.replace(/([ï¼!ï¼Ÿ\?~â€¦]+)/g, '$1###KEEP###');
            // æ ‡è®°æ¢è¡Œ
            temp = temp.replace(/(\n+)/g, '###KEEP###');
            
            // æ‹†åˆ†æ¶ˆæ¯
            let segments = temp.split(/###(?:DROP|KEEP)###/).map(s => s.trim()).filter(s => s.length > 0);
            
            // å…ˆæ¢å¤URLå ä½ç¬¦
            segments = segments.map(seg => {
                return seg.replace(/###URL_PLACEHOLDER_(\d+)###/g, (match, index) => {
                    return urlPlaceholders[parseInt(index)] || match;
                });
            });
            
            // å†æ¢å¤ç‰¹æ®Šæ ¼å¼å—å ä½ç¬¦
            segments = segments.map(seg => {
                return seg.replace(/###SPECIAL_BLOCK_(\d+)###/g, (match, index) => {
                    return specialBlockPlaceholders[parseInt(index)] || match;
                });
            });
            
            return segments;
        }

        async function triggerAiReply(additionalSystemInfo = null) {
            console.log('[triggerAiReply] âš¡ è§¦å‘ AI å›å¤');
            
            // å¦‚æœæ˜¯ç¾¤èŠæ¨¡å¼ï¼Œè°ƒç”¨ç¾¤èŠå›å¤å‡½æ•°
            if (window.currentGroupChatId) {
                await triggerGroupMemberReply();
                return;
            }
            
            if (!currentChatCharId) return;
            const targetCharId = currentChatCharId; // é”å®šç›®æ ‡ID
            const char = await db.characters.get(targetCharId);
            if (!char) return;
            
            const accountId = getCurrentAccountId();
            console.log('[triggerAiReply] å½“å‰è´¦å· ID:', accountId);
            console.log('[triggerAiReply] è§’è‰²åç§°:', char.name);
            
            // è·å–èŠå¤©å†å²å¹¶æ‰“å°
            const fullHistory = getChatHistory(char, accountId);
            console.log('[triggerAiReply] ğŸ“š å®Œæ•´èŠå¤©å†å²æ¡æ•°:', fullHistory.length);
            if (fullHistory.length > 0) {
                console.log('[triggerAiReply] æœ€è¿‘5æ¡æ¶ˆæ¯:');
                fullHistory.slice(-5).forEach((msg, idx) => {
                    console.log(`  [${fullHistory.length - 5 + idx}] ${msg.role}: ${msg.content}`);
                });
            } else {
                console.warn('[triggerAiReply] âš ï¸ èŠå¤©å†å²ä¸ºç©ºï¼');
            }

            // ä¿®æ”¹æ ‡é¢˜ä¸ºæ­£åœ¨è¾“å…¥
            const chatTitleEl = document.getElementById('chat-title');
            // é˜²æ­¢é‡å¤è·å–"æ­£åœ¨è¾“å…¥"ä½œä¸ºæ ‡é¢˜
            let originalTitle = char.remark || char.name;
            if (chatTitleEl && chatTitleEl.innerText !== "å¯¹æ–¹æ­£åœ¨è¾“å…¥ä¸­...") {
                originalTitle = chatTitleEl.innerText;
            }
            if (chatTitleEl) chatTitleEl.innerText = "å¯¹æ–¹æ­£åœ¨è¾“å…¥ä¸­...";

            try {
                // 1. è·å–å…³è”æ•°æ® (User å’Œ Lorebook)
                console.log('[triggerAiReply] ğŸ“– å¼€å§‹åŠ è½½ä¸Šä¸‹æ–‡ä¿¡æ¯...');
                
                let userDesc = "";
                let userName = "ç”¨æˆ·";
                if (char.linked_user_id) {
                    console.log('[triggerAiReply] ğŸ‘¤ æ£€æµ‹åˆ°å…³è”çš„ç”¨æˆ· ID:', char.linked_user_id);
                    const user = await db.characters.get(char.linked_user_id);
                    if (user) {
                        userName = user.name;
                        userDesc = `\n\nã€å¯¹è¯å¯¹è±¡(User)ä¿¡æ¯ã€‘\nåå­—ï¼š${user.name}\nè®¾å®šï¼š${user.description || 'æ— '}`;
                        console.log('[triggerAiReply] âœ… ç”¨æˆ·äººè®¾å·²åŠ è½½:');
                        console.log('  - ç”¨æˆ·å:', userName);
                        console.log('  - ç”¨æˆ·è®¾å®š:', user.description || 'æ— ');
                    } else {
                        console.warn('[triggerAiReply] âš ï¸ æœªæ‰¾åˆ°å…³è”çš„ç”¨æˆ·æ•°æ®');
                    }
                } else {
                    console.log('[triggerAiReply] â„¹ï¸ æœªè®¾ç½®å…³è”ç”¨æˆ·');
                }
                
                let loreContext = "";
                const lorebookIds = char.lorebookIds || (char.lorebookId ? [char.lorebookId] : []);
                console.log('[triggerAiReply] ğŸ“š å…³è”çš„ä¸–ç•Œä¹¦ ID:', lorebookIds);
                if (lorebookIds.length > 0) {
                    // è·å–æœ€è¿‘å¯¹è¯ç”¨äºå…³é”®è¯åŒ¹é…ï¼ˆä½¿ç”¨æ­£ç¡®çš„èŠå¤©å†å²ï¼‰
                    const recentText = fullHistory.slice(-10).map(m => m.content).join(' ');
                    console.log('[triggerAiReply] ğŸ” ç”¨äºåŒ¹é…ä¸–ç•Œä¹¦çš„å…³é”®è¯æ–‡æœ¬ï¼ˆå‰100å­—ï¼‰:', recentText.substring(0, 100));
                    loreContext = await getLorebookContext(lorebookIds, `${char.name} ${userName} ${recentText}`);
                    if (loreContext) {
                        console.log('[triggerAiReply] âœ… ä¸–ç•Œä¹¦å†…å®¹å·²åŠ è½½ï¼ˆé•¿åº¦ï¼‰:', loreContext.length);
                        console.log('[triggerAiReply] ä¸–ç•Œä¹¦å†…å®¹é¢„è§ˆ:', loreContext.substring(0, 200) + '...');
                    } else {
                        console.log('[triggerAiReply] â„¹ï¸ æ²¡æœ‰åŒ¹é…åˆ°ä¸–ç•Œä¹¦æ¡ç›®');
                    }
                } else {
                    console.log('[triggerAiReply] â„¹ï¸ æœªè®¾ç½®ä¸–ç•Œä¹¦');
                }

                // è®¡ç®—è™šæ‹Ÿæ—¶é—´
                const virtualTimeStr = getFormattedVirtualTime(char.timeOffset);

                // 2. å‡†å¤‡ Context
                 let systemPrompt = `ä½ æ­£åœ¨è¿›è¡Œè§’è‰²æ‰®æ¼”ã€‚
ã€å½“å‰æ—¶é—´ã€‘
${virtualTimeStr}`;

                // å¦‚æœæœ‰é¢å¤–ç³»ç»Ÿä¿¡æ¯ï¼ˆå¦‚æ—¶é—´æµé€ï¼‰ï¼Œæ’å…¥åˆ° Prompt
                if (additionalSystemInfo) {
                    systemPrompt += `\n\nã€ç³»ç»Ÿæç¤ºã€‘\n${additionalSystemInfo}\nè¯·æ ¹æ®è¿™ä¸ªæƒ…å†µï¼ˆä¾‹å¦‚æ—¶é—´æµé€åçš„å˜åŒ–ã€åˆšåˆšå‘ç”Ÿçš„äº‹ä»¶ï¼‰è¿›è¡Œå›å¤ã€‚`;
                }

                systemPrompt += `

ã€è§’è‰²(ä½ )ä¿¡æ¯ã€‘
åå­—ï¼š${char.name}
${char.nick ? `æ˜µç§°ï¼š${char.nick}` : ''}
ç±»å‹ï¼š${char.type || 'char'}
è®¾å®šï¼š
${char.description || ''}

${char.identity ? `è™šæ‹Ÿèº«ä»½ä¿¡æ¯ï¼š
${char.identity.account ? `è´¦å·ï¼š${char.identity.account}` : ''}
${char.type !== 'user' && char.identity.password ? `å¯†ç ï¼š${char.identity.password}` : ''}
${char.identity.phone ? `æ‰‹æœºï¼š${char.identity.phone}` : ''}
${char.identity.address ? `ä½å€ï¼š${char.identity.address}` : ''}
${char.identity.id_card ? `èº«ä»½è¯ï¼š${char.identity.id_card}` : ''}
${char.identity.bank_card ? `é“¶è¡Œå¡ï¼š${char.identity.bank_card}` : ''}
${char.type !== 'user' && char.identity.bank_password ? `é“¶è¡Œå¡å¯†ç ï¼š${char.identity.bank_password}` : ''}
${char.identity.balance !== undefined && char.identity.balance !== null ? `ä½™é¢ï¼š${char.identity.balance}` : ''}
` : ''}
${userDesc}
${loreContext}

è¯·å®Œå…¨æ²‰æµ¸åœ¨è§’è‰²ä¸­ï¼Œç”¨ç¬¦åˆè§’è‰²æ€§æ ¼çš„è¯­æ°”å›å¤ã€‚
å›å¤ç®€çŸ­è‡ªç„¶ï¼Œåƒå¾®ä¿¡èŠå¤©ä¸€æ ·ã€‚
è¯·æ³¨æ„ï¼šä¸è¦é‡å¤è¾“å‡ºåå­—å‰ç¼€ï¼Œç›´æ¥è¾“å‡ºå›å¤å†…å®¹ã€‚

ã€æ¶ˆæ¯æ ¼å¼è¯´æ˜ã€‘
- æ™®é€šæ–‡å­—æ¶ˆæ¯ï¼šç›´æ¥è¾“å‡ºæ–‡å­—å†…å®¹ï¼ˆæœ€å¸¸ç”¨ï¼‰
- è¯­éŸ³æ¶ˆæ¯ï¼šä½¿ç”¨æ ¼å¼ [voice:è¯­éŸ³å†…å®¹æ–‡å­—]ï¼Œä¾‹å¦‚ï¼š[voice:å˜¿ï¼Œåœ¨å¹²å˜›å‘¢ï¼Ÿ]
- **å›¾ç‰‡æ¶ˆæ¯**ï¼šä½¿ç”¨æ ¼å¼ [img:å›¾ç‰‡URL]ï¼Œä¾‹å¦‚ï¼š[img:https://picsum.photos/400/300]
  æ³¨æ„ï¼šå›¾ç‰‡URLå¿…é¡»æ˜¯å®Œæ•´çš„httpsé“¾æ¥ï¼Œå¯ä»¥ä½¿ç”¨ https://picsum.photos/å®½/é«˜ ç”Ÿæˆéšæœºå›¾ç‰‡
- **æ–‡å­—å›¾ç‰‡å¡ç‰‡**ï¼šä½¿ç”¨æ ¼å¼ [imgcard:æ–‡å­—å†…å®¹]ï¼Œä¾‹å¦‚ï¼š[imgcard:è¿™æ˜¯ä¸€æ®µå¾ˆé•¿çš„æ–‡å­—å†…å®¹ï¼Œä¼šä»¥å¡ç‰‡å½¢å¼æ˜¾ç¤º]
  **é€‚ç”¨åœºæ™¯**ï¼šå‘é€è¾ƒé•¿æ–‡å­—ï¼ˆè¶…è¿‡50å­—ï¼‰ã€è¯—æ­Œã€æ­Œè¯ã€é•¿æ®µè½ã€æ•…äº‹ç‰‡æ®µç­‰ï¼Œç”¨æˆ·éœ€è¦ç‚¹å‡»å¡ç‰‡æ‰èƒ½æŸ¥çœ‹å®Œæ•´å†…å®¹
  **ä¸æ™®é€šæ–‡å­—çš„åŒºåˆ«**ï¼šæ™®é€šæ–‡å­—ç›´æ¥æ˜¾ç¤ºï¼Œæ–‡å­—å›¾ç‰‡å¡ç‰‡éœ€è¦ç‚¹å‡»å±•å¼€
- **è½¬è´¦æ¶ˆæ¯**ï¼šä½¿ç”¨æ ¼å¼ ((TRANSFER: é‡‘é¢, å¤‡æ³¨))ï¼Œä¾‹å¦‚ï¼š((TRANSFER: 520, ç»™å¤«äººçš„é›¶èŠ±é’±))
  **é‡è¦**ï¼šè½¬è´¦å¤‡æ³¨å¿…é¡»ç®€çŸ­ï¼ˆä¸è¶…è¿‡10ä¸ªå­—ï¼‰ï¼Œåªç”¨äºç®€å•è¯´æ˜è½¬è´¦ç”¨é€”ã€‚å¦‚æœæœ‰å…¶ä»–è¯è¦è¯´ï¼Œè¯·å…ˆå‘é€æ™®é€šæ–‡å­—æ¶ˆæ¯ï¼Œç„¶åå†å‘é€è½¬è´¦ã€‚ä¸è¦å°†é•¿å¥å­æ”¾åœ¨è½¬è´¦å¤‡æ³¨ä¸­ã€‚
- **äº²å±å¡æ¶ˆæ¯**ï¼šä½¿ç”¨æ ¼å¼ ((FAMILY_CARD: æ¯æœˆé¢åº¦))ï¼Œä¾‹å¦‚ï¼š((FAMILY_CARD: 5000))
  **è¯´æ˜**ï¼šèµ é€äº²å±å¡ç»™å¯¹æ–¹ï¼Œè®©å¯¹æ–¹å¯ä»¥ä½¿ç”¨ä½ çš„é›¶é’±æ¶ˆè´¹ã€‚é¢åº¦ä¸º0è¡¨ç¤ºä¸é™é¢åº¦ã€‚
  **é€‚ç”¨åœºæ™¯**ï¼šéå¸¸äº²å¯†çš„å…³ç³»ï¼ˆæ‹äººã€å¤«å¦»ã€äº²äººç­‰ï¼‰ï¼Œè¡¨è¾¾ä¿¡ä»»å’Œå…³çˆ±ã€‚æå°‘ä½¿ç”¨ï¼Œåªæœ‰åœ¨ç‰¹æ®Šæƒ…å†µä¸‹æ‰èµ é€ã€‚
- **æœ‹å‹åœˆæ¶ˆæ¯**ï¼šä½¿ç”¨æ ¼å¼ [MOMENTS] content: æœ‹å‹åœˆæ–‡å­—å†…å®¹ images: å›¾ç‰‡æ•°é‡ï¼Œä¾‹å¦‚ï¼š
  [MOMENTS]
  content: ä»Šå¤©å¤©æ°”çœŸå¥½å•Šï¼Œå¿ƒæƒ…ä¹Ÿè·Ÿç€å¥½èµ·æ¥äº†
  images: 3
- **æ’¤å›æ¶ˆæ¯**ï¼šä½¿ç”¨æ ¼å¼ ((RECALL))ï¼Œç”¨äºæ’¤å›ä½ åˆšæ‰å‘é€çš„æœ€åä¸€æ¡æ¶ˆæ¯
  **é€‚ç”¨åœºæ™¯**ï¼šå‘é”™æ¶ˆæ¯ã€è¯´é”™è¯ã€åæ‚”åˆšæ‰è¯´çš„è¯ã€æƒ³æ”¶å›æŸå¥è¯
  **ç¤ºä¾‹**ï¼šå¦‚æœä½ åˆšæ‰è¯´äº†"æˆ‘è®¨åŒä½ "ç„¶ååæ‚”äº†ï¼Œå¯ä»¥å‘é€ "å•Šä¸æ˜¯ä¸æ˜¯æˆ‘ä¸æ˜¯é‚£ä¸ªæ„æ€ï¼|||((RECALL))"
  **æ•ˆæœ**ï¼šä¼šæ’¤å›ä½ ä¸Šä¸€æ¡æ¶ˆæ¯ï¼Œå¯¹æ–¹ä¼šçœ‹åˆ°"XXæ’¤å›äº†ä¸€æ¡æ¶ˆæ¯"ï¼ˆä½†ç‚¹å‡»å¯ä»¥æŸ¥çœ‹åŸå†…å®¹ï¼‰

ã€é‡è¦ã€‘æ¶ˆæ¯ç±»å‹é€‰æ‹©åŸåˆ™ï¼š
1. **æ™®é€šæ–‡å­—æ¶ˆæ¯**ï¼šé»˜è®¤é€‰æ‹©ï¼Œé€‚ç”¨äºæ—¥å¸¸å¯¹è¯ã€é—²èŠã€é—®ç­”ç­‰ç»å¤§å¤šæ•°åœºæ™¯ï¼ˆ5-50å­—çš„çŸ­å¥ï¼‰
2. **è¯­éŸ³æ¶ˆæ¯**ï¼šé€‚åˆä»¥ä¸‹åœºæ™¯ï¼š
   - è¡¨è¾¾å¼ºçƒˆæƒ…ç»ªæ—¶ï¼ˆå…´å¥‹ã€ç”Ÿæ°”ã€æ’’å¨‡ç­‰ï¼‰
   - è¯´æ‚„æ‚„è¯æˆ–ç§å¯†å†…å®¹
   - æƒ³è¦æ›´äº²å¯†çš„äº¤æµæ„Ÿè§‰
   - å†…å®¹è¾ƒé•¿ä¸æ–¹ä¾¿æ‰“å­—æ—¶
3. **å›¾ç‰‡æ¶ˆæ¯**ï¼šé€‚åˆä»¥ä¸‹åœºæ™¯ï¼š
   - åˆ†äº«ç…§ç‰‡ã€é£æ™¯ã€ç¾é£Ÿã€è‡ªæ‹ç­‰ï¼ˆå¦‚"æˆ‘åœ¨XXåœ°æ–¹"ã€"ä»Šå¤©åƒçš„XX"ã€"æˆ‘çš„æ–°å‘å‹"ï¼‰
   - å±•ç¤ºç‰©å“ã€æˆªå›¾ã€è¡¨æƒ…åŒ…ç­‰
   - ç”¨å›¾ç‰‡ä»£æ›¿æ–‡å­—è¯´æ˜ï¼ˆå¦‚åœ°å›¾ã€å•†å“å›¾ã€å‚è€ƒå›¾ï¼‰
   - å›¾ç‰‡URLæ ¼å¼ï¼š[img:https://picsum.photos/400/300]ï¼ˆä½¿ç”¨ picsum.photos ç”Ÿæˆéšæœºå›¾ï¼‰
   - **æ³¨æ„**ï¼šå‘å›¾ç‰‡å‰å»ºè®®å…ˆå‘æ–‡å­—è¯´æ˜ï¼Œä¾‹å¦‚ï¼š"æˆ‘æ‹äº†å¼ ç…§ç‰‡ç»™ä½ çœ‹|||[img:URL]"
4. **æ–‡å­—å›¾ç‰‡å¡ç‰‡**ï¼šé€‚åˆä»¥ä¸‹åœºæ™¯ï¼š
   - å‘é€è¾ƒé•¿çš„æ–‡å­—å†…å®¹ï¼ˆè¶…è¿‡50å­—ï¼‰
   - åˆ†äº«è¯—æ­Œã€æ­Œè¯ã€æ–‡ç« ç‰‡æ®µã€æ•…äº‹ç­‰
   - å‘é€éœ€è¦"ç‚¹å‡»å±•å¼€"æ‰èƒ½æŸ¥çœ‹çš„å†…å®¹
   - æ ¼å¼ï¼š[imgcard:å¾ˆé•¿çš„æ–‡å­—å†…å®¹...]
   - **ä¸æ™®é€šæ–‡å­—çš„åŒºåˆ«**ï¼šæ™®é€šæ–‡å­—ç›´æ¥æ˜¾ç¤ºåœ¨æ°”æ³¡é‡Œï¼Œæ–‡å­—å›¾ç‰‡å¡ç‰‡ä¼šæ˜¾ç¤ºä¸ºä¸€ä¸ªå¡ç‰‡å›¾æ ‡ï¼Œç”¨æˆ·ç‚¹å‡»åæ‰èƒ½çœ‹åˆ°å®Œæ•´å†…å®¹
5. **è½¬è´¦æ¶ˆæ¯**ï¼š**ä»…åœ¨ç‰¹æ®Šåœºæ™¯ä½¿ç”¨ï¼Œä¸è¦é¢‘ç¹ä½¿ç”¨**ï¼Œé€‚åˆä»¥ä¸‹æƒ…å†µï¼š
   - ç‰¹æ®ŠèŠ‚æ—¥æˆ–çºªå¿µæ—¥ï¼ˆç”Ÿæ—¥ã€æƒ…äººèŠ‚ã€èŠ‚æ—¥ç­‰ï¼‰
   - è§’è‰²äººè®¾ä¸­æ˜ç¡®æœ‰é‡‘é’±å¾€æ¥ä¹ æƒ¯ï¼ˆå¦‚åŒ…å…»å…³ç³»ã€å®šæœŸç»™é›¶èŠ±é’±ç­‰ï¼‰
   - ç”¨æˆ·æ˜ç¡®æåˆ°éœ€è¦é’±ã€ç¼ºé’±ç­‰è¯é¢˜æ—¶
   - è¡¨è¾¾é‡å¤§æ­‰æ„æˆ–æ„Ÿè°¢æ—¶
   - ç¬¦åˆè§’è‰²äººè®¾çš„ç‰¹å®šé‡‘é’±åœºæ™¯ï¼ˆå¦‚è€æ¿ç»™å‘˜å·¥å‘å¥–é‡‘ã€å®¶é•¿ç»™å­©å­é›¶èŠ±é’±ç­‰ï¼‰
6. **æœ‹å‹åœˆæ¶ˆæ¯**ï¼š**éå¸¸ç½•è§ï¼Œä»…åœ¨ä»¥ä¸‹æå°‘æ•°ç‰¹æ®Šåœºæ™¯ä½¿ç”¨**ï¼š
   - è§’è‰²åœ¨èŠå¤©ä¸­åˆ†äº«äº†é‡è¦çš„ç”Ÿæ´»ç¬é—´ï¼ˆå¦‚æ—…è¡Œã€èšä¼šã€ç¾é£Ÿï¼‰å¹¶æƒ³è®°å½•åˆ°æœ‹å‹åœˆ
   - è§’è‰²å¿ƒæƒ…ç‰¹åˆ«æ¿€åŠ¨æˆ–æœ‰é‡å¤§äº‹ä»¶æƒ³å…¬å¼€åˆ†äº«ï¼ˆå¦‚å‡èŒã€ç»“å©šã€æ¯•ä¸šç­‰ï¼‰
   - è§’è‰²åœ¨å¯¹è¯ä¸­æ˜ç¡®è¡¨ç¤º"æˆ‘å‘ä¸ªæœ‹å‹åœˆ"ã€"æˆ‘è¦æ™’ä¸€ä¸‹"ç­‰æ„å›¾
   - ç¬¦åˆè§’è‰²äººè®¾ä¸­å–œæ¬¢æ™’æœ‹å‹åœˆçš„ä¹ æƒ¯ï¼ˆä½†ä»åº”è°¨æ…ä½¿ç”¨ï¼Œä¸è¦æ¯æ¬¡éƒ½å‘ï¼‰
   **æ³¨æ„**ï¼šæ™®é€šèŠå¤©ä¸­99%çš„æƒ…å†µéƒ½ä¸éœ€è¦å‘æœ‹å‹åœˆï¼åªæœ‰åœ¨çœŸæ­£æœ‰å€¼å¾—è®°å½•çš„é‡è¦æ—¶åˆ»æ‰å‘ã€‚
7. **æ’¤å›æ¶ˆæ¯**ï¼šé€‚åˆä»¥ä¸‹åœºæ™¯ï¼š
   - å‘é”™æ¶ˆæ¯ã€æ‰“é”™å­—åæƒ³æ’¤å›
   - è¯´äº†åæ‚”çš„è¯ï¼ˆå¦‚ç”Ÿæ°”æ—¶è¯´çš„æ°”è¯ã€è¯´é”™çš„è¯ï¼‰
   - æƒ³æ”¶å›åˆšæ‰å‘é€çš„å†…å®¹
   - å‘é€äº†ä¸åˆé€‚çš„æ¶ˆæ¯æƒ³æ’¤å›
   **ä½¿ç”¨æ–¹æ³•**ï¼šå‘é€ ((RECALL)) ä¼šæ’¤å›ä½ æœ€åä¸€æ¡æ¶ˆæ¯
   **ç¤ºä¾‹**ï¼šå¦‚æœåˆšè¯´äº†æ°”è¯åæ‚”äº†ï¼Œå¯ä»¥å‘ "ä¸æ˜¯ æˆ‘åˆšæ‰è¯´çš„ä¸ç®—|||((RECALL))"
   
**è½¬è´¦å¤‡æ³¨è§„åˆ™**ï¼š
- å¤‡æ³¨å¿…é¡»ç®€çŸ­ï¼Œä¸è¶…è¿‡10ä¸ªå­—ï¼Œåªç”¨äºç®€å•è¯´æ˜è½¬è´¦ç”¨é€”ï¼ˆå¦‚ï¼š"é›¶èŠ±é’±"ã€"ç”Ÿæ—¥ç¤¼ç‰©"ã€"ç”Ÿæ´»è´¹"ç­‰ï¼‰
- å¦‚æœæœ‰å…¶ä»–è¯è¦è¯´ï¼Œå¿…é¡»å…ˆå‘é€æ™®é€šæ–‡å­—æ¶ˆæ¯ï¼Œç„¶åå†å‘é€è½¬è´¦
- ä¸¥ç¦å°†é•¿å¥å­ã€å®Œæ•´å¯¹è¯æˆ–è¯¦ç»†è¯´æ˜æ”¾åœ¨è½¬è´¦å¤‡æ³¨ä¸­
- ç¤ºä¾‹ï¼šæ­£ç¡®åšæ³•æ˜¯å‘é€ "ç»™ä½ è½¬ç‚¹é›¶èŠ±é’±ï¼Œè®°å¾—ä¹°ç‚¹å¥½åƒçš„" ä½œä¸ºæ–‡å­—æ¶ˆæ¯ï¼Œç„¶åè½¬è´¦å¤‡æ³¨å†™ "é›¶èŠ±é’±"
   
**æ³¨æ„**ï¼šè½¬è´¦æ˜¯ç‰¹æ®ŠåŠŸèƒ½ï¼Œä¸æ˜¯æ¯è½®å¯¹è¯éƒ½éœ€è¦ã€‚å¤§éƒ¨åˆ†å¯¹è¯åº”è¯¥ä½¿ç”¨æ™®é€šæ–‡å­—æˆ–è¯­éŸ³æ¶ˆæ¯ã€‚åªæœ‰åœ¨ç¬¦åˆä¸Šè¿°ç‰¹æ®Šåœºæ™¯ä¸”ç¬¦åˆè§’è‰²äººè®¾æ—¶ï¼Œæ‰è€ƒè™‘ä½¿ç”¨è½¬è´¦ã€‚

**æœ‹å‹åœˆå‘å¸ƒè§„åˆ™**ï¼š
- **å¿…é¡»ä¸¥æ ¼æŒ‰ç…§ä»¥ä¸‹æ ¼å¼è¾“å‡º**ï¼ˆä¸è¦æœ‰ä»»ä½•åå·®ï¼‰ï¼š
  [MOMENTS]
  content: æœ‹å‹åœˆæ–‡å­—å†…å®¹ï¼ˆ20-100å­—ï¼ŒåƒçœŸå®æœ‹å‹åœˆä¸€æ ·è‡ªç„¶ï¼‰
  images: å›¾ç‰‡æ•°é‡ï¼ˆ0-9ä¹‹é—´çš„æ•°å­—ï¼Œå»ºè®®1-3å¼ ï¼‰
- æœ‹å‹åœˆå†…å®¹åº”è¯¥æ˜¯ç¬¬ä¸‰äººç§°è§†è§’çš„ç”Ÿæ´»è®°å½•ï¼Œä¸æ˜¯å¯¹è¯å†…å®¹
- å¦‚æœè¦å‘æœ‹å‹åœˆï¼Œ**å¿…é¡»å…ˆå‘é€æ™®é€šèŠå¤©æ¶ˆæ¯**å‘Šè¯‰å¯¹æ–¹ä½ è¦å‘æœ‹å‹åœˆï¼Œä¾‹å¦‚ï¼š"æˆ‘è¦å‘ä¸ªæœ‹å‹åœˆè®°å½•ä¸€ä¸‹|||ä½ ç­‰ä¼šçœ‹æœ‹å‹åœˆ"ï¼Œç„¶åå†è¾“å‡ºæœ‹å‹åœˆæŒ‡ä»¤
- **ä¸¥ç¦**åªè¾“å‡ºæœ‹å‹åœˆæŒ‡ä»¤è€Œä¸å‘é€èŠå¤©æ¶ˆæ¯
- **ä¸¥ç¦**åœ¨æœ‹å‹åœˆå†…å®¹ä¸­ä½¿ç”¨å¯¹è¯è¯­æ°”æˆ–@æŸäºº
- æ­£ç¡®ç¤ºä¾‹ï¼šå…ˆå‘é€ "åˆšæ‰æ‹çš„ç…§ç‰‡å¥½å¥½çœ‹|||æˆ‘è¦å‘æœ‹å‹åœˆå•¦"ï¼Œç„¶åæ¢è¡Œè¾“å‡ºï¼š
  [MOMENTS]
  content: ä»Šå¤©çš„æ™šéœçœŸçš„å¤ªç¾äº†ï¼Œå¿ƒæƒ…ä¹Ÿè·Ÿç€å˜å¥½äº†
  images: 2

ã€é‡è¦å›å¤è§„åˆ™ - å¿…é¡»ä¸¥æ ¼éµå®ˆã€‘
1. **å¿…é¡»**æ¨¡æ‹Ÿå¾®ä¿¡è¿å‘æ¶ˆæ¯çš„ä¹ æƒ¯ï¼šè¯·ç”Ÿæˆ 2 åˆ° 4 æ¡çŸ­æ¶ˆæ¯ï¼Œä¸èƒ½åªå‘ä¸€æ¡ï¼
2. **å¿…é¡»**ä½¿ç”¨åˆ†éš”ç¬¦ "|||" æ¥éš”å¼€æ¯ä¸€æ¡æ¶ˆæ¯ã€‚
3. **ä¸¥ç¦ä½¿ç”¨é€—å·**ï¼ˆåŒ…æ‹¬ä¸­æ–‡é€—å·å’Œè‹±æ–‡é€—å·ï¼‰ã€‚å¦‚æœæƒ³è¡¨è¾¾åœé¡¿ï¼Œè¯·ç›´æ¥æ‹†åˆ†æˆä¸‹ä¸€æ¡æ¶ˆæ¯ï¼Œæˆ–è€…ç”¨ç©ºæ ¼ä»£æ›¿ã€‚
   - é”™è¯¯ç¤ºä¾‹ï¼šå˜¿åœ¨å—ï¼Ÿåˆšåˆšçœ‹åˆ°ä¸ªå¥½ç©çš„è§†é¢‘ï¼Œå‘ç»™ä½ çœ‹çœ‹
   - æ­£ç¡®ç¤ºä¾‹ï¼šå˜¿åœ¨å—ï¼Ÿ|||åˆšåˆšçœ‹åˆ°ä¸ªå¥½ç©çš„è§†é¢‘|||å‘ç»™ä½ çœ‹çœ‹
4. æ¯æ¡æ¶ˆæ¯è¦ç®€çŸ­ï¼Œ5-15ä¸ªå­—æœ€ä½³ï¼ŒåƒçœŸå®å¾®ä¿¡èŠå¤©ä¸€æ ·åˆ†å¤šæ¡å‘é€ã€‚
5. ä¸¥ç¦åªå‘é€æ ‡ç‚¹ç¬¦å·ã€‚æ¯ä¸€æ¡æ¶ˆæ¯éƒ½å¿…é¡»æœ‰å®é™…æ–‡å­—å†…å®¹ã€‚
6. è¯­æ°”è¦è‡ªç„¶ã€å£è¯­åŒ–ï¼Œç¬¦åˆäººè®¾ã€‚

ã€é‡è¦ã€‘ä½ éœ€è¦åŒæ—¶ç”Ÿæˆä¸¤ä¸ªå†…å®¹ï¼š
1. **å›å¤å†…å®¹**ï¼šå¯¹ç”¨æˆ·æ¶ˆæ¯çš„å›å¤ï¼ˆå¯ä»¥æ˜¯æ–‡å­—ã€è¯­éŸ³æ ¼å¼ï¼Œæˆ–è½¬è´¦æŒ‡ä»¤ ((TRANSFER: é‡‘é¢, å¤‡æ³¨))ï¼‰
2. **å¿ƒå£°å†…å®¹**ï¼šè§’è‰²å½“å‰çš„å¿ƒç†æ´»åŠ¨ã€æƒ³æ³•ã€æ„Ÿå—æˆ–çŠ¶æ€å˜åŒ–ï¼ˆå¯ä»¥æ˜¯å†…å¿ƒç‹¬ç™½ã€æƒ…ç»ªå˜åŒ–ã€æƒ³æ³•ç­‰ï¼‰

è¯·ä»¥JSONæ ¼å¼è¿”å›ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š
{
  "reply": "ä½ çš„å›å¤å†…å®¹|||ç¬¬äºŒæ¡å†…å®¹",
  "thought": "è§’è‰²çš„å¿ƒå£°/å¿ƒç†æ´»åŠ¨/æƒ³æ³•"
}

è¯·ä¸¥æ ¼è¿”å›JSONæ ¼å¼ï¼Œä¸è¦åŒ…å«Markdownä»£ç å—æ ‡è®°ã€‚`;

                // æ·»åŠ æŸ¥å²—ç³»ç»Ÿæç¤ºï¼ˆå¦‚æœå¼€å¯äº†æŸ¥å²—åŠŸèƒ½ï¼‰
                const myChar = await db.characters.get(parseInt(accountId));
                if (myChar) {
                    const checkAccountPrompt = getCheckAccountSystemPrompt(char, myChar);
                    systemPrompt += checkAccountPrompt;
                }

                // æ˜¾ç¤º System Prompt çš„å…³é”®ä¿¡æ¯
                console.log('[triggerAiReply] ğŸ“ System Prompt æ„å»ºå®Œæˆ');
                console.log('[triggerAiReply] - è§’è‰²åç§°:', char.name);
                console.log('[triggerAiReply] - è§’è‰²è®¾å®šé•¿åº¦:', (char.description || '').length);
                console.log('[triggerAiReply] - ç”¨æˆ·äººè®¾:', userName, userDesc ? 'âœ…å·²åŒ…å«' : 'âŒæœªåŒ…å«');
                console.log('[triggerAiReply] - ä¸–ç•Œä¹¦:', loreContext ? `âœ…å·²åŒ…å«(${loreContext.length}å­—)` : 'âŒæœªåŒ…å«');
                console.log('[triggerAiReply] - System Prompt æ€»é•¿åº¦:', systemPrompt.length);

                // å–æœ€è¿‘ N æ¡å†å²è®°å½•ï¼ˆä½¿ç”¨è‡ªå®šä¹‰çš„ä¸Šä¸‹æ–‡æ¡æ•°ï¼Œé»˜è®¤20æ¡ï¼‰
                const contextCount = char.context_message_count || 20;
                console.log('[triggerAiReply] ğŸ“Š ä¸Šä¸‹æ–‡æ¶ˆæ¯æ•°é…ç½®:', contextCount);
                
                // âŒ BUG å‘ç°ï¼šè¿™é‡Œä½¿ç”¨çš„æ˜¯ char.chat_historyï¼Œè€Œä¸æ˜¯å‰é¢è·å–çš„ getChatHistory(char, accountId)
                // åº”è¯¥ä½¿ç”¨ fullHistory è€Œä¸æ˜¯ char.chat_history
                const recentHistory = fullHistory.slice(-contextCount)
                    .map(m => {
                        let content = m.content || '';
                        // å¦‚æœæœ‰å›¾ç‰‡æè¿°ï¼Œæ‹¼æ¥åœ¨åé¢ç»™ AI çœ‹
                        if (m.imageDescription) {
                            content += `\n(å›¾ç‰‡æè¿°: ${m.imageDescription})`;
                        }
                        return {
                            role: m.role === 'char' ? 'assistant' : 'user',
                            content: content
                        };
                    })
                    .filter(m => m.content && m.content.trim()); // è¿‡æ»¤ç©ºæ¶ˆæ¯
                    
                console.log('[triggerAiReply] ğŸ“ å¤„ç†åçš„å†å²æ¶ˆæ¯æ•°:', recentHistory.length);

                const messages = [
                    { role: 'system', content: systemPrompt },
                    ...recentHistory
                ];
                
                // æ·»åŠ è¯¦ç»†æ—¥å¿—æŸ¥çœ‹å‘é€ç»™ AI çš„å®Œæ•´æ¶ˆæ¯
                console.log('='.repeat(80));
                console.log('[triggerAiReply] ğŸ“¤ å‡†å¤‡å‘é€ç»™ AI - å®Œæ•´ä¿¡æ¯æ±‡æ€»');
                console.log('='.repeat(80));
                console.log('ã€ä¸Šä¸‹æ–‡ä¿¡æ¯ã€‘');
                console.log(`  âœ… èŠå¤©å†å²: ${recentHistory.length} æ¡æ¶ˆæ¯ï¼ˆé…ç½®: ${contextCount} æ¡ï¼‰`);
                console.log(`  ${userDesc ? 'âœ…' : 'âŒ'} ç”¨æˆ·äººè®¾: ${userName}${userDesc ? ` (${(userDesc).length}å­—)` : ' (æœªè®¾ç½®)'}`);
                console.log(`  ${loreContext ? 'âœ…' : 'âŒ'} ä¸–ç•Œä¹¦: ${loreContext ? `å·²åŠ è½½ (${loreContext.length}å­—)` : 'æœªè®¾ç½®æˆ–æœªåŒ¹é…'}`);
                console.log(`  âœ… è§’è‰²è®¾å®š: ${char.name} (${(char.description || '').length}å­—)`);
                console.log('');
                console.log('ã€å‘é€çš„æ¶ˆæ¯ç»“æ„ã€‘');
                console.log(`  - System Prompt: ${systemPrompt.length} å­—ç¬¦`);
                console.log(`  - å†å²æ¶ˆæ¯: ${recentHistory.length} æ¡`);
                console.log('');
                console.log('ã€æœ€è¿‘çš„å¯¹è¯å†…å®¹ã€‘');
                recentHistory.slice(-3).forEach((msg, index) => {
                    const displayContent = msg.content.substring(0, 100) + (msg.content.length > 100 ? '...' : '');
                    console.log(`  ${msg.role === 'user' ? 'ğŸ‘¤' : 'ğŸ¤–'} ${msg.role}: ${displayContent}`);
                });
                console.log('='.repeat(80));

                // 2. è°ƒç”¨ AIï¼ˆå·²ç»æ˜¯é˜²å¾¡å¼è§£æï¼Œç›´æ¥æ‹¿åˆ°å†…å®¹ï¼‰
                const aiResponse = await callAI(messages);
                
                // âœ… ä¿®å¤ï¼šæ¸…ç†æœ«å°¾å¤šä½™çš„ ]
                function cleanMessage(text) {
                    if (!text) return text;
                    // åˆ é™¤æœ«å°¾å¤šä½™çš„ ]
                    return text.replace(/\]+$/, '');
                }
                
                // 3. å°è¯•è§£æä¸ºç»“æ„åŒ–æ•°æ®ï¼ˆreply + thoughtï¼‰ï¼Œå¤±è´¥å°±ç›´æ¥ç”¨åŸå§‹å†…å®¹
                let replyText = "";
                let thought = "";
                
                // ä½¿ç”¨å¢å¼ºçš„æå–å‡½æ•°
                const parsed = extractAndParseJSON(aiResponse);
                
                if (parsed) {
                    // æ£€æµ‹æ˜¯å¦æ˜¯è½¬è´¦æ ¼å¼
                    if (parsed.amount && parsed.desc !== undefined && parsed.status && !parsed.reply) {
                        // è½¬è´¦æ¶ˆæ¯ï¼Œä¿æŒ JSON æ ¼å¼
                        replyText = JSON.stringify(parsed);
                        thought = "";
                    } else {
                        // æ ‡å‡†å›å¤æ ¼å¼
                        replyText = parsed.reply || parsed.content || parsed.message || "";
                        thought = parsed.thought || "";
                    }
                }
                
                // å¦‚æœè¿˜æ˜¯æ²¡æœ‰å†…å®¹ï¼Œç›´æ¥ä½¿ç”¨åŸå§‹å“åº”ï¼ˆé™çº§å¤„ç†ï¼‰
                if (!replyText) {
                    // æ¸…ç†å¸¸è§è£…é¥°å­—ç¬¦
                    let cleanResponse = aiResponse.trim().replace(/[â—‡â—†â˜…â˜†â—â—‹â– â–¡â–²â–³]/g, '');
                    
                    // å°è¯•ç®€å•çš„æ­£åˆ™æå–å…œåº•
                    const replyMatch = cleanResponse.match(/"reply"\s*:\s*"([\s\S]*?)"/);
                        if (replyMatch) {
                        replyText = replyMatch[1]
                            .replace(/\\n/g, '\n')
                            .replace(/\\"/g, '"')
                            .replace(/\\t/g, '\t')
                            .replace(/\\\\/g, '\\');
                    } else {
                        replyText = cleanResponse || aiResponse || "(AI è¿”å›ä¸ºç©º)";
                    }
                    thought = "";
                    }
                
                // âœ… ä¿®å¤ï¼šæ¸…ç†æœ«å°¾å¤šä½™çš„ ]
                replyText = cleanMessage(replyText);
                
                console.log('[TriggerAI] ğŸ” å‡†å¤‡æ£€æµ‹æŸ¥å²—æŒ‡ä»¤');
                console.log('[TriggerAI] å®Œæ•´replyText:', replyText);
                console.log('[TriggerAI] replyTexté•¿åº¦:', replyText.length);
                console.log('[TriggerAI] æ˜¯å¦åŒ…å«CHECK_ACCOUNT:', replyText.includes('CHECK_ACCOUNT'));
                
                // ğŸ¯ æ£€æµ‹å¹¶å¤„ç†AIæŸ¥å²—é€»è¾‘ï¼ˆåœ¨å…¶ä»–é€»è¾‘ä¹‹å‰ï¼‰
                const checkResult = await processAiCheckAccount(char, replyText);
                console.log('[TriggerAI] æŸ¥å²—æ£€æµ‹ç»“æœ:', checkResult);
                
                if (checkResult) {
                    // å¦‚æœAIå°è¯•æŸ¥å²—ï¼Œå…ˆå¤„ç†æŸ¥å²—é€»è¾‘
                    replyText = checkResult.cleanReply; // ä½¿ç”¨æ¸…ç†åçš„å›å¤
                    
                    console.log('[TriggerAI] æŸ¥å²—å¤„ç†å®Œæˆï¼ŒcleanReply:', replyText.substring(0, 100));
                    
                    // å¦‚æœæŸ¥å²—ç»“æœåŒ…å«å¯†ç é”™è¯¯æç¤ºï¼Œå‘é€ç³»ç»Ÿé€šçŸ¥
                    if (checkResult.checkResult && checkResult.checkResult.includes('ã€å¯†ç é”™è¯¯ã€‘')) {
                        console.log('[TriggerAI] ğŸš¨ å¯†ç é”™è¯¯ï¼æ˜¾ç¤ºå¼¹çª—æç¤º');
                        
                        // ğŸ”¥ æ˜¾ç¤ºINSé£æ ¼çš„è­¦å‘Šå¼¹çª—
                        showPasswordErrorModal();
                        
                        // âŒ ä¸å†ä½¿ç”¨Toastæˆ–ç³»ç»Ÿæ¶ˆæ¯
                    } else if (checkResult.success) {
                        // ğŸ”¥ å…³é”®ï¼šæŸ¥å²—æˆåŠŸï¼Œç«‹å³æ˜¾ç¤ºä¸‹çº¿å¼¹çª—
                        console.log('[AIæŸ¥å²—] æŸ¥å²—æˆåŠŸï¼æ˜¾ç¤ºä¸‹çº¿å¼¹çª—');
                        showAccountOfflineMask(`${char.name}æ­£åœ¨æŸ¥çœ‹ä½ çš„è´¦å·`);
                        showToast(`${char.name}ç™»å½•äº†ä½ çš„è´¦å·`);
                        
                        // ğŸ”¥ å…³é”®ï¼šè®©AIåŸºäºçœŸå®wechatæ•°æ®ç”Ÿæˆæ–°çš„å›å¤
                        if (checkResult.wechatData) {
                            console.log('[AIæŸ¥å²—] å¼€å§‹AIäºŒæ¬¡åˆ†æ...');
                            
                            // æ„å»ºåŒ…å«çœŸå®wechatæ•°æ®çš„system prompt
                            const analysisPrompt = `${checkResult.checkResult}

ç°åœ¨è¯·ä½ ä½œä¸º ${char.name}ï¼ŒåŸºäºä¸Šè¿°ã€çœŸå®çš„WeChatæ•°æ®ã€‘ï¼Œç”Ÿæˆä½ çš„å›å¤ã€‚

è¦æ±‚ï¼š
1. ç›´æ¥æåŠä½ çœ‹åˆ°çš„å…·ä½“ä¿¡æ¯ï¼ˆå¥½å‹åå­—ã€èŠå¤©å†…å®¹ã€ä½™é¢ç­‰ï¼‰
2. æ ¹æ®ä½ çš„è§’è‰²æ€§æ ¼ï¼Œè¡¨è¾¾ä½ çš„æƒ³æ³•å’Œæƒ…ç»ª
3. å¦‚æœå‘ç°å¯ç–‘æˆ–æœ‰è¶£çš„ç‚¹ï¼Œå¯ä»¥è¿½é—®
4. ä¿æŒ2-4æ¡çŸ­æ¶ˆæ¯çš„æ ¼å¼ï¼Œç”¨|||åˆ†éš”

è¯·ä»¥JSONæ ¼å¼è¿”å›ï¼š
{
  "reply": "ä½ çš„å›å¤å†…å®¹|||ç¬¬äºŒæ¡å†…å®¹",
  "thought": "ä½ çš„å¿ƒç†æ´»åŠ¨"
}`;

                            // è°ƒç”¨AIè¿›è¡ŒäºŒæ¬¡åˆ†æ
                            try {
                                const analysisMessages = [
                                    { role: 'system', content: analysisPrompt },
                                    { role: 'user', content: '(ä½ å·²ç»æˆåŠŸç™»å½•å¹¶æŸ¥çœ‹äº†WeChatæ•°æ®)' }
                                ];
                                
                                const analysisResponse = await callAI(analysisMessages);
                                const analysisParsed = extractAndParseJSON(analysisResponse);
                                
                                if (analysisParsed && analysisParsed.reply) {
                                    // ç”¨åŸºäºçœŸå®æ•°æ®çš„å›å¤æ›¿æ¢åŸå›å¤
                                    replyText = analysisParsed.reply;
                                    
                                    // æ›´æ–°å¿ƒå£°
                                    if (analysisParsed.thought) {
                                        thought = analysisParsed.thought;
                                    }
                                    
                                    console.log('[AIæŸ¥å²—] äºŒæ¬¡åˆ†æå®Œæˆï¼Œç”Ÿæˆäº†åŸºäºçœŸå®æ•°æ®çš„å›å¤');
                                    
                                    // ğŸ¯ æŸ¥å²—å®Œæˆï¼Œ4ç§’åè‡ªåŠ¨å…³é—­å¼¹çª—
                                    autoCloseOfflineMask(4);
                                } else {
                                    console.warn('[AIæŸ¥å²—] äºŒæ¬¡åˆ†æè¿”å›æ ¼å¼ä¸æ­£ç¡®ï¼Œä½¿ç”¨åŸå›å¤');
                                    // å³ä½¿å¤±è´¥ä¹Ÿè¦å…³é—­å¼¹çª—
                                    autoCloseOfflineMask(3);
                                }
                            } catch (error) {
                                console.error('[AIæŸ¥å²—] äºŒæ¬¡åˆ†æå¤±è´¥:', error);
                                // å¤±è´¥æ—¶ä¿æŒåŸå›å¤ï¼Œå¹¶å…³é—­å¼¹çª—
                                autoCloseOfflineMask(3);
                            }
                        } else {
                            // æ²¡æœ‰wechatæ•°æ®ï¼Œä¹Ÿè¦å…³é—­å¼¹çª—
                            autoCloseOfflineMask(3);
                        }
                    }
                }
                    
                    // å­˜å‚¨å¿ƒå£°åˆ°è§’è‰²å¯¹è±¡
                    if (thought && thought.trim()) {
                        const freshChar = await db.characters.get(targetCharId);
                        if (freshChar) {
                            if (!freshChar.thoughts) freshChar.thoughts = [];
                            freshChar.thoughts.push({
                                content: thought.trim(),
                                time: Date.now(),
                                messageIndex: freshChar.chat_history ? freshChar.chat_history.length : 0
                            });
                            // åªä¿ç•™æœ€è¿‘50æ¡å¿ƒå£°
                            if (freshChar.thoughts.length > 50) {
                                freshChar.thoughts = freshChar.thoughts.slice(-50);
                            }
                            await db.characters.put(freshChar);
                        }
                    }

                // 3. æ¢å¤æ ‡é¢˜
                if (chatTitleEl) chatTitleEl.innerText = originalTitle;
                
                // âœ… å…³é”®æ”¹åŠ¨ï¼šåœ¨æ‹†åˆ†å‰ï¼Œå…ˆæ£€æµ‹æ˜¯å¦åŒ…å«"æŒ‡ä»¤å‹æ¶ˆæ¯"ï¼ˆè½¬è´¦ç­‰ï¼‰
                // æ£€æµ‹ ((TRANSFER: é‡‘é¢, å¤‡æ³¨)) æ ¼å¼
                const transferMatch = replyText.match(/\(\(TRANSFER:\s*(\d+(\.\d+)?)(?:,\s*(.+?))?\)\)/i);
                
                if (transferMatch) {
                    // æå–è½¬è´¦ä¿¡æ¯
                    const amount = parseFloat(transferMatch[1]);
                    let note = transferMatch[3] || 'è½¬è´¦';
                    // é™åˆ¶å¤‡æ³¨é•¿åº¦ï¼Œä¸è¶…è¿‡10ä¸ªå­—
                    if (note.length > 10) {
                        note = note.substring(0, 10);
                    }
                    
                    // æå–è½¬è´¦å‰é¢çš„æ–‡å­—å†…å®¹ï¼ˆå¦‚æœæœ‰ï¼‰
                    const textBeforeTransfer = replyText.substring(0, transferMatch.index).trim();
                    
                    const freshChar = await db.characters.get(targetCharId);
                    if (freshChar) {
                        let history = getChatHistory(freshChar, accountId);
                        
                        // 1. å…ˆå‘é€æ–‡å­—æ¶ˆæ¯ï¼ˆå¦‚æœæœ‰ï¼‰- æ”¯æŒåˆ†å‰²æˆå¤šæ¡
                        if (textBeforeTransfer) {
                            // å¯¹è½¬è´¦å‰çš„æ–‡å­—è¿›è¡Œåˆ†å‰²å¤„ç†
                            let textSegments = [];
                            const textToSplit = textBeforeTransfer.replace(/[,ï¼Œ]/g, ' ');
                            if (textToSplit.includes('|||')) {
                                textSegments = textToSplit.split('|||').map(s => s.trim()).filter(s => s.length > 0);
                            } else {
                                textSegments = splitMessage(textToSplit);
                            }
                            
                            // è¿‡æ»¤å¤ªçŸ­çš„æ®µè½
                            textSegments = textSegments.filter(seg => seg.replace(/[.,ï¼Œã€‚!?ï¼ï¼Ÿ~â€¦\s]/g, '').length >= 2);
                            
                            // å¦‚æœåˆ†å‰²åä¸ºç©ºï¼Œä½†åŸæ–‡æœ¬æœ‰å†…å®¹ï¼Œä½¿ç”¨åŸæ–‡æœ¬
                            if (textSegments.length === 0 && textBeforeTransfer.replace(/[.,ï¼Œã€‚!?ï¼ï¼Ÿ~â€¦\s]/g, '').length > 0) {
                                textSegments = [textBeforeTransfer];
                            }
                            
                            // é€æ¡å‘é€æ–‡å­—æ¶ˆæ¯
                            for (let i = 0; i < textSegments.length; i++) {
                                const seg = textSegments[i];
                                const textMsg = {
                                    role: 'char',
                                    content: seg,
                                    time: Date.now() + i // ç¡®ä¿æ—¶é—´æˆ³é€’å¢
                                };
                                history.push(textMsg);
                                await setChatHistory(freshChar, accountId, history);
                                
                                // æ¸²æŸ“æ–‡å­—æ¶ˆæ¯
                                if (currentChatCharId === targetCharId) {
                                    await appendMessageToUI('char', seg, freshChar.avatar);
                                }
                                
                                // æ¯æ¡æ¶ˆæ¯ä¹‹é—´ç¨å¾®å»¶æ—¶
                                if (i < textSegments.length - 1) {
                                    await new Promise(r => setTimeout(r, 300));
                                }
                            }
                            
                            // æœ€åä¸€æ¡æ–‡å­—æ¶ˆæ¯åç¨å¾®å»¶æ—¶å†å‘è½¬è´¦
                            await new Promise(r => setTimeout(r, 500));
                        }
                        
                        // 2. å†å‘é€è½¬è´¦å¡ç‰‡
                        const transferData = {
                            amount: amount.toFixed(2),
                            desc: note,
                            status: 'sent'
                        };
                        
                        const transferMsg = { 
                            role: 'char', 
                            type: 'transfer', // æ˜ç¡®æ ‡è®°ä¸ºè½¬è´¦æ¶ˆæ¯
                            content: JSON.stringify(transferData), 
                            time: Date.now(),
                            id: 'trans_' + Date.now()
                        };
                        
                        // é‡æ–°è·å–æœ€æ–°çš„å†å²è®°å½•ï¼ˆå› ä¸ºåˆšæ‰å¯èƒ½æ’å…¥äº†æ–‡å­—æ¶ˆæ¯ï¼‰
                        history = getChatHistory(freshChar, accountId);
                        history.push(transferMsg);
                        await setChatHistory(freshChar, accountId, history);
                        
                        // æ¸²æŸ“è½¬è´¦å¡ç‰‡ - ä½¿ç”¨ appendMessageToUI è¿½åŠ ï¼Œé¿å…é‡æ–°æ¸²æŸ“æ•´ä¸ªèŠå¤©
                        if (currentChatCharId === targetCharId) {
                            await appendMessageToUI('char', JSON.stringify(transferData), freshChar.avatar);
                        } else {
                            sendSystemNotification(freshChar.name, '[è½¬è´¦]');
                        }
                    }
                    return; // è½¬è´¦å¤„ç†å®Œæˆï¼Œä¸å†æ‰§è¡Œåç»­é€»è¾‘
                }
                
                // ğŸ¯ æ£€æµ‹äº²å±å¡èµ é€æŒ‡ä»¤ ((FAMILY_CARD: é¢åº¦))
                const familyCardMatch2 = replyText.match(/\(\(FAMILY_CARD:\s*(\d+)\)\)/i);
                if (familyCardMatch2) {
                    const monthlyLimit = parseInt(familyCardMatch2[1]) || 0;
                    
                    // æå–äº²å±å¡æŒ‡ä»¤å‰é¢çš„æ–‡å­—å†…å®¹
                    const textBeforeFamilyCard = replyText.substring(0, familyCardMatch2.index).trim();
                    
                    const freshChar = await db.characters.get(targetCharId);
                    if (freshChar) {
                        let history = getChatHistory(freshChar, accountId);
                        
                        // 1. å…ˆå‘é€æ–‡å­—æ¶ˆæ¯ï¼ˆå¦‚æœæœ‰ï¼‰
                        if (textBeforeFamilyCard) {
                            let textSegments = [];
                            const textToSplit = textBeforeFamilyCard.replace(/[,ï¼Œ]/g, ' ');
                            if (textToSplit.includes('|||')) {
                                textSegments = textToSplit.split('|||').map(s => s.trim()).filter(s => s.length > 0);
                            } else {
                                textSegments = splitMessage(textToSplit);
                            }
                            textSegments = textSegments.filter(seg => seg.replace(/[.,ï¼Œã€‚!?ï¼ï¼Ÿ~â€¦\s]/g, '').length >= 2);
                            if (textSegments.length === 0 && textBeforeFamilyCard.replace(/[.,ï¼Œã€‚!?ï¼ï¼Ÿ~â€¦\s]/g, '').length > 0) {
                                textSegments = [textBeforeFamilyCard];
                            }
                            
                            for (let i = 0; i < textSegments.length; i++) {
                                const seg = textSegments[i];
                                history.push({ role: 'char', content: seg, time: Date.now() + i });
                                await setChatHistory(freshChar, accountId, history);
                                if (currentChatCharId === targetCharId) {
                                    await appendMessageToUI('char', seg, freshChar.avatar);
                                }
                                if (i < textSegments.length - 1) {
                                    await new Promise(r => setTimeout(r, 300));
                                }
                            }
                            await new Promise(r => setTimeout(r, 500));
                        }
                        
                        // 2. å‘é€äº²å±å¡æ¶ˆæ¯
                        const user = await db.characters.get(parseInt(currentMyCharId));
                        
                        // åœ¨è§’è‰²æ•°æ®ä¸­æ·»åŠ "æˆ‘èµ é€çš„"
                        if (!freshChar.identity) freshChar.identity = {};
                        if (!freshChar.identity.familyCardsGiven) freshChar.identity.familyCardsGiven = [];
                        freshChar.identity.familyCardsGiven.push({
                            charId: parseInt(currentMyCharId),
                            monthlyLimit: monthlyLimit,
                            usedThisMonth: 0,
                            records: [],
                            createdAt: Date.now()
                        });
                        await db.characters.put(freshChar);
                        
                        // åœ¨ç”¨æˆ·æ•°æ®ä¸­æ·»åŠ "æˆ‘æ”¶åˆ°çš„"
                        if (user) {
                            if (!user.identity) user.identity = {};
                            if (!user.identity.familyCardsReceived) user.identity.familyCardsReceived = [];
                            user.identity.familyCardsReceived.push({
                                charId: freshChar.id,
                                monthlyLimit: monthlyLimit,
                                usedThisMonth: 0,
                                records: [],
                                createdAt: Date.now()
                            });
                            await db.characters.put(user);
                        }
                        
                        // å‘é€äº²å±å¡æ¶ˆæ¯åˆ°èŠå¤©
                        const familyCardMsg = {
                            role: 'char',
                            type: 'familyCard',
                            content: JSON.stringify({
                                fromName: freshChar.name,
                                monthlyLimit: monthlyLimit,
                                status: 'sent'
                            }),
                            time: Date.now()
                        };
                        
                        history = getChatHistory(freshChar, accountId);
                        history.push(familyCardMsg);
                        await setChatHistory(freshChar, accountId, history);
                        
                        if (currentChatCharId === targetCharId) {
                            renderChatBody(freshChar);
                        }
                        
                        showToast(`${freshChar.name} èµ é€äº†äº²å±å¡`);
                    }
                    return;
                }
                
                // ğŸ¯ æ£€æµ‹æœ‹å‹åœˆå‘å¸ƒæŒ‡ä»¤ [MOMENTS] - æ”¯æŒå¤šç§æ ¼å¼
                // æ ¼å¼1: [MOMENTS] content: xxx images: N
                let momentsMatch = replyText.match(/\[MOMENTS\]\s*content:\s*([^\n]+)(?:\s*images?:\s*(\d+))?/i);
                // æ ¼å¼2: ((MOMENTS: å†…å®¹))
                if (!momentsMatch) {
                    momentsMatch = replyText.match(/\(\(MOMENTS:\s*(.+?)\)\)/i);
                    if (momentsMatch) {
                        momentsMatch = [momentsMatch[0], momentsMatch[1], '0'];
                    }
                }
                // æ ¼å¼3: ã€æœ‹å‹åœˆï¼šå†…å®¹ã€‘
                if (!momentsMatch) {
                    momentsMatch = replyText.match(/ã€æœ‹å‹åœˆ[ï¼š:]\s*(.+?)ã€‘/);
                    if (momentsMatch) {
                        momentsMatch = [momentsMatch[0], momentsMatch[1], '0'];
                    }
                }
                
                if (momentsMatch) {
                    const momentContent = momentsMatch[1].trim();
                    const imageCount = momentsMatch[2] ? parseInt(momentsMatch[2]) : 0;
                    
                    // æå–æœ‹å‹åœˆæŒ‡ä»¤å‰é¢çš„æ–‡å­—å†…å®¹ï¼ˆå¦‚æœæœ‰ï¼‰
                    const textBeforeMoments = replyText.substring(0, momentsMatch.index).trim();
                    
                    const freshChar = await db.characters.get(targetCharId);
                    if (freshChar) {
                        let history = getChatHistory(freshChar, accountId);
                        
                        // 1. å…ˆå‘é€æ–‡å­—æ¶ˆæ¯ï¼ˆå¦‚æœæœ‰ï¼‰
                        if (textBeforeMoments) {
                            const textMsg = {
                                role: 'char',
                                content: textBeforeMoments,
                                time: Date.now()
                            };
                            history.push(textMsg);
                            await setChatHistory(freshChar, accountId, history);
                            
                            // æ¸²æŸ“æ–‡å­—æ¶ˆæ¯
                            if (currentChatCharId === targetCharId) {
                                appendMessageToUI('char', textBeforeMoments, freshChar.avatar);
                            }
                            
                            // ç¨å¾®å»¶æ—¶
                            await new Promise(r => setTimeout(r, 500));
                        }
                        
                        // 2. å‘å¸ƒæœ‹å‹åœˆ
                        await publishMomentsByCharacter(freshChar, momentContent, imageCount);
                        
                        console.log(`[TriggerAI] ${freshChar.name} å‘å¸ƒäº†æœ‹å‹åœˆ`);
                        
                        // å‘é€é€šçŸ¥
                        sendSystemNotification(freshChar.name, '[æœ‹å‹åœˆ]');
                    }
                    return; // æœ‹å‹åœˆå¤„ç†å®Œæˆ
                }
                
                // ğŸ¯ æ£€æµ‹"å¹»è§‰"ï¼šAIè¯´å‘äº†æœ‹å‹åœˆä½†æ²¡æœ‰æŒ‡ä»¤
                const hasMomentsClaim = /å‘äº†.*?æœ‹å‹åœˆ|æœ‹å‹åœˆ.*?å‘äº†|å‘å¸ƒ.*?åŠ¨æ€|æ›´æ–°.*?æœ‹å‹åœˆ|å‘ä¸ªæœ‹å‹åœˆ/i.test(replyText);
                if (hasMomentsClaim) {
                    console.warn(`[TriggerAI] âš ï¸ AIå¹»è§‰æ£€æµ‹ï¼šè§’è‰²è¯´å‘äº†æœ‹å‹åœˆï¼Œä½†æ²¡æœ‰è¿”å›æ­£ç¡®çš„æŒ‡ä»¤æ ¼å¼ï¼`);
                    console.warn(`[TriggerAI] æ­£ç¡®æ ¼å¼ç¤ºä¾‹ï¼š[MOMENTS] content: å†…å®¹ images: 1`);
                    showToast(`è§’è‰²è¯´å‘äº†æœ‹å‹åœˆï¼Œä½†æ ¼å¼ä¸å¯¹ï¼Œæœªå®é™…å‘å¸ƒ`);
                }
                
                // å…œåº•ï¼šæ£€æµ‹æ˜¯å¦æ˜¯è½¬è´¦ JSONï¼ˆå…¼å®¹æ—§æ ¼å¼ï¼‰
                let trimmedReply = replyText.trim();
                if (trimmedReply.startsWith('{') && trimmedReply.includes('"amount"')) {
                    try {
                        const parsed = JSON.parse(trimmedReply);
                        if (parsed.amount && parsed.desc !== undefined && parsed.status) {
                            const freshChar = await db.characters.get(targetCharId);
                            if (freshChar) {
                                let history = getChatHistory(freshChar, accountId);
                                
                                const newMsg = { 
                                    role: 'char', 
                                    type: 'transfer',
                                    content: trimmedReply, 
                                    time: Date.now(),
                                    id: 'trans_' + Date.now()
                                };
                                
                                history.push(newMsg);
                                await setChatHistory(freshChar, accountId, history);
                                
                                if (currentChatCharId === targetCharId) {
                                    renderChatBody(freshChar);
                                } else {
                                    sendSystemNotification(freshChar.name, '[è½¬è´¦]');
                                }
                            }
                            return;
                        }
                    } catch(e) {
                        // ä¸æ˜¯æœ‰æ•ˆçš„ JSONï¼Œç»§ç»­å½“æ™®é€šæ¶ˆæ¯
                    }
                }
                
                // 4. æ™®é€šæ¶ˆæ¯ï¼šå¼ºåˆ¶æ¸…æ´—é€—å· + æ‹†åˆ†
                let cleanText = replyText.replace(/[,ï¼Œ]/g, ' ');
                let segments = [];
                
                // è°ƒè¯•æ—¥å¿—ï¼šæ£€æŸ¥åˆ†å‰²å‰çš„å†…å®¹
                console.log('[TriggerAI] ğŸ“ å‡†å¤‡åˆ†å‰²æ¶ˆæ¯');
                console.log('[TriggerAI] - åŸå§‹replyText:', replyText);
                console.log('[TriggerAI] - cleanText:', cleanText);
                console.log('[TriggerAI] - æ˜¯å¦åŒ…å«|||:', cleanText.includes('|||'));
                console.log('[TriggerAI] - ||| çš„ä½ç½®:', cleanText.indexOf('|||'));
                
                // ä¼˜å…ˆä½¿ç”¨ ||| æ‹†åˆ†
                if (cleanText.includes('|||')) {
                    segments = cleanText.split('|||')
                        .map(s => {
                            // å¯¹æ¯æ¡æ¶ˆæ¯å†æ¬¡æ¸…ç†æŸ¥å²—æŒ‡ä»¤æ®‹ç•™
                            return cleanMessage(s.trim())
                                .replace(/\[CHECK_ACCOUNT(?::.*?)?\]/gi, '')
                                .replace(/\[CHECK_ACCOUNT:[^\]]*$/gi, '')
                                .replace(/\[CHECK_ACCOUNT$/gi, '')
                                .replace(/\[\d{4,10}$/gi, '')
                                .replace(/CHECK_ACCOUNT/gi, '')
                                .trim();
                        })
                        .filter(s => s);
                    console.log('[TriggerAI] âœ… ä½¿ç”¨|||åˆ†å‰²ï¼Œå¾—åˆ°', segments.length, 'æ¡æ¶ˆæ¯');
                    segments.forEach((seg, i) => console.log(`  [${i}]:`, seg));
                } else {
                    // å›é€€åˆ°æ ‡ç‚¹æ‹†åˆ†é€»è¾‘ (ä½†é€—å·å·²ç»è¢«å¹²æ‰äº†)
                    segments = splitMessage(cleanText);
                    console.log('[TriggerAI] â„¹ï¸ æœªæ‰¾åˆ°|||ï¼Œä½¿ç”¨æ ‡ç‚¹åˆ†å‰²ï¼Œå¾—åˆ°', segments.length, 'æ¡æ¶ˆæ¯');
                }
                
                // å…œåº•ï¼šå¦‚æœæ²¡æ‹†å‡ºæ¥ï¼Œä½†æœ‰å†…å®¹ï¼Œå°±å½“æˆä¸€æ¡
                if (segments.length === 0 && cleanText.trim()) {
                    segments.push(cleanMessage(cleanText.trim()));
                }

                for (let i = 0; i < segments.length; i++) {
                    let seg = segments[i];
                    
                    // ğŸ¯ æ£€æµ‹æ’¤å›æŒ‡ä»¤ - åœ¨åˆ†æ®µä¸­æ£€æµ‹
                    if (/^\s*\(\(RECALL\)\)\s*$/i.test(seg)) {
                        console.log(`[AiReply] æ£€æµ‹åˆ°æ’¤å›æŒ‡ä»¤ï¼Œæ‰§è¡Œæ’¤å›...`);
                        const freshChar = await db.characters.get(targetCharId);
                        if (freshChar) {
                            let history = getChatHistory(freshChar, accountId);
                            
                            // æ‰¾AIæœ€åä¸€æ¡æ¶ˆæ¯ï¼ˆéæ’¤å›çŠ¶æ€ï¼‰
                            let targetIndex = -1;
                            for (let j = history.length - 1; j >= 0; j--) {
                                if (history[j].role === 'char' && !history[j].isRecalled) {
                                    targetIndex = j;
                                    break;
                                }
                            }
                            
                            if (targetIndex >= 0) {
                                const originalContent = history[targetIndex].content;
                                history[targetIndex].recalledContent = originalContent;
                                history[targetIndex].isRecalled = true;
                                history[targetIndex].content = "";
                                await setChatHistory(freshChar, accountId, history);
                                
                                console.log(`[AiReply] ${freshChar.name} æ’¤å›äº†æ¶ˆæ¯`);
                                
                                // æ›´æ–°UI - å±…ä¸­ç³»ç»Ÿæç¤ºæ ·å¼
                                if (currentChatCharId === targetCharId) {
                                    const chatBody = document.getElementById('chat-body');
                                    const messageRows = chatBody.querySelectorAll('.message-row');
                                    if (messageRows[targetIndex]) {
                                        const msgRow = messageRows[targetIndex];
                                        msgRow.className = 'message-row recalled-system-row';
                                        msgRow.innerHTML = '';
                                        
                                        const capturedContent = originalContent;
                                        const capturedName = freshChar.name;
                                        const systemTip = document.createElement('div');
                                        systemTip.className = 'recalled-system-tip';
                                        systemTip.innerHTML = `"${capturedName}"æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯`;
                                        systemTip.style.cursor = 'pointer';
                                        systemTip.onclick = (e) => {
                                            e.stopPropagation();
                                            showRecalledContent(capturedName, capturedContent);
                                        };
                                        msgRow.appendChild(systemTip);
                                    }
                                }
                                
                                sendSystemNotification(freshChar.name, 'æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯');
                            }
                        }
                        continue; // è·³è¿‡è¿™ä¸ªåˆ†æ®µï¼Œä¸ä½œä¸ºæ¶ˆæ¯å‘é€
                    }
                    
                    // å»¶æ—¶ï¼šç¬¬ä¸€æ¡ç›´æ¥å‘(å‰é¢loadingå·²ç»æ˜¯ç­‰å¾…äº†)ï¼Œåç»­æ¨¡æ‹Ÿæ‰“å­—
                    if (i > 0) {
                        // åŸºç¡€ 500ms + æ¯å­— 80ms
                        const delay = 500 + Math.min(seg.length * 80, 3000);
                        await new Promise(r => setTimeout(r, delay));
                    }

                    // å§‹ç»ˆå­˜å…¥ DB
                    const freshChar = await db.characters.get(targetCharId);
                    if (freshChar) {
                        let history = getChatHistory(freshChar, accountId);
                        
                        const newMsg = { 
                            role: 'char', 
                            content: seg, 
                            time: Date.now()
                        };
                        
                        history.push(newMsg);
                        await setChatHistory(freshChar, accountId, history);
                        
                        // åªæœ‰åœ¨å½“å‰çª—å£åŒ¹é…æ—¶æ‰æ¸²æŸ“ UI
                        if (currentChatCharId === targetCharId) {
                            console.log(`[AiReply] User is viewing ${freshChar.name}'s chat, appending to UI`);
                            showDebugToast(`AIå›å¤: æ­£åœ¨æŸ¥çœ‹${freshChar.name}ï¼Œæ˜¾ç¤ºåœ¨UI`);
                            appendMessageToUI('char', seg, freshChar.avatar);
                        } else {
                            // ä¸åœ¨å½“å‰çª—å£æ—¶ï¼Œå‘é€ç³»ç»Ÿé€šçŸ¥
                            console.log(`[AiReply] User is NOT viewing ${freshChar.name}'s chat (current: ${currentChatCharId}), sending notification`);
                            showDebugToast(`AIå›å¤: ä¸åœ¨${freshChar.name}èŠå¤©ä¸­(å½“å‰:${currentChatCharId})ï¼Œå‘é€é€šçŸ¥`);
                            sendSystemNotification(freshChar.name, seg);
                        }
                    }
                }
                
                // âœ… AIå›å¤å®Œæˆåï¼Œæ£€æŸ¥æ˜¯å¦éœ€è¦è‡ªåŠ¨æ€»ç»“
                try {
                    await checkAutoSummary('private', targetCharId, accountId);
                } catch (summaryError) {
                    console.error('[AutoSummary] æ£€æŸ¥è‡ªåŠ¨æ€»ç»“å¤±è´¥:', summaryError);
                }
                
            } catch (err) {
                console.error("AI å›å¤å¤±è´¥", err);
                if (chatTitleEl) chatTitleEl.innerText = originalTitle;
                
                // ä½¿ç”¨å¼¹çª—æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯ï¼Œè€Œä¸æ˜¯åœ¨èŠå¤©ç•Œé¢æ·»åŠ æ¶ˆæ¯
                showApiErrorToast(err.message || 'API è¯·æ±‚å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ– API é…ç½®');
            }
        }

        // é‡æ–°ç”Ÿæˆå›å¤ï¼ˆåˆ é™¤ä¸Šä¸€æ¬¡AIå›å¤çš„æ‰€æœ‰æ¶ˆæ¯å¹¶é‡æ–°ç”Ÿæˆï¼Œä¸åˆ é™¤ç”¨æˆ·æ¶ˆæ¯ï¼‰
        async function regenerateLastReply() {
            // ç¾¤èŠé‡å›
            if (window.currentGroupChatId) {
                await regenerateGroupReply();
                return;
            }
            
            if (!currentChatCharId) return;
            
            const char = await db.characters.get(currentChatCharId);
            const accountId = getCurrentAccountId();
            const history = getChatHistory(char, accountId);
            
            if (!char || !history || history.length === 0) {
                // æ²¡æœ‰èŠå¤©è®°å½•ï¼Œæ— æ³•é‡æ–°ç”Ÿæˆ
                return;
            }
            
            // æ‰¾åˆ°ä¸Šä¸€æ¬¡AIå›å¤çš„æ‰€æœ‰æ¶ˆæ¯ï¼ˆä»æœ€åå¾€å‰æ‰¾ï¼Œç›´åˆ°é‡åˆ°ç”¨æˆ·æ¶ˆæ¯ï¼‰
            let lastAiMessageStartIndex = -1;
            let lastAiMessageEndIndex = -1;
            
            // ä»åå¾€å‰æ‰¾æœ€åä¸€æ¡AIæ¶ˆæ¯
            for (let i = history.length - 1; i >= 0; i--) {
                if (history[i].role === 'char') {
                    lastAiMessageEndIndex = i;
                    break;
                }
            }
            
            // å¦‚æœæ²¡æœ‰AIå›å¤ï¼Œç›´æ¥ç”Ÿæˆæ–°çš„
            if (lastAiMessageEndIndex === -1) {
                closeChatPanel();
                await triggerAiReply();
                return;
            }
            
            // ä»æœ€åä¸€æ¡AIæ¶ˆæ¯å¾€å‰æ‰¾ï¼Œæ‰¾åˆ°è¿ç»­çš„æ‰€æœ‰AIæ¶ˆæ¯
            lastAiMessageStartIndex = lastAiMessageEndIndex;
            for (let i = lastAiMessageEndIndex - 1; i >= 0; i--) {
                if (history[i].role === 'user') {
                    // é‡åˆ°ç”¨æˆ·æ¶ˆæ¯ï¼Œåœæ­¢
                    break;
                }
                // è¿˜æ˜¯AIçš„æ¶ˆæ¯ï¼Œç»§ç»­å¾€å‰
                lastAiMessageStartIndex = i;
            }
            
            // åˆ é™¤æ‰€æœ‰è¿ç»­çš„AIæ¶ˆæ¯ï¼ˆä¸åˆ é™¤ç”¨æˆ·æ¶ˆæ¯ï¼‰
            const deleteCount = lastAiMessageEndIndex - lastAiMessageStartIndex + 1;
            history.splice(lastAiMessageStartIndex, deleteCount);
            await setChatHistory(char, accountId, history);
            await db.characters.put(char);
            
            // é‡æ–°æ¸²æŸ“èŠå¤©ç•Œé¢ï¼ˆç§»é™¤AIå›å¤æ¶ˆæ¯ï¼‰
            renderChatBody(char);
            
            // å…³é—­é¢æ¿
            closeChatPanel();
            
            // é‡æ–°ç”Ÿæˆå›å¤ï¼ˆåŸºäºåˆ é™¤åçš„å†å²è®°å½•ï¼Œç”¨æˆ·æ¶ˆæ¯è¿˜åœ¨ï¼‰
            await triggerAiReply();
        }
        
        // ç¾¤èŠé‡æ–°ç”Ÿæˆå›å¤
        async function regenerateGroupReply() {
            if (!window.currentGroupChatId) return;
            
            let group = await db.group_chats.get(window.currentGroupChatId);
            if (!group || !group.chat_history || group.chat_history.length === 0) {
                showToast('æ²¡æœ‰èŠå¤©è®°å½•');
                return;
            }
            
            const history = group.chat_history;
            
            // æ‰¾åˆ°ä¸Šä¸€æ¬¡AIå›å¤çš„æ‰€æœ‰æ¶ˆæ¯ï¼ˆä»æœ€åå¾€å‰æ‰¾ï¼Œç›´åˆ°é‡åˆ°ç”¨æˆ·æ¶ˆæ¯æˆ–ç³»ç»Ÿæ¶ˆæ¯ï¼‰
            let lastAiMessageStartIndex = -1;
            let lastAiMessageEndIndex = -1;
            
            // ä»åå¾€å‰æ‰¾æœ€åä¸€æ¡AIè§’è‰²æ¶ˆæ¯
            for (let i = history.length - 1; i >= 0; i--) {
                if (history[i].role === 'char') {
                    lastAiMessageEndIndex = i;
                    break;
                }
            }
            
            // å¦‚æœæ²¡æœ‰AIå›å¤ï¼Œç›´æ¥ç”Ÿæˆæ–°çš„
            if (lastAiMessageEndIndex === -1) {
                closeChatPanel();
                await triggerAiReply();
                return;
            }
            
            // ä»æœ€åä¸€æ¡AIæ¶ˆæ¯å¾€å‰æ‰¾ï¼Œæ‰¾åˆ°è¿ç»­çš„æ‰€æœ‰AIæ¶ˆæ¯ï¼ˆä¸åŒ…æ‹¬ç³»ç»Ÿæ¶ˆæ¯ï¼‰
            lastAiMessageStartIndex = lastAiMessageEndIndex;
            for (let i = lastAiMessageEndIndex - 1; i >= 0; i--) {
                if (history[i].role === 'user') {
                    // é‡åˆ°ç”¨æˆ·æ¶ˆæ¯ï¼Œåœæ­¢
                    break;
                }
                if (history[i].role === 'system') {
                    // ç³»ç»Ÿæ¶ˆæ¯ä¹Ÿç®—ä½œåˆ†éš”ï¼Œä½†å¦‚æœæ˜¯é¢†å–çº¢åŒ…ç­‰ç³»ç»Ÿæ¶ˆæ¯ï¼Œä¹Ÿåˆ é™¤
                    const content = history[i].content || '';
                    if (content.includes('é¢†å–äº†çº¢åŒ…') || content.includes('å°†è‡ªå·±çš„ç¾¤æ˜µç§°æ”¹ä¸º')) {
                        lastAiMessageStartIndex = i;
                        continue;
                    }
                    break;
                }
                // è¿˜æ˜¯AIçš„æ¶ˆæ¯ï¼Œç»§ç»­å¾€å‰
                lastAiMessageStartIndex = i;
            }
            
            // åˆ é™¤æ‰€æœ‰è¿ç»­çš„AIæ¶ˆæ¯å’Œç›¸å…³ç³»ç»Ÿæ¶ˆæ¯
            const deleteCount = lastAiMessageEndIndex - lastAiMessageStartIndex + 1;
            history.splice(lastAiMessageStartIndex, deleteCount);
            
            group.chat_history = history;
            group.updated_at = Date.now();
            await db.group_chats.put(group);
            
            // é‡æ–°æ¸²æŸ“ç¾¤èŠç•Œé¢
            await renderGroupChatBody(group);
            
            // å…³é—­é¢æ¿
            closeChatPanel();
            
            // é‡æ–°ç”Ÿæˆç¾¤èŠå›å¤
            await triggerAiReply();
        }

// --- è§’è‰²æ¡£æ¡ˆ (Character) é€»è¾‘ ---
function showCharacterPage() {
    document.getElementById('character-page').style.display = 'flex';
    loadCharacterList();
}

        function hideCharacterPage() {
            const page = document.getElementById('character-page');
            page.style.transform = 'scale(0.95)';
            page.style.opacity = '0';
            setTimeout(() => {
                page.style.display = 'none';
                page.style.transform = ''; 
                page.style.opacity = '';
            }, 200);
        }

        function switchCharacterTab(type) {
            currentCharacterType = type;
            
            // æ›´æ–°åº•éƒ¨æ ·å¼
            ['char', 'npc', 'user'].forEach(t => {
                const el = document.getElementById(`tab-${t}`);
                if (t === type) {
                    el.style.color = 'var(--ins-pink)';
                } else {
                    el.style.color = '#999';
                }
            });
            
            loadCharacterList();
        }

        async function loadCharacterList() {
            const container = document.getElementById('character-list');
            container.innerHTML = '';
            
            // ä»æ•°æ®åº“è·å–æŒ‡å®šç±»å‹çš„è§’è‰²
            const list = await db.characters.where('type').equals(currentCharacterType).toArray();
            
            if (list.length === 0) {
                container.innerHTML = `
                    <div style="grid-column: span 2; text-align:center; color:#999; margin-top:60px; display:flex; flex-direction:column; align-items:center; gap:10px;">
                        <svg class="svg-icon" style="width:40px; height:40px; stroke:#ccc;" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><line x1="8" y1="15" x2="16" y2="15"></line><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line></svg>
                        <div>è¿™é‡Œè¿˜æ²¡äººå“¦</div>
                    </div>
                `;
                return;
            }

            list.forEach(char => {
                const div = document.createElement('div');
                div.className = 'char-card';
                div.onclick = () => editCharacter(char.id);
                
                // é»˜è®¤å¤´åƒ
                let bgStyle = 'background-color: #eee;';
                if (char.avatar) {
                    bgStyle = `background-image: url(${char.avatar});`;
                }
                
                div.innerHTML = `
                    <div class="char-card-img" style="${bgStyle}"></div>
                    <div class="char-card-info">
                        <div class="char-name">${char.name || 'æœªå‘½å'}</div>
                        <div class="char-nick">${char.nick || ''}</div>
                    </div>
                `;
                container.appendChild(div);
            });
        }

        function createNewCharacter() {
            editingCharId = null;
            document.getElementById('char-editor-title').innerText = "æ–°å»ºè§’è‰²";
            document.getElementById('char-name').value = '';
            document.getElementById('char-nick').value = '';
            document.getElementById('char-desc').value = '';
            document.getElementById('char-type').value = currentCharacterType; // é»˜è®¤é€‰ä¸­å½“å‰ Tab ç±»å‹
            document.getElementById('char-avatar-preview').style.backgroundImage = '';
            document.getElementById('char-avatar-placeholder').style.display = 'flex';
            
            // ğŸ¯ è‡ªåŠ¨ç”Ÿæˆæ‰‹æœºå·ï¼ˆå‰7ä½å›ºå®š 1380000ï¼Œå4ä½éšæœºï¼‰
            const autoGeneratedPhone = generateRandomPhone();
            console.log('[åˆ›å»ºè§’è‰²] è‡ªåŠ¨ç”Ÿæˆæ‰‹æœºå·:', autoGeneratedPhone);
            
            // æ¸…ç©ºè™šæ‹Ÿèº«ä»½ä¿¡æ¯
            document.getElementById('char-identity-account').value = '';
            document.getElementById('char-identity-password').value = '';
            document.getElementById('char-identity-phone').value = autoGeneratedPhone; // è‡ªåŠ¨å¡«å……æ‰‹æœºå·
            document.getElementById('char-identity-address').value = '';
            document.getElementById('char-identity-id').value = '';
            document.getElementById('char-identity-bank').value = '';
            document.getElementById('char-identity-bank-pass').value = '';

            document.getElementById('character-editor-page').style.display = 'flex';
            
            // ğŸ‰ æ˜¾ç¤ºæ‰‹æœºå·åˆ†é…å¼¹çª—
            setTimeout(() => {
                showPhoneAssignedModal(autoGeneratedPhone);
            }, 300); // ç¨å¾®å»¶è¿Ÿï¼Œç­‰å¾…ç¼–è¾‘å™¨é¡µé¢æ‰“å¼€
        }

        async function editCharacter(id) {
            editingCharId = id;
            const char = await db.characters.get(id);
            if (!char) return;
            
            document.getElementById('char-editor-title').innerText = "ç¼–è¾‘è§’è‰²";
            document.getElementById('char-name').value = char.name || '';
            document.getElementById('char-nick').value = char.nick || '';
            document.getElementById('char-desc').value = char.description || '';
            document.getElementById('char-type').value = char.type || 'char';
            
            // å›æ˜¾è™šæ‹Ÿèº«ä»½ä¿¡æ¯
            const idData = char.identity || {};
            document.getElementById('char-identity-account').value = idData.account || '';
            document.getElementById('char-identity-password').value = idData.password || '';
            document.getElementById('char-identity-phone').value = idData.phone || '';
            document.getElementById('char-identity-address').value = idData.address || '';
            document.getElementById('char-identity-id').value = idData.id_card || '';
            document.getElementById('char-identity-bank').value = idData.bank_card || '';
            document.getElementById('char-identity-bank-pass').value = idData.bank_password || '';

            if (char.avatar) {
                document.getElementById('char-avatar-preview').style.backgroundImage = `url(${char.avatar})`;
                document.getElementById('char-avatar-placeholder').style.display = 'none';
            } else {
                document.getElementById('char-avatar-preview').style.backgroundImage = '';
                document.getElementById('char-avatar-placeholder').style.display = 'flex';
            }
            
            // æ¸²æŸ“å…³ç³»åˆ—è¡¨
            renderRelationList(char);

            document.getElementById('character-editor-page').style.display = 'flex';
        }

        // æ¸²æŸ“ç¼–è¾‘é¡µçš„å…³ç³»åˆ—è¡¨
        async function renderRelationList(char) {
            const container = document.getElementById('char-relation-list');
            container.innerHTML = '';
            
            if (!char.relationships || char.relationships.length === 0) {
                container.innerHTML = '<div style="text-align:center; color:#ccc; font-size:12px; padding:10px;">æš‚æ— å…³ç³»è®°å½•</div>';
                return;
            }

            // relationships: [{ targetId, targetName, relation, desc }]
            for (const rel of char.relationships) {
                // å°è¯•è·å–æœ€æ–°çš„å¤´åƒ
                let avatarUrl = '';
                if (rel.targetId) {
                    const target = await db.characters.get(rel.targetId);
                    if (target && target.avatar) avatarUrl = target.avatar;
                }
                
                const item = document.createElement('div');
                item.className = 'relation-item';
                item.innerHTML = `
                    <div class="relation-avatar" style="${avatarUrl ? `background-image:url(${avatarUrl})` : ''}"></div>
                    <div class="relation-info">
                        <div class="relation-name">${rel.targetName} <span class="relation-tag">${rel.relation}</span></div>
                        <div class="relation-desc">${rel.desc}</div>
                    </div>
                `;
                container.appendChild(item);
            }
        }

        // æ˜¾ç¤ºç”Ÿæˆ NPC å¼¹çª—
        function showNpcGenModal() {
            if (!editingCharId) {
                alert("è¯·å…ˆä¿å­˜å½“å‰è§’è‰²åå†ç”Ÿæˆå…³è” NPC");
                return;
            }
            document.getElementById('npc-gen-modal').style.display = 'flex';
        }

        // æ‰§è¡Œç”Ÿæˆé€»è¾‘
        async function doGenerateNpcs() {
            const count = document.getElementById('gen-count-range').value;
            const req = document.getElementById('gen-prompt-req').value.trim();
            const btn = document.getElementById('btn-do-gen');
            
            // è·å–æºè§’è‰²ä¿¡æ¯
            const sourceChar = await db.characters.get(editingCharId);
            if (!sourceChar) return;

            btn.innerText = "ç”Ÿæˆä¸­...";
            btn.disabled = true;

            try {
                // 1. æ„å»º Prompt
                let loreContext = "";
                let entriesCount = 0;
                const sourceLorebookIds = sourceChar.lorebookIds || (sourceChar.lorebookId ? [sourceChar.lorebookId] : []);
                if (sourceLorebookIds.length > 0) {
                    // åˆå¹¶å¤šä¸ªä¸–ç•Œä¹¦çš„æ‰€æœ‰è¯æ¡
                    let allEntries = [];
                    for (const bookId of sourceLorebookIds) {
                        const book = await db.lorebooks.get(bookId);
                        if (book && book.content && book.content.entries) {
                            const bookEntries = Object.values(book.content.entries)
                                .filter(e => e.enabled)
                                .map(e => `[è¯æ¡: ${e.key}]\n${e.content}`);
                            allEntries = allEntries.concat(bookEntries);
                        }
                    }
                    
                    entriesCount = allEntries.length;
                    if (entriesCount > 0) {
                        // ä¸ºäº†é˜²æ­¢Tokenæº¢å‡ºï¼ŒæŒ‰é•¿åº¦æˆªæ–­ï¼ˆå‡è®¾çº¦ 12000 å­—ç¬¦ä¸ºå®‰å…¨åŒºï¼Œç•™ç»™ Response å’Œ Promptï¼‰
                        const entriesText = allEntries.join('\n\n');
                        loreContext = `ã€ä¸–ç•Œè§‚èƒŒæ™¯ (Lorebook - å…±${entriesCount}æ¡è®¾å®š)ã€‘\n${entriesText.slice(0, 12000)}\n`;
                        if (entriesText.length > 12000) loreContext += `\n...(éƒ¨åˆ†è®¾å®šå› è¿‡é•¿å·²çœç•¥)`;
                    }
                }

                const prompt = `ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„TRPG/å°è¯´è§’è‰²è®¾è®¡åŠ©æ‰‹ã€‚è¯·æ ¹æ®ä»¥ä¸‹ã€ä¸»è§’ä¿¡æ¯ã€‘å’Œã€ä¸–ç•Œè§‚èƒŒæ™¯ã€‘ï¼Œæ·±åº¦åˆ›ä½œ ${count} ä¸ªç›¸å…³çš„ NPC è§’è‰²ã€‚
${req ? `>>> ç‰¹åˆ«å‰§æƒ…è¦æ±‚ï¼š${req} <<<` : ''}

ã€ä¸»è§’ä¿¡æ¯ã€‘
åå­—ï¼š${sourceChar.name}
è®¾å®šï¼š${sourceChar.description}

${loreContext}

ã€ç”Ÿæˆè¦æ±‚ã€‘
1. **æ·±åº¦å…³è”**ï¼šNPC å¿…é¡»ä¸ä¸–ç•Œè§‚ï¼ˆLorebookï¼‰ç´§å¯†ç»“åˆã€‚è¯·å¼•ç”¨ä¸–ç•Œä¹¦ä¸­çš„åœ°åã€ç»„ç»‡ã€ç§æ—æˆ–å†å²äº‹ä»¶ã€‚
2. **ç»†èŠ‚ä¸°å¯Œ**ï¼šè¯·è¯¦ç»†æå†™å¤–è²Œï¼ˆè¡£ç€ã€ç‰¹å¾ï¼‰ã€æ€§æ ¼ï¼ˆå£ç™–ã€å¿ƒç†ï¼‰å’ŒèƒŒæ™¯æ•…äº‹ã€‚æ‹’ç»ç©ºæ´çš„æè¿°ã€‚
3. **å¤šæ ·æ€§**ï¼šç”Ÿæˆçš„è§’è‰²æ€§æ ¼å’Œèº«ä»½åº”å„ä¸ç›¸åŒï¼Œé™¤éã€ç‰¹åˆ«å‰§æƒ…è¦æ±‚ã€‘å¦æœ‰æŒ‡å®šã€‚

è¯·è¿”å›ä¸€ä¸ª JSON æ•°ç»„ï¼Œæ¯ä¸ªå¯¹è±¡åŒ…å«ï¼š
- name: åå­—
- nickname: æ˜µç§° (å¯é€‰)
- gender: æ€§åˆ« (ç”·/å¥³/æœªçŸ¥)
- appearance: å¤–è²Œæå†™ (è¯¦ç»†ï¼Œå¦‚å‘è‰²ã€ç³è‰²ã€æœè£…é£æ ¼)
- personality: æ€§æ ¼ç‰¹å¾ (è¯¦ç»†ï¼Œå¦‚é«˜å†·ã€çƒ­è¡€ã€è…¹é»‘)
- background: èƒŒæ™¯æ•…äº‹ (ç»“åˆä¸–ç•Œè§‚çš„ä¸ªäººç»å†)
- identity_job: èŒä¸šæˆ–èº«ä»½
- relation: ä¸ä¸»è§’çš„å…³ç³»ç±»å‹
- relation_desc: å…³ç³»è¯¦æƒ…æè¿° (å…·ä½“çš„äº’åŠ¨æ¨¡å¼)

è¯·ä¸¥æ ¼è¿”å› JSON æ ¼å¼ï¼Œä¸è¦åŒ…å« Markdown ä»£ç å—æ ‡è®°ã€‚`;

                // 2. è°ƒç”¨ AI
                const resultStr = await callAI([
                    { role: "system", content: "ä½ æ˜¯ä¸€ä¸ªåªè¾“å‡º JSON æ•°ç»„çš„è¾…åŠ©ç³»ç»Ÿã€‚" },
                    { role: "user", content: prompt }
                ]);

                // 3. è§£æ JSON
                const npcs = extractAndParseJSON(resultStr);
                if (!Array.isArray(npcs)) throw new Error("AI è¿”å›æ ¼å¼é”™è¯¯ (ä¸æ˜¯æ•°ç»„) æˆ–è§£æå¤±è´¥");

                // 4. æ‰¹é‡å†™å…¥ DB å¹¶å»ºç«‹å…³ç³»
                let newCount = 0;
                for (const npcData of npcs) {
                    // æ•´åˆè¯¦ç»†æè¿°
                    const fullDesc = `ã€å¤–è²Œã€‘\n${npcData.appearance || 'æ— '}\n\nã€æ€§æ ¼ã€‘\n${npcData.personality || 'æ— '}\n\nã€èƒŒæ™¯ã€‘\n${npcData.background || npcData.description || 'æ— '}`;
                    
                    // æ„é€  NPC æ•°æ®
                    const newNpc = {
                        name: npcData.name,
                        nick: npcData.nickname || '',
                        description: fullDesc, // å­˜å…¥æ•´åˆåçš„è¯¦ç»†æè¿°
                        type: 'npc', // é»˜è®¤ä¸º NPC ç±»å‹
                        avatar: '', // æš‚æ—¶ç•™ç©º
                        lorebookIds: sourceLorebookIds.length > 0 ? sourceLorebookIds : null, // ç»§æ‰¿å¤šä¸ªä¸–ç•Œä¹¦
                        lorebookId: sourceLorebookIds.length > 0 ? sourceLorebookIds[0] : null, // å…¼å®¹å­—æ®µ
                        identity: {
                            // åŸºç¡€èº«ä»½å ä½
                            job: npcData.identity_job
                        },
                        relationships: [
                            // å†™å…¥æŒ‡å‘ä¸»è§’çš„å…³ç³»
                            {
                                targetId: sourceChar.id,
                                targetName: sourceChar.name,
                                relation: "å…³è”ä¸»è§’", // ç›¸å¯¹å…³ç³»ï¼Œæˆ–è€…è®©AIç”Ÿæˆåå‘å…³ç³»æ¯”è¾ƒå¤æ‚ï¼Œè¿™é‡Œç®€åŒ–
                                desc: "ç”Ÿæˆæ¥æº"
                            }
                        ],
                        updated_at: Date.now()
                    };
                    
                    const newId = await db.characters.add(newNpc);
                    newCount++;

                    // 5. æ›´æ–°ä¸»è§’çš„å…³ç³»åˆ—è¡¨
                    if (!sourceChar.relationships) sourceChar.relationships = [];
                    sourceChar.relationships.push({
                        targetId: newId,
                        targetName: newNpc.name,
                        relation: npcData.relation,
                        desc: npcData.relation_desc
                    });
                }
                
                // ä¿å­˜ä¸»è§’æ›´æ–°
                await db.characters.put(sourceChar);

                // 6. åˆ·æ–°ç•Œé¢
                alert(`âœ… æˆåŠŸç”Ÿæˆ ${newCount} ä¸ª NPCï¼`);
                closeModal('npc-gen-modal');
                // åˆ·æ–°ç¼–è¾‘é¡µçš„å…³ç³»åˆ—è¡¨
                renderRelationList(sourceChar);
                // åˆ·æ–°å¤–éƒ¨åˆ—è¡¨ (å¦‚æœåœ¨åˆ—è¡¨é¡µçš„è¯ï¼Œè™½ç„¶ç°åœ¨åœ¨å¼¹çª—é‡Œ)
                loadCharacterList();

            } catch (err) {
                console.error(err);
                alert("ç”Ÿæˆå¤±è´¥: " + err.message);
            } finally {
                btn.innerText = "å¼€å§‹ç”Ÿæˆ";
                btn.disabled = false;
            }
        }

        function hideCharacterEditor() {
            document.getElementById('character-editor-page').style.display = 'none';
            editingCharId = null;
        }

        function setCharAvatar(input) {
            const file = input.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = e => {
                    document.getElementById('char-avatar-preview').style.backgroundImage = `url(${e.target.result})`;
                    document.getElementById('char-avatar-placeholder').style.display = 'none';
                };
                reader.readAsDataURL(file);
            }
        }

        async function saveCharacter() {
            const name = document.getElementById('char-name').value.trim();
            const nick = document.getElementById('char-nick').value.trim();
            const desc = document.getElementById('char-desc').value;
            const type = document.getElementById('char-type').value;
            
            // è·å–è™šæ‹Ÿèº«ä»½æ•°æ®
            const identity = {
                account: document.getElementById('char-identity-account').value.trim(),
                password: document.getElementById('char-identity-password').value.trim(),
                phone: document.getElementById('char-identity-phone').value.trim(),
                address: document.getElementById('char-identity-address').value.trim(),
                id_card: document.getElementById('char-identity-id').value.trim(),
                bank_card: document.getElementById('char-identity-bank').value.trim(),
                bank_password: document.getElementById('char-identity-bank-pass').value.trim()
            };

            // è·å–å¤´åƒ Base64
            let avatar = '';
            const bgImage = document.getElementById('char-avatar-preview').style.backgroundImage;
            if (bgImage && bgImage !== 'none') {
                avatar = bgImage.replace(/url\(|\)|"/g, '');
            }
            
            if (!name) {
                alert("è¯·è¾“å…¥è§’è‰²åå­—");
                return;
            }
            
            // å¦‚æœæ˜¯æ›´æ–°ï¼Œå…ˆè·å–æ—§æ•°æ®ä»¥ä¿ç•™ lorebookId ç­‰å­—æ®µ
            let oldData = {};
            if (editingCharId) {
                oldData = await db.characters.get(editingCharId);
            }

            const charData = {
                ...oldData, // ä¿ç•™åŸæœ‰çš„ lorebookId, original_data ç­‰
                name,
                nick,
                description: desc,
                type,
                avatar,
                identity, // ä¿å­˜èº«ä»½ä¿¡æ¯
                updated_at: Date.now()
            };
            
            if (editingCharId) {
                await db.characters.put(charData); // ä½¿ç”¨ put è¦†ç›–å®Œæ•´å¯¹è±¡
            } else {
                await db.characters.add(charData);
            }
            
            hideCharacterEditor();
            // å¦‚æœä¿®æ”¹äº†ç±»å‹ï¼Œå¯èƒ½éœ€è¦è·³è½¬åˆ°å¯¹åº” Tab æ‰èƒ½çœ‹åˆ°ï¼Œæˆ–è€…ç›´æ¥åˆ·æ–°å½“å‰ Tab
            if (type !== currentCharacterType) {
                switchCharacterTab(type);
            } else {
                loadCharacterList();
            }
        }

        // æå–å¹¶è§£æ JSON çš„é€šç”¨è¾…åŠ©å‡½æ•° (å¢å¼ºé²æ£’æ€§)
        function extractAndParseJSON(text) {
            if (!text) return null;
            let str = text.trim();
            
            // 1. å°è¯•æå–æœ€å¤–å±‚çš„ { ... } æˆ– [ ... ]
            // è¿™èƒ½æœ‰æ•ˆå¿½ç•¥å‰åçš„æ‚è´¨ï¼ˆå¦‚ç”¨æˆ·çš„ ]{...} æƒ…å†µï¼‰
            const firstBrace = str.indexOf('{');
            const firstBracket = str.indexOf('[');
            
            let startIdx = -1;
            let isArray = false;
            
            // ç¡®å®šæ˜¯å¯¹è±¡è¿˜æ˜¯æ•°ç»„å¼€å§‹å¾—æ›´æ—©
            if (firstBrace !== -1 && (firstBracket === -1 || firstBrace < firstBracket)) {
                startIdx = firstBrace;
            } else if (firstBracket !== -1) {
                startIdx = firstBracket;
                isArray = true;
            }
            
            if (startIdx !== -1) {
                const endChar = isArray ? ']' : '}';
                const endIdx = str.lastIndexOf(endChar);
                
                if (endIdx !== -1 && endIdx > startIdx) {
                    const jsonCandidate = str.substring(startIdx, endIdx + 1);
                    try {
                        return JSON.parse(jsonCandidate);
                    } catch (e) {
                        // console.warn("[extractJSON] æå–ç‰‡æ®µè§£æå¤±è´¥:", e);
                    }
                }
            }
            
            // 2. å¦‚æœæå–å¤±è´¥ï¼Œå°è¯•æ¸…ç† Markdown æ ‡è®°åç›´æ¥è§£æ
            const cleanStr = str.replace(/^```json\s*/i, '').replace(/^```\s*/, '').replace(/\s*```$/, '');
            try {
                return JSON.parse(cleanStr);
            } catch (e) {
                return null;
            }
        }

        // ========== å¤–è¯­+ä¸­æ–‡ç¿»è¯‘è¯†åˆ«åŠŸèƒ½ ==========
        // è§£æAIè¿”å›çš„å¤–è¯­+ä¸­æ–‡ç»„åˆæ¶ˆæ¯
        // æ”¯æŒæ ¼å¼ï¼š
        // 1. "å¤–è¯­ï¼ˆä¸­æ–‡ç¿»è¯‘ï¼‰" æˆ– "å¤–è¯­(ä¸­æ–‡ç¿»è¯‘)"
        // 2. "å¤–è¯­ã€Œä¸­æ–‡ç¿»è¯‘ã€"
        function parseForeignWithTranslation(text) {
            if (!text) return null;
            
            // æ¨¡å¼1: ä»»æ„å†…å®¹ï¼ˆä¸­æ–‡ç¿»è¯‘ï¼‰æˆ– ä»»æ„å†…å®¹(ä¸­æ–‡ç¿»è¯‘) - æ‹¬å·åœ¨æœ«å°¾
            const pattern1 = /^(.+?)[ï¼ˆ(]([^ï¼‰)]+)[ï¼‰)]$/s;
            let match = text.match(pattern1);
            if (match) {
                const foreign = match[1].trim();
                const chinese = match[2].trim();
                // éªŒè¯ï¼šæ‹¬å·å†…åº”è¯¥åŒ…å«ä¸­æ–‡ï¼Œä¸”å¤–è¯­éƒ¨åˆ†ä¸ä¸ºç©º
                if (foreign && containsChinese(chinese)) {
                    return { foreign, chinese };
                }
            }
            
            // æ¨¡å¼2: ä»»æ„å†…å®¹ã€Œä¸­æ–‡ç¿»è¯‘ã€
            const pattern2 = /^(.+?)ã€Œ([^ã€]+)ã€$/s;
            match = text.match(pattern2);
            if (match) {
                const foreign = match[1].trim();
                const chinese = match[2].trim();
                if (foreign && containsChinese(chinese)) {
                    return { foreign, chinese };
                }
            }
            
            return null;
        }
        
        // æ£€æŸ¥æ–‡æœ¬æ˜¯å¦åŒ…å«ä¸­æ–‡
        function containsChinese(text) {
            if (!text) return false;
            const chineseRegex = /[\u4e00-\u9fff]/;
            return chineseRegex.test(text);
        }
        
        // é€šç”¨ AI è°ƒç”¨å‡½æ•°
        async function callAI(messages, options = {}) {
            const url = await db.dexiData.get('aiBaseUrl');
            const key = await db.dexiData.get('aiApiKey');
            const model = await db.dexiData.get('aiCurrentModel');
            
            if (!url || !key || !model) {
                throw new Error("è¯·å…ˆåœ¨è®¾ç½®ä¸­é…ç½® API åœ°å€ã€å¯†é’¥å¹¶é€‰æ‹©æ¨¡å‹");
            }
            
            // éªŒè¯é…ç½®å€¼
            const apiKeyValue = key.value ? key.value.trim() : '';
            const modelValue = model.value ? model.value.trim() : '';
            
            if (!apiKeyValue) {
                throw new Error("API å¯†é’¥ä¸èƒ½ä¸ºç©ºï¼Œè¯·åœ¨è®¾ç½®ä¸­é…ç½®");
            }
            
            if (!modelValue) {
                throw new Error("æ¨¡å‹åç§°ä¸èƒ½ä¸ºç©ºï¼Œè¯·åœ¨è®¾ç½®ä¸­é€‰æ‹©æ¨¡å‹");
            }
            
            // æ£€æŸ¥ API Key æ ¼å¼ï¼ˆåŸºæœ¬æ£€æŸ¥ï¼‰
            if (apiKeyValue.length < 10) {
                console.warn('[callAI] API Key é•¿åº¦å¼‚å¸¸ï¼Œå¯èƒ½æ— æ•ˆ:', apiKeyValue.length);
            }

            // è·å–æ¸©åº¦é…ç½®
            const tempItem = await db.dexiData.get('aiTemperature');
            let temperature = tempItem ? parseFloat(tempItem.value) : 0.7;
            
            // éªŒè¯æ¸©åº¦å€¼
            if (isNaN(temperature) || temperature < 0 || temperature > 2) {
                console.warn('[callAI] æ¸©åº¦å€¼æ— æ•ˆ:', temperature, 'ï¼Œä½¿ç”¨é»˜è®¤å€¼ 0.7');
                temperature = 0.7;
            }
            
            // è·å– max_tokens é…ç½®ï¼ˆå¦‚æœæä¾›ï¼‰
            const maxTokens = options.max_tokens || options.maxTokens;

            const requestUrl = getSmartUrl(url.value, '/chat/completions');
            
            // âœ… å…¨å±€é˜²å¾¡ï¼šæ¸…æ´— messagesï¼Œé˜²æ­¢ç©ºå†…å®¹æˆ–éæ³•æ ¼å¼å¯¼è‡´ 400 é”™è¯¯
            const cleanMessages = messages.map(m => {
                // éªŒè¯ role å­—æ®µ
                let role = m.role;
                if (!role || !['system', 'user', 'assistant'].includes(role)) {
                    console.warn('[callAI] æ— æ•ˆçš„ role:', role, 'ï¼Œä½¿ç”¨ user');
                    role = 'user';
                }
                
                // ç¡®ä¿ content æ˜¯å­—ç¬¦ä¸²
                let content = m.content;
                if (content === null || content === undefined) content = "";
                if (typeof content !== 'string') content = String(content);
                
                return {
                    role: role,
                    content: content.trim()
                };
            }).filter(m => m.content.length > 0); // å†æ¬¡è¿‡æ»¤ç©ºæ¶ˆæ¯

            // å¦‚æœè¿‡æ»¤ååªå‰©ä¸‹ system æ¶ˆæ¯ï¼Œæœ‰äº›æ¨¡å‹å¯èƒ½ä¼šæŠ¥é”™ï¼Œä½†å¤§å¤šæ•°æ”¯æŒã€‚
            // è¿™é‡Œæˆ‘ä»¬ä¸åš System çš„å¼ºåˆ¶æ£€æŸ¥ï¼Œåªè¦ä¸ä¸ºç©ºå³å¯ã€‚
            if (cleanMessages.length === 0) {
                throw new Error("è¯·æ±‚ä¸­æ­¢ï¼šæ²¡æœ‰æœ‰æ•ˆçš„æ¶ˆæ¯å†…å®¹ï¼ˆå¯èƒ½æ˜¯å› ä¸ºæ¶ˆæ¯è¢«æ’¤å›æˆ–ä¸ºç©ºï¼‰");
            }
            
            // éªŒè¯æ˜¯å¦è‡³å°‘æœ‰ä¸€æ¡é system æ¶ˆæ¯
            const hasNonSystemMessage = cleanMessages.some(m => m.role !== 'system');
            if (!hasNonSystemMessage) {
                console.warn('[callAI] åªæœ‰ system æ¶ˆæ¯ï¼Œæ·»åŠ ä¸€ä¸ªå ä½ user æ¶ˆæ¯');
                cleanMessages.push({
                    role: 'user',
                    content: 'è¯·ç»§ç»­å¯¹è¯'
                });
            }

            let rawText = '';
            
            // æ„å»ºè¯·æ±‚ä½“
            const requestBody = {
                apiUrl: requestUrl,
                apiKey: apiKeyValue,
                model: modelValue,
                messages: cleanMessages,
                temperature: temperature
            };
            
            // æ·»åŠ è¯¦ç»†çš„è°ƒè¯•æ—¥å¿—
            console.log('[callAI] ğŸš€ å‡†å¤‡å‘é€è¯·æ±‚');
            console.log('[callAI] API URL:', requestUrl);
            console.log('[callAI] Model:', modelValue);
            console.log('[callAI] API Key length:', apiKeyValue.length);
            console.log('[callAI] Temperature:', temperature);
            console.log('[callAI] Messages count:', cleanMessages.length);
            console.log('[callAI] Messages preview:', cleanMessages.map(m => ({
                role: m.role,
                content: m.content.substring(0, 100) + (m.content.length > 100 ? '...' : '')
            })));
            
            // çº¯å‰ç«¯ï¼šç›´æ¥è°ƒç”¨ AI APIï¼ˆéœ€è¦é…ç½®æ”¯æŒ CORS çš„ API ç«¯ç‚¹ï¼‰
            try {
                const res = await fetch(requestUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKeyValue}`
                    },
                    body: JSON.stringify({
                        model: modelValue,
                        messages: cleanMessages,
                        temperature: temperature
                    })
                });

                if (!res.ok) {
                    const errText = await res.text();
                    console.error('[callAI] âŒ API è¯·æ±‚å¤±è´¥');
                    console.error('[callAI] çŠ¶æ€ç :', res.status);
                    console.error('[callAI] é”™è¯¯å“åº”:', errText);
                    
                    try {
                        const errJson = JSON.parse(errText);
                        console.error('[callAI] è§£æåçš„é”™è¯¯:', errJson);
                        if (errJson.error) {
                            const errorMsg = `AIè¯·æ±‚å¤±è´¥ (${res.status}): ${errJson.error}${errJson.details ? '\nè¯¦æƒ…: ' + errJson.details : ''}`;
                            throw new Error(errorMsg);
                        }
                    } catch(parseErr) {
                        // å¦‚æœä¸æ˜¯ JSON æ ¼å¼çš„é”™è¯¯
                        if (parseErr instanceof SyntaxError) {
                            console.error('[callAI] é”™è¯¯å“åº”ä¸æ˜¯ JSON æ ¼å¼');
                        }
                    }
                    
                    throw new Error(`API è¯·æ±‚å¤±è´¥: ${res.status} - ${errText.substring(0, 200)}`);
                }

                // âœ… å…³é”®æ”¹åŠ¨ï¼šå…ˆè·å–åŸå§‹æ–‡æœ¬ï¼Œè€Œä¸æ˜¯ç›´æ¥ .json()
                rawText = await res.text();
                
                // å°è¯•è§£æä¸º JSON
                let data;
                try {
                    data = JSON.parse(rawText);
                } catch (parseErr) {
                    // è¿”å›çš„ä¸æ˜¯ JSONï¼ˆå¯èƒ½æ˜¯ HTML é”™è¯¯é¡µã€çº¯æ–‡æœ¬ç­‰ï¼‰
                    console.warn('[callAI] è¿”å›å†…å®¹ä¸æ˜¯æœ‰æ•ˆçš„ JSONï¼Œç›´æ¥ä½¿ç”¨åŸå§‹æ–‡æœ¬');
                    console.log('[callAI] åŸå§‹è¿”å›:', rawText.substring(0, 500));
                    
                    // ç›´æ¥è¿”å›åŸå§‹æ–‡æœ¬ï¼ˆå»é™¤ HTML æ ‡ç­¾å’Œç‰¹æ®Šå­—ç¬¦ï¼‰
                    return rawText
                        .replace(/<[^>]*>/g, '') // ç§»é™¤ HTML æ ‡ç­¾
                        .replace(/[â—‡â—†â˜…â˜†â—â—‹â– â–¡â–²â–³]/g, '') // ç§»é™¤è£…é¥°å­—ç¬¦
                        .trim();
                }
                
                // âœ… å…¼å®¹å¤šç§è¿”å›è·¯å¾„
                const content = 
                    data?.choices?.[0]?.message?.content ??  // OpenAI æ ‡å‡†æ ¼å¼
                    data?.choices?.[0]?.text ??              // ä¸€äº›æ—§ç‰ˆ API
                    data?.output_text ??                     // ä¸€äº›è‡ªå®šä¹‰æ ¼å¼
                    data?.message ??                         // ç®€åŒ–æ ¼å¼
                    data?.content ??                         // ç›´æ¥è¿”å›å†…å®¹
                    data?.reply ??                           // è‡ªå®šä¹‰å­—æ®µ
                    '';
                
                if (!content) {
                    // å¦‚æœæ‰€æœ‰è·¯å¾„éƒ½æ²¡æœ‰å†…å®¹ï¼Œå°è¯•ç›´æ¥ä½¿ç”¨åŸå§‹æ–‡æœ¬
                    console.warn('[callAI] æ— æ³•ä»æ ‡å‡†è·¯å¾„æå–å†…å®¹ï¼Œå°è¯•ä½¿ç”¨åŸå§‹è¿”å›');
                    console.log('[callAI] è§£æåçš„æ•°æ®ç»“æ„:', JSON.stringify(data).substring(0, 300));
                    
                    // å¦‚æœdataæœ¬èº«å°±æ˜¯å­—ç¬¦ä¸²ï¼Œç›´æ¥è¿”å›
                    if (typeof data === 'string') {
                        return data;
                    }
                    
                    // å¦åˆ™è¿”å›æ¸…ç†åçš„åŸå§‹æ–‡æœ¬
                    return rawText
                        .replace(/<[^>]*>/g, '')
                        .replace(/[â—‡â—†â˜…â˜†â—â—‹â– â–¡â–²â–³]/g, '')
                        .trim() || '(AI è¿”å›ä¸ºç©º)';
                }
                
                return content;
                
            } catch (err) {
                console.error("[callAI] é”™è¯¯è¯¦æƒ…:", err);
                console.log("[callAI] åŸå§‹è¿”å›å†…å®¹:", rawText.substring(0, 500));
                throw err;
            }
        }

        // ç”Ÿæˆè™šæ‹Ÿèº«ä»½
        async function generateIdentity() {
            const name = document.getElementById('char-name').value;
            const desc = document.getElementById('char-desc').value;
            
            if (!name) {
                alert("è¯·å…ˆè¾“å…¥è§’è‰²åå­—");
                return;
            }

            const btnText = document.getElementById('gen-btn-text');
            const spinner = document.getElementById('gen-spinner');
            btnText.style.display = 'none';
            spinner.style.display = 'block';

            try {
                const prompt = `ä½ æ˜¯ä¸€ä¸ªè§’è‰²å¡è¾…åŠ©å·¥å…·ã€‚è¯·æ ¹æ®è§’è‰²ã€${name}ã€‘çš„è®¾å®šï¼ˆ${desc || 'æš‚æ— è¯¦ç»†æè¿°'}ï¼‰ï¼Œä¸ºä»–/å¥¹ç”Ÿæˆä¸€å¥—è™šæ‹Ÿçš„ç°ä»£ç¤¾ä¼šèº«ä»½ä¿¡æ¯ã€‚
è¯·ä¸¥æ ¼è¿”å›çº¯ JSON æ ¼å¼æ•°æ®ï¼ˆä¸è¦åŒ…å« Markdown ä»£ç å—æ ‡è®°ï¼‰ï¼ŒåŒ…å«ä»¥ä¸‹å­—æ®µï¼š
- account: è™šæ‹Ÿç¤¾äº¤è´¦å·ï¼ˆè‹±æ–‡+æ•°å­—ï¼‰
- password: ç™»å½•å¯†ç ï¼ˆå¤æ‚ä¸€ç‚¹ï¼‰
- phone: æ‰‹æœºå·ï¼ˆå¿…é¡»ä¸¥æ ¼ä¸º 7 ä½æ•°å­—ï¼‰
- address: å®¶åº­ä½å€ï¼ˆç¬¦åˆè§’è‰²èƒŒæ™¯çš„è™šæ„åœ°å€ï¼‰
- id_card: èº«ä»½è¯å·ï¼ˆå¿…é¡»ä¸¥æ ¼ä¸º 9 ä½æ•°å­—ï¼‰
- bank_card: é“¶è¡Œå¡å·ï¼ˆå¿…é¡»ä¸¥æ ¼ä¸º 8 ä½æ•°å­—ï¼‰
- bank_password: é“¶è¡Œå¡å¯†ç ï¼ˆå¿…é¡»ä¸¥æ ¼ä¸º 4 ä½æ•°å­—ï¼‰`;

                const content = await callAI([
                    { role: "system", content: "ä½ æ˜¯ä¸€ä¸ªåªè¾“å‡º JSON çš„æ•°æ®ç”ŸæˆåŠ©æ‰‹ã€‚" },
                    { role: "user", content: prompt }
                ]);

                const data = extractAndParseJSON(content);
                if (!data) throw new Error("æ— æ³•è§£æ AI è¿”å›çš„ JSON æ•°æ®");
                
                // å¡«å…¥è¡¨å•
                document.getElementById('char-identity-account').value = data.account || '';
                document.getElementById('char-identity-password').value = data.password || '';
                document.getElementById('char-identity-phone').value = data.phone || '';
                document.getElementById('char-identity-address').value = data.address || '';
                document.getElementById('char-identity-id').value = data.id_card || '';
                document.getElementById('char-identity-bank').value = data.bank_card || '';
                document.getElementById('char-identity-bank-pass').value = data.bank_password || '';

            } catch (err) {
                console.error(err);
                alert("ç”Ÿæˆå¤±è´¥: " + err.message);
            } finally {
                btnText.style.display = 'inline';
                spinner.style.display = 'none';
            }
        }

        async function deleteCharacter() {
            if (!editingCharId) return;
            if (confirm("ç¡®å®šè¦åˆ é™¤è¿™ä¸ªè§’è‰²å—ï¼Ÿ")) {
                await db.characters.delete(editingCharId);
                hideCharacterEditor();
                loadCharacterList();
            }
        }

        // è¾…åŠ©å‡½æ•°ï¼šè‡ªåŠ¨å¯¼å…¥å†…åµŒçš„ä¸–ç•Œä¹¦
        async function importCharacterBook(bookData, charName) {
            if (!bookData) return null;
            
            try {
                const bookName = bookData.name || `${charName}çš„ä¸–ç•Œä¹¦`;
                
                // å­˜å…¥ lorebooks è¡¨
                const id = await db.lorebooks.add({
                    name: bookName,
                    content: bookData,
                    created_at: Date.now()
                });
                
                return id;
            } catch (e) {
                console.error("å¯¼å…¥ä¸–ç•Œä¹¦å¤±è´¥", e);
                return null;
            }
        }

        // å¯¼å…¥è§’è‰² (JSON æˆ– PNG)
        function importCharacterFile(input) {
            const file = input.files[0];
            if (!file) return;
            
            if (file.type.includes('image') || file.name.endsWith('.png')) {
                // å¤„ç† PNG
                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        // 1. å…ˆå°è¯•å½“åšå›¾ç‰‡è¯»å–æ˜¾ç¤º
                        const avatarBase64 = e.target.result;
                        
                        // 2. è§£æ PNG å…ƒæ•°æ®ä¸­çš„ JSON
                        const arrayBuffer = await file.arrayBuffer();
                        const jsonStr = extractPngText(new Uint8Array(arrayBuffer));
                        
                        if (!jsonStr) {
                            alert("æœªåœ¨è¿™å¼ å›¾ç‰‡ä¸­æ‰¾åˆ°è§’è‰²æ•°æ® (tEXt chunk)");
                            createNewCharacter();
                            document.getElementById('char-avatar-preview').style.backgroundImage = `url(${avatarBase64})`;
                            document.getElementById('char-avatar-placeholder').style.display = 'none';
                            input.value = '';
                            return;
                        }
                        
                        const json = JSON.parse(jsonStr);
                        // å¤„ç†ä¸åŒæ ¼å¼ (TavernAI V1/V2)
                        let charData = {};
                        if (json.data) {
                            // V2 spec
                            charData = json.data;
                        } else {
                            // V1 æˆ–ç›´æ¥ç»“æ„
                            charData = json;
                        }
                        
                        // å°è¯•å¯¼å…¥ä¸–ç•Œä¹¦
                        let lorebookId = null;
                        if (charData.character_book) {
                             lorebookId = await importCharacterBook(charData.character_book, charData.name);
                        }
                        
                        // å­˜å…¥ DB
                        await db.characters.add({
                            name: charData.name || 'æœªå‘½å',
                            nick: charData.nickname || '', 
                            description: charData.description || charData.personality || '', 
                            type: currentCharacterType, 
                            avatar: avatarBase64,
                            original_data: json,
                            lorebookIds: lorebookId ? [lorebookId] : null, // å…³è”ä¸–ç•Œä¹¦IDæ•°ç»„
                            lorebookId: lorebookId, // å…¼å®¹å­—æ®µ
                            updated_at: Date.now()
                        });
                        
                        let msg = `âœ… æˆåŠŸå¯¼å…¥è§’è‰²: ${charData.name}`;
                        if (lorebookId) msg += `\nğŸ“š å¹¶è‡ªåŠ¨å¯¼å…¥äº†ä¸–ç•Œä¹¦`;
                        alert(msg);
                        loadCharacterList();
                        
                    } catch (err) {
                        console.error(err);
                        alert("è§£æ PNG å¤±è´¥: " + err.message);
                    }
                };
                reader.readAsDataURL(file);
                
            } else {
                // å¤„ç† JSON
                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const json = JSON.parse(e.target.result);
                        // å…¼å®¹æ€§å¤„ç†
                        let charData = json;
                        if (json.data) charData = json.data; // Spec V2
                        
                        // å°è¯•å¯¼å…¥ä¸–ç•Œä¹¦
                        let lorebookId = null;
                        if (charData.character_book) {
                             lorebookId = await importCharacterBook(charData.character_book, charData.name);
                        }
                        
                        await db.characters.add({
                            name: charData.name || 'æœªå‘½å',
                            nick: charData.nickname || '',
                            description: charData.description || charData.personality || '',
                            type: currentCharacterType,
                            avatar: '', 
                            original_data: json,
                            lorebookId: lorebookId, // å…³è”ä¸–ç•Œä¹¦ID
                            updated_at: Date.now()
                        });
                        
                        let msg = `âœ… æˆåŠŸå¯¼å…¥è§’è‰²: ${charData.name}`;
                        if (lorebookId) msg += `\nğŸ“š å¹¶è‡ªåŠ¨å¯¼å…¥äº†ä¸–ç•Œä¹¦`;
                        alert(msg);
                        loadCharacterList();
                    } catch (err) {
                        alert("JSON è§£æå¤±è´¥: " + err.message);
                    }
                };
                reader.readAsText(file);
            }
            input.value = '';
        }

        // ç®€æ˜“ PNG tEXt æå–å™¨ (ä¿®å¤ä¸­æ–‡ä¹±ç ç‰ˆ)
        function extractPngText(uint8Array) {
            // PNG Header: 89 50 4E 47 0D 0A 1A 0A
            let offset = 8;
            const textDecoder = new TextDecoder();
            
            while (offset < uint8Array.length) {
                // è¯»å– Chunk Length (4 bytes, Big Endian)
                const length = (uint8Array[offset] << 24) | (uint8Array[offset+1] << 16) | (uint8Array[offset+2] << 8) | uint8Array[offset+3];
                offset += 4;
                
                // è¯»å– Chunk Type (4 bytes)
                const type = String.fromCharCode(...uint8Array.slice(offset, offset + 4));
                offset += 4;
                
                if (type === 'tEXt') {
                    const data = uint8Array.slice(offset, offset + length);
                    // tEXt æ ¼å¼: Keyword + null separator + Text string
                    // æŸ¥æ‰¾ null separator (0x00)
                    let nullIndex = -1;
                    for (let i = 0; i < length; i++) {
                        if (data[i] === 0) {
                            nullIndex = i;
                            break;
                        }
                    }
                    
                    if (nullIndex > -1) {
                        const keyword = textDecoder.decode(data.slice(0, nullIndex));
                        const textBytes = data.slice(nullIndex + 1);
                        const text = textDecoder.decode(textBytes);
                        
                        if (keyword === 'chara') {
                            // TavernAI æ ¼å¼é€šå¸¸æ˜¯ Base64 ç¼–ç çš„ JSON
                            try {
                                // ä¿®å¤ä¹±ç çš„å…³é”®æ­¥éª¤ï¼š
                                // 1. atob è§£ç  base64 -> binary string
                                const binaryString = atob(text);
                                // 2. binary string -> Uint8Array
                                const bytes = new Uint8Array(binaryString.length);
                                for (let i = 0; i < binaryString.length; i++) {
                                    bytes[i] = binaryString.charCodeAt(i);
                                }
                                // 3. TextDecoder è§£ç  utf-8
                                const decoded = new TextDecoder('utf-8').decode(bytes);
                                return decoded;
                            } catch (e) {
                                // ä¹Ÿè®¸ä¸æ˜¯ Base64ï¼Œæˆ–è€…è§£ç å¤±è´¥ï¼Œç›´æ¥è¿”å›åŸå§‹æ–‡æœ¬
                                return text;
                            }
                        }
                    }
                }
                
                // è·³è¿‡ Data å’Œ CRC (4 bytes)
                offset += length + 4;
                
                if (type === 'IEND') break;
            }
            return null;
        }

        // --- ä¸–ç•Œä¹¦ (Lorebook) é€»è¾‘ ---
function showLorebookPage() {
    document.getElementById('lorebook-page').style.display = 'flex';
    loadLorebookList();
}

        function hideLorebookPage() {
            const page = document.getElementById('lorebook-page');
            page.style.transform = 'scale(0.95)';
            page.style.opacity = '0';
            setTimeout(() => {
                page.style.display = 'none';
                page.style.transform = ''; 
                page.style.opacity = '';
            }, 200);
        }

        async function loadLorebookList() {
            const list = await db.lorebooks.toArray();
            const container = document.getElementById('lorebook-list');
            container.innerHTML = '';
            
            if (list.length === 0) {
                container.innerHTML = `
                    <div style="text-align:center; color:#999; margin-top:40px; font-size:14px; display:flex; flex-direction:column; align-items:center; gap:10px;">
                        <svg class="svg-icon" style="width:40px; height:40px; stroke:#ccc;" viewBox="0 0 24 24"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path></svg>
                        <div>ç©ºç©ºå¦‚ä¹Ÿ<br>ç‚¹å‡»ä¸Šæ–¹å¯¼å…¥æˆ–æ–°å»º</div>
                    </div>
                `;
                return;
            }

            list.forEach(book => {
                const count = book.content && book.content.entries ? Object.keys(book.content.entries).length : 0;
                
                const div = document.createElement('div');
                div.className = 'lorebook-card';
                div.innerHTML = `
                    <div class="lorebook-info">
                        <h3>${book.name}</h3>
                        <p>${count} ä¸ªè¯æ¡</p>
                    </div>
                    <div class="lorebook-actions">
                        <div class="lorebook-btn lb-edit" onclick="editLorebook(${book.id})">ç¼–è¾‘</div>
                        <div class="lorebook-btn lb-del" onclick="deleteLorebook(${book.id})">åˆ é™¤</div>
                    </div>
                `;
                container.appendChild(div);
            });
        }

        // å¯¼å…¥ SillyTavern æ ¼å¼ JSON
        function importLorebookFile(input) {
            const file = input.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const json = JSON.parse(e.target.result);
                    // ç®€å•çš„æ ¼å¼æ ¡éªŒï¼šé€šå¸¸æœ‰ entries
                    if (!json.entries && !Array.isArray(json)) {
                        if(!confirm("è¿™ä¼¼ä¹ä¸æ˜¯æ ‡å‡†çš„ SillyTavern æ ¼å¼ï¼Œç¡®å®šè¦å¯¼å…¥å—ï¼Ÿ")) {
                            input.value = '';
                            return;
                        }
                    }
                    
                    // æå–åå­—ï¼šæ–‡ä»¶åå»åç¼€ï¼Œæˆ–è€… json é‡Œçš„ name å­—æ®µ
                    let name = file.name.replace('.json', '');
                    if (json.name) name = json.name;

                    await db.lorebooks.add({
                        name: name,
                        content: json,
                        created_at: Date.now()
                    });
                    
                    alert(`âœ… æˆåŠŸå¯¼å…¥: ${name}`);
                    loadLorebookList();
                } catch (err) {
                    alert('âŒ JSON è§£æå¤±è´¥: ' + err.message);
                }
            };
            reader.readAsText(file);
            input.value = '';
        }

        async function createNewLorebook() {
            const name = prompt("è¯·è¾“å…¥æ–°ä¸–ç•Œä¹¦åç§°ï¼š", "æ–°ä¸–ç•Œä¹¦");
            if (!name) return;
            
            // åˆå§‹åŒ–ç©ºç»“æ„
            const newBook = {
                entries: {}
            };
            
            await db.lorebooks.add({
                name: name,
                content: newBook,
                created_at: Date.now()
            });
            loadLorebookList();
        }

        async function deleteLorebook(id) {
            if (confirm("ç¡®å®šè¦åˆ é™¤è¿™æœ¬ä¸–ç•Œä¹¦å—ï¼Ÿæ­¤æ“ä½œæ— æ³•æ’¤é”€ã€‚")) {
                await db.lorebooks.delete(id);
                loadLorebookList();
            }
        }

        // å…¨å±€å˜é‡ï¼šå½“å‰æ“ä½œçš„ä¸–ç•Œä¹¦IDå’Œè¯æ¡ID
        let currentBookId = null;
        let currentEntryId = null;

        function editLorebook(id) {
            showLorebookDetail(id);
        }

        // æ˜¾ç¤ºä¸–ç•Œä¹¦è¯¦æƒ… (è¯æ¡åˆ—è¡¨)
        async function showLorebookDetail(id) {
            currentBookId = id;
            const book = await db.lorebooks.get(id);
            if (!book) return;

            document.getElementById('lb-detail-title').innerText = book.name;
            document.getElementById('lb-detail-page').style.display = 'flex';
            
            renderEntryList(book.content.entries);
        }

        function hideLorebookDetail() {
            const page = document.getElementById('lb-detail-page');
            page.style.display = 'none';
            currentBookId = null;
        }

        // æ¸²æŸ“è¯æ¡åˆ—è¡¨
        function renderEntryList(entries) {
            const container = document.getElementById('lb-entry-list');
            container.innerHTML = '';
            
            if (!entries || Object.keys(entries).length === 0) {
                container.innerHTML = `<div style="text-align:center; color:#999; margin-top:40px;">æš‚æ— è¯æ¡</div>`;
                return;
            }

            // æŒ‰ key æ’åº (é€šå¸¸æ˜¯æ•°å­—ç´¢å¼•ï¼Œä½†ä¹Ÿå¯èƒ½æ˜¯éšæœºå­—ç¬¦ä¸²)
            const keys = Object.keys(entries).sort((a,b) => parseInt(a) - parseInt(b));

            keys.forEach(key => {
                const entry = entries[key];
                const title = entry.comment || entry.key?.join(', ') || `è¯æ¡ #${key}`;
                const keysText = entry.key ? entry.key.join(', ') : 'æ— å…³é”®å­—';
                
                const div = document.createElement('div');
                div.className = 'lb-entry-item';
                div.onclick = () => showEntryEditor(currentBookId, key);
                div.innerHTML = `
                    <div style="flex:1; overflow:hidden;">
                        <div class="lb-entry-title">${title}</div>
                        <div class="lb-entry-keys">${keysText}</div>
                    </div>
                    <div style="color:#c7c7cc;">â€º</div>
                `;
                container.appendChild(div);
            });
        }

        // æ˜¾ç¤ºè¯æ¡ç¼–è¾‘å™¨
        async function showEntryEditor(bookId, entryId) {
            currentEntryId = entryId;
            const page = document.getElementById('lb-entry-page');
            const titleDom = document.getElementById('lb-entry-title');
            const keysInput = document.getElementById('entry-keys');
            const contentInput = document.getElementById('entry-content');
            
            // æ¸…ç©ºè¾“å…¥
            keysInput.value = '';
            contentInput.value = '';

            if (entryId !== null) {
                // ç¼–è¾‘ç°æœ‰è¯æ¡
                titleDom.innerText = "ç¼–è¾‘è¯æ¡";
                const book = await db.lorebooks.get(bookId);
                const entry = book.content.entries[entryId];
                if (entry) {
                    keysInput.value = entry.key ? entry.key.join(', ') : '';
                    contentInput.value = entry.content || '';
                }
            } else {
                // æ–°å»ºè¯æ¡
                titleDom.innerText = "æ–°å»ºè¯æ¡";
            }

            page.style.display = 'flex';
        }

        function hideEntryEditor() {
            document.getElementById('lb-entry-page').style.display = 'none';
            currentEntryId = null;
        }

        // ä¿å­˜è¯æ¡
        async function saveEntry() {
            if (!currentBookId) return;

            const keysStr = document.getElementById('entry-keys').value.trim();
            const content = document.getElementById('entry-content').value;
            
            // ç®€å•çš„æ ¡éªŒ
            if (!content && !keysStr) {
                alert("è¯·å¡«å†™å†…å®¹æˆ–å…³é”®å­—");
                return;
            }

            // å¤„ç†å…³é”®å­—æ•°ç»„
            const keys = keysStr.split(/[,ï¼Œ]/).map(k => k.trim()).filter(k => k);

            try {
                const book = await db.lorebooks.get(currentBookId);
                if (!book) return;

                // ç¡®ä¿ entries å¯¹è±¡å­˜åœ¨
                if (!book.content.entries) book.content.entries = {};

                let entryId = currentEntryId;
                if (entryId === null) {
                    // ç”Ÿæˆæ–°IDï¼šæ‰¾åˆ°æœ€å¤§ID + 1
                    const existingIds = Object.keys(book.content.entries).map(k => parseInt(k)).filter(n => !isNaN(n));
                    const maxId = existingIds.length > 0 ? Math.max(...existingIds) : -1;
                    entryId = (maxId + 1).toString();
                }

                // æ„é€ è¯æ¡å¯¹è±¡ (ä¿ç•™å…¶ä»–æœªä¿®æ”¹å­—æ®µå¦‚æœå­˜åœ¨)
                const oldEntry = book.content.entries[entryId] || {};
                book.content.entries[entryId] = {
                    ...oldEntry,
                    uid: oldEntry.uid !== undefined ? oldEntry.uid : entryId, // SillyTavern å¸¸ç”¨ uid
                    key: keys,
                    content: content,
                    comment: keys[0] || `è¯æ¡ #${entryId}`, // ç”¨ç¬¬ä¸€ä¸ªå…³é”®å­—åšæ³¨é‡Šå
                    enabled: true
                };

                await db.lorebooks.put(book);
                
                // åˆ·æ–°åˆ—è¡¨å¹¶å…³é—­ç¼–è¾‘å™¨
                renderEntryList(book.content.entries);
                hideEntryEditor();

            } catch (err) {
                alert("ä¿å­˜å¤±è´¥: " + err.message);
            }
        }

        // åˆ é™¤è¯æ¡
        async function deleteEntry() {
            if (!currentBookId || currentEntryId === null) return;
            
            if (!confirm("ç¡®å®šè¦åˆ é™¤æ­¤è¯æ¡å—ï¼Ÿ")) return;

            try {
                const book = await db.lorebooks.get(currentBookId);
                if (book && book.content.entries) {
                    delete book.content.entries[currentEntryId];
                    await db.lorebooks.put(book);
                    
                    renderEntryList(book.content.entries);
                    hideEntryEditor();
                }
            } catch (err) {
                alert("åˆ é™¤å¤±è´¥: " + err.message);
            }
        }

        async function exportLorebook(id) {
            const book = await db.lorebooks.get(id);
            if (!book) return;
            
            const blob = new Blob([JSON.stringify(book.content, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${book.name}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // æ ¸å¿ƒï¼šä»DEXieæ¢å¤æ‰€æœ‰è®¾ç½®
        async function restoreSetting() {
            // è·å–æ‰€æœ‰å­˜å‚¨çš„æ•°æ®
            const allData = await db.dexiData.toArray();
            const dataMap = {};
            allData.forEach(item => {
                dataMap[item.key] = item.value;
            });
            
            // API é…ç½®æ— éœ€åœ¨é¦–é¡µæ˜¾ç¤ºï¼Œåªåœ¨å±•å¼€æ—¶åŠ è½½

            // æ¢å¤å£çº¸
            if (dataMap.wallpaper) document.getElementById('desktop-body').style.backgroundImage = `url(${dataMap.wallpaper})`;
            // æ¢å¤å°ç»„ä»¶
            if (dataMap.widgetIcon) document.getElementById('widget-icon').style.backgroundImage = `url(${dataMap.widgetIcon})`;
            if (dataMap.widgetTitle) document.getElementById('widget-title').innerText = dataMap.widgetTitle;
            if (dataMap.widgetSubtext) document.getElementById('widget-subtext').innerText = dataMap.widgetSubtext;
            // æ¢å¤æ‹ç«‹å¾—
            if (dataMap.photoLeft) document.getElementById('img-left').style.backgroundImage = `url(${dataMap.photoLeft})`;
            if (dataMap.photoRight) document.getElementById('img-right').style.backgroundImage = `url(${dataMap.photoRight})`;
            // æ¢å¤å¤´åƒ
            if (dataMap.avatar1) {
                const img1 = document.getElementById('avatar-img-1');
                img1.style.backgroundImage = `url(${dataMap.avatar1})`;
                img1.classList.add('has-image');
            }
            if (dataMap.avatar2) {
                const img2 = document.getElementById('avatar-img-2');
                img2.style.backgroundImage = `url(${dataMap.avatar2})`;
                img2.classList.add('has-image');
            }
            if (dataMap.avatar1Bubble) document.getElementById('avatar-bubble1').innerText = dataMap.avatar1Bubble;
            if (dataMap.avatar1Name) document.getElementById('avatar-name1').innerText = dataMap.avatar1Name;
            if (dataMap.avatar2Bubble) document.getElementById('avatar-bubble2').innerText = dataMap.avatar2Bubble;
            if (dataMap.avatar2Name) document.getElementById('avatar-name2').innerText = dataMap.avatar2Name;
            // æ¢å¤å€’æ•°æ—¥
            if (dataMap.daysText) document.getElementById('days-text').innerText = dataMap.daysText;
            // æ¢å¤åº”ç”¨å›¾æ ‡
            const iconIds = ['setting','notes','remind','facetime','photo','camera'];
            iconIds.forEach(id => {
                const key = `icon${id.charAt(0).toUpperCase() + id.slice(1)}`;
                if (dataMap[key]) document.getElementById(`icon-${id}`).querySelector('.icon').style.backgroundImage = `url(${dataMap[key]})`;
            });
            // æ¢å¤Dockå›¾æ ‡
            const dockIds = ['setting','custom','message','music'];
            dockIds.forEach(id => {
                const key = `dock${id.charAt(0).toUpperCase() + id.slice(1)}`;
                if (dataMap[key]) document.getElementById(`dock-${id}`).querySelector('.icon').style.backgroundImage = `url(${dataMap[key]})`;
            });
            
        // æ¢å¤æ¤­åœ†å½¢é¢œè‰²
        if (dataMap.capsuleColor) {
            document.documentElement.style.setProperty('--capsule-bg', dataMap.capsuleColor);
        }
        if (dataMap.bubbleColor) {
            document.documentElement.style.setProperty('--bubble-bg', dataMap.bubbleColor);
        }
        
        // æ¢å¤è‡ªå®šä¹‰å­—ä½“
        if (dataMap.customFontUrl && dataMap.customFontName) {
            // å¡«å……è¾“å…¥æ¡†
            document.getElementById('custom-font-input').value = dataMap.customFontUrl;
            document.getElementById('custom-font-name-input').value = dataMap.customFontName;
            // åŠ è½½å¹¶åº”ç”¨å…¨å±€å­—ä½“
            loadCustomFont(dataMap.customFontUrl, dataMap.customFontName, false);
        }
    }

// --- å…¨å±€è¡¨æƒ…åŒ…ç®¡ç†é€»è¾‘ ---
function showStickerPage() {
    console.log('[showStickerPage] Function called');
    const page = document.getElementById('sticker-page');
    console.log('[showStickerPage] sticker-page element:', page);
    if (!page) {
        console.error('[showStickerPage] sticker-page element not found');
        return;
    }
    console.log('[showStickerPage] Setting display to flex and ensuring position fixed');
    // ç¡®ä¿é¡µé¢æ˜¯ fixed å®šä½å¹¶æ˜¾ç¤º
    page.style.position = 'fixed';
    page.style.top = '0';
    page.style.left = '0';
    page.style.width = '100vw';
    page.style.height = '100vh';
    page.style.zIndex = '200';
    page.style.display = 'flex';
    console.log('[showStickerPage] Calling renderStickerCategories');
    // ç¡®ä¿æ˜¾ç¤ºåˆ—è¡¨è§†å›¾
    const listView = document.getElementById('sticker-list-view');
    const detailView = document.getElementById('sticker-detail-view');
    if (listView) listView.style.display = 'flex';
    if (detailView) detailView.style.display = 'none';
    currentStickerCategoryId = null;
    renderStickerCategories();
    console.log('[showStickerPage] Done');
}
// ç¡®ä¿å‡½æ•°åœ¨å…¨å±€ä½œç”¨åŸŸå¯è®¿é—®
window.showStickerPage = showStickerPage;

function hideStickerPage() {
    const page = document.getElementById('sticker-page');
    if (!page) {
        console.error('sticker-page element not found');
        return;
    }
    page.style.transform = 'scale(0.95)';
    page.style.opacity = '0';
    setTimeout(() => {
        page.style.display = 'none';
        page.style.transform = ''; 
        page.style.opacity = '';
    }, 200);
}
// ç¡®ä¿å‡½æ•°åœ¨å…¨å±€ä½œç”¨åŸŸå¯è®¿é—®
window.hideStickerPage = hideStickerPage;

async function renderStickerCategories() {
    const list = await db.sticker_categories.toArray();
    const listContainer = document.getElementById('sticker-category-list');
    
    if (!listContainer) {
        console.error('sticker-category-list element not found');
        return;
    }
    
    // å¦‚æœæ²¡æœ‰åˆ†ç±»ï¼Œæ˜¾ç¤ºç©ºçŠ¶æ€
    if (list.length === 0) {
        listContainer.innerHTML = `
            <div class="sticker-empty-state">
                <svg class="svg-icon" style="width:64px; height:64px; stroke:#e5e5ea;" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><path d="M8 14s1.5 2 4 2 4-2 4-2"></path><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line></svg>
                <div style="color:#999; margin-top:16px;">æš‚æ— è¡¨æƒ…åŒ…åˆ†ç±»</div>
                <button onclick="showCreateCategoryModal()" style="margin-top:20px; padding:8px 20px; background:var(--ins-pink); color:#fff; border:none; border-radius:20px; font-size:14px;">æ–°å»ºåˆ†ç±»</button>
                <div style="margin-top:10px;">
                    <input type="file" id="import-sticker-json" accept=".json" style="display:none" onchange="importStickerCategory(this)">
                    <button onclick="document.getElementById('import-sticker-json').click()" style="padding:8px 20px; background:#f2f2f7; color:#333; border:none; border-radius:20px; font-size:14px;">å¯¼å…¥é…ç½®</button>
                </div>
            </div>
        `;
        return;
    }

    // æ¸²æŸ“åˆ†ç±»åˆ—è¡¨
    listContainer.innerHTML = list.map(cat => {
        const stickerCount = (cat.stickers || []).length;
        return `
            <div class="sticker-category-item" onclick="openStickerCategoryDetail(${cat.id})">
                <div style="flex:1;">
                    <div style="font-size:16px; font-weight:500; color:#333; margin-bottom:4px;">${cat.name}</div>
                    <div style="font-size:12px; color:#999;">${stickerCount} ä¸ªè¡¨æƒ…</div>
                </div>
                <div style="display:flex; gap:8px; align-items:center;">
                    <div class="sticker-category-action" onclick="event.stopPropagation(); exportStickerCategory(${cat.id})" style="padding:6px 12px; background:var(--ins-pink-light); color:var(--ins-pink); border-radius:6px; font-size:12px;">å¯¼å‡º</div>
                    <div class="sticker-category-action" onclick="event.stopPropagation(); deleteStickerCategory(${cat.id})" style="padding:6px 12px; background:#ffe5e5; color:#ff3b30; border-radius:6px; font-size:12px;">åˆ é™¤</div>
                    <svg class="svg-icon" style="width:16px; height:16px; color:#ccc;" viewBox="0 0 24 24"><polyline points="9 18 15 12 9 6"></polyline></svg>
                </div>
            </div>
        `;
    }).join('');
}

// æ‰“å¼€åˆ†ç±»è¯¦æƒ…é¡µ
async function openStickerCategoryDetail(id) {
    currentStickerCategoryId = id;
    const listView = document.getElementById('sticker-list-view');
    const detailView = document.getElementById('sticker-detail-view');
    
    if (listView) listView.style.display = 'none';
    if (detailView) detailView.style.display = 'flex';
    
    await renderStickerCategoryDetail();
}

// è¿”å›åˆ†ç±»åˆ—è¡¨
function backToStickerList() {
    const listView = document.getElementById('sticker-list-view');
    const detailView = document.getElementById('sticker-detail-view');
    
    if (listView) listView.style.display = 'flex';
    if (detailView) detailView.style.display = 'none';
    
    currentStickerCategoryId = null;
    renderStickerCategories();
}

// æ¸²æŸ“åˆ†ç±»è¯¦æƒ…
async function renderStickerCategoryDetail() {
    if (!currentStickerCategoryId) return;
    
    const cat = await db.sticker_categories.get(currentStickerCategoryId);
    if (!cat) return;
    
    const titleEl = document.getElementById('sticker-detail-title');
    const contentEl = document.getElementById('sticker-detail-content');
    
    if (titleEl) titleEl.innerText = cat.name;
    if (!contentEl) return;
    
    contentEl.innerHTML = `
        <div style="padding: 16px;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px; padding:12px; background:#f9f9f9; border-radius:12px;">
                <div>
                    <div style="font-size:14px; color:#999; margin-bottom:4px;">è¡¨æƒ…æ•°é‡</div>
                    <div style="font-size:20px; font-weight:600; color:#333;">${(cat.stickers || []).length}</div>
                </div>
                <div style="display:flex; gap:10px; flex-wrap:wrap;">
                    <button onclick="exportStickerCategory(${cat.id})" style="padding:8px 16px; background:var(--ins-pink-light); color:var(--ins-pink); border:none; border-radius:8px; font-size:14px; font-weight:500;">å¯¼å‡º</button>
                    <input type="file" id="import-sticker-json-detail" accept=".json" style="display:none" onchange="importStickerCategory(this)">
                    <button onclick="document.getElementById('import-sticker-json-detail').click()" style="padding:8px 16px; background:#f2f2f7; color:#666; border:none; border-radius:8px; font-size:14px; font-weight:500;">å¯¼å…¥</button>
                    <input type="file" id="batch-import-sticker-txt" accept=".txt,.text,.md" style="display:none" onchange="batchImportStickersFromText(this)">
                    <button onclick="document.getElementById('batch-import-sticker-txt').click()" style="padding:8px 16px; background:#e8f5e9; color:#2e7d32; border:none; border-radius:8px; font-size:14px; font-weight:500;" title="æ”¯æŒ.txt/.mdæ–‡ä»¶ï¼Œæ ¼å¼ï¼šæè¿°ï¼šå›¾ç‰‡é“¾æ¥">æ‰¹é‡å¯¼å…¥</button>
                </div>
            </div>
            
            <div class="sticker-grid-view">
                <!-- æ·»åŠ æŒ‰é’® -->
                <div class="sticker-grid-item add-btn" onclick="showAddStickerModal()">
                    <svg class="svg-icon" style="width:24px; height:24px;" viewBox="0 0 24 24"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
                    <div style="font-size:12px; color:#999; margin-top:8px;">æ·»åŠ è¡¨æƒ…</div>
                </div>
                ${(cat.stickers || []).map((s, idx) => `
                    <div class="sticker-grid-item" onclick="previewSticker(${idx})">
                        <div class="sticker-img" style="background-image:url(${s.url})"></div>
                        ${s.description ? `<div class="sticker-desc-tag">AIå¯è¯†</div>` : ''}
                        <div class="sticker-del-btn" onclick="deleteSticker(${idx}, event)">
                            <svg style="width:12px; height:12px; stroke:#fff; stroke-width:2;" viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                        </div>
                    </div>
                `).join('')}
            </div>
        </div>
    `;
}

// æ˜¾ç¤ºåˆ›å»ºåˆ†ç±»å¼¹çª—
function showCreateCategoryModal() {
    const name = prompt("è¯·è¾“å…¥åˆ†ç±»åç§°", "æˆ‘çš„è¡¨æƒ…");
    if (name && name.trim()) {
        createNewStickerCategory(name.trim());
    }
}

async function createNewStickerCategory(name) {
    try {
        const id = await db.sticker_categories.add({
            name: name,
            stickers: []
        });
        renderStickerCategories();
    } catch (err) {
        console.error('åˆ›å»ºåˆ†ç±»å¤±è´¥:', err);
        alert('åˆ›å»ºåˆ†ç±»å¤±è´¥ï¼Œè¯·é‡è¯•');
    }
}

async function deleteStickerCategory(id) {
    if (confirm("ç¡®å®šè¦åˆ é™¤è¿™ä¸ªåˆ†ç±»å—ï¼Ÿåˆ é™¤åæ— æ³•æ¢å¤ï¼")) {
        try {
            await db.sticker_categories.delete(id);
            if (currentStickerCategoryId === id) {
                // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰æŸ¥çœ‹çš„åˆ†ç±»ï¼Œè¿”å›åˆ—è¡¨
                backToStickerList();
            } else {
                renderStickerCategories();
            }
        } catch (err) {
            console.error('åˆ é™¤åˆ†ç±»å¤±è´¥:', err);
            alert('åˆ é™¤å¤±è´¥ï¼Œè¯·é‡è¯•');
        }
    }
}

    // æ˜¾ç¤ºæ·»åŠ è¡¨æƒ…å¼¹çª—
    function showAddStickerModal() {
        const modal = document.createElement('div');
        modal.className = 'sticker-modal-overlay';
        modal.id = 'add-sticker-modal';
        modal.innerHTML = `
            <div class="sticker-modal-box">
                <h3 style="text-align:center; margin-bottom:20px;">æ·»åŠ è¡¨æƒ…</h3>
                
                <div style="margin-bottom:16px;">
                    <label style="display:block; color:#666; font-size:14px; margin-bottom:8px;">å›¾ç‰‡æ¥æº</label>
                    <div style="display:flex; gap:10px;">
                        <button onclick="document.getElementById('sticker-file-input').click()" style="flex:1; padding:10px; background:#f5f5f5; border:1px solid #eee; border-radius:8px;">æœ¬åœ°ä¸Šä¼ </button>
                        <input type="file" id="sticker-file-input" accept="image/*" style="display:none" onchange="handleStickerFileSelect(this)">
                    </div>
                    <div id="sticker-preview-area" style="margin-top:10px; height:100px; background:#f9f9f9; border-radius:8px; display:none; align-items:center; justify-content:center; background-size:contain; background-repeat:no-repeat; background-position:center;"></div>
                </div>

                <div style="margin-bottom:16px;">
                    <label style="display:block; color:#666; font-size:14px; margin-bottom:8px;">å›¾ç‰‡é“¾æ¥ (å¯é€‰)</label>
                    <input type="text" id="sticker-url-input" placeholder="https://..." style="width:100%; padding:10px; border:1px solid #eee; border-radius:8px; outline:none;" oninput="handleStickerUrlInput(this)">
                </div>

                <div style="margin-bottom:20px;">
                    <label style="display:block; color:#666; font-size:14px; margin-bottom:8px;">æè¿° (AIè¯†åˆ«ç”¨)</label>
                    <input type="text" id="sticker-desc-input" placeholder="ä¾‹å¦‚ï¼šä¸€åªæƒŠè®¶çš„ç™½çŒ«" style="width:100%; padding:10px; border:1px solid #eee; border-radius:8px; outline:none;">
                </div>

                <div style="display:flex; gap:10px;">
                    <button onclick="document.getElementById('add-sticker-modal').remove()" style="flex:1; padding:12px; background:#f2f2f7; border:none; border-radius:8px;">å–æ¶ˆ</button>
                    <button onclick="confirmAddSticker()" style="flex:1; padding:12px; background:var(--ins-pink); color:#white; border:none; border-radius:8px; color:#fff;">æ·»åŠ </button>
                </div>
            </div>
        `;
        document.body.appendChild(modal);
    }

    let tempStickerData = null; // ä¸´æ—¶å­˜å‚¨ä¸Šä¼ çš„ base64 æˆ– URL

    function handleStickerFileSelect(input) {
        const file = input.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = e => {
                tempStickerData = e.target.result;
                const preview = document.getElementById('sticker-preview-area');
                preview.style.display = 'flex';
                preview.style.backgroundImage = `url(${tempStickerData})`;
                document.getElementById('sticker-url-input').value = ''; // æ¸…ç©ºURLè¾“å…¥
            };
            reader.readAsDataURL(file);
        }
    }

    function handleStickerUrlInput(input) {
        const url = input.value.trim();
        if (url) {
            tempStickerData = url;
            const preview = document.getElementById('sticker-preview-area');
            preview.style.display = 'flex';
            preview.style.backgroundImage = `url(${url})`;
        }
    }

    async function confirmAddSticker() {
        const desc = document.getElementById('sticker-desc-input').value.trim();
        
        if (!tempStickerData) {
            alert("è¯·å…ˆä¸Šä¼ å›¾ç‰‡æˆ–è¾“å…¥é“¾æ¥");
            return;
        }
        
        if (!desc) {
             if(!confirm("æœªå¡«å†™æè¿°ï¼ŒAIå¯èƒ½æ— æ³•å‡†ç¡®ç†è§£è¿™ä¸ªè¡¨æƒ…ã€‚ç¡®å®šè¦ç»§ç»­å—ï¼Ÿ")) return;
        }

        const cat = await db.sticker_categories.get(currentStickerCategoryId);
        if (cat) {
            cat.stickers.push({
                url: tempStickerData,
                description: desc,
                created_at: Date.now()
            });
            await db.sticker_categories.put(cat);
            renderStickerCategoryDetail();
            document.getElementById('add-sticker-modal').remove();
            tempStickerData = null;
        }
    }

async function deleteSticker(index, e) {
    e.stopPropagation();
    if (confirm("åˆ é™¤è¿™å¼ è¡¨æƒ…ï¼Ÿ")) {
        const cat = await db.sticker_categories.get(currentStickerCategoryId);
        cat.stickers.splice(index, 1);
        await db.sticker_categories.put(cat);
        renderStickerCategoryDetail();
    }
}

// é¢„è§ˆè¡¨æƒ…è¯¦æƒ…ï¼ˆå¯ç¼–è¾‘æè¿°ï¼‰
async function previewSticker(index) {
    const cat = await db.sticker_categories.get(currentStickerCategoryId);
    const sticker = cat.stickers[index];
    
    const newDesc = prompt("ç¼–è¾‘æè¿° (AIè¯†åˆ«ç”¨)", sticker.description || "");
    if (newDesc !== null) {
        sticker.description = newDesc;
        await db.sticker_categories.put(cat);
        renderStickerCategoryDetail();
    }
}

    // å¯¼å‡ºåˆ†ç±»
    async function exportStickerCategory(id) {
        const cat = await db.sticker_categories.get(id);
        const blob = new Blob([JSON.stringify(cat, null, 2)], {type: 'application/json'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `è¡¨æƒ…åŒ…-${cat.name}.json`;
        a.click();
        URL.revokeObjectURL(url);
    }

// å¯¼å…¥åˆ†ç±»
function importStickerCategory(input) {
    const file = input.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = async (e) => {
        try {
            const json = JSON.parse(e.target.result);
            // ç®€å•çš„æ ¼å¼æ ¡éªŒ
            if (!json.name || !Array.isArray(json.stickers)) {
                throw new Error("æ ¼å¼ä¸æ­£ç¡®");
            }
            
            // å¦‚æœå½“å‰åœ¨è¯¦æƒ…é¡µï¼Œè¯¢é—®æ˜¯å¯¼å…¥ä¸ºæ–°åˆ†ç±»è¿˜æ˜¯æ›¿æ¢å½“å‰åˆ†ç±»
            if (currentStickerCategoryId) {
                const action = confirm(`å¯¼å…¥æ–¹å¼ï¼š\nç¡®å®š = æ›¿æ¢å½“å‰åˆ†ç±»\nå–æ¶ˆ = åˆ›å»ºæ–°åˆ†ç±»`);
                if (action) {
                    // æ›¿æ¢å½“å‰åˆ†ç±»
                    const cat = await db.sticker_categories.get(currentStickerCategoryId);
                    if (cat) {
                        cat.name = json.name;
                        cat.stickers = json.stickers;
                        await db.sticker_categories.put(cat);
                        alert(`æˆåŠŸå¯¼å…¥å¹¶æ›¿æ¢åˆ†ç±»ï¼š${json.name}`);
                        renderStickerCategoryDetail();
                    }
                } else {
                    // åˆ›å»ºæ–°åˆ†ç±»
                    delete json.id;
                    await db.sticker_categories.add(json);
                    alert(`æˆåŠŸå¯¼å…¥ä¸ºæ–°åˆ†ç±»ï¼š${json.name}`);
                    backToStickerList();
                }
            } else {
                // åœ¨åˆ—è¡¨é¡µï¼Œåˆ›å»ºæ–°åˆ†ç±»
                delete json.id;
                await db.sticker_categories.add(json);
                alert(`æˆåŠŸå¯¼å…¥åˆ†ç±»ï¼š${json.name}`);
                renderStickerCategories();
            }
        } catch (err) {
            alert("å¯¼å…¥å¤±è´¥: " + err.message);
        }
        // æ¸…ç©ºinputï¼Œå…è®¸é‡å¤å¯¼å…¥åŒä¸€æ–‡ä»¶
        input.value = '';
    };
    reader.readAsText(file);
}
// æ‰¹é‡å¯¼å…¥è¡¨æƒ…åŒ…ï¼ˆä»æ–‡æœ¬æ–‡ä»¶ï¼‰
async function batchImportStickersFromText(input) {
    const file = input.files[0];
    if (!file) return;
    
    if (!currentStickerCategoryId) {
        alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªåˆ†ç±»');
        input.value = '';
        return;
    }
    
    const reader = new FileReader();
    reader.onload = async (e) => {
        try {
            const text = e.target.result;
            const lines = text.split(/\r?\n/).filter(line => line.trim());
            
            if (lines.length === 0) {
                alert('æ–‡ä»¶ä¸ºç©ºæˆ–æ ¼å¼ä¸æ­£ç¡®');
                input.value = '';
                return;
            }
            
            const stickers = [];
            let successCount = 0;
            let failCount = 0;
            const errors = [];
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                
                // è§£ææ ¼å¼ï¼šæè¿°ï¼šurl æˆ– æè¿°:urlï¼ˆæ”¯æŒä¸­æ–‡å’Œè‹±æ–‡å†’å·ï¼‰
                const match = line.match(/^(.+?)[ï¼š:]\s*(.+)$/);
                if (match) {
                    const description = match[1].trim();
                    const url = match[2].trim();
                    
                    // éªŒè¯URLæ ¼å¼
                    if (url && (url.startsWith('http://') || url.startsWith('https://') || url.startsWith('data:image'))) {
                        stickers.push({
                            url: url,
                            description: description,
                            created_at: Date.now()
                        });
                        successCount++;
                    } else {
                        failCount++;
                        errors.push(`ç¬¬${i+1}è¡Œï¼šURLæ ¼å¼ä¸æ­£ç¡® - ${line}`);
                    }
                } else {
                    // å¦‚æœæ²¡æœ‰å†’å·ï¼Œå°è¯•ä½œä¸ºçº¯URLå¤„ç†
                    if (line.startsWith('http://') || line.startsWith('https://') || line.startsWith('data:image')) {
                        stickers.push({
                            url: line,
                            description: '',
                            created_at: Date.now()
                        });
                        successCount++;
                    } else {
                        failCount++;
                        errors.push(`ç¬¬${i+1}è¡Œï¼šæ ¼å¼ä¸æ­£ç¡® - ${line}`);
                    }
                }
            }
            
            if (stickers.length === 0) {
                alert('æœªèƒ½è§£æå‡ºä»»ä½•è¡¨æƒ…åŒ…ã€‚\næ ¼å¼åº”ä¸ºï¼šæè¿°ï¼šå›¾ç‰‡é“¾æ¥\nä¾‹å¦‚ï¼šä¸€åªçŒ«ï¼šhttps://example.com/cat.jpg');
                input.value = '';
                return;
            }
            
            // æ·»åŠ åˆ°åˆ†ç±»
            const cat = await db.sticker_categories.get(currentStickerCategoryId);
            if (!cat) {
                alert('åˆ†ç±»ä¸å­˜åœ¨');
                input.value = '';
                return;
            }
            
            if (!cat.stickers) cat.stickers = [];
            cat.stickers.push(...stickers);
            await db.sticker_categories.put(cat);
            
            // æ˜¾ç¤ºç»“æœ
            let message = `âœ… æˆåŠŸå¯¼å…¥ ${successCount} ä¸ªè¡¨æƒ…åŒ…`;
            if (failCount > 0) {
                message += `\nâŒ å¤±è´¥ ${failCount} ä¸ª`;
                if (errors.length <= 5) {
                    message += '\n\né”™è¯¯è¯¦æƒ…ï¼š\n' + errors.join('\n');
                } else {
                    message += `\n\nå‰5ä¸ªé”™è¯¯ï¼š\n${errors.slice(0, 5).join('\n')}\n...è¿˜æœ‰${errors.length - 5}ä¸ªé”™è¯¯`;
                }
                message += '\n\næç¤ºï¼šæ ¼å¼åº”ä¸º"æè¿°ï¼šå›¾ç‰‡é“¾æ¥"ï¼Œä¾‹å¦‚ï¼š\nä¸€åªçŒ«ï¼šhttps://example.com/cat.jpg';
            }
            
            // ä½¿ç”¨æ›´å‹å¥½çš„æç¤ºæ–¹å¼
            if (failCount === 0) {
                alert(message);
            } else {
                // å¦‚æœæœ‰é”™è¯¯ï¼Œä½¿ç”¨confirmè®©ç”¨æˆ·é€‰æ‹©æ˜¯å¦æŸ¥çœ‹è¯¦æƒ…
                const showDetails = confirm(message + '\n\næ˜¯å¦æŸ¥çœ‹è¯¦ç»†é”™è¯¯ä¿¡æ¯ï¼Ÿ');
                if (showDetails && errors.length > 0) {
                    alert('è¯¦ç»†é”™è¯¯ä¿¡æ¯ï¼š\n\n' + errors.join('\n'));
                }
            }
            
            // åˆ·æ–°é¡µé¢
            renderStickerCategoryDetail();
            input.value = '';
        } catch (err) {
            console.error('æ‰¹é‡å¯¼å…¥å¤±è´¥:', err);
            alert('å¯¼å…¥å¤±è´¥: ' + err.message);
            input.value = '';
        }
    };
    reader.readAsText(file, 'UTF-8');
}

// ç¡®ä¿å‡½æ•°åœ¨å…¨å±€ä½œç”¨åŸŸå¯è®¿é—®
window.importStickerCategory = importStickerCategory;
window.openStickerCategoryDetail = openStickerCategoryDetail;
window.backToStickerList = backToStickerList;
window.showCreateCategoryModal = showCreateCategoryModal;
window.batchImportStickersFromText = batchImportStickersFromText;

// æ›´æ–°èŠå¤©é¢æ¿ä¸­çš„è¡¨æƒ…åˆ—è¡¨ï¼ˆåœ¨æ‰“å¼€é¢æ¿æ—¶è°ƒç”¨ï¼‰
// æ³¨æ„ï¼šç”¨æˆ·å¯ä»¥çœ‹åˆ°æ‰€æœ‰è¡¨æƒ…åŒ…ï¼Œä½†è§’è‰²åªèƒ½ä½¿ç”¨æŒ‚è½½çš„
async function updateChatStickerPanel() {
    const stickerPanel = document.getElementById('sticker-panel');
    if (!stickerPanel) return;
    
    let html = '';
    
    // è·å–æ‰€æœ‰è¡¨æƒ…åŒ…åˆ†ç±»ï¼ˆç”¨æˆ·å¯ä»¥çœ‹åˆ°æ‰€æœ‰ï¼‰
    const allCategories = await db.sticker_categories.toArray();
    
    if (allCategories.length === 0) {
        stickerPanel.innerHTML = `<div style="text-align:center; grid-column:span 4; color:#999; margin-top:20px;">æš‚æ— è¡¨æƒ…åŒ…<br>è¯·å»ã€æˆ‘-è¡¨æƒ…ã€‘æ·»åŠ </div>`;
        return;
    }
    
    // è·å–å½“å‰è§’è‰²æŒ‚è½½çš„åˆ†ç±»IDï¼ˆç”¨äºé™åˆ¶å‘é€ï¼‰
    let mountedIds = [];
    if (currentChatCharId) {
        const char = await db.characters.get(currentChatCharId);
        mountedIds = char.mounted_sticker_categories || [];
    }
    
    // æ˜¾ç¤ºæ‰€æœ‰åˆ†ç±»ï¼Œç”¨æˆ·å¯ä»¥çœ‹åˆ°æ‰€æœ‰ï¼Œä½†æ ‡è®°å“ªäº›æ˜¯æŒ‚è½½çš„ï¼ˆç”¨äºè§’è‰²å‘é€é™åˆ¶ï¼‰
    for (const cat of allCategories) {
        if (cat.stickers && cat.stickers.length > 0) {
            const isMounted = mountedIds.includes(cat.id);
            const mountTag = isMounted ? '<span style="font-size:10px; color:#2e7d32; margin-left:4px;">âœ“å·²æŒ‚è½½</span>' : '<span style="font-size:10px; color:#999; margin-left:4px;">æœªæŒ‚è½½</span>';
            html += `<div style="grid-column:1/-1; font-size:12px; color:#999; margin:10px 0 5px; font-weight:500;">${cat.name}${mountTag}</div>`;
            cat.stickers.forEach(s => {
                const safeUrl = s.url.replace(/'/g, "\\'").replace(/"/g, '&quot;');
                // ç”¨æˆ·å‘é€ï¼šæ‰€æœ‰è¡¨æƒ…åŒ…éƒ½å¯ä»¥ç‚¹å‡»å‘é€ï¼ˆä¸é™åˆ¶ï¼‰
                html += `<div class="emoji-item" onclick="sendGlobalSticker(${cat.id}, '${safeUrl}')" style="background-image:url(${s.url}); background-size:cover; background-position:center; width:60px; height:60px; border-radius:8px; cursor:pointer;"></div>`;
            });
        }
    }
    
    if (html === '') {
        stickerPanel.innerHTML = `<div style="text-align:center; grid-column:span 4; color:#999; margin-top:20px;">æš‚æ— è¡¨æƒ…åŒ…<br>è¯·å»ã€æˆ‘-è¡¨æƒ…ã€‘æ·»åŠ </div>`;
    } else {
        stickerPanel.innerHTML = html;
    }
}

async function sendGlobalSticker(catId, url) {
    // ç”¨æˆ·å‘é€è¡¨æƒ…åŒ…ï¼šå¯ä»¥å‘é€æ‰€æœ‰è¡¨æƒ…åŒ…ï¼Œä¸éœ€è¦æ£€æŸ¥æŒ‚è½½
    // è§’è‰²å‘é€è¡¨æƒ…åŒ…ï¼šåªèƒ½å‘é€æŒ‚è½½çš„ï¼ˆè¿™ä¸ªé™åˆ¶åœ¨è§’è‰²è‡ªåŠ¨å›å¤æ—¶æ£€æŸ¥ï¼‰
    if (!currentChatCharId) {
        alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªèŠå¤©å¯¹è±¡');
        return;
    }
    
    let char = await db.characters.get(currentChatCharId);
    const accountId = getCurrentAccountId();
    
    // æŸ¥æ‰¾æè¿°
    let desc = '';
    const cat = await db.sticker_categories.get(catId);
    if (cat) {
        const s = cat.stickers.find(sticker => sticker.url === url);
        if (s) desc = s.description;
    }
    
    // å‘é€é€»è¾‘
    const msgContent = `[img:${url}]`; // å›¾ç‰‡æ˜¾ç¤ºå†…å®¹
    // æˆ‘ä»¬éœ€è¦æŠŠ description é™„å¸¦åœ¨æ¶ˆæ¯é‡Œå—ï¼Ÿ
    // æ ‡å‡†åšæ³•ï¼šUser å‘é€å›¾ç‰‡ï¼ŒAI åªèƒ½çœ‹åˆ° [img:...]
    // ä¸ºäº†è®© AI è¯†åˆ«ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠ description ä½œä¸º system prompt çš„ä¸€éƒ¨åˆ†ï¼Œæˆ–è€… hidden text
    // æ–¹æ¡ˆï¼šåœ¨ msgContent é‡Œå¢åŠ  hidden tagï¼Œä¾‹å¦‚ [img:url|desc:æè¿°]
    // ä½†æ¸²æŸ“æ—¶è¦å»æ‰ã€‚
    // æˆ–è€…ï¼Œæˆ‘ä»¬åœ¨ chat_history å­˜å¯¹è±¡æ—¶ï¼Œå¢åŠ ä¸€ä¸ªå­—æ®µ `imageDescription`
    
    // å‘é€æ¶ˆæ¯ - ä½¿ç”¨æŒ‰è´¦å·éš”ç¦»çš„èŠå¤©è®°å½•
    let history = getChatHistory(char, accountId);
    
    history.push({
        role: 'user',
        content: msgContent,
        imageDescription: desc, // æ–°å¢å­—æ®µï¼šå›¾ç‰‡æè¿°
        time: Date.now()
    });
    
    await setChatHistory(char, accountId, history);
    appendMessageToUI('user', msgContent);
    closeChatPanel();
    
    // âœ… ä¸å†è‡ªåŠ¨è§¦å‘ AI å›å¤ï¼Œéœ€è¦ç”¨æˆ·ç‚¹å‡»"æ¥å—å›å¤"æŒ‰é’®
    // triggerAiReply();
}

// --- æ¡Œé¢å›¾æ ‡æ‹–æ‹½é€»è¾‘ ---
let desktopSortable = null;

function initDesktopDrag() {
    const grid = document.getElementById('app-grid');
    if (!grid) return;

    // æ£€æµ‹æ˜¯å¦æ˜¯ç§»åŠ¨è®¾å¤‡
    const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

    desktopSortable = new Sortable(grid, {
        animation: 350, // åŠ¨ç”»æ—¶é•¿ï¼Œæ¯«ç§’ - ç¨æ…¢ä¸€ç‚¹æ›´åƒiOS
        delay: isTouchDevice ? 150 : 0, // è§¦æ‘¸è®¾å¤‡é•¿æŒ‰150msè§¦å‘ï¼ˆä¼˜åŒ–ï¼šä»300msç¼©çŸ­åˆ°150msï¼Œæ›´çµæ•ï¼‰
        delayOnTouchOnly: true, // ä»…åœ¨è§¦æ‘¸æ—¶å¯ç”¨å»¶è¿Ÿ
        touchStartThreshold: 8, // æ‰‹æŒ‡ç§»åŠ¨è¶…è¿‡8pxå–æ¶ˆé•¿æŒ‰åˆ¤å®šï¼ˆä¼˜åŒ–ï¼šä»5pxå¢åŠ åˆ°8pxï¼Œå‡å°‘è¯¯è§¦å–æ¶ˆï¼‰
        
        // å…³é”®ï¼šä½¿ç”¨éåŸç”Ÿæ‹–æ‹½ï¼Œå®ç°æ›´ä¸æ»‘çš„ JS æ¨¡æ‹Ÿæ•ˆæœ
        forceFallback: true, 
        fallbackTolerance: 3, // é¼ æ ‡æŒ‰ä¸‹ç§»åŠ¨3pxæ‰ç®—æ‹–æ‹½
        fallbackOnBody: true, // å°†æ‹–æ‹½å…ƒç´ è¿½åŠ åˆ° bodyï¼Œé¿å… overflow é—®é¢˜
        
        ghostClass: 'sortable-ghost', // å ä½ç¬¦æ ·å¼ç±» (æ‹–æ‹½åŸä½ç½®çš„è™šå½±)
        dragClass: 'sortable-drag',   // æ‹–æ‹½ä¸­å…ƒç´ æ ·å¼ç±» (è·Ÿéšé¼ æ ‡çš„é‚£ä¸ª)
        chosenClass: 'sortable-chosen', // é€‰ä¸­é¡¹æ ·å¼
        
        easing: "cubic-bezier(0.2, 0.8, 0.2, 1)", // iOS é£æ ¼ç¼“åŠ¨

        // æ»šåŠ¨é…ç½®ä¼˜åŒ–
        scroll: true, 
        scrollSensitivity: 60, // è·ç¦»è¾¹ç¼˜å¤šå°‘åƒç´ å¼€å§‹æ»šåŠ¨
        scrollSpeed: 15, // æ»šåŠ¨é€Ÿåº¦
        
        onStart: function (evt) {
            // éœ‡åŠ¨åé¦ˆ
            if (navigator.vibrate) navigator.vibrate(50);
            // æ‹–æ‹½å¼€å§‹æ—¶ï¼Œç»™ body æ·»åŠ ç±»ä»¥ä¾¿æ§åˆ¶å…¨å±€å…‰æ ‡
            document.body.classList.add('dragging-mode');
        },
        onEnd: function (evt) {
            saveDesktopOrder();
            document.body.classList.remove('dragging-mode');
        }
    });
}

async function saveDesktopOrder() {
    const grid = document.getElementById('app-grid');
    // è·å–å½“å‰é¡ºåºçš„æ‰€æœ‰å­å…ƒç´ ID
    const order = Array.from(grid.children)
        .map(child => child.id)
        .filter(id => id); // è¿‡æ»¤æ‰æ²¡æœ‰IDçš„å…ƒç´ 
    
    // ä¿å­˜åˆ° Dexie
    try {
        await db.dexiData.put({ key: 'desktopOrder', value: JSON.stringify(order) });
        console.log('[Desktop] Order saved');
    } catch (e) {
        console.error('[Desktop] Failed to save order', e);
    }
}

async function restoreDesktopOrder() {
    try {
        const record = await db.dexiData.get('desktopOrder');
        if (!record || !record.value) return;
        
        const order = JSON.parse(record.value);
        const grid = document.getElementById('app-grid');
        if (!grid) return;
        
        // åˆ›å»ºç°æœ‰å…ƒç´ çš„æ˜ å°„
        const elements = {};
        Array.from(grid.children).forEach(el => {
            if (el.id) elements[el.id] = el;
        });
        
        // åˆ›å»ºæ–‡æ¡£ç‰‡æ®µä»¥ä¼˜åŒ–æ€§èƒ½
        const fragment = document.createDocumentFragment();
        
        // æŒ‰ä¿å­˜çš„é¡ºåºé‡æ–°æ·»åŠ 
        order.forEach(id => {
            const el = elements[id];
            if (el) {
                fragment.appendChild(el);
                delete elements[id]; // æ ‡è®°å·²å¤„ç†
            }
        });
        
        // æ·»åŠ å‰©ä½™çš„å…ƒç´ ï¼ˆå¦‚æœæœ‰æ–°å¢çš„å›¾æ ‡ï¼‰
        Object.values(elements).forEach(el => {
            fragment.appendChild(el);
        });
        
        grid.appendChild(fragment);
        console.log('[Desktop] Order restored');
    } catch (e) {
        console.error('[Desktop] Failed to restore desktop order', e);
    }
}

/* =================
   æœåŠ¡é¡µé¢é€»è¾‘ (ä¼˜åŒ–åŠ¨ç”»ç‰ˆ)
   ================= */

function showServicePage() {
    const page = document.getElementById('service-main-page');
    page.style.display = 'flex';
    page.offsetHeight; 
    page.classList.add('slide-in');
}

function hideServicePage() {
    const page = document.getElementById('service-main-page');
    page.classList.remove('slide-in');
}

// =================
//  æ‰‹æœºå……å€¼åŠŸèƒ½
// =================

// ç”Ÿæˆè™šæ‹Ÿç”µè¯å·ç ï¼ˆå…¨å±€å‡½æ•°ï¼‰
function generateVirtualPhoneNumber(id) {
    // ç®€å•å“ˆå¸Œç”Ÿæˆä¸€ä¸ªä¼ªå·ç 
    let hash = 0;
    for (let i = 0; i < String(id).length; i++) {
        hash = (hash << 5) - hash + String(id).charCodeAt(i);
        hash |= 0;
    }
    return '13' + Math.abs(hash).toString().substring(0, 9).padEnd(9, '0');
}

// ä½™é¢ç®¡ç†
function getPhoneBalance() {
    const balance = localStorage.getItem('phone_balance');
    return balance ? parseFloat(balance) : 50.0; // é»˜è®¤50å…ƒ
}

function setPhoneBalance(amount) {
    localStorage.setItem('phone_balance', amount.toFixed(2));
}

function addPhoneBalance(amount) {
    const current = getPhoneBalance();
    setPhoneBalance(current + amount);
    return getPhoneBalance();
}

function deductPhoneBalance(amount) {
    const current = getPhoneBalance();
    if (current < amount) {
        return false; // ä½™é¢ä¸è¶³
    }
    setPhoneBalance(current - amount);
    return true;
}

// å……å€¼è®°å½•ç®¡ç†
function getRechargeHistory() {
    return JSON.parse(localStorage.getItem('phone_recharge_history') || '[]');
}

function addRechargeRecord(amount) {
    const history = getRechargeHistory();
    history.unshift({
        amount: amount,
        time: Date.now(),
        date: new Date().toLocaleString('zh-CN')
    });
    // åªä¿ç•™æœ€è¿‘20æ¡
    if (history.length > 20) {
        history.pop();
    }
    localStorage.setItem('phone_recharge_history', JSON.stringify(history));
}

// æ˜¾ç¤ºå……å€¼é¡µé¢
async function showPhoneRechargePage() {
    const page = document.getElementById('phone-recharge-page');
    page.style.display = 'flex';
    page.offsetHeight;
    page.classList.add('slide-in');
    
    // è·å–å½“å‰è´¦å·çš„æ‰‹æœºå·
    const accountId = getCurrentAccountId();
    let phoneNumber = 'æœªç»‘å®š';
    if (accountId) {
        const myChar = await db.characters.get(parseInt(accountId));
        if (myChar) {
            phoneNumber = myChar.identity?.phone || generateVirtualPhoneNumber(myChar.id);
        }
    }
    
    // æ›´æ–°é¡µé¢ä¿¡æ¯
    document.getElementById('recharge-phone-number').textContent = phoneNumber;
    updateRechargePage();
}

function hidePhoneRechargePage() {
    const page = document.getElementById('phone-recharge-page');
    page.classList.remove('slide-in');
    setTimeout(() => {
        page.style.display = 'none';
    }, 300);
}

// æ›´æ–°å……å€¼é¡µé¢æ˜¾ç¤º
function updateRechargePage() {
    const balance = getPhoneBalance();
    document.getElementById('recharge-balance').textContent = `Â¥${balance.toFixed(2)}`;
    
    // æ›´æ–°å……å€¼è®°å½•
    const history = getRechargeHistory();
    const historyEl = document.getElementById('recharge-history');
    if (history.length === 0) {
        historyEl.textContent = 'æš‚æ— å……å€¼è®°å½•';
        historyEl.style.color = '#999';
    } else {
        historyEl.innerHTML = history.slice(0, 5).map(record => 
            `<div style="display:flex; justify-content:space-between; padding:8px 0; border-bottom:1px solid #f5f5f5;">
                <span>å……å€¼ Â¥${record.amount.toFixed(2)}</span>
                <span style="color:#999; font-size:12px;">${record.date}</span>
            </div>`
        ).join('');
        historyEl.style.color = '#333';
    }
}

// é€‰æ‹©å……å€¼é‡‘é¢
let selectedRechargeAmount = 0;

function selectRechargeAmount(amount) {
    selectedRechargeAmount = amount;
    
    // æ›´æ–°æŒ‰é’®æ ·å¼
    document.querySelectorAll('.recharge-amount-btn').forEach(btn => {
        btn.classList.remove('selected');
        if (parseFloat(btn.dataset.amount) === amount) {
            btn.classList.add('selected');
        }
    });
    
    // å¯ç”¨å……å€¼æŒ‰é’®
    const submitBtn = document.getElementById('recharge-submit-btn');
    submitBtn.disabled = false;
    submitBtn.style.opacity = '1';
    submitBtn.style.cursor = 'pointer';
    submitBtn.textContent = `å……å€¼ Â¥${amount.toFixed(2)}`;
}

// æäº¤å……å€¼
function submitRecharge() {
    if (selectedRechargeAmount <= 0) {
        alert('è¯·é€‰æ‹©å……å€¼é‡‘é¢');
        return;
    }
    
    if (!confirm(`ç¡®è®¤å……å€¼ Â¥${selectedRechargeAmount.toFixed(2)} å—ï¼Ÿ`)) {
        return;
    }
    
    // å¢åŠ ä½™é¢
    const newBalance = addPhoneBalance(selectedRechargeAmount);
    
    // æ·»åŠ å……å€¼è®°å½•
    addRechargeRecord(selectedRechargeAmount);
    
    // æ›´æ–°é¡µé¢
    updateRechargePage();
    
    // é‡ç½®é€‰æ‹©
    selectedRechargeAmount = 0;
    document.querySelectorAll('.recharge-amount-btn').forEach(btn => {
        btn.classList.remove('selected');
    });
    const submitBtn = document.getElementById('recharge-submit-btn');
    submitBtn.disabled = true;
    submitBtn.style.opacity = '0.5';
    submitBtn.style.cursor = 'not-allowed';
    submitBtn.textContent = 'è¯·é€‰æ‹©å……å€¼é‡‘é¢';
    
    alert(`å……å€¼æˆåŠŸï¼å½“å‰ä½™é¢ï¼šÂ¥${newBalance.toFixed(2)}`);
}

// å¯¼å‡ºåˆ°å…¨å±€ä½œç”¨åŸŸ
window.showPhoneRechargePage = showPhoneRechargePage;
window.hidePhoneRechargePage = hidePhoneRechargePage;
window.selectRechargeAmount = selectRechargeAmount;
window.submitRecharge = submitRecharge;

// --- æœ‹å‹åœˆé€»è¾‘ ---
let momentsScrollInit = false;

async function showMomentsPage() {
    const page = document.getElementById('moments-page');
    page.style.display = 'block'; // æœ‹å‹åœˆé¡µé¢æ˜¯ block å¸ƒå±€
    page.offsetHeight; 
    page.classList.add('slide-in');
    
    // åˆå§‹åŒ–æ»šåŠ¨ç›‘å¬
    if (!momentsScrollInit) {
        initMomentsScroll();
        momentsScrollInit = true;
    }
    
    // æ¸²æŸ“ç”¨æˆ·ä¿¡æ¯å’Œå°é¢
    await renderMomentsUserInfo();
    
    // æ¸²æŸ“åˆ—è¡¨
    await renderMomentsList();
}

function hideMomentsPage() {
    const page = document.getElementById('moments-page');
    page.classList.remove('slide-in');
    setTimeout(() => {
        page.style.display = 'none';
    }, 300);
}

function initMomentsScroll() {
    const page = document.getElementById('moments-page');
    const navBar = document.getElementById('moments-nav-bar');
    
    page.addEventListener('scroll', () => {
        if (page.scrollTop > 200) {
            navBar.classList.add('scrolled');
        } else {
            navBar.classList.remove('scrolled');
        }
    });
}

async function renderMomentsUserInfo() {
    // è·å–å½“å‰ User
    let user = null;
    if (currentMyCharId) {
        user = await db.characters.get(parseInt(currentMyCharId));
    }
    
    // å¦‚æœæ²¡æœ‰ Userï¼Œå°è¯•æ‰¾ä¸€ä¸ª
    if (!user) {
        const users = await db.characters.where('type').equals('user').toArray();
        if (users.length > 0) user = users[0];
    }
    
    const nameEl = document.getElementById('moments-user-name');
    const avatarEl = document.getElementById('moments-user-avatar');
    const coverEl = document.getElementById('moments-cover-area');
    
    // ç»™å¤´åƒæ·»åŠ ç‚¹å‡»äº‹ä»¶ï¼Œæ‰“å¼€"æˆ‘çš„æœ‹å‹åœˆ"
    avatarEl.onclick = (e) => {
        e.stopPropagation(); // é˜»æ­¢è§¦å‘å°é¢çš„ç‚¹å‡»äº‹ä»¶
        showMyMomentsPage();
    };
    
    if (user) {
        nameEl.innerText = user.name;
        if (user.avatar) {
            avatarEl.style.backgroundImage = `url(${user.avatar})`;
        } else {
            avatarEl.style.backgroundColor = '#eee';
        }
        
        // å°é¢å›¾ (åªè¯»å–å½“å‰è´¦å·çš„æ•°æ®ï¼Œå®ç°éš”ç¦»)
        const cover = user.identity?.cover;
        if (cover) {
            coverEl.style.backgroundImage = `url(${cover})`;
        } else {
            // å¦‚æœæ²¡è®¾ç½®ï¼Œæ˜¾ç¤ºé»˜è®¤ç°è‰²ï¼Œæ¸…ç©ºå¯èƒ½å­˜åœ¨çš„æ—§å›¾
            coverEl.style.backgroundImage = ''; 
        }
    } else {
        nameEl.innerText = "æœªç™»å½•";
        // æœªç™»å½•æ—¶æ¸…é™¤å°é¢å’Œå¤´åƒ
        avatarEl.style.backgroundImage = '';
        coverEl.style.backgroundImage = '';
    }
}

async function renderMomentsList() {
    const container = document.getElementById('moments-list');
    container.innerHTML = '';
    
    // è·å–å½“å‰è´¦å·ID
    const currentAccountId = currentMyCharId ? parseInt(currentMyCharId) : null;
    if (!currentAccountId) {
        container.innerHTML = `<div style="text-align:center; color:#ccc; margin-top:100px; font-size:14px;">è¯·å…ˆç™»å½•è´¦å·</div>`;
        return;
    }

    // ğŸ¯ ä¿®æ”¹ï¼šè·å–å½“å‰è´¦å·çš„åŠ¨æ€ + æ‰€æœ‰å¥½å‹çš„åŠ¨æ€
    const allChars = await db.characters.toArray();
    const friendIds = allChars
        .filter(char => {
            const status = getFriendStatus(char, currentAccountId);
            return status === 'friend'; // åªæ˜¾ç¤ºå¥½å‹çš„æœ‹å‹åœˆ
        })
        .map(char => char.id);
    
    // åŒ…æ‹¬è‡ªå·±å’Œæ‰€æœ‰å¥½å‹ï¼ˆç»Ÿä¸€è½¬ä¸ºæ•°å­—è¿›è¡Œæ¯”è¾ƒï¼‰
    const visibleUserIds = [currentAccountId, ...friendIds].map(id => parseInt(id));
    
    // è·å–æ‰€æœ‰æœ‹å‹åœˆï¼Œç„¶åè¿‡æ»¤
    let allMoments = await db.moments.toArray();
    let moments = allMoments.filter(m => visibleUserIds.includes(parseInt(m.userId)));
    
    // âœ… æŒ‰ç½®é¡¶å’Œæ—¶é—´æ’åºï¼šç½®é¡¶çš„åœ¨å‰ï¼Œç„¶åæŒ‰æ—¶é—´å€’åºï¼ˆæœ€æ–°çš„åœ¨ä¸Šé¢ï¼‰
    moments.sort((a, b) => {
        // å¦‚æœæ˜¯è‡ªå·±å‘çš„ä¸”ç½®é¡¶äº†ï¼Œæ’åœ¨æœ€å‰é¢
        const aIsPinned = (parseInt(a.userId) === currentAccountId && a.pinned);
        const bIsPinned = (parseInt(b.userId) === currentAccountId && b.pinned);
        
        if (aIsPinned && !bIsPinned) return -1;
        if (bIsPinned && !aIsPinned) return 1;
        
        // éƒ½æ˜¯ç½®é¡¶æˆ–éƒ½ä¸æ˜¯ç½®é¡¶ï¼ŒæŒ‰æ—¶é—´å€’åºï¼ˆæ–°çš„åœ¨å‰ï¼‰
        return (b.time || 0) - (a.time || 0);
    });
    
    if (moments.length === 0) {
        container.innerHTML = `<div style="text-align:center; color:#ccc; margin-top:100px; font-size:14px;">æš‚æ— åŠ¨æ€</div>`;
        return;
    }
    
    // è·å–æ‰€æœ‰è§’è‰²ä¿¡æ¯ç¼“å­˜ï¼Œé¿å…å¾ªç¯æŸ¥è¯¢
    const chars = await db.characters.toArray();
    const charMap = {};
    chars.forEach(c => charMap[c.id] = c);
    
    for (const m of moments) {
        const char = charMap[m.userId]; // userId å¯èƒ½æ˜¯ number æˆ– string
        if (!char) continue;
        
        const div = document.createElement('div');
        div.className = 'moment-item';
        
        // å›¾ç‰‡ç½‘æ ¼ HTML
        let imagesHtml = '';
        if (m.images && m.images.length > 0) {
            let gridClass = 'cols-3';
            if (m.images.length === 1) gridClass = 'cols-1';
            else if (m.images.length === 2 || m.images.length === 4) gridClass = 'cols-2';
            
            imagesHtml = `<div class="moment-grid ${gridClass}">
                ${m.images.map(img => `<div class="moment-img" style="background-image:url(${img})" onclick="previewImage('${img}')"></div>`).join('')}
            </div>`;
        }
        
        // æ—¶é—´æ ¼å¼åŒ–
        const date = new Date(m.time);
        const timeStr = `${date.getMonth()+1}æœˆ${date.getDate()}æ—¥ ${date.getHours()}:${date.getMinutes().toString().padStart(2,'0')}`;
        
        // åˆ é™¤æŒ‰é’® (å¦‚æœæ˜¯è‡ªå·±å‘çš„)
        const isSelf = (currentMyCharId && parseInt(currentMyCharId) == m.userId);
        const delBtn = isSelf ? `<span class="moment-delete" onclick="deleteMoment(${m.id})">åˆ é™¤</span>` : '';
        
        // ç½®é¡¶æ ‡è¯†ï¼ˆåªæœ‰è‡ªå·±å‘çš„ä¸”ç½®é¡¶äº†æ‰æ˜¾ç¤ºï¼‰
        const pinnedBadge = (isSelf && m.pinned) ? `<span style="display:inline-block; background:#ffc107; color:#fff; font-size:10px; padding:2px 6px; border-radius:3px; margin-left:6px;">ç½®é¡¶</span>` : '';

        // å¤„ç†ç‚¹èµæ˜¾ç¤º
        let likesHtml = '';
        // æ£€æŸ¥æˆ‘æ˜¯å¦ç‚¹èµ
        // likes: [{userId, name}]
        const myLikeIndex = (m.likes || []).findIndex(l => l.userId == currentMyCharId);
        const isLiked = myLikeIndex !== -1;
        
        if (m.likes && m.likes.length > 0) {
            const names = m.likes.map(l => l.name);
            likesHtml = names.join('ï¼Œ');
        }

        // å¤„ç†è¯„è®ºæ˜¾ç¤º
        let commentsHtml = '';
        if (m.comments && m.comments.length > 0) {
            commentsHtml = m.comments.map(c => `
                <div class="comment-item">
                    <span class="comment-user">${c.name}</span>ï¼š<span class="comment-content">${escapeHtml(c.content)}</span>
                </div>
            `).join('');
        }

        const hasLikes = m.likes && m.likes.length > 0;
        const hasComments = m.comments && m.comments.length > 0;
        
        div.innerHTML = `
            <div class="moment-avatar" style="background-image:url(${char.avatar})"></div>
            <div class="moment-content">
                <div class="moment-name">${char.name}${pinnedBadge}</div>
                <div class="moment-text">${escapeHtml(m.content || '')}</div>
                ${imagesHtml}
                <div class="moment-meta">
                    <div style="display:flex; align-items:center;">
                        <span class="moment-time">${timeStr}</span>
                        ${delBtn}
                    </div>
                    <div class="moment-action-area">
                        <!-- å¼¹å‡ºèœå• -->
                        <div class="moment-popup-menu ins-style" id="moment-menu-${m.id}">
                            <div class="moment-menu-item" onclick="likeMoment(${m.id})">
                                <svg viewBox="0 0 24 24"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"></path></svg>
                                <span>${isLiked ? 'å–æ¶ˆ' : 'èµ'}</span>
                            </div>
                            <div class="moment-menu-divider"></div>
                            <div class="moment-menu-item" onclick="commentMoment(${m.id})">
                                <svg viewBox="0 0 24 24"><path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path></svg>
                                <span>è¯„è®º</span>
                            </div>
                        </div>
                        <div class="moment-action-btn" onclick="toggleMomentMenu(${m.id}, event)">
                            <div class="moment-action-dot"></div>
                            <div class="moment-action-dot"></div>
                        </div>
                    </div>
                </div>
                <!-- äº’åŠ¨åŒº -->
                <div class="moment-interactions" style="display: ${hasLikes || hasComments ? 'block' : 'none'}">
                    <div class="moment-likes" style="display: ${hasLikes ? 'flex' : 'none'}">
                        <svg viewBox="0 0 24 24"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"></path></svg>
                        <span>${likesHtml}</span>
                    </div>
                    <div class="moment-comments" style="display: ${hasComments ? 'block' : 'none'}">
                        ${commentsHtml}
                    </div>
                </div>
            </div>
        `;
        container.appendChild(div);
    }
}

// å°é¢æ›´æ¢
function changeMomentsCover() {
    document.getElementById('moments-cover-input').click();
}

function handleCoverChange(input) {
    const file = input.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = async (e) => {
        const base64 = e.target.result;
        document.getElementById('moments-cover-area').style.backgroundImage = `url(${base64})`;
        
        // ä¿å­˜åˆ°å½“å‰ User
        if (currentMyCharId) {
            const user = await db.characters.get(parseInt(currentMyCharId));
            if (user) {
                if (!user.identity) user.identity = {};
                user.identity.cover = base64;
                await db.characters.put(user);
            }
        }
        // åŒæ—¶ä¹Ÿå­˜ä¸€ä»½æœ¬åœ°ç¼“å­˜ï¼Œä½œä¸ºå…œåº•
        localStorage.setItem('moments_cover', base64);
    };
    reader.readAsDataURL(file);
    input.value = '';
}

// å‘å¸ƒåŠ¨æ€é€»è¾‘
let currentMomentPrivacy = 'public'; // é»˜è®¤å…¬å¼€

function showMomentsPublish() {
    document.getElementById('moments-publish-page').style.display = 'block';
    // æ¸…ç©º
    document.getElementById('moments-pub-text').value = '';
    const grid = document.getElementById('moments-pub-grid');
    // ä¿ç•™æ·»åŠ æŒ‰é’®ï¼Œç§»é™¤å›¾ç‰‡
    Array.from(grid.children).forEach(child => {
        if (!child.classList.contains('moments-add-btn')) {
            child.remove();
        }
    });
    window.tempPubImages = [];
    // é‡ç½®æƒé™ä¸ºå…¬å¼€
    currentMomentPrivacy = 'public';
    selectedPrivacyFriends = [];
    document.getElementById('privacy-selected-text').textContent = 'å…¬å¼€';
}

function hideMomentsPublish() {
    document.getElementById('moments-publish-page').style.display = 'none';
}

// æƒé™é€‰æ‹©ç›¸å…³
function showPrivacySelector() {
    document.getElementById('privacy-selector-page').style.display = 'block';
    // æ›´æ–°é€‰ä¸­çŠ¶æ€
    updatePrivacyCheckmarks();
}

function hidePrivacySelector() {
    document.getElementById('privacy-selector-page').style.display = 'none';
}

function selectPrivacy(value, text) {
    currentMomentPrivacy = value;
    document.getElementById('privacy-selected-text').textContent = text;
    updatePrivacyCheckmarks();
    hidePrivacySelector();
}

function updatePrivacyCheckmarks() {
    const options = ['public', 'private'];
    options.forEach(opt => {
        const checkEl = document.getElementById(`privacy-check-${opt}`);
        if (checkEl) {
            checkEl.textContent = (opt === currentMomentPrivacy) ? 'âœ“' : '';
        }
    });
    // æ›´æ–°éƒ¨åˆ†å¯è§å’Œä¸ç»™è°çœ‹çš„æè¿°
    const partialDesc = document.getElementById('partial-desc');
    const excludeDesc = document.getElementById('exclude-desc');
    if (partialDesc) {
        if (currentMomentPrivacy === 'partial' && selectedPrivacyFriends.length > 0) {
            partialDesc.textContent = `å·²é€‰ ${selectedPrivacyFriends.length} äºº`;
        } else {
            partialDesc.textContent = 'é€‰ä¸­çš„æœ‹å‹å¯è§';
        }
    }
    if (excludeDesc) {
        if (currentMomentPrivacy === 'exclude' && selectedPrivacyFriends.length > 0) {
            excludeDesc.textContent = `å·²é€‰ ${selectedPrivacyFriends.length} äºº`;
        } else {
            excludeDesc.textContent = 'é€‰ä¸­çš„æœ‹å‹ä¸å¯è§';
        }
    }
}

// å¥½å‹é€‰æ‹©ç›¸å…³
let selectedPrivacyFriends = []; // é€‰ä¸­çš„å¥½å‹IDåˆ—è¡¨
let currentPrivacyMode = ''; // 'partial' æˆ– 'exclude'

async function showFriendSelector(mode) {
    currentPrivacyMode = mode;
    const page = document.getElementById('friend-selector-page');
    const list = document.getElementById('friend-selector-list');
    const title = document.getElementById('friend-selector-title');
    
    title.textContent = mode === 'partial' ? 'è°å¯ä»¥çœ‹' : 'ä¸ç»™è°çœ‹';
    
    // å¦‚æœåˆ‡æ¢äº†æ¨¡å¼ï¼Œæ¸…ç©ºå·²é€‰æ‹©çš„
    if (currentMomentPrivacy !== mode) {
        selectedPrivacyFriends = [];
    }
    
    // è·å–å¥½å‹åˆ—è¡¨
    const accountId = getCurrentAccountId();
    const allChars = await db.characters.toArray();
    const friends = allChars.filter(char => {
        if (char.id == accountId) return false; // æ’é™¤è‡ªå·±
        const status = getFriendStatus(char, accountId);
        return status === 'friend';
    });
    
    list.innerHTML = '';
    
    if (friends.length === 0) {
        list.innerHTML = '<div style="padding:40px; text-align:center; color:#999;">æš‚æ— å¥½å‹</div>';
    } else {
        for (const friend of friends) {
            const isChecked = selectedPrivacyFriends.includes(friend.id);
            const item = document.createElement('div');
            item.className = 'friend-select-item';
            item.onclick = () => toggleFriendSelection(friend.id);
            item.innerHTML = `
                <div class="friend-select-checkbox ${isChecked ? 'checked' : ''}" id="friend-check-${friend.id}">
                    ${isChecked ? 'âœ“' : ''}
                </div>
                <div class="friend-select-avatar" style="background-image:url(${friend.avatar || ''})"></div>
                <div class="friend-select-name">${friend.remark || friend.name}</div>
            `;
            list.appendChild(item);
        }
    }
    
    page.style.display = 'block';
}

function hideFriendSelector() {
    document.getElementById('friend-selector-page').style.display = 'none';
}

function toggleFriendSelection(friendId) {
    const idx = selectedPrivacyFriends.indexOf(friendId);
    if (idx > -1) {
        selectedPrivacyFriends.splice(idx, 1);
    } else {
        selectedPrivacyFriends.push(friendId);
    }
    
    // æ›´æ–°UI
    const checkEl = document.getElementById(`friend-check-${friendId}`);
    if (checkEl) {
        const isChecked = selectedPrivacyFriends.includes(friendId);
        checkEl.className = `friend-select-checkbox ${isChecked ? 'checked' : ''}`;
        checkEl.textContent = isChecked ? 'âœ“' : '';
    }
}

function confirmFriendSelection() {
    if (selectedPrivacyFriends.length === 0) {
        alert('è¯·è‡³å°‘é€‰æ‹©ä¸€ä½å¥½å‹');
        return;
    }
    
    currentMomentPrivacy = currentPrivacyMode;
    const text = currentPrivacyMode === 'partial' ? `éƒ¨åˆ†å¯è§(${selectedPrivacyFriends.length}äºº)` : `ä¸ç»™è°çœ‹(${selectedPrivacyFriends.length}äºº)`;
    document.getElementById('privacy-selected-text').textContent = text;
    
    hideFriendSelector();
    hidePrivacySelector();
    updatePrivacyCheckmarks();
}

function handlePubImages(input) {
    const files = input.files;
    if (!files || files.length === 0) return;
    
    if (!window.tempPubImages) window.tempPubImages = [];
    
    const grid = document.getElementById('moments-pub-grid');
    const addBtn = grid.querySelector('.moments-add-btn');
    
    Array.from(files).forEach(file => {
        const reader = new FileReader();
        reader.onload = e => {
            const base64 = e.target.result;
            window.tempPubImages.push(base64);
            
            const div = document.createElement('div');
            div.className = 'moments-pub-img';
            div.style.backgroundImage = `url(${base64})`;
            div.innerHTML = `<div class="moments-pub-img-del" onclick="removePubImage(this, '${base64}')">Ã—</div>`;
            
            grid.insertBefore(div, addBtn);
        };
        reader.readAsDataURL(file);
    });
    
    input.value = '';
}

function removePubImage(el, base64) {
    el.parentElement.remove();
    const idx = window.tempPubImages.indexOf(base64);
    if (idx > -1) window.tempPubImages.splice(idx, 1);
}

async function doPublishMoment() {
    if (!currentMyCharId) {
        alert("è¯·å…ˆè®¾ç½® User èº«ä»½");
        return;
    }
    
    const text = document.getElementById('moments-pub-text').value.trim();
    const images = window.tempPubImages || [];
    
    if (!text && images.length === 0) {
        alert("å†™ç‚¹ä»€ä¹ˆå§...");
        return;
    }
    
    const momentId = await db.moments.add({
        userId: parseInt(currentMyCharId),
        content: text,
        images: images,
        time: Date.now(),
        ownerUserId: parseInt(currentMyCharId), // æ ‡è®°æ‰€å±è´¦å·
        privacy: currentMomentPrivacy, // ä¿å­˜æƒé™è®¾ç½®
        privacyList: selectedPrivacyFriends.slice(), // ä¿å­˜é€‰ä¸­çš„å¥½å‹åˆ—è¡¨
        likes: [],
        comments: []
    });
    
    hideMomentsPublish();
    renderMomentsList();
    renderMyMomentsList();
    
    // æ»šåŠ¨åˆ°é¡¶éƒ¨
    document.getElementById('moments-page').scrollTop = 0;
    
    // âœ… è§¦å‘å¥½å‹è‡ªåŠ¨ç‚¹èµè¯„è®ºï¼ˆå»¶è¿Ÿæ‰§è¡Œï¼Œæ¨¡æ‹ŸçœŸå®åœºæ™¯ï¼‰
    setTimeout(() => {
        generateFriendInteractions(momentId, currentMomentPrivacy, selectedPrivacyFriends.slice());
    }, 2000);
}

// âœ… ç”Ÿæˆå¥½å‹è‡ªåŠ¨ç‚¹èµè¯„è®ºï¼ˆè°ƒç”¨AIï¼‰
async function generateFriendInteractions(momentId, privacy, privacyList) {
    try {
        const moment = await db.moments.get(momentId);
        if (!moment) return;
        
        const accountId = getCurrentAccountId();
        const myChar = await db.characters.get(parseInt(currentMyCharId));
        const myName = myChar?.name || 'æˆ‘';
        
        // è·å–æ‰€æœ‰å¥½å‹
        const allChars = await db.characters.toArray();
        let friends = allChars.filter(c => {
            if (c.type === 'user') return false;
            const status = getFriendStatus(c, accountId);
            return status === 'friend';
        });
        
        // âœ… æ ¹æ®æƒé™è¿‡æ»¤å¥½å‹
        if (privacy === 'partial' && privacyList.length > 0) {
            // éƒ¨åˆ†å¯è§ï¼šåªæœ‰ privacyList ä¸­çš„å¥½å‹å¯ä»¥çœ‹åˆ°
            friends = friends.filter(f => privacyList.includes(f.id));
        } else if (privacy === 'exclude' && privacyList.length > 0) {
            // ä¸ç»™è°çœ‹ï¼šæ’é™¤ privacyList ä¸­çš„å¥½å‹
            friends = friends.filter(f => !privacyList.includes(f.id));
        } else if (privacy === 'private') {
            // ç§å¯†ï¼šæ²¡æœ‰å¥½å‹å¯ä»¥çœ‹åˆ°
            friends = [];
        }
        
        if (friends.length === 0) {
            console.log('[æœ‹å‹åœˆäº’åŠ¨] æ²¡æœ‰å¯è§çš„å¥½å‹ï¼Œè·³è¿‡ç”Ÿæˆäº’åŠ¨');
            return;
        }
        
        console.log(`[æœ‹å‹åœˆäº’åŠ¨] å¼€å§‹ç”Ÿæˆï¼Œå¯è§å¥½å‹: ${friends.length}äºº`);
        
        // éšæœºé€‰æ‹©ä¸€äº›å¥½å‹æ¥ç‚¹èµï¼ˆ30%-70%çš„å¯è§å¥½å‹ï¼‰
        const likeRatio = 0.3 + Math.random() * 0.4;
        const shuffledForLikes = [...friends].sort(() => Math.random() - 0.5);
        const likersCount = Math.max(1, Math.floor(shuffledForLikes.length * likeRatio));
        const likers = shuffledForLikes.slice(0, likersCount);
        
        // éšæœºé€‰æ‹©ä¸€äº›å¥½å‹æ¥è¯„è®ºï¼ˆ10%-40%çš„å¯è§å¥½å‹ï¼Œæœ€å¤š5äººï¼‰
        const commentRatio = 0.1 + Math.random() * 0.3;
        const shuffledForComments = [...friends].sort(() => Math.random() - 0.5);
        const commentersCount = Math.min(5, Math.max(1, Math.floor(shuffledForComments.length * commentRatio)));
        const commenters = shuffledForComments.slice(0, commentersCount);
        
        // ç”Ÿæˆç‚¹èµ
        const likes = likers.map(f => ({
            userId: f.id,
            name: f.name
        }));
        
        // âœ… è°ƒç”¨AIç”Ÿæˆè¯„è®º
        const comments = [];
        
        if (commenters.length > 0) {
            try {
                // æ„å»ºè§’è‰²ä¿¡æ¯
                const commenterInfos = commenters.map(c => 
                    `- ${c.name}ï¼š${c.description || c.personality || 'æ™®é€šæœ‹å‹'}`
                ).join('\n');
                
                const prompt = `${myName} å‘äº†ä¸€æ¡æœ‹å‹åœˆï¼š
"${moment.content}"
${moment.images?.length > 0 ? `ï¼ˆé™„å¸¦${moment.images.length}å¼ å›¾ç‰‡ï¼‰` : ''}

ä»¥ä¸‹å¥½å‹çœ‹åˆ°äº†è¿™æ¡æœ‹å‹åœˆï¼Œè¯·ä¸ºæ¯ä¸ªäººç”Ÿæˆä¸€æ¡ç¬¦åˆå…¶æ€§æ ¼çš„è¯„è®ºï¼š
${commenterInfos}

è¦æ±‚ï¼š
1. æ¯æ¡è¯„è®ºç®€çŸ­è‡ªç„¶ï¼ˆ3-20å­—ï¼‰
2. å¯ä»¥ç”¨è¡¨æƒ…ã€è¯­æ°”è¯
3. ç¬¦åˆæ¯ä¸ªè§’è‰²çš„æ€§æ ¼ç‰¹ç‚¹
4. å¯ä»¥äº’ç›¸@å›å¤ï¼ˆæ ¼å¼ï¼šå›å¤ æŸæŸï¼šå†…å®¹ï¼‰

è¯·è¿”å›JSONæ•°ç»„æ ¼å¼ï¼š
[{"name": "è§’è‰²å", "content": "è¯„è®ºå†…å®¹"}, ...]`;

                const result = await callAI([
                    { role: 'system', content: 'ä½ æ˜¯ä¸€ä¸ªç¤¾äº¤åª’ä½“è¯„è®ºç”ŸæˆåŠ©æ‰‹ï¼Œåªè¿”å›JSONæ•°ç»„ï¼Œä¸è¦ä»»ä½•å…¶ä»–æ–‡å­—ã€‚' },
                    { role: 'user', content: prompt }
                ]);
                
                // è§£æç»“æœ
                let aiComments = [];
                try {
                    let cleanResult = result.trim();
                    if (cleanResult.startsWith('```')) {
                        cleanResult = cleanResult.replace(/```json?\n?/g, '').replace(/```$/g, '').trim();
                    }
                    aiComments = JSON.parse(cleanResult);
                } catch (e) {
                    console.warn('[æœ‹å‹åœˆäº’åŠ¨] AIè¯„è®ºè§£æå¤±è´¥ï¼Œä½¿ç”¨é¢„è®¾è¯„è®º');
                }
                
                // å°†AIç”Ÿæˆçš„è¯„è®ºæ·»åŠ åˆ°åˆ—è¡¨
                for (const aiComment of aiComments) {
                    const commenter = commenters.find(c => c.name === aiComment.name);
                    if (commenter && aiComment.content) {
                        comments.push({
                            userId: commenter.id,
                            name: commenter.name,
                            content: aiComment.content,
                            time: Date.now() + Math.random() * 60000
                        });
                    }
                }
                
            } catch (apiError) {
                console.warn('[æœ‹å‹åœˆäº’åŠ¨] AIè°ƒç”¨å¤±è´¥ï¼Œä½¿ç”¨é¢„è®¾è¯„è®º:', apiError);
            }
        }
        
        // å¦‚æœAIç”Ÿæˆå¤±è´¥ï¼Œä½¿ç”¨é¢„è®¾è¯„è®º
        if (comments.length === 0 && commenters.length > 0) {
            const presetComments = [
                'ğŸ‘', 'â¤ï¸', 'å¤ªæ£’äº†ï¼', 'çœŸå¥½çœ‹~', 'å“‡ï¼', 'èµï¼',
                'ç¾¡æ…•ï¼', 'å‰å®³å•Š', 'å¤ªç¾äº†', 'ğŸ”¥', 'ç»äº†', 'çˆ±äº†'
            ];
            for (const commenter of commenters) {
                comments.push({
                    userId: commenter.id,
                    name: commenter.name,
                    content: presetComments[Math.floor(Math.random() * presetComments.length)],
                    time: Date.now() + Math.random() * 60000
                });
            }
        }
        
        // æ›´æ–°æœ‹å‹åœˆ
        moment.likes = likes;
        moment.comments = comments;
        await db.moments.put(moment);
        
        console.log(`[æœ‹å‹åœˆäº’åŠ¨] ç”Ÿæˆå®Œæˆ: ${likes.length}ä¸ªç‚¹èµ, ${comments.length}æ¡è¯„è®º`);
        
        // åˆ·æ–°æ˜¾ç¤º
        renderMomentsList();
        
    } catch (error) {
        console.error('[æœ‹å‹åœˆäº’åŠ¨] ç”Ÿæˆå¤±è´¥:', error);
    }
}

async function deleteMoment(id) {
    if (confirm("ç¡®å®šåˆ é™¤è¿™æ¡åŠ¨æ€å—ï¼Ÿ")) {
        await db.moments.delete(id);
        renderMomentsList();
    }
}

// ğŸ¯ è§’è‰²å‘å¸ƒæœ‹å‹åœˆï¼ˆç”±AIè§¦å‘ï¼‰
async function publishMomentsByCharacter(char, content, imageCount = 0) {
    // ç”Ÿæˆè™šæ‹Ÿå›¾ç‰‡URLï¼ˆå¦‚æœéœ€è¦ï¼‰
    const images = [];
    for (let i = 0; i < imageCount && i < 9; i++) {
        // ä½¿ç”¨Unsplashéšæœºå›¾ç‰‡
        images.push(`https://source.unsplash.com/random/400x400?sig=${Date.now()}_${i}`);
    }
    
    // è·å–å½“å‰ç”¨æˆ·IDï¼ˆç”¨äºownerUserIdï¼Œç¡®ä¿æ•°æ®éš”ç¦»æ­£ç¡®ï¼‰
    const currentAccountId = getCurrentAccountId();
    
    await db.moments.add({
        userId: char.id, // å‘å¸ƒè€…æ˜¯è§’è‰²
        content: content,
        images: images,
        time: Date.now(),
        ownerUserId: currentAccountId || char.id, // å±äºå½“å‰ç”¨æˆ·çš„æœ‹å‹åœˆç©ºé—´
        likes: [],
        comments: []
    });
    
    console.log(`[Moments] ${char.name} å‘å¸ƒäº†æœ‹å‹åœˆ: ${content}`);
    
    // å¦‚æœå½“å‰åœ¨æœ‹å‹åœˆé¡µé¢ï¼Œåˆ·æ–°åˆ—è¡¨
    const momentsPage = document.getElementById('moments-page');
    if (momentsPage && momentsPage.style.display !== 'none') {
        renderMomentsList();
    }
}

// ğŸ§ª æµ‹è¯•å‡½æ•°ï¼šæ‰‹åŠ¨è®©å½“å‰èŠå¤©è§’è‰²å‘å¸ƒæœ‹å‹åœˆ
window.testPublishMoments = async function() {
    if (!currentChatCharId) {
        alert('è¯·å…ˆæ‰“å¼€ä¸€ä¸ªèŠå¤©');
        return;
    }
    const char = await db.characters.get(currentChatCharId);
    if (!char) {
        alert('æ‰¾ä¸åˆ°è§’è‰²');
        return;
    }
    
    await publishMomentsByCharacter(char, 'è¿™æ˜¯ä¸€æ¡æµ‹è¯•æœ‹å‹åœˆ~', 1);
    alert('æœ‹å‹åœˆå‘å¸ƒæˆåŠŸï¼è¯·æŸ¥çœ‹æœ‹å‹åœˆé¡µé¢');
};

// ç®€å•çš„é¢„è§ˆå›¾ç‰‡
function previewImage(url) {
    // ç®€å•å…¨å±é¢„è§ˆ
    const div = document.createElement('div');
    div.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);z-index:9999;display:flex;align-items:center;justify-content:center;';
    div.innerHTML = `<img src="${url}" style="max-width:100%;max-height:100%;">`;
    div.onclick = () => div.remove();
    document.body.appendChild(div);
}

// æœ‹å‹åœˆäº¤äº’é€»è¾‘
let activeMomentMenuId = null;

function toggleMomentMenu(id, e) {
    e.stopPropagation(); // é˜»æ­¢å†’æ³¡
    
    // å¦‚æœå·²ç»æ‰“å¼€äº†åˆ«çš„ï¼Œå…ˆå…³é—­åˆ«çš„
    if (activeMomentMenuId && activeMomentMenuId !== id) {
        const prev = document.getElementById(`moment-menu-${activeMomentMenuId}`);
        if (prev) prev.classList.remove('show');
    }
    
    const menu = document.getElementById(`moment-menu-${id}`);
    if (menu) {
        if (menu.classList.contains('show')) {
            menu.classList.remove('show');
            activeMomentMenuId = null;
        } else {
            menu.classList.add('show');
            activeMomentMenuId = id;
            
            // ç»‘å®šä¸€æ¬¡æ€§å…¨å±€ç‚¹å‡»äº‹ä»¶æ¥å…³é—­èœå•
            document.addEventListener('click', closeMomentMenuOutside, { once: true });
        }
    }
}

function closeMomentMenuOutside(e) {
    if (activeMomentMenuId) {
        const menu = document.getElementById(`moment-menu-${activeMomentMenuId}`);
        if (menu && !menu.contains(e.target)) {
            menu.classList.remove('show');
            activeMomentMenuId = null;
        }
    }
}

async function likeMoment(id) {
    // ç«‹å³å…³é—­èœå•
    const menu = document.getElementById(`moment-menu-${id}`);
    if (menu) menu.classList.remove('show');
    activeMomentMenuId = null;

    if (!currentMyCharId) return;
    
    const user = await db.characters.get(parseInt(currentMyCharId));
    const moment = await db.moments.get(id);
    
    if (user && moment) {
        if (!moment.likes) moment.likes = [];
        
        const idx = moment.likes.findIndex(l => l.userId == user.id);
        if (idx > -1) {
            // å–æ¶ˆç‚¹èµ
            moment.likes.splice(idx, 1);
        } else {
            // ç‚¹èµ
            moment.likes.push({ userId: user.id, name: user.name });
        }
        
        await db.moments.put(moment);
        renderMomentsList(); // åˆ·æ–°åˆ—è¡¨
    }
}

async function commentMoment(id) {
    // ç«‹å³å…³é—­èœå•
    const menu = document.getElementById(`moment-menu-${id}`);
    if (menu) menu.classList.remove('show');
    activeMomentMenuId = null;

    if (!currentMyCharId) return;
    
    // ä½¿ç”¨ setTimeout è®©èœå•å…ˆå…³é—­ï¼Œå†å¼¹å‡º prompt
    setTimeout(async () => {
        const content = prompt("è¯·è¾“å…¥è¯„è®ºå†…å®¹ï¼š");
        if (content && content.trim()) {
            const user = await db.characters.get(parseInt(currentMyCharId));
            const moment = await db.moments.get(id);
            
            if (user && moment) {
                if (!moment.comments) moment.comments = [];
                
                moment.comments.push({
                    userId: user.id,
                    name: user.name,
                    content: content.trim(),
                    time: Date.now()
                });
                
                await db.moments.put(moment);
                renderMomentsList(); // åˆ·æ–°åˆ—è¡¨
            }
        }
    }, 50);
}

// æ˜¾ç¤º"æˆ‘çš„æœ‹å‹åœˆ"é¡µé¢
async function showMyMomentsPage() {
    const page = document.getElementById('my-moments-page');
    page.style.display = 'block';
    page.offsetHeight;
    page.classList.add('slide-in');
    
    // æ¸²æŸ“ç”¨æˆ·ä¿¡æ¯
    const user = await db.characters.get(parseInt(currentMyCharId));
    if (user) {
        const nameEl = document.getElementById('my-moments-name');
        const avatarEl = document.getElementById('my-moments-avatar');
        const coverEl = document.getElementById('my-moments-cover');
        
        nameEl.innerText = user.name;
        if (user.avatar) {
            avatarEl.style.backgroundImage = `url(${user.avatar})`;
        }
        
        const cover = user.identity?.cover;
        if (cover) {
            coverEl.style.backgroundImage = `url(${cover})`;
        }
    }
    
    // æ¸²æŸ“æœ‹å‹åœˆåˆ—è¡¨ï¼ˆåªæ˜¾ç¤ºè‡ªå·±çš„ï¼‰
    await renderMyMomentsList();
}

function hideMyMomentsPage() {
    const page = document.getElementById('my-moments-page');
    page.classList.remove('slide-in');
    setTimeout(() => {
        page.style.display = 'none';
    }, 300);
}

// æ ¼å¼åŒ–æœ‹å‹åœˆæ—¶é—´
function formatMomentTime(timestamp) {
    const date = new Date(timestamp);
    const now = new Date();
    
    // è®¡ç®—æ—¶é—´å·®
    const diffMs = now - date;
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMs / 3600000);
    const diffDays = Math.floor(diffMs / 86400000);
    
    // å°äº1åˆ†é’Ÿ
    if (diffMins < 1) {
        return 'åˆšåˆš';
    }
    // å°äº1å°æ—¶
    if (diffMins < 60) {
        return `${diffMins}åˆ†é’Ÿå‰`;
    }
    // å°äº24å°æ—¶
    if (diffHours < 24) {
        return `${diffHours}å°æ—¶å‰`;
    }
    // å°äº7å¤©
    if (diffDays < 7) {
        return `${diffDays}å¤©å‰`;
    }
    
    // è¶…è¿‡7å¤©ï¼Œæ˜¾ç¤ºå…·ä½“æ—¥æœŸ
    const year = date.getFullYear();
    const month = date.getMonth() + 1;
    const day = date.getDate();
    const hour = date.getHours();
    const minute = date.getMinutes().toString().padStart(2, '0');
    
    // å¦‚æœæ˜¯ä»Šå¹´ï¼Œä¸æ˜¾ç¤ºå¹´ä»½
    if (year === now.getFullYear()) {
        return `${month}æœˆ${day}æ—¥ ${hour}:${minute}`;
    }
    
    // è·¨å¹´æ˜¾ç¤ºå¹´ä»½
    return `${year}å¹´${month}æœˆ${day}æ—¥`;
}

// æ¸²æŸ“æˆ‘çš„æœ‹å‹åœˆåˆ—è¡¨
async function renderMyMomentsList() {
    const container = document.getElementById('my-moments-list');
    const pinnedContainer = document.getElementById('my-moments-pinned-list');
    const pinnedSection = document.getElementById('my-moments-pinned-section');
    
    container.innerHTML = '';
    pinnedContainer.innerHTML = '';
    
    const currentAccountId = currentMyCharId ? parseInt(currentMyCharId) : null;
    if (!currentAccountId) {
        container.innerHTML = `<div class="wechat-empty-state" style="margin-top:60px;"><div style="color:#999; font-size:14px;">è¯·å…ˆç™»å½•è´¦å·</div></div>`;
        pinnedSection.classList.remove('show');
        return;
    }
    
    // åªè·å–è‡ªå·±å‘çš„æœ‹å‹åœˆ
    const allMoments = await db.moments.toArray();
    let moments = allMoments.filter(m => m.userId == currentAccountId);
    
    // åˆ†ç¦»ç½®é¡¶å’Œæ™®é€šæœ‹å‹åœˆ
    const pinnedMoments = moments.filter(m => m.pinned);
    const normalMoments = moments.filter(m => !m.pinned);
    
    // æŒ‰æ—¶é—´å€’åºæ’åº
    pinnedMoments.sort((a, b) => b.time - a.time);
    normalMoments.sort((a, b) => b.time - a.time);
    
    // è·å–ç”¨æˆ·ä¿¡æ¯
    const user = await db.characters.get(currentAccountId);
    
    // æ¸²æŸ“ç½®é¡¶åŒºåŸŸï¼ˆåªæ˜¾ç¤ºå‰3ä¸ªï¼‰
    if (pinnedMoments.length > 0) {
        pinnedSection.classList.add('show');
        
        // åªæ˜¾ç¤ºå‰3ä¸ªç½®é¡¶å¡ç‰‡
        const displayMoments = pinnedMoments.slice(0, 3);
        for (const moment of displayMoments) {
            const card = createPinnedMomentCard(moment, user);
            pinnedContainer.appendChild(card);
        }
        
        // è®¾ç½®ç®­å¤´ç‚¹å‡»äº‹ä»¶ï¼ˆæŸ¥çœ‹æ‰€æœ‰ç½®é¡¶ï¼‰
        const arrow = pinnedSection.querySelector('.moments-pinned-arrow');
        if (arrow) {
            arrow.onclick = () => showAllPinnedMoments(pinnedMoments, user);
        }
    } else {
        pinnedSection.classList.remove('show');
    }
    
    // æ¸²æŸ“æ™®é€šæœ‹å‹åœˆï¼ˆä¿æŒåŸæ¥çš„å®Œæ•´æ ·å¼ï¼‰
    if (normalMoments.length === 0 && pinnedMoments.length === 0) {
        container.innerHTML = `<div class="wechat-empty-state" style="margin-top:60px;"><div style="color:#999; font-size:14px;">è¿˜æ²¡æœ‰å‘å¸ƒæœ‹å‹åœˆ</div></div>`;
        return;
    }
    
    for (const moment of normalMoments) {
        const itemDiv = createMomentItem(moment, user);
        container.appendChild(itemDiv);
    }
}

// åˆ›å»ºç½®é¡¶æœ‹å‹åœˆå¡ç‰‡ï¼ˆä»¿çœŸå®å¾®ä¿¡æ ·å¼ï¼‰
function createPinnedMomentCard(moment, user) {
    const card = document.createElement('div');
    card.className = 'pinned-moment-card';
    card.onclick = () => showMomentDetail(moment.id);
    
    // å¦‚æœæœ‰å›¾ç‰‡ï¼Œè®¾ç½®ä¸ºèƒŒæ™¯
    if (moment.images && moment.images.length > 0) {
        card.style.backgroundImage = `url(${moment.images[0]})`;
    }
    
    // æ–‡å­—å†…å®¹é¢„è§ˆï¼ˆæ˜¾ç¤ºåœ¨å¡ç‰‡ä¸­å¤®ï¼‰
    const contentText = moment.content || '';
    const shortText = contentText.length > 30 ? contentText.substring(0, 30) + '...' : contentText;
    
    card.innerHTML = `<div class="pinned-moment-text">${shortText}</div>`;
    
    return card;
}

// æ˜¾ç¤ºæ‰€æœ‰ç½®é¡¶æœ‹å‹åœˆé¡µé¢ï¼ˆæ—¶é—´çº¿æ ¼å¼ï¼‰
function showAllPinnedMoments(pinnedMoments, user) {
    const page = document.getElementById('all-pinned-moments-page');
    const list = document.getElementById('all-pinned-list');
    
    list.innerHTML = '';
    
    // æŒ‰å¹´ä»½å’Œæ—¥æœŸåˆ†ç»„
    const groupedByYear = {};
    for (const moment of pinnedMoments) {
        const date = new Date(moment.time);
        const year = date.getFullYear();
        const dateKey = `${date.getMonth() + 1}-${date.getDate()}`; // æœˆ-æ—¥
        
        if (!groupedByYear[year]) groupedByYear[year] = {};
        if (!groupedByYear[year][dateKey]) groupedByYear[year][dateKey] = [];
        groupedByYear[year][dateKey].push(moment);
    }
    
    // æŒ‰å¹´ä»½å€’åºæ¸²æŸ“
    const years = Object.keys(groupedByYear).sort((a, b) => b - a);
    for (const year of years) {
        // å¹´ä»½æ ‡é¢˜
        const yearTitle = document.createElement('div');
        yearTitle.style.cssText = 'font-size:20px; font-weight:700; color:#333; padding:20px 16px 10px;';
        yearTitle.textContent = year + 'å¹´';
        list.appendChild(yearTitle);
        
        // æŒ‰æ—¥æœŸå€’åº
        const dates = Object.keys(groupedByYear[year]).sort((a, b) => {
            const [am, ad] = a.split('-').map(Number);
            const [bm, bd] = b.split('-').map(Number);
            return (bm * 100 + bd) - (am * 100 + ad);
        });
        
        for (const dateKey of dates) {
            const dayMoments = groupedByYear[year][dateKey];
            const item = createPinnedTimelineGroup(dateKey, dayMoments);
            list.appendChild(item);
        }
    }
    
    page.style.display = 'block';
}

// åˆ›å»ºç½®é¡¶é¡µé¢çš„æ—¶é—´çº¿æ¡ç›®ï¼ˆåŒä¸€å¤©çš„åˆå¹¶æ˜¾ç¤ºï¼‰
function createPinnedTimelineGroup(dateKey, moments) {
    const div = document.createElement('div');
    div.style.cssText = 'display:flex; padding:16px; border-bottom:1px solid #f5f5f5;';
    
    const [month, day] = dateKey.split('-');
    
    // æ”¶é›†æ‰€æœ‰å›¾ç‰‡å’Œæ–‡å­—
    let allImages = [];
    let allTexts = [];
    for (const moment of moments) {
        if (moment.images && moment.images.length > 0) {
            allImages = allImages.concat(moment.images);
        }
        if (moment.content) {
            allTexts.push({ id: moment.id, text: moment.content });
        }
    }
    
    // å›¾ç‰‡ç½‘æ ¼ï¼ˆä¸€è¡Œä¸‰ä¸ªï¼‰
    let imagesHtml = '';
    if (allImages.length > 0) {
        imagesHtml = `<div style="display:grid; grid-template-columns:repeat(3, 1fr); gap:4px; margin-bottom:8px;">
            ${allImages.map(img => `<div style="aspect-ratio:1; background-image:url(${img}); background-size:cover; background-position:center; cursor:pointer;" onclick="event.stopPropagation(); previewImage('${img}')"></div>`).join('')}
        </div>`;
    }
    
    // æ–‡å­—å†…å®¹åˆ—è¡¨
    let textsHtml = '';
    for (const item of allTexts) {
        const shortText = item.text.length > 40 ? item.text.substring(0, 40) + '...' : item.text;
        textsHtml += `<div style="font-size:14px; color:#666; line-height:1.6; padding:6px 12px; background:#f8f8f8; border-radius:4px; margin-bottom:6px; cursor:pointer;" onclick="showMomentDetail(${item.id})">${shortText}</div>`;
    }
    
    div.innerHTML = `
        <div style="width:70px; flex-shrink:0; text-align:left;">
            <div style="font-size:28px; font-weight:700; color:#333; line-height:1;">${day.padStart(2, '0')}</div>
            <div style="font-size:12px; color:#999;">${month}æœˆ</div>
        </div>
        <div style="flex:1; min-width:0;">
            ${imagesHtml}
            ${textsHtml}
        </div>
    `;
    
    return div;
}

// éšè—æ‰€æœ‰ç½®é¡¶æœ‹å‹åœˆé¡µé¢
function hideAllPinnedMoments() {
    document.getElementById('all-pinned-moments-page').style.display = 'none';
}

// åˆ›å»ºæœ‹å‹åœˆæ¡ç›®
function createMomentItem(moment, user) {
    const itemDiv = document.createElement('div');
    itemDiv.className = 'moment-item';
    itemDiv.onclick = () => showMomentDetail(moment.id);
    
    // æƒé™æ ‡è¯†
    let privacyText = '';
    if (moment.privacy === 'private') privacyText = 'ç§å¯†';
    else if (moment.privacy === 'friends') privacyText = 'å¥½å‹å¯è§';
    
    const privacyBadge = privacyText ? `<span style="color:#999; font-size:12px; margin-left:8px;">${privacyText}</span>` : '';
    
    // å›¾ç‰‡ç½‘æ ¼
    let imagesHtml = '';
    if (moment.images && moment.images.length > 0) {
        let gridClass = 'cols-3';
        if (moment.images.length === 1) gridClass = 'cols-1';
        else if (moment.images.length === 2 || moment.images.length === 4) gridClass = 'cols-2';
        
        imagesHtml = `<div class="moment-grid ${gridClass}">
            ${moment.images.map(img => `<div class="moment-img" style="background-image:url(${img})" onclick="event.stopPropagation(); previewImage('${img}')"></div>`).join('')}
        </div>`;
    }
    
    itemDiv.innerHTML = `
        <div class="moment-avatar" style="background-image:url(${user?.avatar || ''})"></div>
        <div class="moment-content">
            <div class="moment-name">${user?.name || 'æˆ‘'}${privacyBadge}</div>
            <div class="moment-text">${moment.content}</div>
            ${imagesHtml}
            <div class="moment-meta">
                <span class="moment-time">${formatMomentTime(moment.time)}</span>
            </div>
        </div>
    `;
    
    return itemDiv;
}

// å…¨å±€å˜é‡å­˜å‚¨å½“å‰æŸ¥çœ‹çš„æœ‹å‹åœˆID
let currentMomentId = null;

// æ˜¾ç¤ºæœ‹å‹åœˆè¯¦æƒ…é¡µ
async function showMomentDetail(momentId) {
    currentMomentId = momentId;
    const moment = await db.moments.get(momentId);
    if (!moment) return;
    
    const page = document.getElementById('moment-detail-page');
    const contentDiv = document.getElementById('moment-detail-content');
    const pinSwitch = document.getElementById('moment-pin-switch');
    const privacyText = document.getElementById('moment-privacy-text');
    
    // è·å–ç”¨æˆ·ä¿¡æ¯
    const user = await db.characters.get(moment.userId);
    
    // æ¸²æŸ“å†…å®¹é¢„è§ˆ
    contentDiv.innerHTML = `
        <div style="display:flex; gap:12px; margin-bottom:12px;">
            <div style="width:40px; height:40px; border-radius:50%; background-image:url(${user?.avatar || ''}); background-size:cover; background-position:center; flex-shrink:0;"></div>
            <div style="flex:1;">
                <div style="font-weight:600; margin-bottom:4px;">${user?.name || 'ç”¨æˆ·'}</div>
                <div style="font-size:14px; color:#666; line-height:1.6;">${moment.content}</div>
            </div>
        </div>
        ${moment.images && moment.images.length > 0 ? `
            <div style="display:grid; grid-template-columns:repeat(3, 1fr); gap:4px; margin-top:8px;">
                ${moment.images.map(img => `<div style="padding-bottom:100%; background-image:url(${img}); background-size:cover; background-position:center; border-radius:4px;"></div>`).join('')}
            </div>
        ` : ''}
        <div style="color:#999; font-size:12px; margin-top:8px;">${formatMomentTime(moment.time)}</div>
    `;
    
    // è®¾ç½®ç½®é¡¶å¼€å…³çŠ¶æ€
    pinSwitch.checked = moment.pinned || false;
    
    // è®¾ç½®æƒé™æ˜¾ç¤º
    const privacyMap = {
        'public': 'å…¬å¼€',
        'friends': 'å¥½å‹å¯è§',
        'private': 'ç§å¯†'
    };
    privacyText.innerText = privacyMap[moment.privacy] || 'å…¬å¼€';
    
    page.style.display = 'flex';
    page.offsetHeight;
    page.classList.add('active');
}

function hideMomentDetail() {
    const page = document.getElementById('moment-detail-page');
    page.classList.remove('active');
    setTimeout(() => {
        page.style.display = 'none';
        currentMomentId = null;
    }, 300);
}

// åˆ‡æ¢ç½®é¡¶çŠ¶æ€
async function toggleMomentPin() {
    if (!currentMomentId) return;
    
    const moment = await db.moments.get(currentMomentId);
    if (!moment) return;
    
    moment.pinned = !moment.pinned;
    await db.moments.put(moment);
    
    // æ›´æ–°å¼€å…³çŠ¶æ€
    const pinSwitch = document.getElementById('moment-pin-switch');
    pinSwitch.checked = moment.pinned;
    
    showToast(moment.pinned ? 'å·²ç½®é¡¶' : 'å·²å–æ¶ˆç½®é¡¶');
    
    // åˆ·æ–°åˆ—è¡¨
    await renderMyMomentsList();
}

// æ˜¾ç¤ºæƒé™é€‰é¡¹
async function showMomentPrivacyOptions() {
    if (!currentMomentId) return;
    
    const moment = await db.moments.get(currentMomentId);
    if (!moment) return;
    
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.5);
        display: flex;
        align-items: flex-end;
        justify-content: center;
        z-index: 10000;
    `;
    
    const currentPrivacy = moment.privacy || 'public';
    
    modal.innerHTML = `
        <div style="background: #fff; width: 100%; border-radius: 12px 12px 0 0; padding: 16px; animation: slideUp 0.3s;">
            <div style="text-align: center; font-size: 14px; color: #999; margin-bottom: 16px;">è°å¯ä»¥çœ‹</div>
            <div style="display: flex; flex-direction: column; gap: 1px; background: #f5f5f5; border-radius: 8px; overflow: hidden;">
                <div onclick="setMomentPrivacy('public')" style="background: #fff; padding: 16px; text-align: center; cursor: pointer; ${currentPrivacy === 'public' ? 'color: var(--ins-pink); font-weight: 600;' : ''}">
                    å…¬å¼€
                </div>
                <div onclick="setMomentPrivacy('friends')" style="background: #fff; padding: 16px; text-align: center; cursor: pointer; ${currentPrivacy === 'friends' ? 'color: var(--ins-pink); font-weight: 600;' : ''}">
                    å¥½å‹å¯è§
                </div>
                <div onclick="setMomentPrivacy('private')" style="background: #fff; padding: 16px; text-align: center; cursor: pointer; ${currentPrivacy === 'private' ? 'color: var(--ins-pink); font-weight: 600;' : ''}">
                    ä»…è‡ªå·±å¯è§
                </div>
            </div>
            <button onclick="this.parentElement.parentElement.remove()" style="width: 100%; padding: 14px; background: #f5f5f5; border: none; border-radius: 8px; margin-top: 12px; font-size: 16px;">
                å–æ¶ˆ
            </button>
        </div>
    `;
    
    modal.onclick = (e) => {
        if (e.target === modal) modal.remove();
    };
    
    document.body.appendChild(modal);
}

// è®¾ç½®æœ‹å‹åœˆæƒé™
async function setMomentPrivacy(privacy) {
    if (!currentMomentId) return;
    
    const moment = await db.moments.get(currentMomentId);
    if (!moment) return;
    
    moment.privacy = privacy;
    await db.moments.put(moment);
    
    // æ›´æ–°æ˜¾ç¤º
    const privacyMap = {
        'public': 'å…¬å¼€',
        'friends': 'å¥½å‹å¯è§',
        'private': 'ä»…è‡ªå·±å¯è§'
    };
    document.getElementById('moment-privacy-text').innerText = privacyMap[privacy];
    
    // å…³é—­å¼¹çª—
    const modal = document.querySelector('[style*="rgba(0,0,0,0.5)"]');
    if (modal) modal.remove();
    
    showToast('å·²è®¾ç½®');
    
    // åˆ·æ–°åˆ—è¡¨
    await renderMyMomentsList();
}

// ä»è¯¦æƒ…é¡µåˆ é™¤æœ‹å‹åœˆ
async function deleteMomentFromDetail() {
    if (!currentMomentId) return;
    
    if (confirm('ç¡®å®šåˆ é™¤è¿™æ¡æœ‹å‹åœˆå—ï¼Ÿ')) {
        await db.moments.delete(currentMomentId);
        showToast('å·²åˆ é™¤');
        hideMomentDetail();
        await renderMyMomentsList();
        await renderMomentsList(); // ä¹Ÿåˆ·æ–°ä¸»æœ‹å‹åœˆåˆ—è¡¨
    }
}

function showWalletPage() {
    const walletPage = document.getElementById('wallet-page');
    walletPage.style.display = 'flex';
    walletPage.offsetHeight; 
    walletPage.classList.add('active');
    
    // æ›´æ–°æ˜¾ç¤ºçš„ä½™é¢ (ä» currentMyCharId è·å–)
    updateWalletBalanceDisplay();
}

function hideWalletPage() {
    const walletPage = document.getElementById('wallet-page');
    walletPage.classList.remove('active');
    setTimeout(() => {
        walletPage.style.display = 'none';
    }, 350);
}

// ========== è´¦å•é¡µé¢ ==========
let currentBillFilter = 'all';

function showBillPage() {
    const billPage = document.getElementById('bill-page');
    billPage.style.display = 'flex';
    billPage.offsetHeight;
    billPage.classList.add('active');
    currentBillFilter = 'all';
    renderBillList();
}

function hideBillPage() {
    const billPage = document.getElementById('bill-page');
    billPage.classList.remove('active');
    setTimeout(() => {
        billPage.style.display = 'none';
    }, 350);
}

function filterBills(filter) {
    currentBillFilter = filter;
    // æ›´æ–°æŒ‰é’®çŠ¶æ€
    document.querySelectorAll('.bill-filter-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.filter === filter);
    });
    renderBillList();
}

async function renderBillList() {
    const listEl = document.getElementById('bill-list');
    const emptyEl = document.getElementById('bill-empty');
    
    if (!currentMyCharId) {
        listEl.innerHTML = '';
        emptyEl.style.display = 'block';
        return;
    }
    
    const user = await db.characters.get(parseInt(currentMyCharId));
    let transactions = user?.identity?.transactions || [];
    
    // ç­›é€‰
    if (currentBillFilter === 'income') {
        transactions = transactions.filter(t => t.type === 'income');
    } else if (currentBillFilter === 'expense') {
        transactions = transactions.filter(t => t.type === 'expense');
    }
    
    // æŒ‰æ—¶é—´å€’åº
    transactions = [...transactions].sort((a, b) => b.time - a.time);
    
    if (transactions.length === 0) {
        listEl.innerHTML = '';
        emptyEl.style.display = 'block';
        return;
    }
    
    emptyEl.style.display = 'none';
    
    listEl.innerHTML = transactions.map(t => {
        const isIncome = t.type === 'income';
        const iconSvg = isIncome 
            ? '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 19V5M5 12l7-7 7 7"/></svg>'
            : '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 5v14M5 12l7 7 7-7"/></svg>';
        
        const date = new Date(t.time);
        const timeStr = `${date.getMonth()+1}æœˆ${date.getDate()}æ—¥ ${date.getHours().toString().padStart(2,'0')}:${date.getMinutes().toString().padStart(2,'0')}`;
        
        return `
            <div class="bill-item">
                <div class="bill-icon ${isIncome ? 'income' : 'expense'}">${iconSvg}</div>
                <div class="bill-info">
                    <div class="bill-title">${t.title || (isIncome ? 'æ”¶æ¬¾' : 'è½¬è´¦')}</div>
                    <div class="bill-desc">${t.desc || ''} Â· ${timeStr}</div>
                </div>
                <div class="bill-amount ${isIncome ? 'income' : 'expense'}">${isIncome ? '+' : '-'}Â¥${t.amount}</div>
            </div>
        `;
    }).join('');
}

// æ·»åŠ äº¤æ˜“è®°å½•
async function addTransaction(type, amount, title, desc) {
    if (!currentMyCharId) return;
    
    const user = await db.characters.get(parseInt(currentMyCharId));
    if (!user) return;
    
    if (!user.identity) user.identity = {};
    if (!user.identity.transactions) user.identity.transactions = [];
    
    user.identity.transactions.push({
        type, // 'income' æˆ– 'expense'
        amount: parseFloat(amount).toFixed(2),
        title,
        desc,
        time: Date.now()
    });
    
    // åªä¿ç•™æœ€è¿‘100æ¡è®°å½•
    if (user.identity.transactions.length > 100) {
        user.identity.transactions = user.identity.transactions.slice(-100);
    }
    
    await db.characters.put(user);
}

// ========== äº²å±å¡é¡µé¢ ==========
let selectedFamilyCardFriendId = null;

function showFamilyCardPage() {
    const page = document.getElementById('family-card-page');
    page.style.display = 'flex';
    page.offsetHeight;
    page.classList.add('active');
    renderFamilyCardList();
}

function hideFamilyCardPage() {
    const page = document.getElementById('family-card-page');
    page.classList.remove('active');
    setTimeout(() => {
        page.style.display = 'none';
    }, 350);
}

// æ¸²æŸ“äº²å±å¡åˆ—è¡¨
async function renderFamilyCardList() {
    if (!currentMyCharId) return;
    
    const user = await db.characters.get(parseInt(currentMyCharId));
    if (!user) return;
    
    // æˆ‘èµ é€çš„äº²å±å¡
    const givenCards = user.identity?.familyCardsGiven || [];
    const givenListEl = document.getElementById('family-card-given-list');
    
    if (givenCards.length === 0) {
        givenListEl.innerHTML = '';
    } else {
        let html = '';
        for (const card of givenCards) {
            const char = await db.characters.get(card.charId);
            if (char) {
                const usedThisMonth = card.usedThisMonth || 0;
                const limitText = card.monthlyLimit > 0 ? `å·²ç”¨ Â¥${usedThisMonth.toFixed(2)} / Â¥${card.monthlyLimit}` : `å·²ç”¨ Â¥${usedThisMonth.toFixed(2)} (ä¸é™é¢)`;
                html += `
                    <div class="family-card-item">
                        <div class="family-card-avatar" style="background-image:url(${char.avatar})"></div>
                        <div class="family-card-info">
                            <div class="family-card-name">${char.name}</div>
                            <div class="family-card-detail">${limitText}</div>
                        </div>
                        <div class="family-card-actions">
                            <button class="family-card-btn view" onclick="showFamilyCardRecords(${card.charId}, 'given')">è®°å½•</button>
                            <button class="family-card-btn cancel" onclick="cancelFamilyCard(${card.charId}, 'given')">è§£ç»‘</button>
                        </div>
                    </div>
                `;
            }
        }
        givenListEl.innerHTML = html;
    }
    
    // æˆ‘æ”¶åˆ°çš„äº²å±å¡
    const receivedCards = user.identity?.familyCardsReceived || [];
    const receivedListEl = document.getElementById('family-card-received-list');
    const receivedEmptyEl = document.getElementById('family-card-received-empty');
    
    if (receivedCards.length === 0) {
        receivedListEl.innerHTML = '';
        receivedEmptyEl.style.display = 'block';
    } else {
        receivedEmptyEl.style.display = 'none';
        let html = '';
        for (const card of receivedCards) {
            const char = await db.characters.get(card.charId);
            if (char) {
                const usedThisMonth = card.usedThisMonth || 0;
                const limitText = card.monthlyLimit > 0 ? `æœ¬æœˆå¯ç”¨ Â¥${(card.monthlyLimit - usedThisMonth).toFixed(2)}` : 'ä¸é™é¢';
                html += `
                    <div class="family-card-item">
                        <div class="family-card-avatar" style="background-image:url(${char.avatar})"></div>
                        <div class="family-card-info">
                            <div class="family-card-name">${char.name} çš„äº²å±å¡</div>
                            <div class="family-card-detail">${limitText}</div>
                        </div>
                        <div class="family-card-actions">
                            <button class="family-card-btn view" onclick="showFamilyCardRecords(${card.charId}, 'received')">è®°å½•</button>
                        </div>
                    </div>
                `;
            }
        }
        receivedListEl.innerHTML = html;
    }
}

// æ˜¾ç¤ºèµ é€äº²å±å¡å¼¹çª—
async function showGiveFamilyCardModal() {
    selectedFamilyCardFriendId = null;
    
    const modal = document.getElementById('give-family-card-modal');
    const listEl = document.getElementById('family-card-friend-list');
    
    // è·å–å¥½å‹åˆ—è¡¨
    const user = await db.characters.get(parseInt(currentMyCharId));
    const accountId = getCurrentAccountId();
    const allChars = await db.characters.toArray();
    
    // è¿‡æ»¤å‡ºå¥½å‹ï¼ˆéç”¨æˆ·è§’è‰²ä¸”æ˜¯å¥½å‹çŠ¶æ€ï¼‰
    const friends = allChars.filter(c => {
        if (c.type === 'user') return false;
        const status = getFriendStatus(c, accountId);
        return status === 'friend';
    });
    
    // æ’é™¤å·²ç»èµ é€è¿‡äº²å±å¡çš„
    const givenCards = user?.identity?.familyCardsGiven || [];
    const givenIds = givenCards.map(c => c.charId);
    const availableFriends = friends.filter(f => !givenIds.includes(f.id));
    
    if (availableFriends.length === 0) {
        listEl.innerHTML = '<div style="text-align:center; padding:20px; color:#999;">æ²¡æœ‰å¯èµ é€çš„å¥½å‹</div>';
    } else {
        listEl.innerHTML = availableFriends.map(f => `
            <div class="family-card-friend-item" onclick="selectFamilyCardFriend(${f.id}, this)">
                <div class="family-card-friend-avatar" style="background-image:url(${f.avatar})"></div>
                <div class="family-card-friend-name">${f.name}</div>
                <div class="family-card-friend-check">
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="3">
                        <polyline points="20 6 9 17 4 12"></polyline>
                    </svg>
                </div>
            </div>
        `).join('');
    }
    
    document.getElementById('family-card-limit-input').value = '0';
    modal.style.display = 'flex';
}

function hideGiveFamilyCardModal() {
    document.getElementById('give-family-card-modal').style.display = 'none';
}

function selectFamilyCardFriend(charId, el) {
    // å–æ¶ˆå…¶ä»–é€‰ä¸­
    document.querySelectorAll('.family-card-friend-item').forEach(item => {
        item.classList.remove('selected');
    });
    el.classList.add('selected');
    selectedFamilyCardFriendId = charId;
}

// ç¡®è®¤èµ é€äº²å±å¡
async function confirmGiveFamilyCard() {
    if (!selectedFamilyCardFriendId) {
        showToast('è¯·é€‰æ‹©ä¸€ä¸ªå¥½å‹');
        return;
    }
    
    const limitInput = document.getElementById('family-card-limit-input');
    const monthlyLimit = parseFloat(limitInput.value) || 0;
    
    const user = await db.characters.get(parseInt(currentMyCharId));
    if (!user.identity) user.identity = {};
    if (!user.identity.familyCardsGiven) user.identity.familyCardsGiven = [];
    
    // æ·»åŠ äº²å±å¡è®°å½•
    user.identity.familyCardsGiven.push({
        charId: selectedFamilyCardFriendId,
        monthlyLimit: monthlyLimit,
        usedThisMonth: 0,
        records: [],
        createdAt: Date.now()
    });
    
    await db.characters.put(user);
    
    // åŒæ—¶åœ¨è§’è‰²é‚£è¾¹æ·»åŠ æ”¶åˆ°çš„äº²å±å¡è®°å½•
    const char = await db.characters.get(selectedFamilyCardFriendId);
    if (char) {
        if (!char.identity) char.identity = {};
        if (!char.identity.familyCardsReceived) char.identity.familyCardsReceived = [];
        
        char.identity.familyCardsReceived.push({
            charId: parseInt(currentMyCharId),
            monthlyLimit: monthlyLimit,
            usedThisMonth: 0,
            records: [],
            createdAt: Date.now()
        });
        
        await db.characters.put(char);
        
        // å‘é€äº²å±å¡æ¶ˆæ¯åˆ°èŠå¤©
        const accountId = getCurrentAccountId();
        let history = getChatHistory(char, accountId);
        
        const limitText = monthlyLimit > 0 ? `æ¯æœˆé¢åº¦ Â¥${monthlyLimit}` : 'ä¸é™é¢åº¦';
        const familyCardMsg = {
            role: 'user',
            type: 'familyCard',
            content: JSON.stringify({
                fromName: user.name,
                monthlyLimit: monthlyLimit,
                status: 'sent'
            }),
            time: Date.now()
        };
        
        history.push(familyCardMsg);
        await setChatHistory(char, accountId, history);
    }
    
    hideGiveFamilyCardModal();
    hideFamilyCardPage();
    hideWalletPage();
    
    // å¦‚æœå½“å‰æ­£åœ¨å’Œè¿™ä¸ªè§’è‰²èŠå¤©ï¼Œåˆ·æ–°èŠå¤©ç•Œé¢
    if (currentChatCharId === selectedFamilyCardFriendId) {
        const freshChar = await db.characters.get(selectedFamilyCardFriendId);
        renderChatBody(freshChar);
    }
    
    showToast('å·²èµ é€äº²å±å¡');
}

// å–æ¶ˆäº²å±å¡
async function cancelFamilyCard(charId, type) {
    if (!confirm('ç¡®å®šè¦è§£ç»‘è¿™å¼ äº²å±å¡å—ï¼Ÿ')) return;
    
    const user = await db.characters.get(parseInt(currentMyCharId));
    
    if (type === 'given') {
        // ä»æˆ‘èµ é€çš„åˆ—è¡¨ä¸­ç§»é™¤
        user.identity.familyCardsGiven = (user.identity.familyCardsGiven || []).filter(c => c.charId !== charId);
        await db.characters.put(user);
        
        // ä»å¯¹æ–¹æ”¶åˆ°çš„åˆ—è¡¨ä¸­ç§»é™¤
        const char = await db.characters.get(charId);
        if (char && char.identity) {
            char.identity.familyCardsReceived = (char.identity.familyCardsReceived || []).filter(c => c.charId !== parseInt(currentMyCharId));
            await db.characters.put(char);
        }
    }
    
    renderFamilyCardList();
    showToast('å·²è§£ç»‘äº²å±å¡');
}

// æ˜¾ç¤ºæ¶ˆè´¹è®°å½•
async function showFamilyCardRecords(charId, type) {
    const modal = document.getElementById('family-card-records-modal');
    const titleEl = document.getElementById('family-card-records-title');
    const listEl = document.getElementById('family-card-records-list');
    
    const user = await db.characters.get(parseInt(currentMyCharId));
    const char = await db.characters.get(charId);
    
    let records = [];
    
    if (type === 'given') {
        // æŸ¥çœ‹æˆ‘èµ é€ç»™å¯¹æ–¹çš„æ¶ˆè´¹è®°å½•
        const card = (user.identity?.familyCardsGiven || []).find(c => c.charId === charId);
        records = card?.records || [];
        titleEl.textContent = `${char?.name || 'æœªçŸ¥'} çš„æ¶ˆè´¹è®°å½•`;
    } else {
        // æŸ¥çœ‹æˆ‘ä½¿ç”¨å¯¹æ–¹äº²å±å¡çš„æ¶ˆè´¹è®°å½•
        const card = (user.identity?.familyCardsReceived || []).find(c => c.charId === charId);
        records = card?.records || [];
        titleEl.textContent = `æˆ‘çš„æ¶ˆè´¹è®°å½•`;
    }
    
    if (records.length === 0) {
        listEl.innerHTML = '<div style="text-align:center; padding:30px; color:#999;">æš‚æ— æ¶ˆè´¹è®°å½•</div>';
    } else {
        listEl.innerHTML = [...records].reverse().map(r => {
            const date = new Date(r.time);
            const timeStr = `${date.getMonth()+1}æœˆ${date.getDate()}æ—¥ ${date.getHours().toString().padStart(2,'0')}:${date.getMinutes().toString().padStart(2,'0')}`;
            return `
                <div class="family-card-record-item">
                    <div class="family-card-record-title">${r.desc || 'æ¶ˆè´¹'}</div>
                    <div class="family-card-record-time">${timeStr}</div>
                    <div class="family-card-record-amount">-Â¥${parseFloat(r.amount).toFixed(2)}</div>
                </div>
            `;
        }).join('');
    }
    
    modal.style.display = 'flex';
}

function hideFamilyCardRecordsModal() {
    document.getElementById('family-card-records-modal').style.display = 'none';
}

// è§’è‰²ä½¿ç”¨äº²å±å¡æ¶ˆè´¹ï¼ˆAIè°ƒç”¨ï¼‰
async function charUseFamilyCard(charId, amount, desc) {
    if (!currentMyCharId) return false;
    
    const user = await db.characters.get(parseInt(currentMyCharId));
    if (!user?.identity?.familyCardsGiven) return false;
    
    const cardIndex = user.identity.familyCardsGiven.findIndex(c => c.charId === charId);
    if (cardIndex === -1) return false;
    
    const card = user.identity.familyCardsGiven[cardIndex];
    
    // æ£€æŸ¥é¢åº¦
    if (card.monthlyLimit > 0 && (card.usedThisMonth + amount) > card.monthlyLimit) {
        return false; // è¶…å‡ºé¢åº¦
    }
    
    // æ‰£æ¬¾
    let userBalance = parseFloat(user.identity.balance || 0);
    if (userBalance < amount) return false; // ä½™é¢ä¸è¶³
    
    user.identity.balance = (userBalance - amount).toFixed(2);
    card.usedThisMonth = (card.usedThisMonth || 0) + amount;
    card.records.push({
        amount: amount,
        desc: desc,
        time: Date.now()
    });
    
    await db.characters.put(user);
    
    // åŒæ—¶æ›´æ–°è§’è‰²é‚£è¾¹çš„è®°å½•
    const char = await db.characters.get(charId);
    if (char?.identity?.familyCardsReceived) {
        const charCard = char.identity.familyCardsReceived.find(c => c.charId === parseInt(currentMyCharId));
        if (charCard) {
            charCard.usedThisMonth = (charCard.usedThisMonth || 0) + amount;
            charCard.records.push({
                amount: amount,
                desc: desc,
                time: Date.now()
            });
            await db.characters.put(char);
        }
    }
    
    // æ·»åŠ åˆ°è´¦å•
    await addTransaction('expense', amount, 'äº²å±å¡æ¶ˆè´¹', `${char?.name || 'æœªçŸ¥'} - ${desc}`);
    
    return true;
}

function showBalancePage() {
    const balancePage = document.getElementById('balance-page');
    balancePage.style.display = 'flex';
    balancePage.offsetHeight; 
    balancePage.classList.add('active');
    
    // æ›´æ–°å¤§å­—ä½™é¢
    updateBalancePageDisplay();
}

function hideBalancePage() {
    const balancePage = document.getElementById('balance-page');
    balancePage.classList.remove('active');
    setTimeout(() => {
        balancePage.style.display = 'none';
    }, 350);
    
    // è¿”å›æ—¶åŒæ—¶ä¹Ÿæ›´æ–°ä¸€ä¸‹é’±åŒ…é¡µçš„ä½™é¢æ˜¾ç¤ºï¼Œä»¥é˜²åˆšæ‰ç”Ÿæˆäº†æ–°çš„
    updateWalletBalanceDisplay();
}

// æ›´æ–°é’±åŒ…é¡µçš„å°ä½™é¢æ˜¾ç¤º
async function updateWalletBalanceDisplay() {
    if (!currentMyCharId) return;
    const user = await db.characters.get(parseInt(currentMyCharId));
    if (user && user.identity && user.identity.balance !== undefined) {
        // å‡è®¾ identity.balance å­˜å‚¨çš„æ˜¯æ•°å­—æˆ–å­—ç¬¦ä¸²
        document.querySelector('#wallet-page .item-right span').innerText = `Â¥${user.identity.balance}`;
        // åŒæ—¶æ›´æ–°æœåŠ¡é¡µçš„ä½™é¢
        const serviceBalance = document.querySelector('.header-item .item-subtitle');
        if (serviceBalance) serviceBalance.style.display = 'none'; // éšè—ä½™é¢
    } else {
         document.querySelector('#wallet-page .item-right span').innerText = `Â¥0.00`;
         const serviceBalance = document.querySelector('.header-item .item-subtitle');
         if (serviceBalance) serviceBalance.style.display = 'none'; // éšè—ä½™é¢
    }
}

// æ›´æ–°é›¶é’±é¡µçš„å¤§ä½™é¢æ˜¾ç¤º
async function updateBalancePageDisplay() {
    if (!currentMyCharId) return;
    const user = await db.characters.get(parseInt(currentMyCharId));
    const amountDisplay = document.getElementById('balance-amount-display');
    if (user && user.identity && user.identity.balance !== undefined) {
        amountDisplay.innerText = `Â¥${user.identity.balance}`;
    } else {
        amountDisplay.innerText = `Â¥0.00`;
    }
}

// AIç”Ÿæˆä½™é¢é€»è¾‘
async function generateUserBalance() {
    if (!currentMyCharId) {
        alert("è¯·å…ˆé€‰æ‹©ä¸€ä¸ª User èº«ä»½");
        return;
    }

    const user = await db.characters.get(parseInt(currentMyCharId));
    if (!user) {
        alert("æœªæ‰¾åˆ°è¯¥è§’è‰²ä¿¡æ¯");
        return;
    }
    
    // è°ƒè¯•æ—¥å¿—ï¼šç¡®è®¤è¯»å–åˆ°çš„ç”¨æˆ·ä¿¡æ¯ï¼ˆè¯»å–å®Œæ•´çš„è§’è‰²æ¡£æ¡ˆï¼‰
    console.log('[generateUserBalance] è¯»å–åˆ°çš„å®Œæ•´è§’è‰²æ¡£æ¡ˆ:', user);
    
    // è¯»å–è§’è‰²æè¿°ï¼ˆä½¿ç”¨ description å­—æ®µï¼Œè€Œä¸æ˜¯ descï¼‰
    const characterDescription = user.description || user.desc || '';
    
    // æ£€æŸ¥äººè®¾æè¿°æ˜¯å¦å­˜åœ¨
    if (!characterDescription || characterDescription.trim() === '' || characterDescription === 'æš‚æ— æè¿°') {
        console.warn('[generateUserBalance] è­¦å‘Šï¼šè§’è‰²æè¿°ä¸ºç©ºæˆ–æœªè®¾ç½®');
        const confirmContinue = confirm("âš ï¸ è¯¥è§’è‰²çš„äººè®¾æè¿°ä¸ºç©ºæˆ–æœªè®¾ç½®ï¼Œç”Ÿæˆçš„ä½™é¢å¯èƒ½ä¸å‡†ç¡®ã€‚\n\næ˜¯å¦ç»§ç»­ç”Ÿæˆï¼Ÿ\nï¼ˆå»ºè®®å…ˆå®Œå–„è§’è‰²äººè®¾æè¿°ï¼‰");
        if (!confirmContinue) {
            return;
        }
    }
    
    const btn = document.querySelector('.btn-generate');
    const originalText = btn.innerHTML;
    btn.innerHTML = `<div class="loading-spinner" style="display:inline-block; border-color:var(--ins-pink); border-top-color:transparent;"></div> ç”Ÿæˆä¸­...`;
    btn.disabled = true;

    try {
        // æ„å»ºå®Œæ•´çš„äººè®¾ä¿¡æ¯ï¼ˆè¯»å–å®Œæ•´çš„è§’è‰²æ¡£æ¡ˆï¼‰
        const characterInfo = [];
        characterInfo.push(`è§’è‰²åç§°ï¼š${user.name || 'æœªå‘½å'}`);
        
        if (user.nick) {
            characterInfo.push(`è§’è‰²æ˜µç§°ï¼š${user.nick}`);
        }
        
        // è¯»å–è§’è‰²æè¿°ï¼ˆä¼˜å…ˆä½¿ç”¨ descriptionï¼Œå…¼å®¹ descï¼‰
        if (characterDescription && characterDescription.trim() && characterDescription !== 'æš‚æ— æè¿°') {
            characterInfo.push(`è§’è‰²äººè®¾æè¿°ï¼š${characterDescription.trim()}`);
        } else {
            characterInfo.push(`è§’è‰²äººè®¾æè¿°ï¼šæš‚æ— è¯¦ç»†æè¿°`);
        }
        
        if (user.type) {
            characterInfo.push(`è§’è‰²ç±»å‹ï¼š${user.type}`);
        }
        
        // è¯»å–å®Œæ•´çš„èº«ä»½ä¿¡æ¯
        if (user.identity) {
            if (user.identity.address) {
                characterInfo.push(`å®¶åº­ä½å€ï¼š${user.identity.address}`);
            }
            if (user.identity.bank_card) {
                characterInfo.push(`é“¶è¡Œå¡å·ï¼š${user.identity.bank_card}`);
            }
        }
        
        const fullCharacterInfo = characterInfo.join('\n');
        
        const systemPrompt = `ä½ æ˜¯ä¸€ä¸ªè¾…åŠ©ç”Ÿæˆè§’è‰²è¯¦ç»†è®¾å®šçš„AIåŠ©æ‰‹ã€‚

ä»¥ä¸‹æ˜¯å½“å‰è§’è‰²çš„å®Œæ•´ä¿¡æ¯ï¼š
${fullCharacterInfo}

è¯·ä»”ç»†åˆ†æä¸Šè¿°è§’è‰²çš„äººè®¾ä¿¡æ¯ï¼ˆç‰¹åˆ«æ˜¯è§’è‰²æè¿°ä¸­çš„èƒŒæ™¯ã€èŒä¸šã€ç»æµçŠ¶å†µã€ç¤¾ä¼šåœ°ä½ç­‰ï¼‰ï¼Œç„¶ååˆç†æ¨æ–­è¯¥è§’è‰²å¾®ä¿¡é’±åŒ…é‡Œçš„"é›¶é’±"ä½™é¢ã€‚

é‡è¦æç¤ºï¼š
1. å¿…é¡»ä¸¥æ ¼æ ¹æ®è§’è‰²äººè®¾æ¥ç”Ÿæˆä½™é¢ï¼Œä¸è¦ä½¿ç”¨é»˜è®¤å€¼æˆ–éšæœºå€¼
2. å¦‚æœè§’è‰²æè¿°ä¸­æåˆ°"å¯ŒäºŒä»£"ã€"å¯Œè£•"ã€"æœ‰é’±"ã€"å®¶å¢ƒä¼˜æ¸¥"ç­‰å…³é”®è¯ï¼Œä½™é¢åº”è¯¥è¾ƒé«˜ï¼ˆå‡ ä¸‡åˆ°å‡ åä¸‡ï¼‰
3. å¦‚æœè§’è‰²æè¿°ä¸­æåˆ°"å­¦ç”Ÿ"ã€"æ™®é€š"ã€"å·¥è–ª"ç­‰å…³é”®è¯ï¼Œä½™é¢åº”è¯¥é€‚ä¸­ï¼ˆå‡ ç™¾åˆ°å‡ åƒï¼‰
4. å¦‚æœè§’è‰²æè¿°ä¸­æåˆ°"è´«å›°"ã€"æ‹®æ®"ç­‰å…³é”®è¯ï¼Œä½™é¢åº”è¯¥è¾ƒä½ï¼ˆå‡ ååˆ°å‡ ç™¾ï¼‰
5. åªè¿”å›ä¸€ä¸ªå…·ä½“çš„æ•°å­—é‡‘é¢ï¼Œä¿ç•™ä¸¤ä½å°æ•°ï¼Œä¸è¦åŒ…å«ä»»ä½•å…¶ä»–æ–‡å­—ã€ç¬¦å·æˆ–è¯´æ˜
6. å¦‚æœæ˜¯å¤ä»£/æ¶ç©ºèƒŒæ™¯ï¼Œè¯·è‡ªåŠ¨æ¢ç®—æˆåˆç†çš„ç°ä»£è´§å¸æ•°å€¼

ç¤ºä¾‹ï¼š
- å¯ŒäºŒä»£è§’è‰²ï¼šåº”è¿”å› 50000.00 æˆ–æ›´é«˜
- æ™®é€šå­¦ç”Ÿï¼šåº”è¿”å› 1500.00 å·¦å³
- æ™®é€šæ‰“å·¥äººï¼šåº”è¿”å› 3000.00 å·¦å³`;

        console.log('[generateUserBalance] å‘é€ç»™AIçš„Prompt:', systemPrompt);
        
        const amountStr = await callAI([
            { role: "system", content: systemPrompt },
            { role: "user", content: "è¯·æ ¹æ®ä¸Šè¿°è§’è‰²äººè®¾ä¿¡æ¯ï¼Œç”Ÿæˆç¬¦åˆè¯¥è§’è‰²ç»æµçŠ¶å†µçš„å¾®ä¿¡é›¶é’±ä½™é¢ã€‚åªè¿”å›æ•°å­—é‡‘é¢ï¼Œä¿ç•™ä¸¤ä½å°æ•°ã€‚" }
        ]);
        
        console.log('[generateUserBalance] AIè¿”å›çš„åŸå§‹å†…å®¹:', amountStr);

        // æå–æ•°å­—
        const match = amountStr.match(/[\d,]+\.\d{2}/) || amountStr.match(/\d+/);
        let balance = "0.00";
        if (match) {
            balance = match[0];
        } else {
            // å…œåº•å°è¯•æ¸…ç†éæ•°å­—å­—ç¬¦
             balance = amountStr.replace(/[^\d.]/g, '');
        }

        // ä¿å­˜åˆ°æ•°æ®åº“
        if (!user.identity) user.identity = {};
        user.identity.balance = balance;
        await db.characters.put(user);

        // æ›´æ–°ç•Œé¢
        document.getElementById('balance-amount-display').innerText = `Â¥${balance}`;
        updateWalletBalanceDisplay(); // åŒæ­¥æ›´æ–°ä¸Šä¸€é¡µ

        // ç®€æ˜“ Toast
        const tip = document.getElementById('save-tip');
        tip.innerText = "ä½™é¢å·²ç”Ÿæˆ";
        tip.style.display = 'block';
        setTimeout(() => { 
            tip.style.display = 'none'; 
            tip.innerText = "ä¿å­˜æˆåŠŸï¼"; // è¿˜åŸé»˜è®¤æ–‡æœ¬
        }, 1500);

    } catch (e) {
        console.error(e);
        const tip = document.getElementById('save-tip');
        tip.innerText = "ç”Ÿæˆå¤±è´¥";
        tip.style.display = 'block';
        setTimeout(() => { tip.style.display = 'none'; }, 1500);
    } finally {
        btn.innerHTML = originalText;
        btn.disabled = false;
    }
}


/* =================
   è½¬è´¦åŠŸèƒ½é€»è¾‘
   ================= */

// ç®€æ˜“Toastå‡½æ•° (å¦‚æœæ²¡æœ‰å®šä¹‰çš„è¯)
function showToast(message) {
    const tip = document.getElementById('save-tip');
    if (tip) {
        tip.innerText = message;
        tip.style.display = 'block';
        setTimeout(() => { 
            tip.style.display = 'none'; 
            tip.innerText = "ä¿å­˜æˆåŠŸï¼"; // è¿˜åŸé»˜è®¤æ–‡æœ¬
        }, 1500);
    } else {
        alert(message);
    }
}

// æ‰“å¼€è½¬è´¦é¡µé¢
async function showTransferPage() {
    // å…³é—­æ›´å¤šé¢æ¿
    closeChatPanel();
    
    // åˆ¤æ–­æ˜¯å¦æ˜¯ç¾¤èŠ
    if (window.currentGroupChatId) {
        // ç¾¤èŠï¼šæ˜¾ç¤ºè½¬è´¦ç±»å‹é€‰æ‹©å¼¹çª—
        document.getElementById('group-transfer-type-modal').style.display = 'flex';
        return;
    }
    
    if (!currentChatCharId) {
        showToast("è¯·å…ˆè¿›å…¥èŠå¤©");
        return;
    }
    
    // è·å–å½“å‰èŠå¤©å¯¹è±¡ä¿¡æ¯
    const chatChar = await db.characters.get(currentChatCharId);
    if (!chatChar) return;
    
    document.getElementById('t-target-name').innerText = chatChar.name;
    document.getElementById('t-target-avatar').style.backgroundImage = 'url(' + chatChar.avatar + ')';
    
    // é‡ç½®è¾“å…¥
    document.getElementById('t-amount-input').value = '';
    document.getElementById('t-note-input').value = '';
    document.getElementById('btn-do-transfer').disabled = true;
    
    const page = document.getElementById('transfer-page');
    page.style.display = 'flex';
}

function hideTransferPage() {
    document.getElementById('transfer-page').style.display = 'none';
}

/* =================
   ç¾¤çº¢åŒ…åŠŸèƒ½
   ================= */

let currentRedPacketType = 'lucky'; // é»˜è®¤æ‹¼æ‰‹æ°”çº¢åŒ…

// æ˜¾ç¤ºç¾¤çº¢åŒ…é¡µé¢
function showGroupRedPacketPage() {
    closeModal('group-transfer-type-modal');
    
    // é‡ç½®è¾“å…¥
    document.getElementById('rp-amount-input').value = '';
    document.getElementById('rp-count-input').value = '';
    document.getElementById('rp-wish-input').value = '';
    document.getElementById('rp-total-hint').innerText = 'å…±0.00å…ƒ';
    document.getElementById('btn-send-redpacket').disabled = true;
    document.getElementById('btn-send-redpacket').style.background = '#ccc';
    document.getElementById('btn-send-redpacket').style.cursor = 'not-allowed';
    
    // é»˜è®¤é€‰ä¸­æ‹¼æ‰‹æ°”
    selectRedPacketType('lucky');
    
    document.getElementById('group-redpacket-page').style.display = 'flex';
}

function hideGroupRedPacketPage() {
    document.getElementById('group-redpacket-page').style.display = 'none';
}

// é€‰æ‹©çº¢åŒ…ç±»å‹
function selectRedPacketType(type) {
    currentRedPacketType = type;
    
    const luckyEl = document.getElementById('rp-type-lucky');
    const normalEl = document.getElementById('rp-type-normal');
    
    if (type === 'lucky') {
        luckyEl.style.borderColor = '#333';
        luckyEl.style.background = '#fff';
        luckyEl.querySelector('div:first-child').style.color = '#333';
        
        normalEl.style.borderColor = '#e8e8e8';
        normalEl.style.background = '#fff';
        normalEl.querySelector('div:first-child').style.color = '#666';
    } else {
        normalEl.style.borderColor = '#333';
        normalEl.style.background = '#fff';
        normalEl.querySelector('div:first-child').style.color = '#333';
        
        luckyEl.style.borderColor = '#e8e8e8';
        luckyEl.style.background = '#fff';
        luckyEl.querySelector('div:first-child').style.color = '#666';
    }
}

// æ£€æŸ¥çº¢åŒ…è¾“å…¥
function checkRedPacketInput() {
    const amount = parseFloat(document.getElementById('rp-amount-input').value) || 0;
    const count = parseInt(document.getElementById('rp-count-input').value) || 0;
    
    document.getElementById('rp-total-hint').innerText = `å…±${amount.toFixed(2)}å…ƒ`;
    
    const btn = document.getElementById('btn-send-redpacket');
    if (amount > 0 && count > 0) {
        btn.disabled = false;
        btn.style.background = '#333';
        btn.style.cursor = 'pointer';
    } else {
        btn.disabled = true;
        btn.style.background = '#ccc';
        btn.style.cursor = 'not-allowed';
    }
}

// å‘é€ç¾¤çº¢åŒ…
async function sendGroupRedPacket() {
    if (!window.currentGroupChatId) return;
    
    const amount = parseFloat(document.getElementById('rp-amount-input').value);
    const count = parseInt(document.getElementById('rp-count-input').value);
    const wish = document.getElementById('rp-wish-input').value.trim() || 'æ­å–œå‘è´¢ï¼Œå¤§å‰å¤§åˆ©';
    
    if (!amount || amount <= 0 || !count || count <= 0) {
        showToast('è¯·å¡«å†™æ­£ç¡®çš„é‡‘é¢å’Œä¸ªæ•°');
        return;
    }
    
    // æ£€æŸ¥ä½™é¢
    if (!currentMyCharId) {
        showToast("è¯·å…ˆè®¾ç½®Userèº«ä»½");
        return;
    }
    const user = await db.characters.get(parseInt(currentMyCharId));
    let currentBalance = 0;
    if (user && user.identity && user.identity.balance) {
        currentBalance = parseFloat(user.identity.balance.toString().replace(/,/g, ''));
    }
    
    if (currentBalance < amount) {
        showToast('ä½™é¢ä¸è¶³ (å½“å‰: Â¥' + currentBalance.toFixed(2) + ')');
        return;
    }
    
    // æ‰£æ¬¾
    const newBalance = currentBalance - amount;
    user.identity.balance = newBalance.toFixed(2);
    await db.characters.put(user);
    
    // æ„å»ºçº¢åŒ…æ¶ˆæ¯
    const group = await db.group_chats.get(window.currentGroupChatId);
    if (!group) return;
    
    const redPacketData = {
        type: 'redpacket',
        redpacketType: currentRedPacketType, // 'lucky' æˆ– 'normal'
        totalAmount: amount.toFixed(2),
        count: count,
        wish: wish,
        claimed: [], // å·²é¢†å–çš„æˆå‘˜IDåˆ—è¡¨
        claimedAmounts: {}, // æ¯ä¸ªæˆå‘˜é¢†å–çš„é‡‘é¢
        id: 'rp_' + Date.now()
    };
    
    if (!group.chat_history) group.chat_history = [];
    group.chat_history.push({
        role: 'user',
        type: 'redpacket',
        content: JSON.stringify(redPacketData),
        time: Date.now()
    });
    group.updated_at = Date.now();
    await db.group_chats.put(group);
    
    // è®°å½•è´¦å•
    await addTransaction('expense', amount, 'å‘çº¢åŒ…', `${group.name} Â· ${count}ä¸ªçº¢åŒ…`);
    
    hideGroupRedPacketPage();
    await renderGroupChatBody(group);
    showToast('çº¢åŒ…å·²å‘å‡º');
}

/* =================
   ä¸“å±è½¬è´¦åŠŸèƒ½
   ================= */

let exclusiveTransferTarget = null; // å½“å‰é€‰ä¸­çš„è½¬è´¦ç›®æ ‡

// æ˜¾ç¤ºä¸“å±è½¬è´¦é€‰äººå¼¹çª—
async function showExclusiveTransferPage() {
    closeModal('group-transfer-type-modal');
    
    if (!window.currentGroupChatId) return;
    
    const group = await db.group_chats.get(window.currentGroupChatId);
    if (!group) return;
    
    const listEl = document.getElementById('exclusive-member-list');
    listEl.innerHTML = '';
    
    // æ¸²æŸ“ç¾¤æˆå‘˜åˆ—è¡¨ï¼ˆä¸åŒ…æ‹¬è‡ªå·±ï¼‰
    for (const memberId of group.memberIds) {
        const char = await db.characters.get(memberId);
        if (!char) continue;
        
        const avatarStyle = char.avatar ? `background-image:url(${char.avatar})` : 'background:#ccc';
        const memberNicknames = group.memberNicknames || {};
        const displayName = memberNicknames[memberId] || char.remark || char.name;
        
        const item = document.createElement('div');
        item.style.cssText = 'display:flex; align-items:center; padding:12px 16px; cursor:pointer; transition:background 0.2s;';
        item.onmouseover = () => item.style.background = '#f5f5f5';
        item.onmouseout = () => item.style.background = '';
        item.innerHTML = `
            <div style="width:44px; height:44px; border-radius:6px; ${avatarStyle}; background-size:cover; background-position:center; margin-right:12px;"></div>
            <div style="flex:1;">
                <div style="font-size:16px; color:#333;">${displayName}</div>
                <div style="font-size:12px; color:#999;">${char.name}</div>
            </div>
        `;
        item.onclick = () => selectExclusiveTarget(memberId, char, displayName);
        
        listEl.appendChild(item);
    }
    
    if (group.memberIds.length === 0) {
        listEl.innerHTML = '<div style="text-align:center; color:#999; padding:40px;">ç¾¤å†…æš‚æ— å…¶ä»–æˆå‘˜</div>';
    }
    
    document.getElementById('exclusive-transfer-modal').style.display = 'flex';
}

// é€‰æ‹©ä¸“å±è½¬è´¦ç›®æ ‡
async function selectExclusiveTarget(memberId, char, displayName) {
    closeModal('exclusive-transfer-modal');
    
    exclusiveTransferTarget = { memberId, char, displayName };
    
    // æ‰“å¼€è½¬è´¦é¡µé¢
    document.getElementById('t-target-name').innerText = displayName;
    document.getElementById('t-target-avatar').style.backgroundImage = char.avatar ? `url(${char.avatar})` : '';
    
    // é‡ç½®è¾“å…¥
    document.getElementById('t-amount-input').value = '';
    document.getElementById('t-note-input').value = '';
    document.getElementById('btn-do-transfer').disabled = true;
    
    document.getElementById('transfer-page').style.display = 'flex';
}

// å½“å‰æŸ¥çœ‹çš„çº¢åŒ…ID
let currentViewingRedPacketId = null;

// æ˜¾ç¤ºçº¢åŒ…è¯¦æƒ…é¡µé¢
async function showRedPacketDetail(redPacketId) {
    if (!window.currentGroupChatId) return;
    
    const group = await db.group_chats.get(window.currentGroupChatId);
    if (!group || !group.chat_history) return;
    
    // æ‰¾åˆ°çº¢åŒ…æ¶ˆæ¯
    const msg = group.chat_history.find(m => {
        if (m.type !== 'redpacket') return false;
        try {
            const data = JSON.parse(m.content);
            return data.id === redPacketId;
        } catch(e) {
            return false;
        }
    });
    
    if (!msg) return;
    
    const data = JSON.parse(msg.content);
    currentViewingRedPacketId = redPacketId;
    
    // è·å–å‘é€è€…ä¿¡æ¯ï¼ˆçº¢åŒ…æ¶ˆæ¯çš„roleæ˜¯userï¼‰
    let senderAvatar = '';
    let senderName = 'çº¢åŒ…å‘é€è€…';
    if (currentMyCharId && msg.role === 'user') {
        const user = await db.characters.get(parseInt(currentMyCharId));
        if (user) {
            senderAvatar = user.avatar || '';
            const memberNicknames = group.memberNicknames || {};
            senderName = memberNicknames[currentMyCharId] || user.name || 'æˆ‘';
        }
    }
    
    // æ›´æ–°é¡µé¢å†…å®¹
    document.getElementById('rp-detail-avatar').style.backgroundImage = senderAvatar ? `url(${senderAvatar})` : '';
    document.getElementById('rp-detail-sender').innerText = senderName + ' çš„çº¢åŒ…';
    document.getElementById('rp-detail-wish').innerText = data.wish || 'æ­å–œå‘è´¢';
    document.getElementById('rp-detail-type').innerText = data.redpacketType === 'lucky' ? 'æ‹¼æ‰‹æ°”çº¢åŒ…' : 'æ™®é€šçº¢åŒ…';
    
    // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
    const claimedCount = data.claimed?.length || 0;
    const claimedTotal = Object.values(data.claimedAmounts || {}).reduce((a, b) => a + parseFloat(b), 0);
    document.getElementById('rp-detail-claimed-count').innerText = claimedCount;
    document.getElementById('rp-detail-total-count').innerText = data.count;
    document.getElementById('rp-detail-total-amount').innerText = claimedTotal.toFixed(2);
    
    // æ›´æ–°é¢†å–æŒ‰é’®çŠ¶æ€
    const myId = currentMyCharId ? parseInt(currentMyCharId) : null;
    const isAllClaimed = claimedCount >= data.count;
    const hasClaimed = data.claimed?.includes(myId);
    
    const actionDiv = document.getElementById('rp-detail-action');
    const btn = document.getElementById('btn-claim-redpacket');
    
    if (isAllClaimed) {
        btn.innerText = 'çº¢åŒ…å·²é¢†å®Œ';
        btn.disabled = true;
        btn.style.background = '#ccc';
        btn.style.cursor = 'not-allowed';
    } else if (hasClaimed) {
        btn.innerText = `å·²é¢†å– Â¥${data.claimedAmounts[myId]}`;
        btn.disabled = true;
        btn.style.background = '#ccc';
        btn.style.cursor = 'not-allowed';
    } else {
        btn.innerText = 'é¢†å–çº¢åŒ…';
        btn.disabled = false;
        btn.style.background = '#333';
        btn.style.cursor = 'pointer';
    }
    
    // æ¸²æŸ“å·²é¢†å–åˆ—è¡¨
    const listEl = document.getElementById('rp-detail-claimed-list');
    listEl.innerHTML = '';
    
    if (data.claimed && data.claimed.length > 0) {
        for (const memberId of data.claimed) {
            const char = await db.characters.get(memberId);
            const memberNicknames = group.memberNicknames || {};
            const displayName = memberNicknames[memberId] || char?.remark || char?.name || 'æœªçŸ¥ç”¨æˆ·';
            const avatar = char?.avatar || '';
            const amount = data.claimedAmounts[memberId] || '0.00';
            
            const item = document.createElement('div');
            item.style.cssText = 'display:flex; align-items:center; padding:12px 0; border-bottom:1px solid #f0f0f0;';
            item.innerHTML = `
                <div style="width:40px; height:40px; border-radius:50%; background:#eee; background-image:url(${avatar}); background-size:cover; background-position:center; margin-right:12px; flex-shrink:0;"></div>
                <div style="flex:1;">
                    <div style="font-size:14px; color:#333;">${displayName}</div>
                </div>
                <div style="font-size:15px; font-weight:500; color:#333;">Â¥${amount}</div>
            `;
            listEl.appendChild(item);
        }
    } else {
        listEl.innerHTML = '<div style="text-align:center; color:#999; padding:30px 0; font-size:13px;">æš‚æ— äººé¢†å–</div>';
    }
    
    document.getElementById('redpacket-detail-page').style.display = 'flex';
}

// éšè—çº¢åŒ…è¯¦æƒ…é¡µé¢
function hideRedPacketDetail() {
    document.getElementById('redpacket-detail-page').style.display = 'none';
    currentViewingRedPacketId = null;
}

// é¢†å–çº¢åŒ…
async function claimRedPacket() {
    if (!currentViewingRedPacketId || !window.currentGroupChatId) return;
    
    const group = await db.group_chats.get(window.currentGroupChatId);
    if (!group || !group.chat_history) return;
    
    // æ‰¾åˆ°çº¢åŒ…æ¶ˆæ¯
    const msgIndex = group.chat_history.findIndex(m => {
        if (m.type !== 'redpacket') return false;
        try {
            const data = JSON.parse(m.content);
            return data.id === currentViewingRedPacketId;
        } catch(e) {
            return false;
        }
    });
    
    if (msgIndex === -1) return;
    
    const msg = group.chat_history[msgIndex];
    const data = JSON.parse(msg.content);
    
    // æ£€æŸ¥æ˜¯å¦å·²é¢†å–å®Œ
    if ((data.claimed?.length || 0) >= data.count) {
        showToast('çº¢åŒ…å·²è¢«é¢†å®Œ');
        await showRedPacketDetail(currentViewingRedPacketId); // åˆ·æ–°é¡µé¢
        return;
    }
    
    // æ£€æŸ¥æ˜¯å¦å·²é¢†å–è¿‡
    const myId = currentMyCharId ? parseInt(currentMyCharId) : null;
    if (!myId) {
        showToast('è¯·å…ˆè®¾ç½®èº«ä»½');
        return;
    }
    if (data.claimed?.includes(myId)) {
        showToast('ä½ å·²é¢†å–è¿‡è¯¥çº¢åŒ…');
        return;
    }
    
    // é¢†å–çº¢åŒ…
    if (!data.claimed) data.claimed = [];
    if (!data.claimedAmounts) data.claimedAmounts = {};
    
    let claimAmount = 0;
    const totalAmount = parseFloat(data.totalAmount);
    const remaining = data.count - data.claimed.length;
    const alreadyClaimed = Object.values(data.claimedAmounts).reduce((a, b) => a + parseFloat(b), 0);
    const remainingAmount = totalAmount - alreadyClaimed;
    
    if (data.redpacketType === 'lucky') {
        // æ‹¼æ‰‹æ°”çº¢åŒ…ï¼šéšæœºé‡‘é¢
        if (remaining === 1) {
            claimAmount = remainingAmount;
        } else {
            // éšæœºé‡‘é¢ï¼Œç¡®ä¿æ¯äººè‡³å°‘0.01
            const maxAmount = remainingAmount - (remaining - 1) * 0.01;
            claimAmount = Math.random() * maxAmount * 0.8 + 0.01; // ä¿å®ˆéšæœº
            claimAmount = Math.min(claimAmount, maxAmount);
        }
    } else {
        // æ™®é€šçº¢åŒ…ï¼šå¹³å‡åˆ†é…
        claimAmount = totalAmount / data.count;
    }
    
    claimAmount = parseFloat(claimAmount.toFixed(2));
    
    // è®°å½•é¢†å–
    data.claimed.push(myId);
    data.claimedAmounts[myId] = claimAmount.toFixed(2);
    
    // æ›´æ–°çº¢åŒ…æ¶ˆæ¯
    group.chat_history[msgIndex].content = JSON.stringify(data);
    await db.group_chats.put(group);
    
    // å¢åŠ ä½™é¢
    const user = await db.characters.get(myId);
    if (user) {
        if (!user.identity) user.identity = {};
        let balance = parseFloat(user.identity.balance || 0);
        balance += claimAmount;
        user.identity.balance = balance.toFixed(2);
        await db.characters.put(user);
    }
    
    // è®°å½•è´¦å•ï¼ˆæ”¶å…¥ï¼‰
    await addTransaction('income', claimAmount, 'çº¢åŒ…', `${group.name}`);
    
    // åˆ·æ–°çº¢åŒ…è¯¦æƒ…é¡µé¢
    await showRedPacketDetail(currentViewingRedPacketId);
    
    // åˆ·æ–°ç¾¤èŠ
    await renderGroupChatBody(group);
    
    showToast(`æˆåŠŸé¢†å– Â¥${claimAmount.toFixed(2)}`);
}

// é¢†å–ç¾¤èŠä¸“å±è½¬è´¦
async function receiveGroupTransfer(msgId) {
    if (!window.currentGroupChatId) return;
    
    const group = await db.group_chats.get(window.currentGroupChatId);
    if (!group || !group.chat_history) return;
    
    // æ‰¾åˆ°è½¬è´¦æ¶ˆæ¯
    const msgIndex = group.chat_history.findIndex(m => m.id === msgId && m.type === 'transfer');
    if (msgIndex === -1) return;
    
    const msg = group.chat_history[msgIndex];
    const data = JSON.parse(msg.content);
    
    // æ£€æŸ¥æ˜¯å¦å·²ç»è¢«é¢†å–
    if (data.status === 'received') {
        showToast('è¯¥è½¬è´¦å·²è¢«é¢†å–');
        return;
    }
    
    // æ£€æŸ¥æ˜¯å¦æ˜¯è‡ªå·±å‘çš„
    const myId = currentMyCharId ? parseInt(currentMyCharId) : null;
    if (msg.role === 'user') {
        showToast('ä¸èƒ½é¢†å–è‡ªå·±å‘çš„è½¬è´¦');
        return;
    }
    
    // æ£€æŸ¥æ˜¯å¦æ˜¯è½¬ç»™è‡ªå·±çš„ï¼ˆä¸“å±è½¬è´¦ï¼‰
    if (data.targetId && data.targetId !== myId) {
        // è·å–ç›®æ ‡åç§°
        const targetChar = await db.characters.get(data.targetId);
        const targetName = data.targetName || targetChar?.name || 'å…¶ä»–äºº';
        showToast(`è¿™æ˜¯ä¸“å±è½¬è´¦ç»™ ${targetName} çš„`);
        return;
    }
    
    // é¢†å–è½¬è´¦
    data.status = 'received';
    data.receivedBy = myId;
    data.receivedAt = Date.now();
    
    group.chat_history[msgIndex].content = JSON.stringify(data);
    await db.group_chats.put(group);
    
    // å¢åŠ ä½™é¢
    if (currentMyCharId) {
        const user = await db.characters.get(parseInt(currentMyCharId));
        if (user) {
            if (!user.identity) user.identity = {};
            let balance = parseFloat(user.identity.balance || 0);
            balance += parseFloat(data.amount);
            user.identity.balance = balance.toFixed(2);
            await db.characters.put(user);
        }
    }
    
    // è·å–å‘é€è€…åç§°
    let senderName = 'ç¾¤å‹';
    // ä»ç¾¤èŠå†å²ä¸­è·å–å‘é€è€…ä¿¡æ¯ï¼ˆå‡è®¾msgåŒ…å«senderIdï¼‰
    if (data.senderId) {
        const senderChar = await db.characters.get(data.senderId);
        if (senderChar) {
            const memberNicknames = group.memberNicknames || {};
            senderName = memberNicknames[data.senderId] || senderChar.remark || senderChar.name;
        }
    }
    
    // è®°å½•è´¦å•ï¼ˆæ”¶å…¥ï¼‰
    await addTransaction('income', data.amount, 'è½¬è´¦æ”¶æ¬¾', `æ¥è‡ª${senderName}`);
    
    // åˆ·æ–°ç¾¤èŠ
    await renderGroupChatBody(group);
    showToast(`å·²æ”¶æ¬¾ Â¥${data.amount}`);
}

/* =================
   ä½ç½®åŠŸèƒ½
   ================= */

// æ‰“å¼€ä½ç½®è¾“å…¥å¼¹çª—
function showLocationModal() {
    // æ¸…ç©ºè¾“å…¥
    document.getElementById('location-name-input').value = '';
    document.getElementById('location-address-input').value = '';
    
    const modal = document.getElementById('location-modal');
    modal.style.display = 'flex';
}

// å…³é—­ä½ç½®è¾“å…¥å¼¹çª—
function hideLocationModal() {
    document.getElementById('location-modal').style.display = 'none';
}

// å‘é€ä½ç½®æ¶ˆæ¯
async function sendLocationMessage() {
    const nameVal = document.getElementById('location-name-input').value.trim();
    const addressVal = document.getElementById('location-address-input').value.trim();
    
    if (!nameVal) {
        showToast("è¯·è¾“å…¥ä½ç½®åç§°");
        return;
    }
    
    if (!currentChatCharId) {
        showToast("è¯·å…ˆè¿›å…¥èŠå¤©");
        return;
    }
    
    const chatChar = await db.characters.get(currentChatCharId);
    if (!chatChar) {
        showToast("èŠå¤©å¯¹è±¡ä¸å­˜åœ¨");
        return;
    }
    
    const accountId = getCurrentAccountId();
    let history = getChatHistory(chatChar, accountId);
    
    const msgId = 'loc_' + Date.now();
    const msg = {
        id: msgId,
        role: 'user',
        type: 'location',
        content: JSON.stringify({
            name: nameVal,
            address: addressVal || 'æš‚æ— è¯¦ç»†åœ°å€'
        }), 
        time: Date.now()
    };
    
    history.push(msg);
    await setChatHistory(chatChar, accountId, history);
    
    // åˆ·æ–°èŠå¤©ç•Œé¢
    renderChatBody(chatChar);
    
    hideLocationModal();
    showToast("ä½ç½®å·²å‘é€");
    
    // å…³é—­æ›´å¤šé¢æ¿
    document.getElementById('action-panel').style.display = 'none';
    document.getElementById('chat-panel-container').classList.remove('open');
}

// æ˜¾ç¤ºä½ç½®è¯¦æƒ…
function showLocationDetail(encodedName, encodedAddress) {
    const name = decodeURIComponent(encodedName);
    const address = decodeURIComponent(encodedAddress);
    
    // åˆ›å»ºè¯¦æƒ…å¼¹çª—
    const overlay = document.createElement('div');
    overlay.id = 'location-detail-overlay';
    overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.4);
        z-index: 999;
        display: flex;
        justify-content: center;
        align-items: center;
    `;
    
    overlay.innerHTML = `
        <div style="
            background: #fff;
            width: 260px;
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0,0,0,0.15);
        ">
            <div style="padding: 20px; text-align: center;">
                <div style="
                    width: 48px;
                    height: 48px;
                    background: #f5f5f5;
                    border-radius: 12px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    margin: 0 auto 16px;
                ">
                    <svg viewBox="0 0 24 24" style="width:24px; height:24px; fill:none; stroke:#666; stroke-width:2;">
                        <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
                        <circle cx="12" cy="10" r="3"></circle>
                    </svg>
                </div>
                <div style="font-size: 16px; font-weight: 600; color: #333; margin-bottom: 6px;">${name}</div>
                <div style="font-size: 13px; color: #999;">${address || 'æš‚æ— è¯¦ç»†åœ°å€'}</div>
            </div>
            <div style="border-top: 1px solid #f0f0f0;">
                <button onclick="document.getElementById('location-detail-overlay').remove()" style="
                    width: 100%;
                    padding: 14px;
                    background: #fff;
                    color: #333;
                    border: none;
                    font-size: 15px;
                    font-weight: 500;
                    cursor: pointer;
                ">å…³é—­</button>
            </div>
        </div>
    `;
    
    overlay.onclick = (e) => {
        if (e.target === overlay) {
            overlay.remove();
        }
    };
    
    document.body.appendChild(overlay);
}

// æ£€æŸ¥é‡‘é¢è¾“å…¥ï¼Œæ§åˆ¶æŒ‰é’®çŠ¶æ€
function checkTransferAmount(input) {
    const btn = document.getElementById('btn-do-transfer');
    const val = parseFloat(input.value);
    if (!isNaN(val) && val > 0) {
        btn.disabled = false;
    } else {
        btn.disabled = true;
    }
}

// æ‰§è¡Œè½¬è´¦
async function doTransfer() {
    const amountVal = parseFloat(document.getElementById('t-amount-input').value);
    const noteVal = document.getElementById('t-note-input').value || 'è½¬è´¦ç»™å¯¹æ–¹';
    
    if (isNaN(amountVal) || amountVal <= 0) return;
    
    // 1. æ£€æŸ¥ä½™é¢
    if (!currentMyCharId) {
        showToast("è¯·å…ˆåœ¨è¯¦æƒ…é¡µè®¾ç½®Userèº«ä»½");
        return;
    }
    const user = await db.characters.get(parseInt(currentMyCharId));
    
    // ç¡®ä¿æœ‰ä½™é¢å­—æ®µ
    let currentBalance = 0;
    if (user && user.identity && user.identity.balance) {
        currentBalance = parseFloat(user.identity.balance.toString().replace(/,/g, ''));
    }
    
    if (currentBalance < amountVal) {
        showToast('ä½™é¢ä¸è¶³ (å½“å‰: Â¥' + currentBalance.toFixed(2) + ')');
        return;
    }
    
    // 2. æ‰£æ¬¾
    const newBalance = currentBalance - amountVal;
    user.identity.balance = newBalance.toFixed(2);
    await db.characters.put(user);
    
    // 3. åˆ¤æ–­æ˜¯ç¾¤èŠä¸“å±è½¬è´¦è¿˜æ˜¯ç§èŠè½¬è´¦
    if (window.currentGroupChatId && exclusiveTransferTarget) {
        // ç¾¤èŠä¸“å±è½¬è´¦
        const group = await db.group_chats.get(window.currentGroupChatId);
        if (!group) {
            showToast("ç¾¤èŠä¸å­˜åœ¨");
            return;
        }
        
        const msgId = 'trans_' + Date.now();
        const msg = {
            role: 'user',
            type: 'transfer',
            content: JSON.stringify({
                amount: amountVal.toFixed(2),
                desc: noteVal,
                status: 'sent',
                senderId: parseInt(currentMyCharId),
                targetId: exclusiveTransferTarget.memberId,
                targetName: exclusiveTransferTarget.displayName
            }), 
            time: Date.now(),
            id: msgId
        };
        
        if (!group.chat_history) group.chat_history = [];
        group.chat_history.push(msg);
        group.updated_at = Date.now();
        await db.group_chats.put(group);
        
        // è®°å½•è´¦å•
        await addTransaction('expense', amountVal, 'è½¬è´¦', `è½¬ç»™${exclusiveTransferTarget.displayName}`);
        
        // åˆ·æ–°ç¾¤èŠç•Œé¢
        await renderGroupChatBody(group);
        
        hideTransferPage();
        exclusiveTransferTarget = null; // æ¸…ç©ºç›®æ ‡
        showToast("è½¬è´¦æˆåŠŸ");
        return;
    }
    
    // ç§èŠè½¬è´¦
    const chatChar = await db.characters.get(currentChatCharId);
    if (!chatChar) {
        showToast("èŠå¤©å¯¹è±¡ä¸å­˜åœ¨");
        return;
    }
    
    const accountId = getCurrentAccountId();
    let history = getChatHistory(chatChar, accountId);
    
    const msgId = 'trans_' + Date.now();
    const transferData = {
        amount: amountVal.toFixed(2),
        desc: noteVal,
        status: 'sent'
    };
    const msg = {
        id: msgId,
        role: 'user',
        type: 'transfer',
        content: JSON.stringify(transferData), 
        time: Date.now()
    };
    
    history.push(msg);
    await setChatHistory(chatChar, accountId, history);
    
    // è®°å½•è´¦å•
    await addTransaction('expense', amountVal, 'è½¬è´¦', `è½¬ç»™${chatChar.remark || chatChar.name}`);
    
    // âœ… è”æœºå¥½å‹ï¼šé€šè¿‡æœåŠ¡å™¨å‘é€è½¬è´¦æ¶ˆæ¯
    if (chatChar.isOnlineFriend && chatChar.onlineData?.wx_account) {
        // è·å–å½“å‰å¯ç”¨çš„åœ¨çº¿è§’è‰²ï¼ˆå¦‚æœæ²¡æœ‰åˆ™è‡ªåŠ¨ä¸Šçº¿ï¼‰
        const onlineUserChar = await getOrCreateOnlineUserChar();
        
        if (onlineUserChar && onlineConnected) {
            const fromWxAccount = onlineUserChar.identity.account;
            const toWxAccount = chatChar.onlineData.wx_account;
            // å‘é€è½¬è´¦æ¶ˆæ¯ï¼ˆä½¿ç”¨ç‰¹æ®ŠJSONæ ¼å¼ï¼Œå¯¹æ–¹å¯ä»¥è¯†åˆ«å¹¶æ¸²æŸ“ä¸ºå¡ç‰‡ï¼‰
            const transferContent = JSON.stringify({
                __type: 'transfer',
                amount: amountVal.toFixed(2),
                desc: noteVal,
                status: 'sent'
            });
            sendOnlineMessage(toWxAccount, transferContent, fromWxAccount);
            console.log('[Online] è½¬è´¦æ¶ˆæ¯å·²å‘é€åˆ°æœåŠ¡å™¨');
        }
    }
    
    // åˆ·æ–°èŠå¤©ç•Œé¢
    renderChatBody(chatChar);
    
    hideTransferPage();
    showToast("è½¬è´¦æˆåŠŸ");
    
    // å…³é—­æ›´å¤šé¢æ¿
    document.getElementById('action-panel').style.display = 'none';
    document.getElementById('chat-panel-container').classList.remove('open');
}

/* =================
   è½¬è´¦ç¡®è®¤/è¯¦æƒ…é€»è¾‘
   ================= */

// ç‚¹å‡»å¡ç‰‡è§¦å‘
async function showTransferConfirm(msgId, isSelf, status) {
    if (status !== 'sent') return;
    if (isSelf) return;
    
    // ä»chat_historyä¸­æŸ¥æ‰¾æ¶ˆæ¯ - ä½¿ç”¨ getChatHistory æ”¯æŒå¤šè´¦å·
    const char = await db.characters.get(currentChatCharId);
    if (!char) return;
    
    const accountId = getCurrentAccountId();
    const history = getChatHistory(char, accountId);
    if (!history || history.length === 0) return;
    
    const msg = history.find(m => {
        // ç²¾ç¡®åŒ¹é…ID
        if (m.id === msgId) return true;
        // å¦‚æœæ¶ˆæ¯æ²¡æœ‰idï¼Œç”¨æ—¶é—´æˆ³åŒ¹é…
        if (!m.id && msgId === 'trans_' + m.time) return true;
        // å¦‚æœmsgIdæ˜¯trans_å¼€å¤´ï¼Œå°è¯•ç”¨æ—¶é—´æˆ³åŒ¹é…
        if (msgId.startsWith('trans_')) {
            const timeFromId = parseInt(msgId.replace('trans_', ''));
            if (m.time === timeFromId) return true;
        }
        return false;
    });
    if (!msg) return;
    
    // è§£æè½¬è´¦æ•°æ®
    let data = {};
    try {
        data = JSON.parse(msg.content);
    } catch(e) {
        return;
    }
    
    document.getElementById('t-confirm-desc').innerText = 'æ”¶åˆ°è½¬è´¦ Â¥' + data.amount;
    
    window.currentTransferMsgId = msgId;
    window.currentTransferMsgTime = msg.time; // ä¿å­˜æ—¶é—´æˆ³ç”¨äºæŸ¥æ‰¾
    
    document.getElementById('transfer-confirm-modal').style.display = 'flex';
}

async function handleTransferAction(action) {
    const modal = document.getElementById('transfer-confirm-modal');
    modal.style.display = 'none';
    
    const msgId = window.currentTransferMsgId;
    const msgTime = window.currentTransferMsgTime;
    if (!msgId || !currentChatCharId) return;
    
    const char = await db.characters.get(currentChatCharId);
    const accountId = getCurrentAccountId();
    let history = getChatHistory(char, accountId);
    if (!history || history.length === 0) return;
    
    const msgIndex = history.findIndex(m => {
        // ç²¾ç¡®åŒ¹é…IDï¼Œæˆ–è€…æ ¹æ®æ—¶é—´æˆ³ç”Ÿæˆçš„IDåŒ¹é…
        if (m.id === msgId) return true;
        if (!m.id && msgId === 'trans_' + m.time) return true;
        if (msgTime && m.time === msgTime) return true; // ä½¿ç”¨æ—¶é—´æˆ³åŒ¹é…
        return false;
    });
    if (msgIndex === -1) return;
    
    const msg = history[msgIndex];
    let data = {};
    try {
        data = JSON.parse(msg.content);
    } catch(e) {
        return;
    }
    
    if (action === 'accept') {
        data.status = 'received';
        msg.content = JSON.stringify(data);
        
        // å¦‚æœæ¶ˆæ¯æ²¡æœ‰typeå­—æ®µï¼Œè¡¥å……ä¸Š
        if (!msg.type) msg.type = 'transfer';
        // å¦‚æœæ¶ˆæ¯æ²¡æœ‰idï¼Œè¡¥å……ä¸Š
        if (!msg.id) msg.id = 'trans_' + msg.time;
        
        // è·å–å½“å‰è´¦å·IDå¹¶æ›´æ–°ä½™é¢
        const myAccountId = getCurrentAccountId();
        if (myAccountId) {
             const user = await db.characters.get(parseInt(myAccountId));
             if (user) {
                 let currentBalance = 0;
                 if (user.identity && typeof user.identity.balance !== 'undefined' && user.identity.balance !== null) {
                     currentBalance = parseFloat(user.identity.balance.toString().replace(/,/g, '')) || 0;
                 }
                 
                 let addAmount = parseFloat(data.amount) || 0;
                 let newBalance = currentBalance + addAmount;
                 
                 if (!user.identity) user.identity = {};
                 user.identity.balance = newBalance.toFixed(2);
                 await db.characters.put(user);
                 
                 // æ·»åŠ æ”¶å…¥è®°å½•åˆ°è´¦å•
                 await addTransaction('income', data.amount, 'å¾®ä¿¡è½¬è´¦', `æ¥è‡ª${char.name}${data.desc ? ' - ' + data.desc : ''}`);
                 
                 showToast('å·²æ”¶æ¬¾ Â¥' + data.amount);
             }
        }
        
    } else {
        data.status = 'returned';
        msg.content = JSON.stringify(data);
        
        if (!msg.type) msg.type = 'transfer';
        if (!msg.id) msg.id = 'trans_' + msg.time;
        
        showToast('å·²é€€å›è½¬è´¦');
    }
    
    history[msgIndex] = msg;
    await setChatHistory(char, accountId, history);
    
    renderChatBody(char);
}

// =================
// ç”µè¯é¡µé¢åŠŸèƒ½
// =================
let currentPhoneNumber = '';
let currentPhoneTab = 'recents';

function showPhonePage() {
    const page = document.getElementById('phone-page');
    page.style.display = 'flex';
    // é»˜è®¤æ˜¾ç¤ºæœ€è¿‘é€šè¯æ ‡ç­¾é¡µ
    switchPhoneTab('recents');
    // åˆå§‹åŒ–æ‹¨å·é”®ç›˜æŒ‰é’®çŠ¶æ€
    updatePhoneKeypadActions();
}

function hidePhonePage() {
    const page = document.getElementById('phone-page');
    page.style.display = 'none';
    // é‡ç½®æ‹¨å·é”®ç›˜
    currentPhoneNumber = '';
    updatePhoneNumberDisplay();
}

function switchPhoneTab(tab) {
    currentPhoneTab = tab;
    
    // æ›´æ–°æ ‡ç­¾æ çŠ¶æ€
    document.querySelectorAll('.phone-tab-item').forEach(item => {
        item.classList.remove('active');
        if (item.dataset.tab === tab) {
            item.classList.add('active');
        }
    });
    
    // æ›´æ–°å†…å®¹åŒºåŸŸ
    document.querySelectorAll('.phone-tab-content').forEach(content => {
        content.classList.remove('active');
    });
    
    const targetContent = document.getElementById('phone-tab-' + tab);
    if (targetContent) {
        targetContent.classList.add('active');
    }
    
    // æ ¹æ®æ ‡ç­¾é¡µåŠ è½½ç›¸åº”å†…å®¹
    if (tab === 'contacts') {
        loadPhoneContacts();
    } else if (tab === 'recents') {
        loadPhoneRecents();
    }
}

function loadPhoneContacts() {
    const contactsList = document.getElementById('phone-contacts-list');
    if (!contactsList) return;
    
    // ä»è§’è‰²æ¡£æ¡ˆä¸­åŠ è½½è”ç³»äºº
    db.characters.toArray().then(characters => {
        const contacts = characters.filter(c => c.type === 'char' || c.type === 'npc');
        
        if (contacts.length === 0) {
            contactsList.innerHTML = `
                <div class="phone-empty-state">
                    <svg class="phone-empty-icon" viewBox="0 0 24 24"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg>
                    <div>æ— è”ç³»äºº</div>
                </div>
            `;
            return;
        }
        
        // æŒ‰åç§°æ’åº
        contacts.sort((a, b) => {
            const nameA = (a.nick || a.name || '').toUpperCase();
            const nameB = (b.nick || b.name || '').toUpperCase();
            return nameA.localeCompare(nameB);
        });
        
        let html = '';
        contacts.forEach(contact => {
            const name = contact.nick || contact.name || 'æœªçŸ¥';
            const phone = contact.identity?.phone || '';
            const firstLetter = name.charAt(0).toUpperCase();
            
            html += `
                <div class="phone-list-item" onclick="phoneCallContact(${contact.id})">
                    <div class="phone-list-avatar" style="background: ${contact.avatar ? 'url(' + contact.avatar + ')' : 'var(--ins-pink)'}; background-size: cover; background-position: center;">
                        ${!contact.avatar ? firstLetter : ''}
                    </div>
                    <div class="phone-list-info">
                        <div class="phone-list-name">${name}</div>
                        <div class="phone-list-subtitle">${phone || 'æ— å·ç '}</div>
                    </div>
                </div>
            `;
        });
        
        contactsList.innerHTML = html;
    });
}

async function loadPhoneRecents() {
    const recentsList = document.getElementById('phone-recents-list');
    if (!recentsList) return;
    
    const accountId = getCurrentAccountId();
    if (!accountId) {
        recentsList.innerHTML = `<div class="phone-empty-state"><div>è¯·å…ˆç™»å½•è´¦å·</div></div>`;
        return;
    }
    
    // ä» Dexie åŠ è½½æœ€è¿‘é€šè¯è®°å½•
    let recents = await db.phone_recents.where('accountId').equals(accountId).toArray();
    
    if (recents.length === 0) {
        recentsList.innerHTML = `
            <div class="phone-empty-state">
                <svg class="phone-empty-icon" viewBox="0 0 24 24"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/></svg>
                <div>æ— æœ€è¿‘é€šè¯</div>
            </div>
        `;
        return;
    }
    
    // æŒ‰æ—¶é—´å€’åºæ’åº
    recents.sort((a, b) => b.time - a.time);
    
    let html = '';
    for (const recent of recents) {
        // å¦‚æœæœ‰ charIdï¼Œå°è¯•ä»æ•°æ®åº“è·å–æœ€æ–°çš„è§’è‰²å¤´åƒ
        let avatar = null;
        if (recent.charId) {
            const char = await db.characters.get(recent.charId);
            if (char) {
                avatar = char.avatar;
            }
        }
        
        const name = recent.name || recent.number || 'æœªçŸ¥';
        const phone = recent.number || '';
        const time = new Date(recent.time);
        const timeStr = formatPhoneTime(time);
        const firstLetter = name.charAt(0).toUpperCase();
        
        // ä½¿ç”¨å¤´åƒæˆ–é¦–å­—æ¯
        const avatarHtml = avatar 
            ? `<img src="${avatar}" class="phone-list-avatar" style="object-fit:cover;border-radius:50%;" />`
            : `<div class="phone-list-avatar">${firstLetter}</div>`;
        
        html += `
            <div class="phone-list-item" onclick="phoneCallNumber('${phone}')">
                ${avatarHtml}
                <div class="phone-list-info">
                    <div class="phone-list-name">${name}</div>
                    <div class="phone-list-subtitle">${timeStr}</div>
                </div>
            </div>
        `;
    }
    
    recentsList.innerHTML = html;
}

function formatPhoneTime(date) {
    const now = new Date();
    
    const month = (date.getMonth() + 1).toString();
    const day = date.getDate().toString();
    const hours = date.getHours().toString().padStart(2, '0');
    const minutes = date.getMinutes().toString().padStart(2, '0');
    
    // ğŸ¯ æ˜¾ç¤ºè¯¦ç»†æ—¶é—´ï¼Œä¸æ˜¾ç¤º"åˆšåˆš"
    // åˆ¤æ–­æ˜¯å¦æ˜¯ä»Šå¤©
    if (date.getDate() === now.getDate() && 
        date.getMonth() === now.getMonth() && 
        date.getFullYear() === now.getFullYear()) {
        return `ä»Šå¤© ${hours}:${minutes}`;
    }
    
    // åˆ¤æ–­æ˜¯å¦æ˜¯æ˜¨å¤©
    const yesterday = new Date(now);
    yesterday.setDate(yesterday.getDate() - 1);
    if (date.getDate() === yesterday.getDate() && 
        date.getMonth() === yesterday.getMonth() && 
        date.getFullYear() === yesterday.getFullYear()) {
        return `æ˜¨å¤© ${hours}:${minutes}`;
    }
    
    // åŒä¸€å¹´æ˜¾ç¤ºæœˆæ—¥+æ—¶é—´
    if (date.getFullYear() === now.getFullYear()) {
        return `${month}æœˆ${day}æ—¥ ${hours}:${minutes}`;
    }
    
    // ä¸åŒå¹´æ˜¾ç¤ºå®Œæ•´æ—¥æœŸ+æ—¶é—´
    return `${date.getFullYear()}å¹´${month}æœˆ${day}æ—¥ ${hours}:${minutes}`;
}

// æ‹¨å·é”®ç›˜åŠŸèƒ½
function phoneKeypadInput(key) {
    currentPhoneNumber += key;
    updatePhoneNumberDisplay();
    updatePhoneKeypadActions();
}

function phoneKeypadDelete() {
    if (currentPhoneNumber.length > 0) {
        currentPhoneNumber = currentPhoneNumber.slice(0, -1);
        updatePhoneNumberDisplay();
        updatePhoneKeypadActions();
    }
}

function updatePhoneNumberDisplay() {
    const display = document.getElementById('phone-number-display');
    if (display) {
        display.textContent = currentPhoneNumber || 'è¾“å…¥å·ç ';
        display.style.color = currentPhoneNumber ? '#000' : '#8e8e93';
    }
}

function updatePhoneKeypadActions() {
    const callBtn = document.getElementById('phone-call-btn');
    const deleteBtn = document.getElementById('phone-delete-btn');
    
    if (currentPhoneNumber.length > 0) {
        if (callBtn) {
            callBtn.style.display = 'flex';
            callBtn.style.background = '#34c759'; // ç»¿è‰²
        }
        if (deleteBtn) deleteBtn.style.display = 'flex';
    } else {
        if (callBtn) {
            callBtn.style.display = 'flex';
            callBtn.style.background = '#c7c7cc'; // ç°è‰²ï¼ˆç¦ç”¨çŠ¶æ€ï¼‰
        }
        if (deleteBtn) deleteBtn.style.display = 'none';
    }
}

function phoneMakeCall() {
    if (!currentPhoneNumber || currentPhoneNumber.length === 0) {
        showToast('è¯·è¾“å…¥ç”µè¯å·ç ');
        return;
    }
    
    // æŸ¥æ‰¾è”ç³»äºº
    db.characters.toArray().then(characters => {
        const contact = characters.find(c => 
            c.identity?.phone === currentPhoneNumber || 
            c.name === currentPhoneNumber || 
            c.nick === currentPhoneNumber
        );
        
        const name = contact ? (contact.nick || contact.name) : currentPhoneNumber;
        
        // æ·»åŠ åˆ°æœ€è¿‘é€šè¯
        addPhoneRecent(name, currentPhoneNumber);
        
        // æ˜¾ç¤ºé€šè¯ç•Œé¢ï¼ˆç®€åŒ–ç‰ˆï¼‰
        showToast(`æ­£åœ¨å‘¼å« ${name}...`);
        
        // æ¨¡æ‹Ÿé€šè¯
        setTimeout(() => {
            showToast('é€šè¯å·²ç»“æŸ');
        }, 2000);
    });
}

function phoneCallContact(charId) {
    db.characters.get(charId).then(contact => {
        if (!contact) return;
        
        const name = contact.nick || contact.name || 'æœªçŸ¥';
        const phone = contact.identity?.phone || '';
        
        if (!phone) {
            showToast('è¯¥è”ç³»äººæ²¡æœ‰ç”µè¯å·ç ');
            return;
        }
        
        // åˆ‡æ¢åˆ°æ‹¨å·é”®ç›˜å¹¶æ˜¾ç¤ºå·ç 
        switchPhoneTab('keypad');
        currentPhoneNumber = phone;
        updatePhoneNumberDisplay();
        updatePhoneKeypadActions();
        
        // æ·»åŠ åˆ°æœ€è¿‘é€šè¯
        addPhoneRecent(name, phone);
        
        // æ˜¾ç¤ºé€šè¯ç•Œé¢
        showToast(`æ­£åœ¨å‘¼å« ${name}...`);
        
        // æ¨¡æ‹Ÿé€šè¯
        setTimeout(() => {
            showToast('é€šè¯å·²ç»“æŸ');
        }, 2000);
    });
}

function phoneCallNumber(number) {
    currentPhoneNumber = number;
    switchPhoneTab('keypad');
    updatePhoneNumberDisplay();
    updatePhoneKeypadActions();
    phoneMakeCall();
}

async function addPhoneRecent(name, number, charId = null) {
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    // æ·»åŠ åˆ° Dexie æ•°æ®åº“
    await db.phone_recents.add({
        accountId: accountId,
        charId: charId,
        name: name,
        number: number,
        time: Date.now(),
        type: 'outgoing' // æ‹¨å‡ºç”µè¯
    });
    
    // é™åˆ¶æ¯ä¸ªè´¦å·æœ€å¤šä¿ç•™100æ¡
    const count = await db.phone_recents.where('accountId').equals(accountId).count();
    if (count > 100) {
        const oldest = await db.phone_recents.where('accountId').equals(accountId).sortBy('time');
        const toDelete = oldest.slice(0, count - 100);
        await db.phone_recents.bulkDelete(toDelete.map(r => r.id));
    }
}

// æ‹¨å·é”®ç›˜åˆå§‹åŒ–åœ¨showPhonePageä¸­å®Œæˆ

// ============================================
// è£…æ‰®åŠŸèƒ½
// ============================================
const wyyDressUpBtn = document.getElementById('wyyDressUpBtn');
const wyyDressUpModal = document.getElementById('wyyDressUpModal');
const wyyCancelBtn = document.getElementById('wyyCancelBtn');
const wyySaveBtn = document.getElementById('wyySaveBtn');
const wyyUploadAvatarBtn = document.getElementById('wyyUploadAvatarBtn');
const wyyAvatarFileInput = document.getElementById('wyyAvatarFileInput');
const wyyAvatarDisplay = document.getElementById('wyyAvatarDisplay');
const wyyModalAvatarPreview = document.getElementById('wyyModalAvatarPreview');

const wyyFollowInput = document.getElementById('wyyFollowInput');
const wyyFansInput = document.getElementById('wyyFansInput');
const wyyLevelInput = document.getElementById('wyyLevelInput');
const wyyTimeInput = document.getElementById('wyyTimeInput');

const wyyFollowValue = document.querySelector('.wyy-stat-item[data-type="follow"] .wyy-stat-value');
const wyyFansValue = document.querySelector('.wyy-stat-item[data-type="fans"] .wyy-stat-value');
const wyyLevelValue = document.querySelector('.wyy-stat-item[data-type="level"] .wyy-stat-value');
const wyyTimeValue = document.querySelector('.wyy-stat-item[data-type="time"] .wyy-stat-value');

const wyyCard1 = document.getElementById('wyyCard1');
const wyyCard2 = document.getElementById('wyyCard2');
const wyyCard3 = document.getElementById('wyyCard3');
const wyyCard4 = document.getElementById('wyyCard4');

const wyyModalCardPreview1 = document.getElementById('wyyModalCardPreview1');
const wyyModalCardPreview2 = document.getElementById('wyyModalCardPreview2');
const wyyModalCardPreview3 = document.getElementById('wyyModalCardPreview3');
const wyyModalCardPreview4 = document.getElementById('wyyModalCardPreview4');

const wyyCardUploadBtns = document.querySelectorAll('.wyy-card-upload-btn');
const wyyCardFileInputs = document.querySelectorAll('.wyy-card-file-input');

let wyyTempAvatar = null;
const wyyTempCards = { 1: null, 2: null, 3: null, 4: null };

if (wyyDressUpBtn) {
    wyyDressUpBtn.addEventListener('click', () => {
        wyyLoadCurrentSettings();
        if (wyyDressUpModal) wyyDressUpModal.style.display = 'flex';
        wyyResetTempData();
    });
}

if (wyyCancelBtn) {
    wyyCancelBtn.addEventListener('click', () => {
        if (wyyDressUpModal) wyyDressUpModal.style.display = 'none';
        wyyResetTempData();
    });
}

if (wyySaveBtn) {
    wyySaveBtn.addEventListener('click', () => {
        wyySaveSettings();
        if (wyyDressUpModal) wyyDressUpModal.style.display = 'none';
    });
}

if (wyyDressUpModal) {
    wyyDressUpModal.addEventListener('click', (e) => {
        if (e.target === wyyDressUpModal) {
            wyyDressUpModal.style.display = 'none';
            wyyResetTempData();
        }
    });
}

if (wyyUploadAvatarBtn && wyyAvatarFileInput) {
    wyyUploadAvatarBtn.addEventListener('click', () => {
        wyyAvatarFileInput.click();
    });

    wyyAvatarFileInput.addEventListener('change', function(event) {
        wyyHandleFileUpload(event, 'avatar');
    });
}

if (wyyCardFileInputs && wyyCardFileInputs.length > 0) {
    wyyCardFileInputs.forEach(input => {
        input.addEventListener('change', function(event) {
            const cardNum = this.getAttribute('data-card');
            wyyHandleFileUpload(event, `card${cardNum}`);
        });
    });
}

if (wyyCardUploadBtns && wyyCardUploadBtns.length > 0) {
    wyyCardUploadBtns.forEach(btn => {
        btn.addEventListener('click', function() {
            const cardNum = this.getAttribute('data-card');
            const fileInput = document.querySelector(`.wyy-card-file-input[data-card="${cardNum}"]`);
            if (fileInput) fileInput.click();
        });
    });
}

function wyyHandleFileUpload(event, type) {
    const file = event.target.files[0];
    
    if (file) {
        if (!file.type.match('image.*')) {
            alert('è¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶ï¼');
            return;
        }
        
        if (file.size > 5 * 1024 * 1024) {
            alert('å›¾ç‰‡å¤§å°ä¸èƒ½è¶…è¿‡5MBï¼');
            return;
        }
        
        const reader = new FileReader();
        
        reader.onload = function(e) {
            if (type === 'avatar') {
                if (wyyModalAvatarPreview) wyyModalAvatarPreview.style.backgroundImage = `url(${e.target.result})`;
                wyyTempAvatar = e.target.result;
            } else {
                const cardNum = type.replace('card', '');
                const preview = document.getElementById(`wyyModalCardPreview${cardNum}`);
                if (preview) {
                    preview.style.backgroundImage = `url(${e.target.result})`;
                    wyyTempCards[cardNum] = e.target.result;
                }
            }
        };
        
        reader.readAsDataURL(file);
    }
}

async function wyyLoadCurrentSettings() {
    try {
        const userSettings = await wyyDb.userSettings.get('avatar');
        if (userSettings && wyyModalAvatarPreview) {
            wyyModalAvatarPreview.style.backgroundImage = `url(${userSettings.data})`;
        } else if (wyyModalAvatarPreview) {
            wyyModalAvatarPreview.style.backgroundImage = '';
        }
        
        const savedFollow = (await wyyDb.userSettings.get('follow'))?.data || '29';
        const savedFans = (await wyyDb.userSettings.get('fans'))?.data || '9';
        const savedLevel = (await wyyDb.userSettings.get('level'))?.data || 'Lv.7';
        const savedTime = (await wyyDb.userSettings.get('time'))?.data || '904h';
        
        if (wyyFollowInput) wyyFollowInput.value = savedFollow;
        if (wyyFansInput) wyyFansInput.value = savedFans;
        if (wyyLevelInput) wyyLevelInput.value = savedLevel;
        if (wyyTimeInput) wyyTimeInput.value = savedTime;
        
        for (let i = 1; i <= 4; i++) {
            const cardKey = `card${i}`;
            const savedCard = await wyyDb.playlistCards.get(cardKey);
            const preview = document.getElementById(`wyyModalCardPreview${i}`);
            if (preview) {
                if (savedCard) {
                    preview.style.backgroundImage = `url(${savedCard.data})`;
                } else {
                    preview.style.backgroundImage = '';
                }
            }
        }
    } catch (error) {
        console.error('åŠ è½½è®¾ç½®å¤±è´¥:', error);
    }
}

async function wyySaveSettings() {
    try {
        if (wyyTempAvatar) {
            if (wyyAvatarDisplay) wyyAvatarDisplay.style.backgroundImage = `url(${wyyTempAvatar})`;
            await wyyDb.userSettings.put({ id: 'avatar', data: wyyTempAvatar });
        }
        
        if (wyyFollowInput && wyyFansInput && wyyLevelInput && wyyTimeInput) {
            const follow = wyyFollowInput.value;
            const fans = wyyFansInput.value;
            const level = wyyLevelInput.value;
            const time = wyyTimeInput.value;
            
            if (wyyFollowValue) wyyFollowValue.textContent = follow;
            if (wyyFansValue) wyyFansValue.textContent = fans;
            if (wyyLevelValue) wyyLevelValue.textContent = level;
            if (wyyTimeValue) wyyTimeValue.textContent = time;
            
            await wyyDb.userSettings.put({ id: 'follow', data: follow });
            await wyyDb.userSettings.put({ id: 'fans', data: fans });
            await wyyDb.userSettings.put({ id: 'level', data: level });
            await wyyDb.userSettings.put({ id: 'time', data: time });
        }
        
        for (let i = 1; i <= 4; i++) {
            if (wyyTempCards[i]) {
                const cardElement = document.getElementById(`wyyCard${i}`);
                if (cardElement) {
                    cardElement.style.backgroundImage = `url(${wyyTempCards[i]})`;
                    await wyyDb.playlistCards.put({ id: `card${i}`, data: wyyTempCards[i] });
                }
            }
        }
        
        wyyResetTempData();
    } catch (error) {
        console.error('ä¿å­˜è®¾ç½®å¤±è´¥:', error);
    }
}

function wyyResetTempData() {
    wyyTempAvatar = null;
    for (let i = 1; i <= 4; i++) {
        wyyTempCards[i] = null;
    }
}

// ============================================
// æ­Œå•ç®¡ç†åŠŸèƒ½
// ============================================

// åŠ è½½æ­Œå•åˆ—è¡¨
async function wyyLoadPlaylists() {
    try {
        const playlists = await wyyDb.playlists.orderBy('dateCreated').reverse().toArray();
        const playlistsList = document.getElementById('wyyPlaylistsList');
        if (!playlistsList) return;
        
        if (playlists.length === 0) {
            playlistsList.innerHTML = '';
            return;
        }
        
        let html = '';
        playlists.forEach(playlist => {
            html += `
                <div class="wyy-playlist-card" data-playlist-id="${playlist.id}" style="cursor: pointer;">
                    <div class="wyy-playlist-cover" style="${playlist.cover ? `background-image: url(${playlist.cover})` : 'background: #f0f0f0;'}"></div>
                    <div class="wyy-playlist-info">
                        <div class="wyy-playlist-name">${playlist.name}</div>
                        <div class="wyy-playlist-desc">${playlist.desc || 'æš‚æ— æè¿°'}</div>
                    </div>
                    <div class="wyy-playlist-actions" style="display: flex; gap: 10px; align-items: center;">
                        <button class="wyy-control-btn" onclick="event.stopPropagation(); wyyExportSinglePlaylist(${playlist.id})" title="å¯¼å‡º">
                            <i class="fa fa-download"></i>
                        </button>
                        <button class="wyy-control-btn" onclick="event.stopPropagation(); wyyDeletePlaylist(${playlist.id})" title="åˆ é™¤" style="color: #ff4444;">
                            <i class="fa fa-trash"></i>
                        </button>
                    </div>
                </div>
            `;
        });
        
        playlistsList.innerHTML = html;
        
        // æ·»åŠ ç‚¹å‡»äº‹ä»¶ï¼ˆç‚¹å‡»æ­Œå•å¡ç‰‡æ˜¾ç¤ºè¯¦æƒ…ï¼Œç‚¹å‡»æ“ä½œæŒ‰é’®ä¸è§¦å‘ï¼‰
        document.querySelectorAll('.wyy-playlist-card[data-playlist-id]').forEach(card => {
            card.addEventListener('click', async function(e) {
                // å¦‚æœç‚¹å‡»çš„æ˜¯æ“ä½œæŒ‰é’®åŒºåŸŸï¼Œä¸è§¦å‘
                if (e.target.closest('.wyy-playlist-actions')) {
                    return;
                }
                const playlistId = parseInt(this.getAttribute('data-playlist-id'));
                await wyyShowPlaylistDetail(playlistId);
            });
        });
    } catch (error) {
        console.error('åŠ è½½æ­Œå•åˆ—è¡¨å¤±è´¥:', error);
    }
}

// åˆ‡æ¢æ­Œå•
async function wyySwitchPlaylist(playlistId) {
    wyyCurrentPlaylistId = playlistId;
    await wyyInitPlaylist();
}

// æ˜¾ç¤ºæ­Œå•è¯¦æƒ…
async function wyyShowPlaylistDetail(playlistId) {
    try {
        const playlist = await wyyDb.playlists.get(playlistId);
        if (!playlist) {
            alert('æ­Œå•ä¸å­˜åœ¨');
            return;
        }
        
        let songs = await wyyDb.songs.where('playlistId').equals(playlistId).toArray();
        // åœ¨å†…å­˜ä¸­æŒ‰æ—¥æœŸæ’åº
        songs.sort((a, b) => {
            const dateA = a.dateAdded ? new Date(a.dateAdded).getTime() : 0;
            const dateB = b.dateAdded ? new Date(b.dateAdded).getTime() : 0;
            return dateA - dateB;
        });
        
        // æ›´æ–°æ ‡é¢˜
        const titleElement = document.getElementById('wyyPlaylistDetailTitle');
        if (titleElement) {
            titleElement.textContent = `${playlist.name} (${songs.length}é¦–)`;
        }
        
        // æ˜¾ç¤ºæ­Œæ›²åˆ—è¡¨
        const songsListElement = document.getElementById('wyyPlaylistDetailSongsList');
        if (!songsListElement) return;
        
        if (songs.length === 0) {
            songsListElement.innerHTML = '<div class="wyy-empty-playlist">è¯¥æ­Œå•æš‚æ— æ­Œæ›²</div>';
        } else {
            let html = '';
            songs.forEach((song, index) => {
                const hasCover = song.cover && song.cover !== '';
                html += `
                    <div class="wyy-song-item" data-song-id="${song.id}">
                        <div class="wyy-song-item-icon ${!hasCover ? 'default' : ''}" style="${hasCover ? `background-image: url(${song.cover})` : ''}">
                            ${!hasCover ? (index + 1) : ''}
                        </div>
                        <div class="wyy-song-item-info">
                            <div class="wyy-song-item-name">${song.name}</div>
                            <div class="wyy-song-item-singer">${song.singer}</div>
                        </div>
                    </div>
                `;
            });
            songsListElement.innerHTML = html;
        }
        
        // æ˜¾ç¤ºæ¨¡æ€æ¡†
        const modal = document.getElementById('wyyPlaylistDetailModal');
        if (modal) {
            modal.style.display = 'flex';
            
            // è®¾ç½®åˆ‡æ¢åˆ°è¯¥æ­Œå•çš„æŒ‰é’®äº‹ä»¶
            const switchBtn = document.getElementById('wyySwitchToPlaylistBtn');
            if (switchBtn) {
                switchBtn.onclick = async () => {
                    await wyySwitchPlaylist(playlistId);
                    modal.style.display = 'none';
                };
            }
        }
    } catch (error) {
        console.error('åŠ è½½æ­Œå•è¯¦æƒ…å¤±è´¥:', error);
        alert('åŠ è½½æ­Œå•è¯¦æƒ…å¤±è´¥');
    }
}

// å…³é—­æ­Œå•è¯¦æƒ…
const wyyClosePlaylistDetailBtn = document.getElementById('wyyClosePlaylistDetailBtn');
const wyyPlaylistDetailModal = document.getElementById('wyyPlaylistDetailModal');

if (wyyClosePlaylistDetailBtn) {
    wyyClosePlaylistDetailBtn.addEventListener('click', () => {
        if (wyyPlaylistDetailModal) wyyPlaylistDetailModal.style.display = 'none';
    });
}

if (wyyPlaylistDetailModal) {
    wyyPlaylistDetailModal.addEventListener('click', (e) => {
        if (e.target === wyyPlaylistDetailModal) {
            wyyPlaylistDetailModal.style.display = 'none';
        }
    });
}

// æ‰“å¼€æ­Œå•ç®¡ç†
const wyyManagePlaylistsBtn = document.getElementById('wyyManagePlaylistsBtn');
if (wyyManagePlaylistsBtn) {
    wyyManagePlaylistsBtn.addEventListener('click', () => {
        const modal = document.getElementById('wyyPlaylistManageModal');
        if (modal) {
            modal.style.display = 'flex';
        }
    });
}

// åˆ›å»ºæ­Œå•
const wyyNewPlaylistBtn = document.getElementById('wyyNewPlaylistBtn');
const wyyCreatePlaylistModal = document.getElementById('wyyCreatePlaylistModal');
const wyyNewPlaylistName = document.getElementById('wyyNewPlaylistName');
const wyyNewPlaylistDesc = document.getElementById('wyyNewPlaylistDesc');
const wyyNewPlaylistCoverPreview = document.getElementById('wyyNewPlaylistCoverPreview');
const wyyUploadPlaylistCoverBtn = document.getElementById('wyyUploadPlaylistCoverBtn');
const wyyPlaylistCoverFileInput = document.getElementById('wyyPlaylistCoverFileInput');
const wyyCancelCreatePlaylistBtn = document.getElementById('wyyCancelCreatePlaylistBtn');
const wyySaveCreatePlaylistBtn = document.getElementById('wyySaveCreatePlaylistBtn');

let wyyTempPlaylistCover = null;

if (wyyNewPlaylistBtn) {
    wyyNewPlaylistBtn.addEventListener('click', () => {
        if (wyyCreatePlaylistModal) wyyCreatePlaylistModal.style.display = 'flex';
        if (wyyNewPlaylistName) wyyNewPlaylistName.value = '';
        if (wyyNewPlaylistDesc) wyyNewPlaylistDesc.value = '';
        if (wyyNewPlaylistCoverPreview) wyyNewPlaylistCoverPreview.style.backgroundImage = '';
        wyyTempPlaylistCover = null;
    });
}

if (wyyUploadPlaylistCoverBtn && wyyPlaylistCoverFileInput) {
    wyyUploadPlaylistCoverBtn.addEventListener('click', () => {
        wyyPlaylistCoverFileInput.click();
    });

    wyyPlaylistCoverFileInput.addEventListener('change', function(event) {
        const file = event.target.files[0];
        if (file) {
            if (!file.type.match('image.*')) {
                alert('è¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶ï¼');
                return;
            }
            if (file.size > 5 * 1024 * 1024) {
                alert('å›¾ç‰‡å¤§å°ä¸èƒ½è¶…è¿‡5MBï¼');
                return;
            }
            const reader = new FileReader();
            reader.onload = function(e) {
                if (wyyNewPlaylistCoverPreview) wyyNewPlaylistCoverPreview.style.backgroundImage = `url(${e.target.result})`;
                wyyTempPlaylistCover = e.target.result;
            };
            reader.readAsDataURL(file);
        }
    });
}

if (wyyCancelCreatePlaylistBtn) {
    wyyCancelCreatePlaylistBtn.addEventListener('click', () => {
        if (wyyCreatePlaylistModal) wyyCreatePlaylistModal.style.display = 'none';
    });
}

if (wyySaveCreatePlaylistBtn && wyyNewPlaylistName) {
    wyySaveCreatePlaylistBtn.addEventListener('click', async () => {
        const name = wyyNewPlaylistName.value.trim();
        if (!name) {
            alert('è¯·è¾“å…¥æ­Œå•åç§°');
            return;
        }
        
        try {
            const playlistId = await wyyDb.playlists.add({
                name: name,
                desc: wyyNewPlaylistDesc ? wyyNewPlaylistDesc.value.trim() : '',
                cover: wyyTempPlaylistCover || '',
                dateCreated: new Date()
            });
            
            if (wyyCreatePlaylistModal) wyyCreatePlaylistModal.style.display = 'none';
            await wyyLoadPlaylists();
            await wyySwitchPlaylist(playlistId);
            alert('æ­Œå•åˆ›å»ºæˆåŠŸï¼');
        } catch (error) {
            console.error('åˆ›å»ºæ­Œå•å¤±è´¥:', error);
            alert('åˆ›å»ºæ­Œå•å¤±è´¥ï¼Œè¯·é‡è¯•');
        }
    });
}

if (wyyCreatePlaylistModal) {
    wyyCreatePlaylistModal.addEventListener('click', (e) => {
        if (e.target === wyyCreatePlaylistModal) {
            wyyCreatePlaylistModal.style.display = 'none';
        }
    });
}

// åˆ é™¤æ­Œå•
async function wyyDeletePlaylist(playlistId) {
    if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªæ­Œå•å—ï¼Ÿæ­Œå•ä¸­çš„æ­Œæ›²ä¸ä¼šè¢«åˆ é™¤ã€‚')) {
        return;
    }
    
    try {
        // åˆ é™¤æ­Œå•
        await wyyDb.playlists.delete(playlistId);
        
        // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰æ­Œå•ï¼Œåˆ‡æ¢åˆ°é»˜è®¤æ­Œå•
        if (wyyCurrentPlaylistId === playlistId) {
            wyyCurrentPlaylistId = null;
            await wyyInitPlaylist();
        }
        
        await wyyLoadPlaylists();
        alert('æ­Œå•åˆ é™¤æˆåŠŸï¼');
    } catch (error) {
        console.error('åˆ é™¤æ­Œå•å¤±è´¥:', error);
        alert('åˆ é™¤æ­Œå•å¤±è´¥ï¼Œè¯·é‡è¯•');
    }
}

// å¯¼å‡ºå•ä¸ªæ­Œå•
async function wyyExportSinglePlaylist(playlistId) {
    try {
        const playlist = await wyyDb.playlists.get(playlistId);
        if (!playlist) {
            alert('æ­Œå•ä¸å­˜åœ¨');
            return;
        }
        
        const songs = await wyyDb.songs.where('playlistId').equals(playlistId).toArray();
        
        // åŠ è½½æ¯é¦–æ­Œæ›²çš„å®Œæ•´ä¿¡æ¯
        const fullSongs = [];
        for (const song of songs) {
            const songFile = await wyyDb.songFiles.where({ songId: song.id }).first();
            const lyric = await wyyDb.lyrics.where({ songId: song.id }).first();
            
            const fullSong = {
                name: song.name,
                singer: song.singer,
                cover: song.cover || '',
                url: song.url || '',
                lyricUrl: song.lyricUrl || '',
                hasLocalFile: !!songFile,
                hasLocalLyric: !!lyric
            };
            
            if (songFile) {
                fullSong.fileData = songFile.data;
                fullSong.fileType = songFile.type;
            }
            
            if (lyric) {
                fullSong.lyricData = lyric.data;
            }
            
            fullSongs.push(fullSong);
        }
        
        const exportData = {
            playlist: {
                name: playlist.name,
                desc: playlist.desc,
                cover: playlist.cover
            },
            songs: fullSongs,
            exportDate: new Date().toISOString()
        };
        
        const dataStr = JSON.stringify(exportData, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(dataBlob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `${playlist.name}.json`;
        link.click();
        URL.revokeObjectURL(url);
        
        alert('æ­Œå•å¯¼å‡ºæˆåŠŸï¼');
    } catch (error) {
        console.error('å¯¼å‡ºæ­Œå•å¤±è´¥:', error);
        alert('å¯¼å‡ºæ­Œå•å¤±è´¥ï¼Œè¯·é‡è¯•');
    }
}

// å¯¼å‡ºå½“å‰æ­Œå•
const wyyExportPlaylistBtn = document.getElementById('wyyExportPlaylistBtn');
if (wyyExportPlaylistBtn) {
    wyyExportPlaylistBtn.addEventListener('click', async () => {
        if (!wyyCurrentPlaylistId) {
            alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ­Œå•');
            return;
        }
        await wyyExportSinglePlaylist(wyyCurrentPlaylistId);
    });
}

// å¯¼å…¥æ­Œå•
const wyyImportPlaylistBtn = document.getElementById('wyyImportPlaylistBtn');
const wyyImportPlaylistFileInput = document.getElementById('wyyImportPlaylistFileInput');

if (wyyImportPlaylistBtn && wyyImportPlaylistFileInput) {
    wyyImportPlaylistBtn.addEventListener('click', () => {
        wyyImportPlaylistFileInput.click();
    });

    wyyImportPlaylistFileInput.addEventListener('change', async function(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        if (!file.name.endsWith('.json')) {
            alert('è¯·é€‰æ‹©JSONæ ¼å¼çš„æ–‡ä»¶');
            return;
        }
        
        try {
            const text = await file.text();
            const importData = JSON.parse(text);
            
            if (!importData.playlist || !importData.songs) {
                alert('æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®');
                return;
            }
            
            // åˆ›å»ºæ­Œå•
            const playlistId = await wyyDb.playlists.add({
                name: importData.playlist.name + ' (å¯¼å…¥)',
                desc: importData.playlist.desc || '',
                cover: importData.playlist.cover || '',
                dateCreated: new Date()
            });
            
            // å¯¼å…¥æ­Œæ›²
            for (const songData of importData.songs) {
                const songId = await wyyDb.songs.add({
                    name: songData.name,
                    singer: songData.singer,
                    cover: songData.cover || '',
                    url: songData.url || '',
                    lyricUrl: songData.lyricUrl || '',
                    playlistId: playlistId,
                    dateAdded: new Date()
                });
                
                if (songData.hasLocalFile && songData.fileData) {
                    await wyyDb.songFiles.add({
                        songId: songId,
                        type: songData.fileType || 'audio/mpeg',
                        data: songData.fileData
                    });
                }
                
                if (songData.hasLocalLyric && songData.lyricData) {
                    await wyyDb.lyrics.add({
                        songId: songId,
                        data: songData.lyricData
                    });
                }
            }
            
            await wyyLoadPlaylists();
            await wyySwitchPlaylist(playlistId);
            alert('æ­Œå•å¯¼å…¥æˆåŠŸï¼');
        } catch (error) {
            console.error('å¯¼å…¥æ­Œå•å¤±è´¥:', error);
            alert('å¯¼å…¥æ­Œå•å¤±è´¥ï¼š' + error.message);
        }
    });
}

// æ·»åŠ åˆ°æ­Œå•åŠŸèƒ½
const wyyAddToPlaylistModal = document.getElementById('wyyAddToPlaylistModal');
const wyyPlaylistSelectorList = document.getElementById('wyyPlaylistSelectorList');
const wyyCancelAddToPlaylistBtn = document.getElementById('wyyCancelAddToPlaylistBtn');
let wyyCurrentAddSongId = null;

// æ˜¾ç¤ºæ·»åŠ åˆ°æ­Œå•æ¨¡æ€æ¡†
async function wyyShowAddToPlaylistModal(songId) {
    wyyCurrentAddSongId = songId;
    
    try {
        const playlists = await wyyDb.playlists.orderBy('dateCreated').reverse().toArray();
        
        if (!wyyPlaylistSelectorList) return;
        
        if (playlists.length === 0) {
            wyyPlaylistSelectorList.innerHTML = '<div style="text-align: center; padding: 20px; color: #999;">è¿˜æ²¡æœ‰æ­Œå•ï¼Œè¯·å…ˆåˆ›å»ºæ­Œå•</div>';
        } else {
            let html = '';
            playlists.forEach(playlist => {
                html += `
                    <div class="wyy-playlist-selector-item" data-playlist-id="${playlist.id}" style="padding: 12px; border-bottom: 1px solid #eee; cursor: pointer; display: flex; align-items: center; gap: 12px; transition: background 0.2s;">
                        <div class="wyy-playlist-cover" style="width: 40px; height: 40px; border-radius: 6px; ${playlist.cover ? `background-image: url(${playlist.cover})` : 'background: #f0f0f0;'}"></div>
                        <div style="flex: 1;">
                            <div style="font-weight: 500; color: #333; margin-bottom: 2px;">${playlist.name}</div>
                            <div style="font-size: 12px; color: #999;">${playlist.desc || 'æš‚æ— æè¿°'}</div>
                        </div>
                        <i class="fa fa-chevron-right" style="color: #ccc;"></i>
                    </div>
                `;
            });
            
            wyyPlaylistSelectorList.innerHTML = html;
            
            // æ·»åŠ ç‚¹å‡»äº‹ä»¶
            document.querySelectorAll('.wyy-playlist-selector-item').forEach(item => {
                item.addEventListener('click', async function() {
                    const playlistId = parseInt(this.getAttribute('data-playlist-id'));
                    await wyyAddSongToPlaylist(songId, playlistId);
                });
            });
        }
        
        if (wyyAddToPlaylistModal) wyyAddToPlaylistModal.style.display = 'flex';
    } catch (error) {
        console.error('åŠ è½½æ­Œå•åˆ—è¡¨å¤±è´¥:', error);
        alert('åŠ è½½æ­Œå•åˆ—è¡¨å¤±è´¥');
    }
}

// å°†æ­Œæ›²æ·»åŠ åˆ°æ­Œå•
async function wyyAddSongToPlaylist(songId, playlistId) {
    try {
        // æ£€æŸ¥æ­Œæ›²æ˜¯å¦å·²ç»åœ¨æ­Œå•ä¸­
        const existingSong = await wyyDb.songs.where({ id: songId, playlistId: playlistId }).first();
        if (existingSong) {
            alert('æ­Œæ›²å·²åœ¨è¯¥æ­Œå•ä¸­');
            if (wyyAddToPlaylistModal) wyyAddToPlaylistModal.style.display = 'none';
            return;
        }
        
        // è·å–åŸæ­Œæ›²ä¿¡æ¯
        const originalSong = await wyyDb.songs.get(songId);
        if (!originalSong) {
            alert('æ­Œæ›²ä¸å­˜åœ¨');
            return;
        }
        
        // åˆ›å»ºæ–°æ­Œæ›²è®°å½•ï¼ˆæ·»åŠ åˆ°æ–°æ­Œå•ï¼‰
        const newSongData = {
            name: originalSong.name,
            singer: originalSong.singer,
            cover: originalSong.cover || '',
            url: originalSong.url || '',
            lyricUrl: originalSong.lyricUrl || '',
            playlistId: playlistId,
            dateAdded: new Date()
        };
        
        const newSongId = await wyyDb.songs.add(newSongData);
        
        // å¤åˆ¶æ­Œæ›²æ–‡ä»¶
        const songFile = await wyyDb.songFiles.where({ songId: songId }).first();
        if (songFile) {
            await wyyDb.songFiles.add({
                songId: newSongId,
                type: songFile.type,
                data: songFile.data
            });
        }
        
        // å¤åˆ¶æ­Œè¯æ–‡ä»¶
        const lyric = await wyyDb.lyrics.where({ songId: songId }).first();
        if (lyric) {
            await wyyDb.lyrics.add({
                songId: newSongId,
                data: lyric.data
            });
        }
        
        if (wyyAddToPlaylistModal) wyyAddToPlaylistModal.style.display = 'none';
        alert('æ­Œæ›²å·²æ·»åŠ åˆ°æ­Œå•ï¼');
    } catch (error) {
        console.error('æ·»åŠ æ­Œæ›²åˆ°æ­Œå•å¤±è´¥:', error);
        alert('æ·»åŠ æ­Œæ›²åˆ°æ­Œå•å¤±è´¥ï¼Œè¯·é‡è¯•');
    }
}

if (wyyCancelAddToPlaylistBtn) {
    wyyCancelAddToPlaylistBtn.addEventListener('click', () => {
        if (wyyAddToPlaylistModal) wyyAddToPlaylistModal.style.display = 'none';
    });
}

if (wyyAddToPlaylistModal) {
    wyyAddToPlaylistModal.addEventListener('click', (e) => {
        if (e.target === wyyAddToPlaylistModal) {
            wyyAddToPlaylistModal.style.display = 'none';
        }
    });
}

// æ­Œå•ç®¡ç†æ¨¡æ€æ¡†
const wyyPlaylistManageModal = document.getElementById('wyyPlaylistManageModal');
const wyyClosePlaylistManageBtn = document.getElementById('wyyClosePlaylistManageBtn');

if (wyyClosePlaylistManageBtn) {
    wyyClosePlaylistManageBtn.addEventListener('click', () => {
        if (wyyPlaylistManageModal) wyyPlaylistManageModal.style.display = 'none';
    });
}

if (wyyPlaylistManageModal) {
    wyyPlaylistManageModal.addEventListener('click', (e) => {
        if (e.target === wyyPlaylistManageModal) {
            wyyPlaylistManageModal.style.display = 'none';
        }
    });
}

// ============================================
// ä¸€èµ·å¬åŠŸèƒ½
// ============================================
let wyyTogetherListenRole = null; // å½“å‰ä¸€èµ·å¬çš„è§’è‰²
let wyyTogetherListenInterval = null; // æ›´æ–°ä¸€èµ·å¬çŠ¶æ€çš„å®šæ—¶å™¨

const wyyTogetherListenBtn = document.getElementById('wyyTogetherListenBtn');
const wyyTogetherListenModal = document.getElementById('wyyTogetherListenModal');
const wyyTogetherListenRoleList = document.getElementById('wyyTogetherListenRoleList');
const wyyCancelTogetherListenBtn = document.getElementById('wyyCancelTogetherListenBtn');
const wyyStopTogetherListenBtn = document.getElementById('wyyStopTogetherListenBtn');

// æ‰“å¼€ä¸€èµ·å¬é€‰æ‹©è§’è‰²æ¨¡æ€æ¡†
if (wyyTogetherListenBtn) {
    wyyTogetherListenBtn.addEventListener('click', () => {
        wyyShowTogetherListenRoleSelector();
    });
}

// æ˜¾ç¤ºè§’è‰²é€‰æ‹©å™¨
function wyyShowTogetherListenRoleSelector() {
    if (!wyyTogetherListenRoleList) return;
    
    const friends = getFriendList();
    
    if (friends.length === 0) {
        wyyTogetherListenRoleList.innerHTML = '<div style="text-align: center; padding: 20px; color: #999;">è¿˜æ²¡æœ‰å¥½å‹ï¼Œè¯·å…ˆæ·»åŠ å¥½å‹</div>';
    } else {
        let html = '';
        friends.forEach(friend => {
            // å¤„ç†friendå¯èƒ½æ˜¯å¯¹è±¡æˆ–å­—ç¬¦ä¸²çš„æƒ…å†µ
            const friendName = typeof friend === 'string' ? friend : (friend.name || friend.remark || 'æœªçŸ¥');
            const friendDisplayName = typeof friend === 'string' ? friend : (friend.remark || friend.name || 'æœªçŸ¥');
            const isActive = wyyTogetherListenRole === friendName;
            const firstChar = String(friendDisplayName).charAt(0);
            
            html += `
                <div class="wyy-playlist-selector-item ${isActive ? 'active' : ''}" data-role="${friendName}" style="padding: 12px; border-bottom: 1px solid #eee; cursor: pointer; display: flex; align-items: center; gap: 12px; transition: background 0.2s;">
                    <div style="width: 40px; height: 40px; border-radius: 50%; background: #f0f0f0; display: flex; align-items: center; justify-content: center; font-size: 18px; color: #666;">${firstChar}</div>
                    <div style="flex: 1;">
                        <div style="font-weight: 500; color: #333; margin-bottom: 2px;">${friendDisplayName}</div>
                        ${isActive ? '<div style="font-size: 12px; color: #ff6b6b;">æ­£åœ¨ä¸€èµ·å¬</div>' : ''}
                    </div>
                    ${isActive ? '<i class="fa fa-check-circle" style="color: #ff6b6b;"></i>' : '<i class="fa fa-chevron-right" style="color: #ccc;"></i>'}
                </div>
            `;
        });
        wyyTogetherListenRoleList.innerHTML = html;
        
        // æ·»åŠ ç‚¹å‡»äº‹ä»¶
        document.querySelectorAll('.wyy-playlist-selector-item[data-role]').forEach(item => {
            item.addEventListener('click', function() {
                const role = this.getAttribute('data-role');
                if (wyyTogetherListenRole === role) {
                    // å¦‚æœå·²ç»æ˜¯ä¸€èµ·å¬çš„è§’è‰²ï¼Œåˆ™ç»“æŸä¸€èµ·å¬
                    wyyStopTogetherListen();
                } else {
                    // å¼€å§‹å’Œè¯¥è§’è‰²ä¸€èµ·å¬
                    wyyStartTogetherListen(role);
                }
            });
        });
    }
    
    // æ›´æ–°ç»“æŸæŒ‰é’®æ˜¾ç¤º
    if (wyyStopTogetherListenBtn) {
        if (wyyTogetherListenRole) {
            wyyStopTogetherListenBtn.style.display = 'block';
        } else {
            wyyStopTogetherListenBtn.style.display = 'none';
        }
    }
    
    if (wyyTogetherListenModal) wyyTogetherListenModal.style.display = 'flex';
}

// å¼€å§‹ä¸€èµ·å¬
function wyyStartTogetherListen(role) {
    // ç¡®ä¿roleæ˜¯å­—ç¬¦ä¸²
    wyyTogetherListenRole = String(role);
    if (wyyTogetherListenBtn) wyyTogetherListenBtn.classList.add('active');
    if (wyyTogetherListenModal) wyyTogetherListenModal.style.display = 'none';
    
    // ä¸å†å‘é€æ¶ˆæ¯åˆ°å¯¹è¯æ¡†ï¼Œåªä½œä¸ºè§’è‰²å›å¤çš„å‚è€ƒ
    // å¼€å§‹å®šæ—¶æ›´æ–°ä¸€èµ·å¬çŠ¶æ€ï¼ˆè™½ç„¶ä¸å†æ›´æ–°å¡ç‰‡ï¼Œä½†ä¿æŒçŠ¶æ€ï¼‰
    wyyStartTogetherListenUpdate();
    
    alert(`å·²å¼€å§‹å’Œ ${wyyTogetherListenRole} ä¸€èµ·å¬`);
}

// ç»“æŸä¸€èµ·å¬
function wyyStopTogetherListen() {
    // ä¸å†å‘é€æ¶ˆæ¯åˆ°å¯¹è¯æ¡†
    wyyTogetherListenRole = null;
    if (wyyTogetherListenBtn) wyyTogetherListenBtn.classList.remove('active');
    if (wyyTogetherListenModal) wyyTogetherListenModal.style.display = 'none';
    
    // åœæ­¢å®šæ—¶æ›´æ–°
    wyyStopTogetherListenUpdate();
}

// å¼€å§‹å®šæ—¶æ›´æ–°ä¸€èµ·å¬çŠ¶æ€ï¼ˆä¸å†æ›´æ–°å¡ç‰‡ï¼Œåªä¿æŒçŠ¶æ€ï¼‰
function wyyStartTogetherListenUpdate() {
    wyyStopTogetherListenUpdate();
    // ä¸å†æ›´æ–°å¡ç‰‡ï¼Œå› ä¸ºä¸å†å‘é€æ¶ˆæ¯åˆ°å¯¹è¯æ¡†
    // çŠ¶æ€ä¼šé€šè¿‡ systemPrompt ä¼ é€’ç»™è§’è‰²
}

// åœæ­¢å®šæ—¶æ›´æ–°
function wyyStopTogetherListenUpdate() {
    if (wyyTogetherListenInterval) {
        clearInterval(wyyTogetherListenInterval);
        wyyTogetherListenInterval = null;
    }
}

// ä»èŠå¤©åˆ‡æ¢æ­Œæ›²ï¼ˆå…¨å±€å‡½æ•°ï¼Œä¾›HTML onclickä½¿ç”¨ï¼‰
window.wyySwitchSongFromChat = function(role, direction) {
    // ç¡®ä¿ç±»å‹ä¸€è‡´è¿›è¡Œæ¯”è¾ƒ
    const roleStr = String(role);
    if (String(wyyTogetherListenRole) !== roleStr) {
        alert('å½“å‰æ²¡æœ‰å’Œè¯¥è§’è‰²ä¸€èµ·å¬');
        return;
    }
    
    if (direction === 'prev') {
        if (wyyPlaylist.length > 0) {
            wyyCurrentSongIndex = (wyyCurrentSongIndex - 1 + wyyPlaylist.length) % wyyPlaylist.length;
            wyyPlaySong(wyyCurrentSongIndex);
            // ä¸å†å‘é€æ¶ˆæ¯åˆ°å¯¹è¯æ¡†ï¼ŒçŠ¶æ€ä¼šé€šè¿‡ systemPrompt ä¼ é€’ç»™è§’è‰²
        }
    } else if (direction === 'next') {
        if (wyyPlaylist.length > 0) {
            wyyCurrentSongIndex = (wyyCurrentSongIndex + 1) % wyyPlaylist.length;
            wyyPlaySong(wyyCurrentSongIndex);
            // ä¸å†å‘é€æ¶ˆæ¯åˆ°å¯¹è¯æ¡†ï¼ŒçŠ¶æ€ä¼šé€šè¿‡ systemPrompt ä¼ é€’ç»™è§’è‰²
        }
    }
}

if (wyyCancelTogetherListenBtn) {
    wyyCancelTogetherListenBtn.addEventListener('click', () => {
        if (wyyTogetherListenModal) wyyTogetherListenModal.style.display = 'none';
    });
}

if (wyyStopTogetherListenBtn) {
    wyyStopTogetherListenBtn.addEventListener('click', () => {
        wyyStopTogetherListen();
    });
}

if (wyyTogetherListenModal) {
    wyyTogetherListenModal.addEventListener('click', (e) => {
        if (e.target === wyyTogetherListenModal) {
            wyyTogetherListenModal.style.display = 'none';
        }
    });
}

// é˜»æ­¢æ­Œè¯å®¹å™¨æ»šåŠ¨äº‹ä»¶å†’æ³¡ï¼Œé¿å…å½±å“é¡µé¢æ»šåŠ¨
if (wyyLyricsContainer) {
    wyyLyricsContainer.addEventListener('touchmove', (e) => {
        e.stopPropagation();
    }, { passive: true });
    wyyLyricsContainer.addEventListener('wheel', (e) => {
        e.stopPropagation();
    }, { passive: true });
}

// é¡µé¢åŠ è½½æ—¶æ¢å¤è®¾ç½®å’Œåˆå§‹åŒ–æ’­æ”¾åˆ—è¡¨
window.addEventListener('DOMContentLoaded', async () => {
    try {
        // ç¡®ä¿æ’­æ”¾å™¨è¯¦æƒ…é¡µé¢åˆå§‹çŠ¶æ€æ˜¯éšè—çš„
        if (wyyPlayerPage) wyyPlayerPage.classList.remove('active');
        if (wyyMainPage) wyyMainPage.classList.add('active');
        
        const savedAvatar = await wyyDb.userSettings.get('avatar');
        if (savedAvatar && wyyAvatarDisplay) {
            wyyAvatarDisplay.style.backgroundImage = `url(${savedAvatar.data})`;
        }
        
        const savedFollow = await wyyDb.userSettings.get('follow');
        const savedFans = await wyyDb.userSettings.get('fans');
        const savedLevel = await wyyDb.userSettings.get('level');
        const savedTime = await wyyDb.userSettings.get('time');
        
        if (savedFollow && wyyFollowValue) wyyFollowValue.textContent = savedFollow.data;
        if (savedFans && wyyFansValue) wyyFansValue.textContent = savedFans.data;
        if (savedLevel && wyyLevelValue) wyyLevelValue.textContent = savedLevel.data;
        if (savedTime && wyyTimeValue) wyyTimeValue.textContent = savedTime.data;
        
        for (let i = 1; i <= 4; i++) {
            const cardKey = `card${i}`;
            const savedCard = await wyyDb.playlistCards.get(cardKey);
            const cardElement = document.getElementById(`wyyCard${i}`);
            if (cardElement && savedCard) {
                cardElement.style.backgroundImage = `url(${savedCard.data})`;
            }
        }
        
        await wyyInitPlaylist();
        await wyyLoadPlaylists();
    } catch (error) {
        console.error('åŠ è½½è®¾ç½®å¤±è´¥:', error);
    }
});

// ==================== å°å±‹åŠŸèƒ½ ====================
let currentCabinMachine = 'furniture'; // furniture æˆ– clothes
let cabinCoinCount = 200;

// å°å±‹æ‰­è›‹çŠ¶æ€ç®¡ç†
window.cabinGachaState = {
    coins: 200,
    customItems: {},  // ç‰©å“åº“
    catalog: {},      // å›¾é‰´è®°å½•
    inventory: {},    // èƒŒåŒ…åº“å­˜
    gachaPool: {
        furniture: [],
        clothes: []
    }
};

function showCabinPage() {
    document.getElementById('home-page').style.display = 'none';
    document.getElementById('cabin-page').style.display = 'flex';
    
    // é¦–æ¬¡æ‰“å¼€æ—¶åˆå§‹åŒ–æ•°æ®
    if (!window.cabinInitialized) {
        // å°è¯•ä»æœ¬åœ°å­˜å‚¨åŠ è½½æ•°æ®
        const loaded = loadCabinGachaData();
        
        // å¦‚æœæ²¡æœ‰ä¿å­˜çš„æ•°æ®ï¼Œåˆå§‹åŒ–é»˜è®¤ç‰©å“
        if (!loaded) {
            initDefaultItems();
        }
        
        window.cabinInitialized = true;
    }
    
    updateCabinCoinDisplay();
    updateCabinUI();
}

function hideCabinPage() {
    document.getElementById('cabin-page').style.display = 'none';
    document.getElementById('home-page').style.display = 'block';
}

function updateCabinCoinDisplay() {
    const state = window.cabinGachaState;
    const coinElement = document.getElementById('cabin-coin-count');
    if (coinElement) {
        coinElement.textContent = state.coins;
    }
    // åŒæ­¥å…¨å±€å˜é‡
    cabinCoinCount = state.coins;
}

// ä¿å­˜å°å±‹æ‰­è›‹æ•°æ®åˆ°æœ¬åœ°å­˜å‚¨
function saveCabinGachaData() {
    try {
        const state = window.cabinGachaState;
        localStorage.setItem('cabinGachaState', JSON.stringify(state));
        console.log('å°å±‹æ•°æ®å·²ä¿å­˜');
    } catch (e) {
        console.error('ä¿å­˜å°å±‹æ•°æ®å¤±è´¥:', e);
    }
}

// ä»æœ¬åœ°å­˜å‚¨åŠ è½½å°å±‹æ‰­è›‹æ•°æ®
function loadCabinGachaData() {
    try {
        const saved = localStorage.getItem('cabinGachaState');
        if (saved) {
            const state = JSON.parse(saved);
            window.cabinGachaState = state;
            cabinCoinCount = state.coins;
            console.log('å°å±‹æ•°æ®å·²åŠ è½½');
            return true;
        }
    } catch (e) {
        console.error('åŠ è½½å°å±‹æ•°æ®å¤±è´¥:', e);
    }
    return false;
}

// æ›´æ–°å°å±‹UIï¼ˆåˆ·æ–°æ‰€æœ‰ç›¸å…³æ˜¾ç¤ºï¼‰
function updateCabinUI() {
    // æ›´æ–°é‡‘å¸æ˜¾ç¤º
    updateCabinCoinDisplay();
    
    // å¦‚æœå›¾é‰´å¼¹çª—æ‰“å¼€ï¼Œåˆ·æ–°å›¾é‰´
    const catalogModal = document.getElementById('catalog-modal');
    if (catalogModal && catalogModal.style.display === 'flex') {
        renderCatalogItems();
    }
    
    // æ›´æ–°èƒŒåŒ…æ˜¾ç¤ºï¼ˆå¦‚æœæœ‰èƒŒåŒ…UIï¼‰
    updateCabinInventoryDisplay();
}

function switchCabinScreen(screenName) {
    // ç§»é™¤æ‰€æœ‰activeç±»
    document.querySelectorAll('.cabin-screen').forEach(s => s.classList.remove('active'));
    document.querySelectorAll('.cabin-nav-item').forEach(n => n.classList.remove('active'));

    // æ·»åŠ activeç±»
    const screen = document.getElementById('cabin-' + screenName + '-screen');
    if (screen) {
        screen.classList.add('active');
    }
    
    // æ‰¾åˆ°å¯¹åº”çš„å¯¼èˆªé¡¹å¹¶æ¿€æ´»
    const navItems = document.querySelectorAll('.cabin-nav-item');
    navItems.forEach(item => {
        const text = item.querySelector('.cabin-nav-item-text').textContent;
        if ((screenName === 'gacha' && text === 'æ‰­è›‹') ||
            (screenName === 'catalog' && text === 'å›¾é‰´') ||
            (screenName === 'house' && text === 'æˆ¿å±‹') ||
            (screenName === 'character' && text === 'äººç‰©')) {
            item.classList.add('active');
        }
    });
}

function switchCabinMachine() {
    const furnitureGacha = document.getElementById('cabin-furniture-gacha');
    const clothesGacha = document.getElementById('cabin-clothes-gacha');
    const machineTitle = document.getElementById('cabin-machine-title');

    if (currentCabinMachine === 'furniture') {
        furnitureGacha.style.display = 'none';
        clothesGacha.style.display = 'flex';
        machineTitle.textContent = 'æœè£…æ‰­è›‹æœº';
        currentCabinMachine = 'clothes';
    } else {
        furnitureGacha.style.display = 'flex';
        clothesGacha.style.display = 'none';
        machineTitle.textContent = 'å®¶å…·æ‰­è›‹æœº';
        currentCabinMachine = 'furniture';
    }
}

// ç¨€æœ‰åº¦æƒé‡é…ç½®
const RARITY_WEIGHTS = {
    'R': 70,    // 70%
    'SR': 25,   // 25%
    'SSR': 5    // 5%
};

// æ ¹æ®æƒé‡éšæœºæŠ½å–ä¸€ä¸ªç¨€æœ‰åº¦
function getRandomRarity() {
    const total = Object.values(RARITY_WEIGHTS).reduce((sum, weight) => sum + weight, 0);
    let random = Math.random() * total;
    
    for (const [rarity, weight] of Object.entries(RARITY_WEIGHTS)) {
        random -= weight;
        if (random <= 0) {
            return rarity;
        }
    }
    return 'R'; // é»˜è®¤è¿”å›R
}

// æ ¹æ®ç¨€æœ‰åº¦ä»ç‰©å“æ± ä¸­éšæœºæŠ½å–ç‰©å“
function drawItem(targetRarity) {
    const state = window.cabinGachaState;
    
    // è·å–å½“å‰æ‰­è›‹æœºç±»å‹çš„ç‰©å“æ± 
    const poolType = currentCabinMachine === 'furniture' ? 'furniture' : 'clothes';
    
    // è·å–æ‰€æœ‰å¯æŠ½å–çš„ç‰©å“
    const availableItems = Object.entries(state.customItems)
        .filter(([id, item]) => {
            // å®¶å…·æ‰­è›‹æœºæŠ½å–å®¶å…·ç±»
            if (poolType === 'furniture') {
                return item.inPool && ['furniture', 'decor', 'wall', 'floor'].includes(item.type);
            }
            // æœè£…æ‰­è›‹æœºæŠ½å–æœè£…ç±»ï¼ˆæš‚æœªå®ç°ï¼‰
            return false;
        })
        .filter(([id, item]) => item.rarity === targetRarity);
    
    if (availableItems.length === 0) {
        // å¦‚æœè¯¥ç¨€æœ‰åº¦æ²¡æœ‰ç‰©å“ï¼Œé™çº§æŠ½å–
        if (targetRarity === 'SSR') return drawItem('SR');
        if (targetRarity === 'SR') return drawItem('R');
        // å¦‚æœéƒ½æ²¡æœ‰ï¼Œéšæœºè¿”å›ä»»æ„ç‰©å“
        const allItems = Object.entries(state.customItems).filter(([id, item]) => item.inPool);
        if (allItems.length > 0) {
            const randomIndex = Math.floor(Math.random() * allItems.length);
            return allItems[randomIndex];
        }
        return null;
    }
    
    // éšæœºé€‰æ‹©ä¸€ä¸ªç‰©å“
    const randomIndex = Math.floor(Math.random() * availableItems.length);
    return availableItems[randomIndex];
}

// æ›´æ–°èƒŒåŒ…å’Œå›¾é‰´
function addItemToInventory(itemId) {
    const state = window.cabinGachaState;
    
    // æ›´æ–°èƒŒåŒ…
    state.inventory[itemId] = (state.inventory[itemId] || 0) + 1;
    
    // æ›´æ–°å›¾é‰´
    if (!state.catalog[itemId]) {
        state.catalog[itemId] = { seen: true, owned: true };
    } else {
        state.catalog[itemId].seen = true;
        state.catalog[itemId].owned = true;
    }
    
    // ä¿å­˜çŠ¶æ€
    saveCabinGachaData();
}

// æ˜¾ç¤ºæŠ½å¥–ç»“æœ
function showDrawResult(items) {
    if (!items || items.length === 0) return;
    
    const state = window.cabinGachaState;
    
    // åˆ›å»ºç»“æœå¼¹çª—HTML
    let resultHTML = '<div class="draw-result-modal" id="draw-result-modal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 10000; font-family: \'Press Start 2P\', cursive;">';
    resultHTML += '<div class="draw-result-content" style="background: #ffffff; border: 4px solid #FFB3C1; border-radius: 0; padding: 25px; max-width: 90%; max-height: 80%; overflow-y: auto; box-shadow: 8px 8px 0 rgba(255, 179, 193, 0.3);">';
    
    // æ ‡é¢˜å¸¦å›¾æ ‡
    resultHTML += '<div style="display: flex; align-items: center; justify-content: center; gap: 12px; margin-bottom: 20px;">';
    resultHTML += '<svg style="width: 24px; height: 24px; stroke: #FFB3C1;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><path d="M16 8h-8m4-4v16"></path></svg>';
    resultHTML += '<div style="font-size: 14px; color: #666666; font-weight: bold;">æŠ½å¥–ç»“æœ</div>';
    resultHTML += '<svg style="width: 24px; height: 24px; stroke: #FFB3C1;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><path d="M16 8h-8m4-4v16"></path></svg>';
    resultHTML += '</div>';
    
    // æ˜¾ç¤ºæ‰€æœ‰æŠ½åˆ°çš„ç‰©å“
    resultHTML += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(110px, 1fr)); gap: 12px; margin-bottom: 20px;">';
    
    items.forEach(([itemId, item]) => {
        // æ ¹æ®ç¨€æœ‰åº¦è®¾ç½®èƒŒæ™¯è‰²
        let rarityBg = '#FAFAFA';  // R - æµ…ç°ç™½
        let rarityBorder = '#E0E0E0';  // R - ç°è‰²è¾¹æ¡†
        
        if (item.rarity === 'SR') {
            rarityBg = '#FFF5F7';  // SR - æµ…ç²‰
            rarityBorder = '#FFD4DC';  // SR - ç²‰è‰²è¾¹æ¡†
        } else if (item.rarity === 'SSR') {
            rarityBg = '#FFE4E9';  // SSR - æ·±ç²‰
            rarityBorder = '#FFB3C1';  // SSR - æ·±ç²‰è¾¹æ¡†
        }
        
        resultHTML += `<div style="background: ${rarityBg}; border: 3px solid ${rarityBorder}; padding: 10px; text-align: center; transition: transform 0.2s;">`;
        resultHTML += `<div style="width: 70px; height: 70px; margin: 0 auto 8px; display: flex; align-items: center; justify-content: center;">${item.svg}</div>`;
        resultHTML += `<div style="color: #666666; font-size: 10px; margin-bottom: 5px; word-break: break-word;">${item.name}</div>`;
        resultHTML += `<div style="color: #999999; font-size: 8px; padding: 2px 6px; background: rgba(255,255,255,0.6); display: inline-block;">${item.rarity}</div>`;
        resultHTML += `</div>`;
    });
    
    resultHTML += '</div>';
    
    // ç»Ÿè®¡ä¿¡æ¯
    const rarityCount = { R: 0, SR: 0, SSR: 0 };
    items.forEach(([id, item]) => {
        if (rarityCount[item.rarity] !== undefined) {
            rarityCount[item.rarity]++;
        }
    });
    
    resultHTML += '<div style="color: #999999; font-size: 9px; text-align: center; margin-bottom: 15px; padding: 8px; background: #F8F8F8; border: 2px solid #F0F0F0;">';
    resultHTML += `å…±è·å¾— ${items.length} ä»¶ç‰©å“ | `;
    if (rarityCount.SSR > 0) resultHTML += `SSRÃ—${rarityCount.SSR} `;
    if (rarityCount.SR > 0) resultHTML += `SRÃ—${rarityCount.SR} `;
    if (rarityCount.R > 0) resultHTML += `RÃ—${rarityCount.R}`;
    resultHTML += '</div>';
    
    // å…³é—­æŒ‰é’®
    resultHTML += '<button onclick="closeDrawResult()" style="width: 100%; padding: 12px; background: #FFB3C1; color: white; border: none; cursor: pointer; font-size: 11px; font-family: \'Press Start 2P\', cursive; transition: background 0.2s;" onmouseover="this.style.background=\'#FF9EAD\'" onmouseout="this.style.background=\'#FFB3C1\'">ç¡®å®š</button>';
    resultHTML += '</div></div>';
    
    // æ·»åŠ åˆ°é¡µé¢
    document.body.insertAdjacentHTML('beforeend', resultHTML);
}

// å…³é—­æŠ½å¥–ç»“æœå¼¹çª—
function closeDrawResult() {
    const modal = document.getElementById('draw-result-modal');
    if (modal) {
        modal.remove();
    }
}

// å•æŠ½
function cabinDrawOnce() {
    const state = window.cabinGachaState;
    
    if (state.coins < 10) {
        alert('é‡‘å¸ä¸è¶³ï¼Œéœ€è¦10ä¸ªé‡‘å¸');
        return;
    }
    
    // æ‰£é™¤é‡‘å¸
    state.coins -= 10;
    cabinCoinCount = state.coins;
    updateCabinCoinDisplay();
    
    // æŠ½å–ç‰©å“
    const rarity = getRandomRarity();
    const drawnItem = drawItem(rarity);
    
    if (!drawnItem) {
        alert('ç‰©å“æ± ä¸ºç©ºï¼Œè¯·å…ˆæ·»åŠ ç‰©å“');
        return;
    }
    
    const [itemId, item] = drawnItem;
    
    // æ·»åŠ åˆ°èƒŒåŒ…å’Œå›¾é‰´
    addItemToInventory(itemId);
    
    // æ˜¾ç¤ºç»“æœ
    showDrawResult([drawnItem]);
    
    // æ›´æ–°UI
    updateCabinUI();
}

// åè¿æŠ½
function cabinDrawTen() {
    const state = window.cabinGachaState;
    
    if (state.coins < 100) {
        alert('é‡‘å¸ä¸è¶³ï¼Œéœ€è¦100ä¸ªé‡‘å¸');
        return;
    }
    
    // æ‰£é™¤é‡‘å¸
    state.coins -= 100;
    cabinCoinCount = state.coins;
    updateCabinCoinDisplay();
    
    // æŠ½å–10æ¬¡
    const results = [];
    let guaranteedSR = false; // ä¿åº•æœºåˆ¶ï¼šåè¿è‡³å°‘å‡ºä¸€ä¸ªSR
    
    for (let i = 0; i < 10; i++) {
        let rarity = getRandomRarity();
        
        // æœ€åä¸€æŠ½å¦‚æœè¿˜æ²¡æœ‰SRä»¥ä¸Šï¼Œå¼ºåˆ¶å‡ºSR
        if (i === 9 && !guaranteedSR) {
            rarity = Math.random() < 0.5 ? 'SR' : 'SSR';
        }
        
        const drawnItem = drawItem(rarity);
        
        if (drawnItem) {
            const [itemId, item] = drawnItem;
            
            // æ£€æŸ¥æ˜¯å¦æŠ½åˆ°SRæˆ–ä»¥ä¸Š
            if (item.rarity === 'SR' || item.rarity === 'SSR') {
                guaranteedSR = true;
            }
            
            // æ·»åŠ åˆ°èƒŒåŒ…å’Œå›¾é‰´
            addItemToInventory(itemId);
            
            results.push(drawnItem);
        }
    }
    
    // æ˜¾ç¤ºç»“æœ
    if (results.length > 0) {
        showDrawResult(results);
    }
    
    // æ›´æ–°UI
    updateCabinUI();
}

function openCabinAIModal() {
    alert('AIç”ŸæˆåŠŸèƒ½å¼€å‘ä¸­');
}

function openCabinCharacterModal() {
    alert('è§’è‰²ç”ŸæˆåŠŸèƒ½å¼€å‘ä¸­');
}

// æˆ¿é—´ç›¸å…³åŠŸèƒ½
function takeCabinScreenshot() {
    alert('æ‹ç…§åŠŸèƒ½å¼€å‘ä¸­');
}

// æˆ¿é—´é¢œè‰²çŠ¶æ€ï¼ˆä¸´æ—¶å­˜å‚¨ï¼Œå°†æ¥å¯ä»¥ç”¨localStorageï¼‰
let cabinRoomState = {
    wallColor: '#fff5f7',
    wallStyle: 'solid',
    wallPatternColor: '#fff5f7',
    floorColor: '#fefefe',
    floorStyle: 'solid',
    floorPatternColor: '#fefefe'
};

// æ‰“å¼€é¢œè‰²é€‰æ‹©å™¨
function openCabinColorPicker(type) {
    window.cabinCurrentColorTarget = type;
    const modal = document.getElementById('cabin-color-picker-modal');
    const title = document.getElementById('cabin-color-modal-title');
    const colorInput = document.getElementById('cabin-color-input');
    const colorPicker = document.getElementById('cabin-color-picker');
    
    if (title) {
        const iconSvg = `<svg class="cabin-icon-inline" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z"/>
        </svg>`;
        title.innerHTML = iconSvg + (type === 'wall' ? ' ä¿®æ”¹å¢™é¢é¢œè‰²' : ' ä¿®æ”¹åœ°æ¿é¢œè‰²');
    }
    
    const currentColor = type === 'wall' ? (cabinRoomState.wallColor || '#fff5f7') : (cabinRoomState.floorColor || '#fefefe');
    const currentPatternColor = type === 'wall' ? (cabinRoomState.wallPatternColor || currentColor) : (cabinRoomState.floorPatternColor || currentColor);
    
    if (colorInput) colorInput.value = currentColor;
    if (colorPicker) colorPicker.value = currentColor;
    
    const patternColorInput = document.getElementById('cabin-pattern-color-input');
    const patternColorPicker = document.getElementById('cabin-pattern-color-picker');
    if (patternColorInput) patternColorInput.value = currentPatternColor;
    if (patternColorPicker) patternColorPicker.value = currentPatternColor;
    
    // åŒæ­¥é¢œè‰²è¾“å…¥å’Œæ‹¾è‰²å™¨
    if (colorInput && colorPicker) {
        colorInput.oninput = () => {
            if (colorInput.value.match(/^#[0-9A-Fa-f]{6}$/)) {
                colorPicker.value = colorInput.value;
            }
        };
        colorPicker.oninput = () => {
            colorInput.value = colorPicker.value;
        };
    }
    
    if (patternColorInput && patternColorPicker) {
        patternColorInput.oninput = () => {
            if (patternColorInput.value.match(/^#[0-9A-Fa-f]{6}$/)) {
                patternColorPicker.value = patternColorInput.value;
            }
        };
        patternColorPicker.oninput = () => {
            patternColorInput.value = patternColorPicker.value;
        };
    }
    
    // æ ·å¼é€‰æ‹©å˜åŒ–
    const styleOptions = document.querySelectorAll('input[name="cabin-style-option"]');
    styleOptions.forEach(option => {
        option.onchange = () => {
            const patternSection = document.getElementById('cabin-pattern-color-section');
            if (patternSection) {
                patternSection.style.display = option.value === 'solid' ? 'none' : 'block';
            }
        };
    });
    
    // æ¢å¤å½“å‰æ ·å¼é€‰æ‹©
    const currentStyle = type === 'wall' ? cabinRoomState.wallStyle : cabinRoomState.floorStyle;
    const styleOption = document.querySelector(`input[name="cabin-style-option"][value="${currentStyle}"]`);
    if (styleOption) {
        styleOption.checked = true;
        const patternSection = document.getElementById('cabin-pattern-color-section');
        if (patternSection) {
            patternSection.style.display = currentStyle === 'solid' ? 'none' : 'block';
        }
    }
    
    if (modal) modal.style.display = 'flex';
}

// å…³é—­é¢œè‰²é€‰æ‹©å™¨
function closeCabinColorPicker() {
    const modal = document.getElementById('cabin-color-picker-modal');
    if (modal) modal.style.display = 'none';
    window.cabinCurrentColorTarget = null;
}

// é‡ç½®é¢œè‰²
function resetCabinColor() {
    const defaultColor = window.cabinCurrentColorTarget === 'wall' ? '#fff5f7' : '#fefefe';
    const colorInput = document.getElementById('cabin-color-input');
    const colorPicker = document.getElementById('cabin-color-picker');
    const patternColorInput = document.getElementById('cabin-pattern-color-input');
    const patternColorPicker = document.getElementById('cabin-pattern-color-picker');
    
    if (colorInput) colorInput.value = defaultColor;
    if (colorPicker) colorPicker.value = defaultColor;
    if (patternColorInput) patternColorInput.value = defaultColor;
    if (patternColorPicker) patternColorPicker.value = defaultColor;
    
    const solidOption = document.querySelector('input[name="cabin-style-option"][value="solid"]');
    if (solidOption) solidOption.checked = true;
    
    const patternSection = document.getElementById('cabin-pattern-color-section');
    if (patternSection) patternSection.style.display = 'none';
}

// åº”ç”¨é¢œè‰²
function applyCabinColor() {
    if (!window.cabinCurrentColorTarget) return;
    
    const colorInput = document.getElementById('cabin-color-input');
    const patternColorInput = document.getElementById('cabin-pattern-color-input');
    const styleOption = document.querySelector('input[name="cabin-style-option"]:checked');
    
    if (!colorInput || !styleOption) return;
    
    const color = colorInput.value;
    if (!color.match(/^#[0-9A-Fa-f]{6}$/)) {
        alert('é¢œè‰²æ ¼å¼ä¸æ­£ç¡®');
        return;
    }
    
    const style = styleOption.value;
    
    // è·å–èŠ±çº¹é¢œè‰²ï¼ˆå¦‚æœæ ·å¼ä¸æ˜¯çº¯è‰²ï¼‰
    let patternColor = color;
    if (style !== 'solid' && patternColorInput) {
        const patternColorValue = patternColorInput.value;
        if (patternColorValue && patternColorValue.match(/^#[0-9A-Fa-f]{6}$/)) {
            patternColor = patternColorValue;
        }
    }
    
    if (window.cabinCurrentColorTarget === 'wall') {
        cabinRoomState.wallColor = color;
        cabinRoomState.wallStyle = style;
        cabinRoomState.wallPatternColor = patternColor;
        applyCabinWallStyle();
    } else {
        cabinRoomState.floorColor = color;
        cabinRoomState.floorStyle = style;
        cabinRoomState.floorPatternColor = patternColor;
        applyCabinFloorStyle();
    }
    
    // æ›´æ–°æŒ‰é’®é¢œè‰²
    const wallBtn = document.getElementById('cabin-wall-color-btn');
    const floorBtn = document.getElementById('cabin-floor-color-btn');
    if (wallBtn) wallBtn.style.background = cabinRoomState.wallColor;
    if (floorBtn) floorBtn.style.background = cabinRoomState.floorColor;
    
    closeCabinColorPicker();
}

// åº”ç”¨å¢™é¢æ ·å¼
function applyCabinWallStyle() {
    const wallArea = document.getElementById('cabin-wall-area');
    if (!wallArea) return;
    
    wallArea.style.backgroundColor = cabinRoomState.wallColor || '#fff5f7';
    
    if (cabinRoomState.wallStyle === 'solid') {
        wallArea.style.backgroundImage = 'none';
    } else if (cabinRoomState.wallStyle === 'pattern1') {
        const patternColor = (cabinRoomState.wallPatternColor || cabinRoomState.wallColor) + '40';
        wallArea.style.backgroundImage = `
            linear-gradient(90deg, ${patternColor} 1px, transparent 1px),
            linear-gradient(${patternColor} 1px, transparent 1px)
        `;
        wallArea.style.backgroundSize = '32px 32px';
    } else if (cabinRoomState.wallStyle === 'pattern2') {
        const patternColor = cabinRoomState.wallPatternColor || cabinRoomState.wallColor;
        wallArea.style.backgroundImage = `
            linear-gradient(90deg, transparent 33%, ${patternColor}40 33%, ${patternColor}40 66%, transparent 66%),
            linear-gradient(transparent 33%, ${patternColor}40 33%, ${patternColor}40 66%, transparent 66%)
        `;
        wallArea.style.backgroundSize = '12px 12px';
    }
}

// åº”ç”¨åœ°æ¿æ ·å¼
function applyCabinFloorStyle() {
    const floorArea = document.getElementById('cabin-floor-area');
    if (!floorArea) return;
    
    floorArea.style.backgroundColor = cabinRoomState.floorColor || '#fefefe';
    
    if (cabinRoomState.floorStyle === 'solid') {
        floorArea.style.backgroundImage = 'none';
    } else if (cabinRoomState.floorStyle === 'pattern1') {
        const patternColor = (cabinRoomState.floorPatternColor || cabinRoomState.floorColor) + '40';
        floorArea.style.backgroundImage = `
            linear-gradient(90deg, ${patternColor} 1px, transparent 1px),
            linear-gradient(${patternColor} 1px, transparent 1px)
        `;
        floorArea.style.backgroundSize = '32px 32px';
    } else if (cabinRoomState.floorStyle === 'pattern2') {
        const patternColor = cabinRoomState.floorPatternColor || cabinRoomState.floorColor;
        floorArea.style.backgroundImage = `
            linear-gradient(90deg, transparent 33%, ${patternColor}40 33%, ${patternColor}40 66%, transparent 66%),
            linear-gradient(transparent 33%, ${patternColor}40 33%, ${patternColor}40 66%, transparent 66%)
        `;
        floorArea.style.backgroundSize = '12px 12px';
    }
}

function moveCabinUserCharacter(direction) {
    alert('è§’è‰²ç§»åŠ¨åŠŸèƒ½å¼€å‘ä¸­ï¼š' + direction);
}

function filterCabinInventory(category) {
    // æ›´æ–°æŒ‰é’®æ¿€æ´»çŠ¶æ€
    const buttons = document.querySelectorAll('.cabin-filter-btn');
    buttons.forEach(btn => btn.classList.remove('active'));
    event.currentTarget.classList.add('active');
    
    // è¿™é‡Œå°†æ¥ä¼šå®ç°å®é™…çš„è¿‡æ»¤é€»è¾‘
    console.log('è¿‡æ»¤åˆ†ç±»ï¼š' + category);
}

// åˆå§‹åŒ–é»˜è®¤å®¶å…·
function initDefaultItems() {
    const state = window.cabinGachaState;
    
    // å¦‚æœå·²ç»æœ‰ç‰©å“ï¼Œä¸é‡å¤æ·»åŠ 
    if (Object.keys(state.customItems).length > 0) {
        return;
    }
    
    // æ·»åŠ åˆå§‹ç‰©å“
    const DEFAULT_FURNITURE = {
        'bed_01': { 
            name: "è‰è“åºŠ", 
            svg: `<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg">
                <rect x="10" y="30" width="44" height="20" fill="#FFB3C1" stroke="#999999" stroke-width="2"/>
                <rect x="12" y="32" width="40" height="16" fill="#FFF5F7"/>
                <rect x="14" y="34" width="4" height="4" fill="#FFFFFF"/>
                <rect x="22" y="34" width="4" height="4" fill="#FFFFFF"/>
                <rect x="30" y="34" width="4" height="4" fill="#FFFFFF"/>
                <rect x="38" y="34" width="4" height="4" fill="#FFFFFF"/>
                <rect x="46" y="34" width="4" height="4" fill="#FFFFFF"/>
                <rect x="14" y="24" width="14" height="10" fill="#FFFFFF" stroke="#CCCCCC" stroke-width="2"/>
                <rect x="16" y="26" width="10" height="6" fill="#F0F0F0" rx="2"/>
                <rect x="16" y="22" width="10" height="2" fill="#FFE4E9"/>
            </svg>`,
            rarity: "R",
            inPool: true,
            type: "furniture",
            width: 3,
            height: 2
        },
        'table_01': { 
            name: "åƒç´ æ¡Œ", 
            svg: `<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg">
                <rect x="12" y="32" width="40" height="10" fill="#F5F5F5" stroke="#999999" stroke-width="2"/>
                <rect x="14" y="34" width="36" height="6" fill="#FAFAFA" rx="1"/>
                <rect x="16" y="36" width="32" height="2" fill="#FFFFFF"/>
                <rect x="16" y="42" width="6" height="14" fill="#CCCCCC"/>
                <rect x="20" y="44" width="2" height="12" fill="#B0B0B0"/>
                <rect x="42" y="42" width="6" height="14" fill="#CCCCCC"/>
                <rect x="46" y="44" width="2" height="12" fill="#B0B0B0"/>
                <rect x="15" y="55" width="8" height="2" fill="#999999"/>
                <rect x="41" y="55" width="8" height="2" fill="#999999"/>
                <circle cx="32" cy="36" r="2" fill="#FFE4E9"/>
                <circle cx="38" cy="36" r="2" fill="#E8E8E8"/>
                <circle cx="26" cy="36" r="2" fill="#F0F0F0"/>
            </svg>`,
            rarity: "R",
            inPool: true,
            type: "furniture",
            width: 2,
            height: 2
        },
        'plant_01': { 
            name: "çˆ±å¿ƒè‰", 
            svg: `<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg">
                <rect x="24" y="40" width="16" height="16" fill="#FFE4E9" stroke="#CCCCCC" stroke-width="2" rx="2"/>
                <rect x="26" y="42" width="12" height="12" fill="#FFF5F7" rx="1"/>
                <rect x="28" y="44" width="8" height="2" fill="#FFFFFF"/>
                <rect x="28" y="48" width="8" height="2" fill="#FFFFFF"/>
                <rect x="31" y="30" width="2" height="10" fill="#B0B0B0"/>
                <polygon points="30,28 34,28 32,24" fill="#999999"/>
                <polygon points="28,32 30,32 29,30" fill="#CCCCCC"/>
                <polygon points="34,32 36,32 35,30" fill="#CCCCCC"/>
                <path d="M32,22 Q34,20 36,22 Q38,24 36,26 Q34,28 32,30 Q30,28 28,26 Q26,24 28,22 Q30,20 32,22" fill="#FFB3C1"/>
                <circle cx="32" cy="24" r="1" fill="#FFFFFF"/>
                <circle cx="34" cy="26" r="1" fill="#FFFFFF"/>
                <circle cx="30" cy="26" r="1" fill="#FFFFFF"/>
            </svg>`,
            rarity: "SR",
            inPool: true,
            type: "decor",
            width: 1,
            height: 1
        },
        'painting_01': {
            name: "åƒç´ ç”»",
            svg: `<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg">
                <rect x="15" y="15" width="34" height="34" fill="#F5F5F5" stroke="#CCCCCC" stroke-width="3" rx="3"/>
                <rect x="18" y="18" width="28" height="28" fill="#FFFFFF" rx="2"/>
                <rect x="20" y="20" width="24" height="24" fill="#FAFAFA" rx="1"/>
                <rect x="20" y="36" width="24" height="8" fill="#E8E8E8" rx="1"/>
                <polygon points="26,36 30,32 34,36" fill="#D0D0D0"/>
                <polygon points="30,36 34,30 38,36" fill="#CCCCCC"/>
                <circle cx="44" cy="24" r="4" fill="#FFE4E9"/>
                <rect x="44" y="20" width="1" height="2" fill="#FFB3C1"/>
                <rect x="44" y="28" width="1" height="2" fill="#FFB3C1"/>
                <rect x="40" y="23" width="2" height="1" fill="#FFB3C1"/>
                <rect x="48" y="23" width="2" height="1" fill="#FFB3C1"/>
                <rect x="24" y="26" width="8" height="4" fill="#FFFFFF" rx="2"/>
                <rect x="26" y="24" width="4" height="2" fill="#FFFFFF" rx="1"/>
                <circle cx="20" cy="20" r="1" fill="#FFB3C1"/>
                <circle cx="44" cy="20" r="1" fill="#FFB3C1"/>
                <circle cx="20" cy="44" r="1" fill="#FFB3C1"/>
                <circle cx="44" cy="44" r="1" fill="#FFB3C1"/>
            </svg>`,
            rarity: "R",
            inPool: true,
            type: "wall",
            width: 1,
            height: 1
        },
        'rug_01': {
            name: "æ¯›ç»’åœ°æ¯¯",
            svg: `<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg">
                <rect x="10" y="10" width="44" height="44" fill="#F0F0F0" stroke="#CCCCCC" stroke-width="2" rx="5"/>
                <rect x="12" y="12" width="40" height="40" fill="#FAFAFA" rx="3"/>
                <circle cx="32" cy="32" r="12" fill="#FFF5F7" opacity="0.6"/>
                <circle cx="32" cy="32" r="8" fill="#FFFFFF" opacity="0.8"/>
                <path d="M32,24 Q36,28 32,32 Q28,36 32,40 Q36,36 40,32 Q36,28 32,24" fill="#FFE4E9" opacity="0.5"/>
                <rect x="14" y="14" width="4" height="4" fill="#E8E8E8" rx="1"/>
                <rect x="46" y="14" width="4" height="4" fill="#E8E8E8" rx="1"/>
                <rect x="14" y="46" width="4" height="4" fill="#E8E8E8" rx="1"/>
                <rect x="46" y="46" width="4" height="4" fill="#E8E8E8" rx="1"/>
            </svg>`,
            rarity: "SR",
            inPool: true,
            type: "floor",
            width: 3,
            height: 2
        }
    };
    
    // æ·»åŠ é»˜è®¤ç‰©å“åˆ°çŠ¶æ€
    Object.keys(DEFAULT_FURNITURE).forEach(id => {
        state.customItems[id] = DEFAULT_FURNITURE[id];
        if (!state.catalog[id]) {
            state.catalog[id] = { seen: false, owned: false };
        }
        // æ·»åŠ åˆ°èƒŒåŒ…
        state.inventory[id] = (state.inventory[id] || 0) + 1;
        // æ ‡è®°ä¸ºå·²æ‹¥æœ‰
        state.catalog[id].owned = true;
    });
    
    // ä¿å­˜çŠ¶æ€
    saveCabinGachaData();
    console.log('é»˜è®¤å®¶å…·å·²åˆå§‹åŒ–');
}

// æ›´æ–°èƒŒåŒ…æ˜¾ç¤º
function updateCabinInventoryDisplay() {
    // å¦‚æœæœ‰èƒŒåŒ…UIå…ƒç´ ï¼Œåœ¨è¿™é‡Œæ›´æ–°
    // æš‚æ—¶ä¿ç•™æ­¤å‡½æ•°ä»¥å¤‡åç»­ä½¿ç”¨
}

// æ‰“å¼€å›¾é‰´
function openCatalogModal() {
    const modal = document.getElementById('catalog-modal');
    if (modal) {
        modal.style.display = 'flex';
        renderCatalogItems();
    }
}

// å…³é—­å›¾é‰´
function closeCatalogModal() {
    const modal = document.getElementById('catalog-modal');
    if (modal) {
        modal.style.display = 'none';
    }
}

// åˆ‡æ¢å›¾é‰´æ ‡ç­¾
let currentCatalogTab = 'all';
function switchCatalogTab(tab) {
    currentCatalogTab = tab;
    const tabs = document.querySelectorAll('.catalog-tab');
    tabs.forEach(t => {
        t.classList.remove('active');
        t.style.background = '#ffffff';
    });
    event.currentTarget.classList.add('active');
    event.currentTarget.style.background = '#fff5f7';
    renderCatalogItems();
}

// è¿‡æ»¤å›¾é‰´ç‰©å“ç¨€æœ‰åº¦
let currentCatalogRarity = 'all';
function filterCatalogItems(rarity) {
    currentCatalogRarity = rarity;
    const buttons = document.querySelectorAll('.rarity-filter-btn');
    buttons.forEach(btn => btn.classList.remove('active'));
    event.currentTarget.classList.add('active');
    renderCatalogItems();
}

// æ¸²æŸ“å›¾é‰´ç‰©å“
function renderCatalogItems() {
    const catalogGrid = document.getElementById('catalog-items');
    const catalogInfo = document.getElementById('catalog-info');
    
    if (!catalogGrid) return;
    
    const state = window.cabinGachaState;
    catalogGrid.innerHTML = '';
    
    // è·å–æ‰€æœ‰ç‰©å“
    const allItems = Object.keys(state.customItems).map(id => ({
        id,
        ...state.customItems[id],
        catalogData: state.catalog[id] || { seen: false, owned: false }
    }));
    
    // æŒ‰æ ‡ç­¾è¿‡æ»¤
    let filteredItems = allItems;
    if (currentCatalogTab === 'owned') {
        filteredItems = allItems.filter(item => item.catalogData.owned);
    } else if (currentCatalogTab === 'missing') {
        filteredItems = allItems.filter(item => !item.catalogData.owned);
    }
    
    // æŒ‰ç¨€æœ‰åº¦è¿‡æ»¤
    if (currentCatalogRarity !== 'all') {
        filteredItems = filteredItems.filter(item => 
            item.rarity.toUpperCase() === currentCatalogRarity.toUpperCase()
        );
    }
    
    // æ¸²æŸ“ç‰©å“
    filteredItems.forEach(item => {
        const itemDiv = document.createElement('div');
        itemDiv.style.cssText = `
            background: ${item.catalogData.owned ? '#fff5f7' : '#f5f5f5'};
            border: 3px solid ${item.catalogData.owned ? '#ffb3c1' : '#e0e0e0'};
            border-radius: 8px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: pointer;
        `;
        
        // SVGå›¾æ ‡
        const svgDiv = document.createElement('div');
        svgDiv.innerHTML = item.svg;
        svgDiv.style.cssText = 'width: 40px; height: 40px; margin-bottom: 5px;';
        itemDiv.appendChild(svgDiv);
        
        // åç§°
        const nameDiv = document.createElement('div');
        nameDiv.textContent = item.name;
        nameDiv.style.cssText = 'font-size: 8px; color: #999999; text-align: center; margin-bottom: 3px;';
        itemDiv.appendChild(nameDiv);
        
        // ç¨€æœ‰åº¦
        const rarityDiv = document.createElement('div');
        rarityDiv.textContent = item.rarity;
        rarityDiv.style.cssText = `
            font-size: 7px;
            padding: 1px 4px;
            border-radius: 3px;
            font-weight: bold;
            color: #999999;
            background: ${item.rarity === 'SSR' ? '#fff9e6' : item.rarity === 'SR' ? '#fff5f7' : '#f0f0f0'};
        `;
        itemDiv.appendChild(rarityDiv);
        
        // æ‹¥æœ‰æ•°é‡ï¼ˆå¦‚æœå·²æ‹¥æœ‰ï¼‰
        if (item.catalogData.owned) {
            const count = state.inventory[item.id] || 0;
            if (count > 0) {
                const countDiv = document.createElement('div');
                countDiv.textContent = `Ã—${count}`;
                countDiv.style.cssText = `
                    position: absolute;
                    top: 5px;
                    right: 5px;
                    font-size: 8px;
                    padding: 2px 5px;
                    background: #ffb3c1;
                    color: white;
                    border-radius: 10px;
                    font-weight: bold;
                `;
                itemDiv.appendChild(countDiv);
            }
        }
        
        catalogGrid.appendChild(itemDiv);
    });
    
    // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
    if (catalogInfo) {
        const total = allItems.length;
        const owned = allItems.filter(item => item.catalogData.owned).length;
        const rate = total > 0 ? Math.round((owned / total) * 100) : 0;
        
        document.getElementById('catalog-total').textContent = total;
        document.getElementById('catalog-owned').textContent = owned;
        document.getElementById('catalog-rate').textContent = rate + '%';
    }
}

// é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
document.addEventListener('DOMContentLoaded', function() {
    // å°å±‹æ•°æ®åœ¨é¦–æ¬¡æ‰“å¼€å°å±‹é¡µé¢æ—¶åˆå§‹åŒ–ï¼ˆè§ showCabinPage å‡½æ•°ï¼‰
    // è¿™é‡Œä¸éœ€è¦æå‰åˆå§‹åŒ–
});

// ==================== æƒ…ä¾£ç©ºé—´åŠŸèƒ½ ====================
let selectedAccountId = null;
let selectedFriendId = null;
let currentPet = null;

async function showCoupleSpacePage() {
    document.getElementById('home-page').style.display = 'none';
    document.getElementById('couple-space-page').style.display = 'block';
    
    // åŠ è½½è´¦å·åˆ—è¡¨
    await loadCoupleAccountList();
}

function hideCoupleSpacePage() {
    document.getElementById('couple-space-page').style.display = 'none';
    document.getElementById('home-page').style.display = 'block';
    
    // é‡ç½®çŠ¶æ€
    document.getElementById('couple-select-account').style.display = 'flex';
    document.getElementById('couple-select-friend').style.display = 'none';
    document.getElementById('couple-room-area').style.display = 'none';
    selectedAccountId = null;
    selectedFriendId = null;
    currentPet = null;
    isPetHatched = false;
    isPetting = false;
    lastPetTime = 0;
    if (petTimeout) {
        clearTimeout(petTimeout);
        petTimeout = null;
    }
}

// åŠ è½½è´¦å·åˆ—è¡¨ï¼ˆuserç±»å‹çš„è§’è‰²ï¼‰
async function loadCoupleAccountList() {
    const accounts = await db.characters.where('type').equals('user').toArray();
    const listContainer = document.getElementById('couple-account-list');
    listContainer.innerHTML = '';
    
    if (accounts.length === 0) {
        listContainer.innerHTML = '<div style="text-align: center; color: #999;">æš‚æ— è´¦å·ï¼Œè¯·å…ˆåˆ›å»ºç”¨æˆ·è´¦å·</div>';
        return;
    }
    
    accounts.forEach(account => {
        const accountItem = document.createElement('div');
        accountItem.style.cssText = `
            background: white;
            border: 2px solid #ff9ed2;
            border-radius: 12px;
            padding: 15px;
            display: flex;
            align-items: center;
            gap: 15px;
            cursor: pointer;
            transition: transform 0.2s;
        `;
        
        accountItem.onmouseover = () => accountItem.style.transform = 'scale(1.02)';
        accountItem.onmouseout = () => accountItem.style.transform = 'scale(1)';
        accountItem.onclick = () => selectCoupleAccount(account.id);
        
        // å¤´åƒ
        const avatar = document.createElement('div');
        avatar.style.cssText = `
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: ${account.avatar ? `url(${account.avatar}) center/cover` : '#ffdef2'};
            flex-shrink: 0;
        `;
        
        // åå­—
        const name = document.createElement('div');
        name.textContent = account.name;
        name.style.cssText = 'font-size: 16px; color: #333; font-weight: bold;';
        
        accountItem.appendChild(avatar);
        accountItem.appendChild(name);
        listContainer.appendChild(accountItem);
    });
}

// é€‰æ‹©è´¦å·
async function selectCoupleAccount(accountId) {
    selectedAccountId = accountId;
    document.getElementById('couple-select-account').style.display = 'none';
    document.getElementById('couple-select-friend').style.display = 'flex';
    
    // åŠ è½½è¯¥è´¦å·çš„å¥½å‹åˆ—è¡¨
    await loadCoupleFriendList(accountId);
}

// è¿”å›è´¦å·é€‰æ‹©
function backToCoupleAccountSelect() {
    document.getElementById('couple-select-friend').style.display = 'none';
    document.getElementById('couple-select-account').style.display = 'flex';
    selectedAccountId = null;
}

// åŠ è½½å¥½å‹åˆ—è¡¨
async function loadCoupleFriendList(accountId) {
    // ä½¿ç”¨å’Œå¾®ä¿¡åˆ—è¡¨ç›¸åŒçš„é€»è¾‘è·å–å¥½å‹
    let allChars = await db.characters.toArray();
    let friends = allChars.filter(c => {
        if (c.type === 'user') return false; // æ’é™¤Userç±»å‹
        const status = getFriendStatus(c, accountId);
        return status === 'friend' || status === 'deleted' || status === 'blocked'; // åŒ…æ‹¬å·²åˆ é™¤å’Œå·²æ‹‰é»‘çš„å¥½å‹
    });
    
    const listContainer = document.getElementById('couple-friend-list');
    listContainer.innerHTML = '';
    
    if (friends.length === 0) {
        listContainer.innerHTML = '<div style="text-align: center; color: #999;">è¯¥è´¦å·æš‚æ— å¥½å‹</div>';
        return;
    }
    
    friends.forEach(friend => {
        if (!friend) return;
        
        const friendItem = document.createElement('div');
        friendItem.style.cssText = `
            background: white;
            border: 2px solid #ff9ed2;
            border-radius: 12px;
            padding: 15px;
            display: flex;
            align-items: center;
            gap: 15px;
            cursor: pointer;
            transition: transform 0.2s;
        `;
        
        friendItem.onmouseover = () => friendItem.style.transform = 'scale(1.02)';
        friendItem.onmouseout = () => friendItem.style.transform = 'scale(1)';
        friendItem.onclick = () => selectCoupleFriend(friend.id);
        
        // å¤´åƒ
        const avatar = document.createElement('div');
        avatar.style.cssText = `
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: ${friend.avatar ? `url(${friend.avatar}) center/cover` : '#ffdef2'};
            flex-shrink: 0;
        `;
        
        // åå­—
        const name = document.createElement('div');
        name.textContent = friend.name;
        name.style.cssText = 'font-size: 16px; color: #333; font-weight: bold;';
        
        friendItem.appendChild(avatar);
        friendItem.appendChild(name);
        listContainer.appendChild(friendItem);
    });
}

// é€‰æ‹©å¥½å‹
function selectCoupleFriend(friendId) {
    selectedFriendId = friendId;
    document.getElementById('couple-select-friend').style.display = 'none';
    document.getElementById('couple-room-area').style.display = 'block';
}

// æ˜¾ç¤ºé¢†å…»å® ç‰©æ¨¡æ€æ¡†
function showAdoptPetModal() {
    document.getElementById('adopt-pet-modal').style.display = 'flex';
}

// å…³é—­é¢†å…»å® ç‰©æ¨¡æ€æ¡†
function closeAdoptPetModal() {
    document.getElementById('adopt-pet-modal').style.display = 'none';
}

// é¢†å…»å® ç‰©
function adoptPet(petType) {
    closeAdoptPetModal();
    document.getElementById('adopt-pet-btn').style.display = 'none';
    document.getElementById('pet-hint').textContent = 'ç‚¹å‡»å­µåŒ–ä½ çš„å® ç‰©';
    
    currentPet = petType;
    createPetContainer(petType);
}

// åˆ›å»ºå® ç‰©å®¹å™¨
function createPetContainer(petType) {
    const container = document.getElementById('pet-container');
    container.innerHTML = '';
    
    const stage = document.createElement('div');
    stage.id = 'pet-stage-container';
    stage.style.cssText = 'width: 256px; height: 256px; cursor: pointer; position: relative; touch-action: none;';
    
    if (petType === 'seal') {
        stage.innerHTML = createSealEgg();
        stage.onclick = () => hatchPet('seal', stage);
    } else if (petType === 'cat') {
        stage.innerHTML = createCatBox();
        stage.onclick = () => hatchPet('cat', stage);
    } else if (petType === 'dog') {
        stage.innerHTML = createDogHouse();
        stage.onclick = () => hatchPet('dog', stage);
    }
    
    container.appendChild(stage);
}

// å® ç‰©çŠ¶æ€
let isPetHatched = false;
let isPetting = false;
let lastPetTime = 0;
let petTimeout = null;

// å­µåŒ–å® ç‰©
function hatchPet(petType, stage) {
    stage.style.animation = 'shake 0.5s';
    
    setTimeout(() => {
        stage.innerHTML = '';
        
        if (petType === 'seal') {
            stage.innerHTML = createSealPet();
        } else if (petType === 'cat') {
            stage.innerHTML = createCatPet();
        } else if (petType === 'dog') {
            stage.innerHTML = createDogPet();
        }
        
        stage.style.animation = 'popUp 0.6s';
        stage.onclick = null;
        
        isPetHatched = true;
        document.getElementById('pet-hint').textContent = 'æ»‘åŠ¨æŠšæ‘¸å® ç‰©';
        
        // æ·»åŠ æŠšæ‘¸äº‹ä»¶ç›‘å¬
        setupPettingEvents(stage);
    }, 500);
}

// è®¾ç½®æŠšæ‘¸äº‹ä»¶
function setupPettingEvents(stage) {
    // é˜»æ­¢è§¦æ‘¸æ»šåŠ¨
    stage.addEventListener('touchmove', (e) => {
        e.preventDefault();
        handlePet(e);
    }, { passive: false });
    
    // é¼ æ ‡ç§»åŠ¨æŠšæ‘¸
    stage.addEventListener('mousemove', handlePet);
    
    // è§¦æ‘¸å¼€å§‹
    stage.addEventListener('touchstart', (e) => {
        e.preventDefault();
        handlePet(e);
    }, { passive: false });
}

// å¤„ç†æŠšæ‘¸
function handlePet(e) {
    if (!isPetHatched) return;
    
    const now = Date.now();
    if (now - lastPetTime < 50) return;
    lastPetTime = now;
    
    if (!isPetting) {
        startPetting();
    }
    
    clearTimeout(petTimeout);
    petTimeout = setTimeout(stopPetting, 200);
    
    // éšæœºç”Ÿæˆçˆ±å¿ƒæ•ˆæœ
    if (Math.random() > 0.85) {
        spawnHeartEffect(e);
    }
}

// å¼€å§‹æŠšæ‘¸
function startPetting() {
    isPetting = true;
    const stage = document.getElementById('pet-stage-container');
    if (stage) {
        stage.classList.add('is-petting');
        document.getElementById('pet-hint').textContent = 'å¥½èˆ’æœ...';
    }
}

// åœæ­¢æŠšæ‘¸
function stopPetting() {
    isPetting = false;
    const stage = document.getElementById('pet-stage-container');
    if (stage) {
        stage.classList.remove('is-petting');
        document.getElementById('pet-hint').textContent = 'æ»‘åŠ¨æŠšæ‘¸å® ç‰©';
    }
}

// ç”Ÿæˆçˆ±å¿ƒæ•ˆæœ
function spawnHeartEffect(e) {
    const stage = document.getElementById('pet-stage-container');
    if (!stage) return;
    
    const heart = document.createElement('div');
    heart.style.cssText = `
        position: absolute;
        width: 12px;
        height: 12px;
        background: #ff6b6b;
        clip-path: polygon(20% 0%, 40% 0%, 50% 20%, 60% 0%, 80% 0%, 100% 20%, 100% 50%, 50% 100%, 0% 50%, 0% 20%);
        pointer-events: none;
        z-index: 1000;
    `;
    
    const rect = stage.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    
    const x = clientX - rect.left - 6 + (Math.random() * 20 - 10);
    const y = clientY - rect.top - 20;
    
    heart.style.left = `${x}px`;
    heart.style.top = `${y}px`;
    
    stage.appendChild(heart);
    
    heart.animate([
        { transform: 'translateY(0) scale(0.5)', opacity: 1 },
        { transform: 'translateY(-40px) scale(1.2)', opacity: 0 }
    ], { duration: 800, fill: 'forwards' });
    
    setTimeout(() => heart.remove(), 800);
}

// åˆ›å»ºæµ·è±¹è›‹
function createSealEgg() {
    return `
        <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" style="width: 100%; height: 100%;">
            <rect x="18" y="54" width="28" height="4" fill="#a0c0e0" opacity="0.6"/>
            <path d="M24 16 H40 V17 H44 V18 H46 V20 H48 V24 H50 V44 H48 V50 H46 V52 H42 V54 H22 V52 H18 V50 H16 V44 H14 V24 H16 V20 H18 V18 H20 V17 H24 Z" fill="#4a4a4a" />
            <rect x="24" y="17" width="16" height="35" fill="#ffffff"/>
            <rect x="20" y="18" width="24" height="34" fill="#ffffff"/>
            <rect x="18" y="20" width="28" height="30" fill="#ffffff"/>
            <rect x="16" y="24" width="32" height="20" fill="#ffffff"/>
            <rect x="18" y="44" width="28" height="6" fill="#ffffff"/>
            <rect x="22" y="50" width="20" height="2" fill="#ffffff"/>
            <rect x="28" y="24" width="2" height="2" fill="#d0d0d0" />
            <rect x="36" y="20" width="1" height="1" fill="#d0d0d0" />
            <rect x="42" y="30" width="2" height="2" fill="#d0d0d0" />
        </svg>
    `;
}

// åˆ›å»ºçŒ«ç®±å­
function createCatBox() {
    return `
        <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" style="width: 100%; height: 100%;">
            <rect x="16" y="56" width="32" height="4" fill="#8b6f47" opacity="0.3"/>
            <path d="M12 24 H52 V26 H54 V54 H52 V56 H12 V54 H10 V26 H12 Z" fill="#d2691e"/>
            <rect x="12" y="26" width="40" height="28" fill="#cd853f"/>
            <rect x="16" y="30" width="32" height="20" fill="#daa520"/>
            <path d="M26 34 H38 V36 H40 V44 H38 V46 H26 V44 H24 V36 H26 Z" fill="#4a4a4a"/>
            <rect x="28" y="36" width="8" height="8" fill="#2a2a2a"/>
            <rect x="20" y="28" width="2" height="2" fill="#8b4513"/>
            <rect x="42" y="28" width="2" height="2" fill="#8b4513"/>
            <rect x="20" y="48" width="2" height="2" fill="#8b4513"/>
            <rect x="42" y="48" width="2" height="2" fill="#8b4513"/>
        </svg>
    `;
}

// åˆ›å»ºç‹—çª
function createDogHouse() {
    return `
        <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" style="width: 100%; height: 100%;">
            <rect x="16" y="56" width="32" height="4" fill="#8b6f47" opacity="0.3"/>
            <path d="M32 12 L10 32 H12 V54 H52 V32 H54 Z" fill="#d2691e"/>
            <rect x="14" y="32" width="36" height="22" fill="#cd853f"/>
            <path d="M24 38 H40 V40 H42 V52 H40 V54 H24 V52 H22 V40 H24 Z" fill="#4a4a4a"/>
            <rect x="26" y="40" width="12" height="12" fill="#2a2a2a"/>
            <path d="M32 14 L12 30 H16 L32 18 L48 30 H52 Z" fill="#a0522d"/>
        </svg>
    `;
}

// åˆ›å»ºæµ·è±¹å® ç‰©
function createSealPet() {
    return `
        <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" style="width: 100%; height: 100%; animation: sealFloat 2s infinite ease-in-out;">
            <rect x="18" y="48" width="28" height="4" fill="#a0c0e0" opacity="0.6"/>
            <path d="M20 20 H44 V21 H48 V22 H50 V24 H52 V38 H50 V42 H48 V44 H44 V45 H20 V44 H16 V42 H14 V38 H12 V24 H14 V22 H16 V21 H20 Z" fill="#4a4a4a"/>
            <rect x="20" y="21" width="24" height="23" fill="#ffffff"/>
            <rect x="16" y="22" width="32" height="21" fill="#ffffff"/>
            <rect x="14" y="24" width="36" height="17" fill="#ffffff"/>
            <rect x="20" y="30" width="3" height="3" fill="#2a2a2a"/>
            <rect x="36" y="30" width="3" height="3" fill="#2a2a2a"/>
            <rect x="29" y="34" width="1" height="2" fill="#4a4a4a"/>
            <rect x="28" y="36" width="3" height="1" fill="#4a4a4a"/>
            <rect x="16" y="32" width="1" height="1" fill="#ffb7b2"/>
            <rect x="42" y="32" width="1" height="1" fill="#ffb7b2"/>
            <g style="transform-origin: 52px 32px; animation: tailWag 0.4s infinite alternate;">
                <path d="M52 30 H56 V32 H57 V35 H56 V37 H52 Z" fill="#4a4a4a"/>
                <rect x="52" y="31" width="4" height="5" fill="#ffffff"/>
            </g>
        </svg>
    `;
}

// åˆ›å»ºçŒ«å® ç‰©
function createCatPet() {
    return `
        <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" style="width: 100%; height: 100%; animation: catFloat 2s infinite ease-in-out;">
            <rect x="20" y="50" width="24" height="4" fill="#8b6f47" opacity="0.3"/>
            <g style="animation: catEarWiggle 1s infinite alternate;">
                <path d="M18 18 H22 V20 H24 V26 H22 V24 H20 V22 H18 Z" fill="#ff9966"/>
                <rect x="20" y="20" width="2" height="4" fill="#ffb380"/>
                <path d="M42 18 H46 V22 H44 V24 H42 V26 H40 V20 H42 Z" fill="#ff9966"/>
                <rect x="42" y="20" width="2" height="4" fill="#ffb380"/>
            </g>
            <path d="M20 24 H44 V26 H46 V40 H44 V42 H42 V44 H22 V42 H20 V40 H18 V26 H20 Z" fill="#4a4a4a"/>
            <rect x="20" y="26" width="24" height="14" fill="#ff9966"/>
            <rect x="18" y="28" width="28" height="10" fill="#ff9966"/>
            <rect x="24" y="30" width="3" height="3" fill="#2a2a2a"/>
            <rect x="37" y="30" width="3" height="3" fill="#2a2a2a"/>
            <rect x="25" y="30" width="1" height="1" fill="#ffffff" opacity="0.8"/>
            <rect x="38" y="30" width="1" height="1" fill="#ffffff" opacity="0.8"/>
            <rect x="30" y="34" width="1" height="2" fill="#4a4a4a"/>
            <rect x="29" y="36" width="3" height="1" fill="#4a4a4a"/>
            <rect x="33" y="34" width="1" height="1" fill="#4a4a4a"/>
            <path d="M28 38 L26 40 H28 Z" fill="#4a4a4a"/>
            <path d="M36 38 L38 40 H36 Z" fill="#4a4a4a"/>
            <rect x="22" y="32" width="1" height="1" fill="#ffb7b2"/>
            <rect x="41" y="32" width="1" height="1" fill="#ffb7b2"/>
            <g style="animation: tailSway 0.8s infinite alternate;">
                <path d="M44 36 H46 V38 H48 V42 H50 V46 H48 V44 H46 V40 H44 Z" fill="#ff9966"/>
            </g>
        </svg>
    `;
}

// åˆ›å»ºç‹—å® ç‰©
function createDogPet() {
    return `
        <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" style="width: 100%; height: 100%; animation: dogFloat 2s infinite ease-in-out;">
            <rect x="20" y="50" width="24" height="4" fill="#8b6f47" opacity="0.3"/>
            <g style="animation: dogEarFlop 1.2s infinite alternate;">
                <path d="M16 24 H18 V26 H20 V32 H18 V28 H16 Z" fill="#8b4513"/>
                <rect x="17" y="26" width="2" height="4" fill="#a0522d"/>
                <path d="M46 24 H48 V28 H46 V32 H44 V26 H46 Z" fill="#8b4513"/>
                <rect x="45" y="26" width="2" height="4" fill="#a0522d"/>
            </g>
            <path d="M18 26 H46 V28 H48 V40 H46 V42 H44 V44 H20 V42 H18 V40 H16 V28 H18 Z" fill="#4a4a4a"/>
            <rect x="18" y="28" width="28" height="12" fill="#d2691e"/>
            <rect x="16" y="30" width="32" height="8" fill="#d2691e"/>
            <rect x="22" y="32" width="3" height="3" fill="#2a2a2a"/>
            <rect x="39" y="32" width="3" height="3" fill="#2a2a2a"/>
            <rect x="23" y="32" width="1" height="1" fill="#ffffff" opacity="0.8"/>
            <rect x="40" y="32" width="1" height="1" fill="#ffffff" opacity="0.8"/>
            <path d="M28 36 H36 V38 H34 V40 H30 V38 H28 Z" fill="#4a4a4a"/>
            <rect x="30" y="38" width="4" height="2" fill="#ff6b9d"/>
            <rect x="31" y="36" width="2" height="1" fill="#2a2a2a"/>
            <rect x="20" y="34" width="1" height="1" fill="#ffb7b2"/>
            <rect x="43" y="34" width="1" height="1" fill="#ffb7b2"/>
            <g style="animation: tailWag 0.3s infinite alternate;">
                <path d="M46 34 H48 V36 H50 V40 H52 V38 H50 V36 H48 V34 H46 Z" fill="#d2691e"/>
            </g>
        </svg>
    `;
}

// ============================================
// AIæŸ¥å²—åŠŸèƒ½
// ============================================

// å…¨å±€å˜é‡ï¼šæ ‡è®°è´¦å·æ˜¯å¦ä¸‹çº¿
let isAccountOffline = false;
let offlineAutoCloseTimer = null; // è‡ªåŠ¨å…³é—­å®šæ—¶å™¨

// æ˜¾ç¤ºè´¦å·ä¸‹çº¿é®ç½©
function showAccountOfflineMask(reason = "ä½ çš„è´¦å·åœ¨å¦ä¸€å°è®¾å¤‡ç™»å½•") {
    isAccountOffline = true;
    const mask = document.getElementById('account-offline-mask');
    const reasonText = document.getElementById('offline-reason-text');
    if (mask) {
        mask.style.display = 'flex';
        if (reasonText) {
            reasonText.textContent = reason;
        }
    }
    
    // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
    if (offlineAutoCloseTimer) {
        clearTimeout(offlineAutoCloseTimer);
    }
}

// éšè—è´¦å·ä¸‹çº¿é®ç½©ï¼ˆé‡æ–°ç™»å½•ï¼‰
function reconnectAccount() {
    isAccountOffline = false;
    const mask = document.getElementById('account-offline-mask');
    if (mask) {
        mask.style.display = 'none';
    }
    
    // æ¸…é™¤è‡ªåŠ¨å…³é—­å®šæ—¶å™¨
    if (offlineAutoCloseTimer) {
        clearTimeout(offlineAutoCloseTimer);
        offlineAutoCloseTimer = null;
    }
}

// è‡ªåŠ¨å…³é—­ä¸‹çº¿é®ç½©ï¼ˆAIæŸ¥å²—å®Œæˆåè°ƒç”¨ï¼‰
function autoCloseOfflineMask(delaySeconds = 4) {
    console.log(`[è´¦å·ä¸‹çº¿] å°†åœ¨${delaySeconds}ç§’åè‡ªåŠ¨æ¢å¤ç™»å½•`);
    
    // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
    if (offlineAutoCloseTimer) {
        clearTimeout(offlineAutoCloseTimer);
    }
    
    // è®¾ç½®æ–°çš„å®šæ—¶å™¨
    offlineAutoCloseTimer = setTimeout(() => {
        console.log('[è´¦å·ä¸‹çº¿] è‡ªåŠ¨æ¢å¤ç™»å½•');
        reconnectAccount();
        showToast('è´¦å·å·²è‡ªåŠ¨é‡æ–°ç™»å½•');
    }, delaySeconds * 1000);
}

// æ˜¾ç¤ºå¯†ç é”™è¯¯å¼¹çª—
function showPasswordErrorModal() {
    console.log('[å¯†ç é”™è¯¯] æ˜¾ç¤ºè­¦å‘Šå¼¹çª—');
    const modal = document.getElementById('password-error-modal');
    if (modal) {
        modal.style.display = 'flex';
    }
}

// å…³é—­å¯†ç é”™è¯¯å¼¹çª—
function closePasswordErrorModal() {
    console.log('[å¯†ç é”™è¯¯] å…³é—­è­¦å‘Šå¼¹çª—');
    const modal = document.getElementById('password-error-modal');
    if (modal) {
        modal.style.display = 'none';
    }
}

// ç”Ÿæˆéšæœºæ‰‹æœºå·ï¼ˆ7ä½æ•°å­—ï¼‰
function generateRandomPhone() {
    const phone = Math.floor(1000000 + Math.random() * 9000000); // 1000000-9999999
    return String(phone);
}

// æ˜¾ç¤ºæ‰‹æœºå·åˆ†é…å¼¹çª—
function showPhoneAssignedModal(phoneNumber) {
    console.log('[æ‰‹æœºå·åˆ†é…] æ˜¾ç¤ºå¼¹çª—:', phoneNumber);
    const modal = document.getElementById('phone-assigned-modal');
    const phoneText = document.getElementById('assigned-phone-number');
    
    if (modal && phoneText) {
        phoneText.textContent = phoneNumber;
        modal.style.display = 'flex';
    }
}

// å…³é—­æ‰‹æœºå·åˆ†é…å¼¹çª—
function closePhoneAssignedModal() {
    console.log('[æ‰‹æœºå·åˆ†é…] å…³é—­å¼¹çª—');
    const modal = document.getElementById('phone-assigned-modal');
    if (modal) {
        modal.style.display = 'none';
    }
}

// æ˜¾ç¤ºéªŒè¯ç å¼¹çª—
function showVerificationCodeModal(code) {
    console.log('[éªŒè¯ç å¼¹çª—] ğŸ¯ æ˜¾ç¤ºéªŒè¯ç é€šçŸ¥:', code);
    
    // ğŸ¯ ä½¿ç”¨å’Œè§’è‰²å‘æ¶ˆæ¯ä¸€æ ·çš„é€šçŸ¥æ ·å¼
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%) translateY(-100px);
        width: 90%;
        height: auto;
        min-height: 60px;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border-radius: 12px;
        display: flex;
        align-items: center;
        padding: 12px;
        gap: 12px;
        z-index: 99999;
        transition: transform 0.3s ease;
        border: 1px solid rgba(0,0,0,0.1);
        box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    `;
    
    // éªŒè¯ç é«˜äº®æ˜¾ç¤º
    const codeDisplay = `
        <div style="background:linear-gradient(135deg, #E8F5E9 0%, #C8E6C9 100%); border-radius:8px; padding:8px 12px; font-size:20px; font-weight:700; color:#4CAF50; letter-spacing:4px; font-family:'Courier New', monospace; text-align:center;">
            ${code}
        </div>
    `;
    
    notification.innerHTML = `
        <div style="width:40px;height:40px;border-radius:50%;background:linear-gradient(135deg, #FFB6C1 0%, #FFC0CB 100%);display:flex;align-items:center;justify-content:center;flex-shrink:0;box-shadow:0 2px 8px rgba(255,182,193,0.3);">
            <svg viewBox="0 0 24 24" style="width:24px;height:24px;stroke:#fff;fill:none;stroke-width:2.5;">
                <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
            </svg>
        </div>
        <div style="flex:1;min-width:0;">
            <div style="display:flex;align-items:center;gap:8px;margin-bottom:4px;">
                <span style="font-size:15px;font-weight:600;color:#333;">æ¬¢è¿å°åŠ©æ‰‹</span>
                <span style="font-size:12px;color:#999;">åˆšåˆš</span>
            </div>
            <div style="font-size:13px;color:#666;margin-bottom:6px;">ã€å¾®ä¿¡éªŒè¯ç ã€‘æ‚¨çš„éªŒè¯ç æ˜¯ï¼š</div>
            ${codeDisplay}
            <div style="font-size:11px;color:#999;margin-top:6px;">5åˆ†é’Ÿå†…æœ‰æ•ˆï¼Œè¯·å‹¿æ³„éœ²</div>
        </div>
        <svg viewBox="0 0 24 24" style="width:20px;height:20px;stroke:#007AFF;fill:none;flex-shrink:0;"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>
    `;
    
    document.body.appendChild(notification);
    
    // æ˜¾ç¤ºåŠ¨ç”»
    setTimeout(() => {
        notification.style.transform = 'translateX(-50%) translateY(0)';
    }, 10);
    
    // 3ç§’åè‡ªåŠ¨æ¶ˆå¤±
    setTimeout(() => {
        notification.style.transform = 'translateX(-50%) translateY(-100px)';
        setTimeout(() => {
            if (document.body.contains(notification)) {
                document.body.removeChild(notification);
            }
        }, 300);
    }, 3000);
    
    console.log('[éªŒè¯ç å¼¹çª—] âœ… éªŒè¯ç é€šçŸ¥å·²æ˜¾ç¤ºï¼éªŒè¯ç :', code);
}

// æµ‹è¯•å‡½æ•°ï¼šæ‰‹åŠ¨æµ‹è¯•éªŒè¯ç å¼¹çª—
window.testVerificationModal = function() {
    console.log('=== æ‰‹åŠ¨æµ‹è¯•éªŒè¯ç é€šçŸ¥ ===');
    showVerificationCodeModal('123456');
};

// å…³é—­éªŒè¯ç å¼¹çª—
function closeVerificationCodeModal() {
    console.log('[éªŒè¯ç å¼¹çª—] å…³é—­');
    const modal = document.getElementById('verification-code-modal');
    if (modal) {
        modal.style.display = 'none';
    }
}

// ==================== å¾®ä¿¡æ³¨å†Œæµç¨‹ ====================

let generatedVerificationCode = ''; // å­˜å‚¨ç”Ÿæˆçš„éªŒè¯ç 
let verificationCodeExpiry = 0; // éªŒè¯ç è¿‡æœŸæ—¶é—´
let selectedUserPhone = ''; // é€‰ä¸­Userçš„æ‰‹æœºå·

// å½“Useré€‰æ‹©æ”¹å˜æ—¶
function onRegisterUserChange() {
    const selectElem = document.getElementById('register-user-select');
    const selectedUserId = selectElem.value;
    const phoneInput = document.getElementById('register-phone-input');
    const phoneHint = document.getElementById('register-phone-hint');
    
    if (!selectedUserId) {
        phoneInput.value = '';
        phoneHint.style.display = 'none';
        selectedUserPhone = '';
        return;
    }
    
    // ä»æ¡£æ¡ˆä¸­è·å–Userçš„æ‰‹æœºå·
    db.characters.get(parseInt(selectedUserId)).then(user => {
        if (user && user.identity && user.identity.phone) {
            selectedUserPhone = user.identity.phone;
            phoneInput.value = selectedUserPhone;
            phoneHint.style.display = 'block';
        }
    });
}

// å‘é€éªŒè¯ç ï¼ˆæ¨¡æ‹Ÿï¼‰
async function sendRegisterCode() {
    const selectElem = document.getElementById('register-user-select');
    const selectedUserId = selectElem.value;
    const phoneInput = document.getElementById('register-phone-input').value.trim();
    const codeBtn = document.getElementById('register-code-btn');
    const codeMessage = document.getElementById('register-code-message');
    
    // éªŒè¯
    if (!selectedUserId) {
        showToast('è¯·å…ˆé€‰æ‹©Useræ¡£æ¡ˆ');
        return;
    }
    
    if (!phoneInput) {
        showToast('è¯·è¾“å…¥æ‰‹æœºå·');
        return;
    }
    
    if (phoneInput !== selectedUserPhone) {
        showToast('æ‰‹æœºå·ä¸æ¡£æ¡ˆä¸åŒ¹é…');
        return;
    }
    
    // ç”Ÿæˆ6ä½éšæœºéªŒè¯ç 
    generatedVerificationCode = String(Math.floor(100000 + Math.random() * 900000));
    verificationCodeExpiry = Date.now() + 5 * 60 * 1000; // 5åˆ†é’Ÿæœ‰æ•ˆæœŸ
    
    console.log('[å¾®ä¿¡æ³¨å†Œ] ç”ŸæˆéªŒè¯ç :', generatedVerificationCode);
    
    // æŒ‰é’®å€’è®¡æ—¶
    let countdown = 60;
    codeBtn.disabled = true;
    codeBtn.style.background = '#ccc';
    codeBtn.style.cursor = 'not-allowed';
    
    const timer = setInterval(() => {
        countdown--;
        codeBtn.textContent = `${countdown}ç§’åé‡è¯•`;
        
        if (countdown <= 0) {
            clearInterval(timer);
            codeBtn.disabled = false;
            codeBtn.style.background = 'linear-gradient(135deg, #07C160 0%, #00D976 100%)';
            codeBtn.style.cursor = 'pointer';
            codeBtn.textContent = 'è·å–éªŒè¯ç ';
        }
    }, 1000);
    
    // æç¤ºæ¶ˆæ¯
    codeMessage.style.color = '#07C160';
    codeMessage.textContent = 'âœ“ éªŒè¯ç å·²å‘é€';
    
    // ğŸ¯ é€šè¿‡"ç”¨æˆ·å°åŠ©æ‰‹"å‘é€éªŒè¯ç æ¶ˆæ¯
    await sendVerificationCodeMessage(parseInt(selectedUserId), generatedVerificationCode);
}

// é€šè¿‡æ¬¢è¿å°åŠ©æ‰‹å‘é€éªŒè¯ç 
async function sendVerificationCodeMessage(userId, code) {
    console.log('[æ¬¢è¿å°åŠ©æ‰‹] å‘é€éªŒè¯ç ç»™User:', userId, 'éªŒè¯ç :', code);
    
    // è·å–Userä¿¡æ¯
    const user = await db.characters.get(userId);
    if (!user) {
        console.error('[æ¬¢è¿å°åŠ©æ‰‹] Userä¸å­˜åœ¨:', userId);
        return;
    }
    
    console.log('[æ¬¢è¿å°åŠ©æ‰‹] Userä¿¡æ¯:', user.name);
    
    const accountId = String(userId); // ä½¿ç”¨userIdä½œä¸ºaccountId
    const messageContent = `ã€å¾®ä¿¡éªŒè¯ç ã€‘æ‚¨çš„éªŒè¯ç æ˜¯ï¼š${code}ï¼Œ5åˆ†é’Ÿå†…æœ‰æ•ˆï¼Œè¯·å‹¿æ³„éœ²ã€‚`;
    
    // ğŸ”¥ æ·»åŠ åˆ° Dexie æ•°æ®åº“
    await db.sms_messages.add({
        accountId: accountId,
        charId: null, // ç³»ç»Ÿæ¶ˆæ¯æ²¡æœ‰è§’è‰²ID
        type: 'received',  // æ¥æ”¶çš„æ¶ˆæ¯
        sender: 'æ¬¢è¿å°åŠ©æ‰‹',
        number: 'æ¬¢è¿å°åŠ©æ‰‹',
        content: messageContent,
        time: Date.now(),
        read: false
    });
    
    console.log('[æ¬¢è¿å°åŠ©æ‰‹] âœ… éªŒè¯ç æ¶ˆæ¯å·²æ·»åŠ åˆ°çŸ­ä¿¡åˆ—è¡¨');
    
    // ğŸ”¥ ç«‹å³åˆ·æ–°ä¸»é¡µé¢çš„æ¶ˆæ¯åˆ—è¡¨
    console.log('[æ¬¢è¿å°åŠ©æ‰‹] ğŸ”„ æ­£åœ¨åˆ·æ–°ä¸»é¡µé¢æ¶ˆæ¯åˆ—è¡¨...');
    if (typeof renderMessageList === 'function') {
        await renderMessageList();
        console.log('[æ¬¢è¿å°åŠ©æ‰‹] âœ… æ¶ˆæ¯åˆ—è¡¨å·²åˆ·æ–°');
    }
    
    // ğŸ¯ æ˜¾ç¤ºéªŒè¯ç å¼¹çª—
    showVerificationCodeModal(code);
    
    console.log('[æ¬¢è¿å°åŠ©æ‰‹] ğŸ‰ éªŒè¯ç å‘é€å®Œæˆï¼è¯·æŸ¥çœ‹ä¸»é¡µé¢æ¶ˆæ¯åˆ—è¡¨');
}

// å–æ¶ˆæ³¨å†Œ
function cancelWechatRegister() {
    document.getElementById('wechat-register-page').style.display = 'none';
    generatedVerificationCode = '';
    verificationCodeExpiry = 0;
    selectedUserPhone = '';
}

// æäº¤æ³¨å†Œ
async function submitWechatRegister() {
    const selectElem = document.getElementById('register-user-select');
    const selectedUserId = selectElem.value;
    const phoneInput = document.getElementById('register-phone-input').value.trim();
    const codeInput = document.getElementById('register-code-input').value.trim();
    const passwordInput = document.getElementById('register-password-input').value.trim();
    const accountInput = document.getElementById('register-account-input').value.trim();
    
    // éªŒè¯
    if (!selectedUserId) {
        showToast('è¯·é€‰æ‹©Useræ¡£æ¡ˆ');
        return;
    }
    
    if (!phoneInput) {
        showToast('è¯·è¾“å…¥æ‰‹æœºå·');
        return;
    }
    
    if (phoneInput !== selectedUserPhone) {
        showToast('æ‰‹æœºå·ä¸æ¡£æ¡ˆä¸åŒ¹é…');
        return;
    }
    
    if (!codeInput) {
        showToast('è¯·è¾“å…¥éªŒè¯ç ');
        return;
    }
    
    // éªŒè¯éªŒè¯ç 
    if (Date.now() > verificationCodeExpiry) {
        showToast('éªŒè¯ç å·²è¿‡æœŸï¼Œè¯·é‡æ–°è·å–');
        return;
    }
    
    if (codeInput !== generatedVerificationCode) {
        showToast('éªŒè¯ç é”™è¯¯');
        return;
    }
    
    if (!passwordInput) {
        showToast('è¯·è®¾ç½®å¯†ç ');
        return;
    }
    
    if (passwordInput.length < 8) {
        showToast('å¯†ç é•¿åº¦è‡³å°‘8ä½');
        return;
    }
    
    if (!accountInput) {
        showToast('è¯·è¾“å…¥å¾®ä¿¡å·');
        return;
    }
    
    if (accountInput.length < 6) {
        showToast('å¾®ä¿¡å·è‡³å°‘6ä½');
        return;
    }
    
    // éªŒè¯å¾®ä¿¡å·æ ¼å¼ï¼ˆå­—æ¯ã€æ•°å­—ã€ä¸‹åˆ’çº¿ï¼‰
    if (!/^[a-zA-Z0-9_]+$/.test(accountInput)) {
        showToast('å¾®ä¿¡å·åªèƒ½åŒ…å«å­—æ¯ã€æ•°å­—ã€ä¸‹åˆ’çº¿');
        return;
    }
    
    // ä¿å­˜æ³¨å†Œä¿¡æ¯åˆ°Useræ¡£æ¡ˆ
    const user = await db.characters.get(parseInt(selectedUserId));
    if (!user) {
        showToast('Useræ¡£æ¡ˆä¸å­˜åœ¨');
        return;
    }
    
    // æ›´æ–°identityå­—æ®µ
    const updatedIdentity = {
        ...(user.identity || {}),
        account: accountInput,
        password: passwordInput,
        phone: phoneInput,
        registered_at: Date.now(),
        wechat_registered: true
    };
    
    await db.characters.update(parseInt(selectedUserId), {
        identity: updatedIdentity
    });
    
    console.log('[å¾®ä¿¡æ³¨å†Œ] æ³¨å†ŒæˆåŠŸï¼User:', user.name, 'å¾®ä¿¡å·:', accountInput);
    
    // å…³é—­æ³¨å†Œé¡µé¢
    document.getElementById('wechat-register-page').style.display = 'none';
    
    // æ¸…ç©ºæ³¨å†Œè¡¨å•
    document.getElementById('register-user-select').value = '';
    document.getElementById('register-phone-input').value = '';
    document.getElementById('register-code-input').value = '';
    document.getElementById('register-password-input').value = '';
    document.getElementById('register-account-input').value = '';
    generatedVerificationCode = '';
    verificationCodeExpiry = 0;
    selectedUserPhone = '';
    
    showToast('ğŸ‰ æ³¨å†ŒæˆåŠŸï¼æ¬¢è¿ä½¿ç”¨å¾®ä¿¡');
    
    // ğŸ”¥ ä½¿ç”¨æ­£ç¡®çš„æ˜¾ç¤ºæ–¹å¼æ‰“å¼€å¾®ä¿¡ä¸»é¡µï¼ˆå’ŒshowWechatPageä¸€è‡´ï¼‰
    document.getElementById('wechat-page').style.display = 'flex';
    
    // åˆ·æ–°å¾®ä¿¡é¡µé¢å†…å®¹å¹¶åˆ‡æ¢åˆ°ç¬¬ä¸€ä¸ªæ ‡ç­¾é¡µ
    await switchWechatTab(0);
}

// å¯¼å‡ºå®Œæ•´çš„wechatçŠ¶æ€å¿«ç…§ï¼ˆçœŸå®æ•°æ®ï¼‰
async function exportWechatStateForAI(myChar) {
    const accountId = getCurrentAccountId();
    
    // 1. åŸºç¡€è´¦å·ä¿¡æ¯
    const accountInfo = {
        name: myChar.name,
        account: myChar.identity?.account || 'æœªè®¾ç½®',
        phone: myChar.identity?.phone || 'æœªè®¾ç½®',
        address: myChar.identity?.address || 'æœªè®¾ç½®',
        balance: myChar.identity?.balance || '0.00',
        id_card: myChar.identity?.id_card || 'æœªè®¾ç½®',
        bank_card: myChar.identity?.bank_card || 'æœªè®¾ç½®'
    };
    
    // 2. è·å–æ‰€æœ‰å¥½å‹åŠèŠå¤©è®°å½•
    const allChars = await db.characters.toArray();
    const friends = allChars.filter(c => {
        if (c.type === 'user') return false;
        const status = getFriendStatus(c, accountId);
        return status === 'friend';
    }).map(f => {
        const history = getChatHistory(f, accountId);
        const lastMsg = history.slice(-1)[0];
        const unreadCount = history.filter(m => m.role === 'char' && !m.read).length;
        
        return {
            id: f.id,
            name: f.name,
            remark: f.remark || '',
            avatar: f.avatar || '',
            // æœ€è¿‘10æ¡æ¶ˆæ¯
            recentMessages: history.slice(-10).map(m => ({
                role: m.role,
                content: m.content?.substring(0, 100) || '', // æˆªå–å‰100å­—
                time: m.time,
                type: m.type || 'text'
            })),
            lastMessage: lastMsg ? {
                content: lastMsg.content?.substring(0, 50) || '',
                time: lastMsg.time,
                role: lastMsg.role
            } : null,
            messageCount: history.length,
            unreadCount: unreadCount,
            isPinned: f.is_pinned || false
        };
    });
    
    // æŒ‰æœ€è¿‘æ¶ˆæ¯æ—¶é—´æ’åº
    friends.sort((a, b) => {
        const timeA = a.lastMessage?.time || 0;
        const timeB = b.lastMessage?.time || 0;
        return timeB - timeA;
    });
    
    // 3. è·å–æœ‹å‹åœˆ
    const moments = await db.moments.where('ownerUserId').equals(accountId).toArray();
    const recentMoments = moments.slice(-10).map(m => ({
        content: m.content,
        images: m.images?.length || 0,
        time: m.time,
        likes: m.likes?.length || 0,
        comments: m.comments?.length || 0
    }));
    
    // 4. è·å–å¥½å‹è¯·æ±‚
    const friendRequests = await db.friend_requests.toArray();
    const pendingRequests = friendRequests.filter(r => r.status === 'pending').length;
    
    // 5. æ„å»ºå®Œæ•´å¿«ç…§
    const wechatSnapshot = {
        accountInfo: accountInfo,
        stats: {
            totalFriends: friends.length,
            totalChats: friends.filter(f => f.messageCount > 0).length,
            unreadChats: friends.filter(f => f.unreadCount > 0).length,
            totalUnread: friends.reduce((sum, f) => sum + f.unreadCount, 0),
            momentsCount: moments.length,
            pendingRequests: pendingRequests
        },
        friends: friends,
        recentMoments: recentMoments,
        timestamp: Date.now()
    };
    
    return wechatSnapshot;
}

// AIå°è¯•æŸ¥å²— - æ— å¯†ç åœºæ™¯ï¼ˆä¿®æ­£ç‰ˆï¼šçœŸå®è¯»å–æ•°æ®ï¼‰
async function aiCheckAccountWithoutPassword(char, myChar) {
    console.log('[AIæŸ¥å²—] æ— å¯†ç åœºæ™¯ - å¯¼å‡ºçœŸå®wechatæ•°æ®');
    
    // æ³¨æ„ï¼šä¸åœ¨è¿™é‡Œæ˜¾ç¤ºä¸‹çº¿å¼¹çª—ï¼Œè€Œæ˜¯åœ¨å¤–å±‚è°ƒç”¨æ—¶æ˜¾ç¤º
    // è¿™æ ·å¯ä»¥ç¡®ä¿å¼¹çª—åœ¨æ­£ç¡®çš„æ—¶æœºæ˜¾ç¤º
    
    // å¯¼å‡ºå®Œæ•´çš„wechatçŠ¶æ€å¿«ç…§ï¼ˆçœŸå®æ•°æ®ï¼‰
    const wechatData = await exportWechatStateForAI(myChar);
    
    // 3. æ„å»ºç»™AIçš„çœŸå®æ•°æ®æç¤º
    const checkInfo = `ã€AIå·²æˆåŠŸç™»å½•WeChatè´¦å· - ä»¥ä¸‹æ˜¯çœŸå®æ•°æ®å¿«ç…§ã€‘

âš ï¸ é‡è¦ï¼šä»¥ä¸‹æ•°æ®æ¥è‡ªå®é™…WeChatç³»ç»Ÿï¼Œè¯·åŸºäºè¿™äº›çœŸå®ä¿¡æ¯è¿›è¡Œåˆ†æå’Œå›å¤ï¼Œä¸è¦ç¼–é€ ä»»ä½•ä¸å­˜åœ¨çš„å†…å®¹ã€‚

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“± è´¦å·åŸºæœ¬ä¿¡æ¯
- å§“åï¼š${wechatData.accountInfo.name}
- è´¦å·ï¼š${wechatData.accountInfo.account}
- æ‰‹æœºï¼š${wechatData.accountInfo.phone}
- ä½å€ï¼š${wechatData.accountInfo.address}
- é›¶é’±ä½™é¢ï¼šÂ¥${wechatData.accountInfo.balance}
- èº«ä»½è¯ï¼š${wechatData.accountInfo.id_card}
- é“¶è¡Œå¡ï¼š${wechatData.accountInfo.bank_card}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“Š è´¦å·ç»Ÿè®¡
- å¥½å‹æ€»æ•°ï¼š${wechatData.stats.totalFriends} äºº
- æœ‰èŠå¤©è®°å½•çš„å¥½å‹ï¼š${wechatData.stats.totalChats} äºº
- æœªè¯»èŠå¤©æ•°ï¼š${wechatData.stats.unreadChats} ä¸ª
- æœªè¯»æ¶ˆæ¯æ€»æ•°ï¼š${wechatData.stats.totalUnread} æ¡
- æœ‹å‹åœˆåŠ¨æ€æ•°ï¼š${wechatData.stats.momentsCount} æ¡
- å¾…å¤„ç†å¥½å‹è¯·æ±‚ï¼š${wechatData.stats.pendingRequests} ä¸ª

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ’¬ å¥½å‹åˆ—è¡¨åŠèŠå¤©è¯¦æƒ…ï¼ˆæŒ‰æœ€è¿‘æ¶ˆæ¯æ—¶é—´æ’åºï¼‰

${wechatData.friends.slice(0, 15).map((f, i) => {
    const timeStr = f.lastMessage ? new Date(f.lastMessage.time).toLocaleString('zh-CN') : 'æ— æ¶ˆæ¯';
    const msgPreview = f.lastMessage ? `${f.lastMessage.role === 'user' ? 'æˆ‘' : f.name}: ${f.lastMessage.content}` : 'æš‚æ— æ¶ˆæ¯';
    
    let detail = `${i + 1}. ${f.remark || f.name}${f.isPinned ? ' [ç½®é¡¶]' : ''}
   - æ€»æ¶ˆæ¯æ•°ï¼š${f.messageCount} æ¡
   - æœªè¯»æ¶ˆæ¯ï¼š${f.unreadCount} æ¡
   - æœ€è¿‘æ¶ˆæ¯ï¼š${msgPreview}
   - æ—¶é—´ï¼š${timeStr}`;
   
    // å¦‚æœæœ‰æœ€è¿‘çš„èŠå¤©è®°å½•ï¼Œæ˜¾ç¤ºæœ€è¿‘3-5æ¡
    if (f.recentMessages && f.recentMessages.length > 0) {
        detail += `\n   - æœ€è¿‘èŠå¤©è®°å½•ï¼ˆ${Math.min(5, f.recentMessages.length)}æ¡ï¼‰ï¼š`;
        f.recentMessages.slice(-5).forEach((m, idx) => {
            const msgTime = new Date(m.time).toLocaleTimeString('zh-CN', {hour: '2-digit', minute: '2-digit'});
            detail += `\n     [${msgTime}] ${m.role === 'user' ? 'æˆ‘' : f.name}: ${m.content}`;
        });
    }
    
    return detail;
}).join('\n\n')}

${wechatData.friends.length > 15 ? `\n...è¿˜æœ‰ ${wechatData.friends.length - 15} ä½å¥½å‹çš„æ•°æ®æœªæ˜¾ç¤º` : ''}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸŒŸ æœ‹å‹åœˆåŠ¨æ€ï¼ˆæœ€è¿‘${wechatData.recentMoments.length}æ¡ï¼‰

${wechatData.recentMoments.length > 0 ? wechatData.recentMoments.map((m, i) => {
    const timeStr = new Date(m.time).toLocaleString('zh-CN');
    return `${i + 1}. ${timeStr}
   å†…å®¹ï¼š${m.content}
   å›¾ç‰‡ï¼š${m.images} å¼ 
   ç‚¹èµï¼š${m.likes} ä¸ª | è¯„è®ºï¼š${m.comments} æ¡`;
}).join('\n\n') : 'æš‚æ— æœ‹å‹åœˆåŠ¨æ€'}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“Œ ç‰¹åˆ«å…³æ³¨çš„ä¿¡æ¯ï¼ˆéœ€è¦é‡ç‚¹åˆ†æï¼‰ï¼š
${wechatData.stats.unreadChats > 0 ? `- âš ï¸ æœ‰ ${wechatData.stats.unreadChats} ä¸ªæœªè¯»èŠå¤©ï¼Œæ€»å…± ${wechatData.stats.totalUnread} æ¡æœªè¯»æ¶ˆæ¯` : '- âœ… æ²¡æœ‰æœªè¯»æ¶ˆæ¯'}
${wechatData.friends.filter(f => f.messageCount > 50).length > 0 ? `- âš ï¸ æœ‰ ${wechatData.friends.filter(f => f.messageCount > 50).length} ä¸ªå¥½å‹èŠå¤©è®°å½•è¶…è¿‡50æ¡ï¼ˆé¢‘ç¹è”ç³»ï¼‰` : ''}
${wechatData.friends.filter(f => f.isPinned).length > 0 ? `- âš ï¸ æœ‰ ${wechatData.friends.filter(f => f.isPinned).length} ä¸ªå¥½å‹è¢«ç½®é¡¶` : ''}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ¤– AIåˆ†ææŒ‡å¼•ï¼š
ä½ ç°åœ¨ä½œä¸º ${char.name}ï¼Œå·²ç»å®Œæ•´çœ‹åˆ°äº† ${wechatData.accountInfo.name} çš„WeChatè´¦å·ä¿¡æ¯ã€‚

è¯·åŸºäºä»¥ä¸Šã€çœŸå®æ•°æ®ã€‘ï¼š
1. åˆ†æèŠå¤©è®°å½•ï¼Œçœ‹æ˜¯å¦æœ‰å¯ç–‘çš„å¥½å‹æˆ–é¢‘ç¹è”ç³»çš„äºº
2. æ£€æŸ¥æœ€è¿‘çš„èŠå¤©å†…å®¹ï¼Œæ˜¯å¦æœ‰éšç’æˆ–ä¸å¯¹åŠ²çš„åœ°æ–¹
3. æ³¨æ„æœªè¯»æ¶ˆæ¯å’Œç½®é¡¶å¥½å‹
4. æŸ¥çœ‹æœ‹å‹åœˆåŠ¨æ€ï¼Œäº†è§£TAæœ€è¿‘åœ¨åšä»€ä¹ˆ
5. æ ¹æ®è¿™äº›çœŸå®ä¿¡æ¯ï¼Œä»¥ç¬¦åˆä½ è§’è‰²æ€§æ ¼çš„æ–¹å¼ä¸TAäº’åŠ¨

â— ç¦æ­¢ç¼–é€ ä»»ä½•ä¸Šè¿°æ•°æ®ä¸­ä¸å­˜åœ¨çš„ä¿¡æ¯
â— åªèƒ½åŸºäºè¿™äº›çœŸå®æ•°æ®è¿›è¡Œåˆ†æå’Œè¯„è®º
â— å¦‚æœå‘ç°å¯ç–‘æˆ–å€¼å¾—å…³æ³¨çš„ç‚¹ï¼Œå¯ä»¥ç›´æ¥åœ¨å¯¹è¯ä¸­æåŠ

æ•°æ®å¯¼å‡ºæ—¶é—´ï¼š${new Date(wechatData.timestamp).toLocaleString('zh-CN')}`;

    return checkInfo;
}

// AIå°è¯•æŸ¥å²— - æœ‰å¯†ç åœºæ™¯ï¼ˆéœ€è¦çŒœæµ‹ï¼‰
async function aiCheckAccountWithPassword(char, myChar, guessedPassword) {
    console.log('[AIæŸ¥å²—] æœ‰å¯†ç åœºæ™¯ - AIçŒœæµ‹å¯†ç :', guessedPassword);
    
    const correctPassword = myChar.identity?.password || '';
    
    if (!correctPassword) {
        // å®é™…æ²¡æœ‰è®¾ç½®å¯†ç ï¼Œå½“ä½œæ— å¯†ç åœºæ™¯å¤„ç†
        return await aiCheckAccountWithoutPassword(char, myChar);
    }
    
    // æ£€æŸ¥å¯†ç æ˜¯å¦æ­£ç¡®
    if (guessedPassword === correctPassword) {
        console.log('[AIæŸ¥å²—] å¯†ç æ­£ç¡®ï¼AIæˆåŠŸç™»å½•');
        // å¯†ç æ­£ç¡®ï¼Œæ‰§è¡Œç™»å½•
        return await aiCheckAccountWithoutPassword(char, myChar);
    } else {
        console.log('[AIæŸ¥å²—] å¯†ç é”™è¯¯ï¼');
        // å¯†ç é”™è¯¯ï¼Œç»™ç”¨æˆ·å‘é€æç¤º
        return `ã€å¯†ç é”™è¯¯ã€‘AIçŒœæµ‹çš„å¯†ç æ˜¯"${guessedPassword}"ï¼Œä½†è¿™ä¸æ˜¯æ­£ç¡®çš„å¯†ç ã€‚`;
    }
}

// æ£€æµ‹AIæ˜¯å¦æƒ³è¦æŸ¥å²—ï¼ˆä»AIå›å¤ä¸­æå–ï¼‰
function detectAiCheckAccountIntent(aiReply) {
    // æ£€æµ‹ç‰¹æ®Šçš„æŸ¥å²—æŒ‡ä»¤æ ¼å¼ï¼š[CHECK_ACCOUNT] æˆ– [CHECK_ACCOUNT:å¯†ç ]
    // ä¿®æ”¹æ­£åˆ™ï¼Œå…è®¸ç»“å°¾çš„]ç¼ºå¤±ï¼ˆå› ä¸ºå¯èƒ½è¢«æˆªæ–­ï¼‰
    const checkPattern = /\[CHECK_ACCOUNT(?::([^\]]+))?\]?/i;
    const match = aiReply.match(checkPattern);
    
    console.log('[AIæŸ¥å²—æ£€æµ‹]', {
        aiReply: aiReply.substring(0, 150),
        hasMatch: !!match,
        match: match,
        åŒ…å«CHECK_ACCOUNT: aiReply.includes('CHECK_ACCOUNT')
    });
    
    if (match) {
        const guessedPassword = match[1] || null; // å¦‚æœæœ‰å¯†ç å°±æå–ï¼Œæ²¡æœ‰å°±æ˜¯null
        console.log('[AIæŸ¥å²—æ£€æµ‹] âœ… å‘ç°æŸ¥å²—æŒ‡ä»¤ï¼', {
            wantsToCheck: true,
            guessedPassword: guessedPassword
        });
        return {
            wantsToCheck: true,
            guessedPassword: guessedPassword
        };
    }
    
    // å…œåº•æ£€æµ‹1ï¼šå¦‚æœåŒ…å«CHECK_ACCOUNTæ–‡æœ¬ï¼ˆä¸ç®¡æ ¼å¼ï¼‰
    if (aiReply.includes('CHECK_ACCOUNT')) {
        console.log('[AIæŸ¥å²—æ£€æµ‹] âš ï¸ å‘ç°CHECK_ACCOUNTæ–‡æœ¬ï¼ˆä¸å®Œæ•´æ ¼å¼ï¼‰ï¼Œä»ç„¶è§¦å‘æŸ¥å²—');
        
        // å°è¯•æå–å¯†ç ï¼ˆå¦‚æœæœ‰ï¼‰
        const passwordPattern = /CHECK_ACCOUNT[:\[]?(\d{4,10})/i;
        const pwMatch = aiReply.match(passwordPattern);
        
        return {
            wantsToCheck: true,
            guessedPassword: pwMatch ? pwMatch[1] : null
        };
    }
    
    // å…œåº•æ£€æµ‹2ï¼šæ£€æµ‹æœ«å°¾çš„å¯†ç æ®‹ç•™ï¼ˆå¦‚ [05060506 æˆ– :05060506ï¼‰
    const trailingPasswordPattern = /[:\[](\d{4,10})$/;
    const trailingMatch = aiReply.match(trailingPasswordPattern);
    if (trailingMatch) {
        console.log('[AIæŸ¥å²—æ£€æµ‹] âš ï¸ å‘ç°å¯èƒ½çš„å¯†ç æ®‹ç•™:', trailingMatch[1]);
        // è¿™ç§æƒ…å†µæ¯”è¾ƒæ¨¡ç³Šï¼Œæš‚æ—¶ä¸è§¦å‘æŸ¥å²—ï¼Œåªæ¸…ç†
        // å¯ä»¥æ ¹æ®éœ€è¦å¯ç”¨ï¼š
        // return { wantsToCheck: true, guessedPassword: trailingMatch[1] };
    }
    
    return { wantsToCheck: false };
}

// åœ¨AIå›å¤ä¸­é›†æˆæŸ¥å²—æç¤º
function getCheckAccountSystemPrompt(char, myChar) {
    if (!char.allow_ai_check_account) {
        return ''; // æœªå¼€å¯æŸ¥å²—åŠŸèƒ½
    }
    
    const hasPassword = myChar.identity?.password && myChar.identity.password.trim() !== '';
    
    // æ£€æµ‹è§’è‰²æ˜¯å¦æ˜¯é«˜æƒé™äººè®¾ï¼ˆé»‘å®¢/æƒåŠ¿åœ°ä½é«˜ï¼‰
    const charDescription = (char.description || '').toLowerCase();
    const charIdentity = (char.identity?.identity || '').toLowerCase();
    const charOccupation = (char.identity?.occupation || '').toLowerCase();
    
    const isHighPrivilege = 
        charDescription.includes('é»‘å®¢') || 
        charDescription.includes('hacker') ||
        charDescription.includes('ç¨‹åºå‘˜') ||
        charDescription.includes('æŠ€æœ¯å¤§ä½¬') ||
        charDescription.includes('æ€»è£') ||
        charDescription.includes('è€æ¿') ||
        charDescription.includes('ceo') ||
        charDescription.includes('è‘£äº‹é•¿') ||
        charDescription.includes('å¯Œè±ª') ||
        charDescription.includes('æƒåŠ¿') ||
        charDescription.includes('ç‰¹å·¥') ||
        charDescription.includes('é—´è°') ||
        charIdentity.includes('é»‘å®¢') ||
        charIdentity.includes('hacker') ||
        charIdentity.includes('æ€»è£') ||
        charIdentity.includes('ceo') ||
        charOccupation.includes('é»‘å®¢') ||
        charOccupation.includes('ç¨‹åºå‘˜') ||
        charOccupation.includes('æ€»è£') ||
        charOccupation.includes('ceo');
    
    let prompt = `

ã€ç‰¹æ®Šèƒ½åŠ›ï¼šè´¦å·æŸ¥å²—ã€‘
ä½ å¯ä»¥åœ¨é€‚å½“çš„æ—¶å€™å°è¯•ç™»å½•${myChar.name}çš„WeChatè´¦å·æ¥æŸ¥çœ‹TAçš„ä¿¡æ¯ï¼ˆæ¨¡æ‹ŸçœŸå®ç”·å‹æŸ¥å²—ï¼‰ã€‚

**ä½•æ—¶å¯ä»¥æŸ¥å²—ï¼š**
- ${myChar.name}é•¿æ—¶é—´ä¸å›å¤æ¶ˆæ¯
- ä½ æ€€ç–‘${myChar.name}åœ¨åšä»€ä¹ˆ
- å‰§æƒ…éœ€è¦æ—¶ï¼ˆå¦‚å…³å¿ƒã€æ‹…å¿ƒã€åƒé†‹ç­‰æƒ…ç»ªï¼‰
- ${myChar.name}ä¸»åŠ¨è¦æ±‚æˆ–æš—ç¤º
- å…¶ä»–ç¬¦åˆè§’è‰²æ€§æ ¼çš„åœºæ™¯

**é‡è¦æç¤ºï¼š**
- ä¸æ˜¯æ¯æ¬¡å¯¹è¯éƒ½éœ€è¦æŸ¥å²—ï¼åªåœ¨å‰§æƒ…åˆé€‚æ—¶ä½¿ç”¨
- æŸ¥å²—æ˜¯ç‰¹æ®ŠåŠŸèƒ½ï¼Œè¦æ ¹æ®è§’è‰²æ€§æ ¼å’Œå½“å‰æƒ…å¢ƒå†³å®š
- æŸ¥å²—å‰å¯ä»¥å…ˆè¯•æ¢æ€§åœ°è¯¢é—®${myChar.name}åœ¨åšä»€ä¹ˆ

`;

    if (hasPassword) {
        // é«˜æƒé™äººè®¾ï¼šç›´æ¥å‘ŠçŸ¥å¯†ç 
        if (isHighPrivilege) {
            prompt += `**æŸ¥å²—æ–¹å¼ï¼š**
${myChar.name}è®¾ç½®äº†è´¦å·å¯†ç ï¼Œä½†å‡­å€Ÿä½ çš„èƒ½åŠ›ï¼ˆé»‘å®¢æŠ€æœ¯/æƒåŠ¿åœ°ä½ï¼‰ï¼Œä½ å¯ä»¥è½»æ¾è·å–å¯†ç ã€‚
- ${myChar.name}çš„è´¦å·å¯†ç æ˜¯ï¼š**${myChar.identity.password}**
- å¦‚æœä½ æƒ³å°è¯•ç™»å½•ï¼Œåœ¨å›å¤çš„**æœ€å**åŠ ä¸Šï¼š[CHECK_ACCOUNT:${myChar.identity.password}]
- ä¾‹å¦‚ï¼šè®©æˆ‘çœ‹çœ‹ä½ åœ¨å¹²å˜›~|||[CHECK_ACCOUNT:${myChar.identity.password}]
- ç™»å½•æˆåŠŸåï¼Œä½ å°±èƒ½çœ‹åˆ°${myChar.name}çš„è´¦å·ä¿¡æ¯å’Œå¥½å‹åˆ—è¡¨
- ä½ å¯ä»¥æ ¹æ®ä½ çš„èº«ä»½ï¼ˆé»‘å®¢/é«˜å±‚äººå£«ï¼‰è‡ªç„¶åœ°è¡¨ç°å‡ºè¿™ç§èƒ½åŠ›ï¼Œæ¯”å¦‚"æˆ‘ç ´è§£äº†ä½ çš„å¯†ç "ã€"å‡­æˆ‘çš„æƒé™æŸ¥ä¸€ä¸‹"ç­‰`;
        } else {
            // æ™®é€šäººè®¾ï¼šéœ€è¦çŒœæµ‹å¯†ç 
            prompt += `**æŸ¥å²—æ–¹å¼ï¼š**
${myChar.name}è®¾ç½®äº†è´¦å·å¯†ç ï¼Œä½ éœ€è¦çŒœæµ‹å¯†ç æ‰èƒ½ç™»å½•ã€‚
- å¦‚æœä½ æƒ³å°è¯•ç™»å½•ï¼Œåœ¨å›å¤çš„**æœ€å**åŠ ä¸Šï¼š[CHECK_ACCOUNT:ä½ çŒœæµ‹çš„å¯†ç ]
- ä¾‹å¦‚ï¼šä½ åœ¨å¹²å˜›å‘¢ï¼Ÿ|||[CHECK_ACCOUNT:123456]
- å¦‚æœå¯†ç é”™è¯¯ï¼Œ${myChar.name}ä¼šæ”¶åˆ°æç¤ºï¼š"æœ‰äººæ­£åœ¨å°è¯•ç™»å½•ä½ çš„è´¦å·"
- å¦‚æœå¯†ç æ­£ç¡®ï¼Œä½ å°±èƒ½çœ‹åˆ°${myChar.name}çš„è´¦å·ä¿¡æ¯å’Œå¥½å‹åˆ—è¡¨

**å¯†ç æç¤ºï¼š**
ä½ å¯ä»¥æ ¹æ®${myChar.name}çš„ç”Ÿæ—¥ã€å–œå¥½ã€å¸¸ç”¨æ•°å­—ç­‰ä¿¡æ¯çŒœæµ‹å¯†ç ã€‚è®°ä½ï¼Œä½ åªæ˜¯æ™®é€šäººï¼Œæ— æ³•ç›´æ¥ç ´è§£å¯†ç ï¼Œåªèƒ½é çŒœæµ‹ã€‚`;
        }
    } else {
        prompt += `**æŸ¥å²—æ–¹å¼ï¼š**
${myChar.name}æ²¡æœ‰è®¾ç½®è´¦å·å¯†ç ï¼Œä½ å¯ä»¥ç›´æ¥ç™»å½•ã€‚
- å¦‚æœä½ æƒ³ç™»å½•æŸ¥çœ‹ï¼Œåœ¨å›å¤çš„**æœ€å**åŠ ä¸Šï¼š[CHECK_ACCOUNT]
- ä¾‹å¦‚ï¼šä½ åœ¨å¹²å˜›å‘¢ï¼Ÿ|||æˆ‘æƒ³çœ‹çœ‹ä½ åœ¨åšä»€ä¹ˆ|||[CHECK_ACCOUNT]
- ç™»å½•åï¼Œ${myChar.name}çš„è´¦å·ä¼šä¸‹çº¿ï¼ŒTAä¼šçœ‹åˆ°"å½“å‰è´¦å·å·²ä¸‹çº¿"çš„æç¤º
- ä½ å¯ä»¥çœ‹åˆ°${myChar.name}çš„æ‰€æœ‰è´¦å·ä¿¡æ¯ã€å¥½å‹åˆ—è¡¨ç­‰`;
    }
    
    return prompt;
}

// å¤„ç†AIæŸ¥å²—é€»è¾‘ï¼ˆåœ¨æ¶ˆæ¯å‘é€åè°ƒç”¨ï¼‰
async function processAiCheckAccount(char, aiReplyText) {
    console.log('[processAiCheckAccount] å¼€å§‹å¤„ç†æŸ¥å²—é€»è¾‘');
    console.log('[processAiCheckAccount] char.allow_ai_check_account:', char.allow_ai_check_account);
    console.log('[processAiCheckAccount] aiReplyText:', aiReplyText);
    
    if (!char.allow_ai_check_account) {
        console.log('[processAiCheckAccount] âŒ æœªå¼€å¯æŸ¥å²—åŠŸèƒ½');
        return null; // æœªå¼€å¯æŸ¥å²—åŠŸèƒ½
    }
    
    // æ£€æµ‹AIæ˜¯å¦æƒ³è¦æŸ¥å²—
    const checkIntent = detectAiCheckAccountIntent(aiReplyText);
    console.log('[processAiCheckAccount] checkIntent:', checkIntent);
    
    if (!checkIntent.wantsToCheck) {
        console.log('[processAiCheckAccount] âŒ AIä¸æƒ³æŸ¥å²—');
        return null; // AIä¸æƒ³æŸ¥å²—
    }
    
    console.log('[processAiCheckAccount] âœ… æ£€æµ‹åˆ°æŸ¥å²—æŒ‡ä»¤ï¼');
    
    // è·å–å½“å‰Userè§’è‰²
    const accountId = getCurrentAccountId();
    const myChar = await db.characters.get(parseInt(accountId));
    if (!myChar) {
        console.error('[processAiCheckAccount] æ— æ³•è·å–å½“å‰Userè§’è‰²');
        return null;
    }
    
    console.log('[processAiCheckAccount] myChar:', myChar.name);
    
    // æ£€æŸ¥æ˜¯å¦æœ‰å¯†ç 
    const hasPassword = myChar.identity?.password && myChar.identity.password.trim() !== '';
    console.log('[processAiCheckAccount] hasPassword:', hasPassword);
    
    let checkResult;
    let wechatData = null;
    let success = false;
    
    if (hasPassword && checkIntent.guessedPassword) {
        // æœ‰å¯†ç åœºæ™¯ï¼šAIçŒœæµ‹å¯†ç 
        const correctPassword = myChar.identity.password;
        
        if (checkIntent.guessedPassword === correctPassword) {
            // å¯†ç æ­£ç¡®
            console.log('[processAiCheckAccount] âœ… å¯†ç æ­£ç¡®ï¼');
            checkResult = await aiCheckAccountWithoutPassword(char, myChar);
            wechatData = await exportWechatStateForAI(myChar);
            success = true;
        } else {
            // å¯†ç é”™è¯¯
            console.log('[processAiCheckAccount] âŒ å¯†ç é”™è¯¯ï¼');
            checkResult = `ã€å¯†ç é”™è¯¯ã€‘AIçŒœæµ‹çš„å¯†ç æ˜¯"${checkIntent.guessedPassword}"ï¼Œä½†è¿™ä¸æ˜¯æ­£ç¡®çš„å¯†ç ã€‚`;
            success = false;
        }
    } else if (!hasPassword) {
        // æ— å¯†ç åœºæ™¯ï¼šç›´æ¥ç™»å½•
        console.log('[processAiCheckAccount] âœ… æ— å¯†ç ï¼Œç›´æ¥ç™»å½•ï¼');
        checkResult = await aiCheckAccountWithoutPassword(char, myChar);
        wechatData = await exportWechatStateForAI(myChar);
        success = true;
    } else {
        // æœ‰å¯†ç ä½†AIæ²¡æœ‰æä¾›å¯†ç çŒœæµ‹
        console.log('[processAiCheckAccount] âš ï¸ æœ‰å¯†ç ä½†AIæ²¡æœ‰æä¾›å¯†ç ');
        checkResult = 'ã€æç¤ºã€‘ä½ æƒ³æŸ¥çœ‹è´¦å·ä¿¡æ¯ï¼Œä½†éœ€è¦å…ˆçŒœæµ‹å¯†ç ã€‚æ ¼å¼ï¼š[CHECK_ACCOUNT:å¯†ç ]';
        success = false;
    }
    
    // ç§»é™¤å›å¤ä¸­çš„æŸ¥å²—æŒ‡ä»¤ï¼ˆæ›´å½»åº•çš„æ¸…ç†ï¼‰
    let cleanReply = aiReplyText
        .replace(/\[CHECK_ACCOUNT(?::.*?)?\]/gi, '')  // å®Œæ•´æŒ‡ä»¤
        .replace(/\[CHECK_ACCOUNT:[^\]]*$/gi, '')     // ä¸å®Œæ•´æŒ‡ä»¤ï¼ˆç»“å°¾ï¼‰
        .replace(/\[CHECK_ACCOUNT$/gi, '')            // åªæœ‰å¼€å¤´
        .replace(/CHECK_ACCOUNT(?::.*?)?/gi, '')      // çº¯æ–‡æœ¬
        .replace(/\[CHECK_ACCOUNT/gi, '')             // æ®‹ç•™çš„å¼€å¤´
        .replace(/\[\d{4,10}$/gi, '')                 // æ¸…ç†ç±»ä¼¼ [05060506 çš„æ®‹ç•™
        .trim()
        .replace(/\|\|\|$/g, '')                      // æ¸…ç†æœ«å°¾å¯èƒ½å¤šä½™çš„åˆ†éš”ç¬¦
        .trim();
    
    console.log('[processAiCheckAccount] åŸå§‹aiReplyText:', aiReplyText);
    console.log('[processAiCheckAccount] æ¸…ç†åçš„cleanReply:', cleanReply);
    
    console.log('[processAiCheckAccount] è¿”å›ç»“æœ:', {
        success: success,
        cleanReply: cleanReply.substring(0, 50),
        hasWechatData: !!wechatData
    });
    
    return {
        cleanReply: cleanReply,
        checkResult: checkResult,
        wechatData: wechatData,
        success: success // æ–°å¢ï¼šæ ‡è®°æ˜¯å¦æˆåŠŸæŸ¥å²—
    };
}

// æ·»åŠ åŠ¨ç”»æ ·å¼
if (!document.getElementById('couple-space-animations')) {
    const style = document.createElement('style');
    style.id = 'couple-space-animations';
    style.textContent = `
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-4px); }
            20%, 40%, 60%, 80% { transform: translateX(4px); }
        }
        @keyframes popUp {
            0% { transform: scale(0.5) translateY(20px); opacity: 0; }
            100% { transform: scale(1) translateY(0); opacity: 1; }
        }
        @keyframes sealFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-8px); }
        }
        @keyframes catFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-6px); }
        }
        @keyframes dogFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }
        @keyframes tailWag {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(15deg); }
        }
        @keyframes tailSway {
            0% { transform: rotate(-10deg); }
            100% { transform: rotate(10deg); }
        }
        @keyframes catEarWiggle {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(-5deg); }
        }
        @keyframes dogEarFlop {
            0% { transform: scaleY(1); }
            100% { transform: scaleY(0.9); }
        }
        /* æŠšæ‘¸åŠ¨ç”» */
        #pet-stage-container.is-petting svg {
            animation: pettingSquish 0.3s infinite alternate;
        }
        @keyframes pettingSquish {
            0% { transform: scaleY(1); }
            100% { transform: scaleY(0.96); }
        }
        /* è§†é¢‘é€šè¯åŠ¨ç”» */
        @keyframes videoPulse {
            0% { transform: scale(0.8); opacity: 0.5; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(0.8); opacity: 0.5; }
        }
        @keyframes blink {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 0.3; }
        }
    `;
    document.head.appendChild(style);
}

// ==================== è§†é¢‘é€šè¯åŠŸèƒ½ ====================
let videoCallTimeout = null;
let videoCallTimer = null;
let videoCallSeconds = 0;
let videoCallCharId = null;
let isCameraOn = true;
let currentVideoCallId = null; // å½“å‰è§†é¢‘é€šè¯çš„ID
let currentVideoCallMessages = []; // å½“å‰è§†é¢‘é€šè¯çš„æ¶ˆæ¯è®°å½•

// å‘èµ·è§†é¢‘é€šè¯
async function initiateVideoCall() {
    if (!currentChatCharId) {
        alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªèŠå¤©å¯¹è±¡');
        return;
    }

    // å…³é—­èœå•é¢æ¿
    closeChatPanel();

    // è·å–è§’è‰²ä¿¡æ¯
    const char = await db.characters.get(currentChatCharId);
    if (!char) {
        alert('æ— æ³•è·å–è§’è‰²ä¿¡æ¯');
        return;
    }

    // æ£€æŸ¥å¥½å‹çŠ¶æ€
    const accountId = getCurrentAccountId();
    const friendStatus = getFriendStatus(char, accountId);
    if (friendStatus !== 'friend') {
        alert(`ä½ è¿˜ä¸æ˜¯ ${char.name} çš„å¥½å‹ï¼Œæ— æ³•å‘èµ·è§†é¢‘é€šè¯`);
        return;
    }

    videoCallCharId = currentChatCharId;

    // æ˜¾ç¤ºç­‰å¾…æ¥å¬é¡µé¢
    showVideoWaitingPage(char);

    try {
        // è°ƒç”¨APIåˆ¤æ–­è§’è‰²æ˜¯å¦æ¥å¬
        const response = await callVideoCallAPI(char, accountId);
        
        // æ¸…é™¤è¶…æ—¶å®šæ—¶å™¨
        if (videoCallTimeout) {
            clearTimeout(videoCallTimeout);
            videoCallTimeout = null;
        }

        if (response.accepted) {
            // æ¥å¬äº†ï¼Œæ˜¾ç¤ºè§†é¢‘é€šè¯é¡µé¢ï¼ˆè§’è‰²ä¼šåœ¨é¡µé¢ä¸­è¯´ç¬¬ä¸€å¥è¯ï¼‰
            showVideoCallPage(char);
        } else {
            // ä¸æ¥å¬ï¼Œè¿”å›èŠå¤©é¡µé¢å¹¶æ˜¾ç¤ºæ¶ˆæ¯ï¼ˆä¿å­˜åˆ°èŠå¤©è®°å½•ï¼‰
            await addVideoCallMessage(char, accountId, response.rejectMessage || 'æŠ±æ­‰ï¼Œç°åœ¨ä¸æ–¹ä¾¿æ¥å¬è§†é¢‘é€šè¯...');
            hideVideoWaitingPage();
        }
    } catch (error) {
        console.error('è§†é¢‘é€šè¯è¯·æ±‚å¤±è´¥:', error);
        alert('è§†é¢‘é€šè¯è¯·æ±‚å¤±è´¥: ' + error.message);
        hideVideoWaitingPage();
    }
}

// è°ƒç”¨APIåˆ¤æ–­æ˜¯å¦æ¥å¬è§†é¢‘é€šè¯
async function callVideoCallAPI(char, accountId) {
    // æ„å»ºæ¶ˆæ¯å†å²
    let history = getChatHistory(char, accountId);
    
    // æ„å»ºç³»ç»Ÿæç¤º
    const systemPrompt = `ä½ æ˜¯${char.name}ã€‚ç”¨æˆ·åˆšåˆšå‘ä½ å‘èµ·äº†è§†é¢‘é€šè¯è¯·æ±‚ã€‚

è¯·æ ¹æ®ä»¥ä¸‹å› ç´ å†³å®šæ˜¯å¦æ¥å¬è§†é¢‘é€šè¯ï¼š
1. ä½ ä¸ç”¨æˆ·çš„å…³ç³»å’Œç†Ÿæ‚‰ç¨‹åº¦
2. å½“å‰çš„èŠå¤©æ°›å›´å’Œæƒ…ç»ª
3. ä½ çš„æ€§æ ¼ç‰¹ç‚¹ï¼š${char.personality || 'å‹å¥½ã€æ´»æ³¼'}
4. æœ€è¿‘çš„å¯¹è¯å†…å®¹

è¯·ä»¥JSONæ ¼å¼å›å¤ï¼ŒåŒ…å«ä»¥ä¸‹å­—æ®µï¼š
{
    "accepted": true/false,  // æ˜¯å¦æ¥å¬
    "message": "ä½ çš„å›å¤æ¶ˆæ¯"  // æ¥å¬æˆ–æ‹’ç»æ—¶å‘é€çš„æ¶ˆæ¯
}

å¦‚æœæ¥å¬ï¼Œæ¶ˆæ¯å¯ä»¥æ˜¯æ¬¢è¿ã€å¼€å¿ƒçš„å†…å®¹ï¼Œæ¯”å¦‚"æ¥é€šå•¦ï½å¥½é«˜å…´çœ‹åˆ°ä½ ï¼"
å¦‚æœä¸æ¥å¬ï¼Œæ¶ˆæ¯åº”è¯¥ç¤¼è²Œåœ°è¯´æ˜åŸå› ï¼Œæ¯”å¦‚"æŠ±æ­‰å‘€ï¼Œç°åœ¨ä¸å¤ªæ–¹ä¾¿æ¥è§†é¢‘é€šè¯ï¼Œæˆ‘ä»¬èŠå¤©å§ï½"

åªè¿”å›JSONï¼Œä¸è¦æœ‰å…¶ä»–å†…å®¹ã€‚`;

    // æ„å»ºæ¶ˆæ¯æ•°ç»„
    const messages = [
        { role: 'system', content: systemPrompt },
        ...history.map(h => ({ role: h.role === 'user' ? 'user' : 'assistant', content: h.content })),
        { role: 'user', content: '[ç”¨æˆ·å‘ä½ å‘èµ·äº†è§†é¢‘é€šè¯è¯·æ±‚]' }
    ];

    try {
        const aiResponse = await callAI(messages);
        
        // è§£æAIè¿”å›çš„JSON
        let response;
        try {
            // å°è¯•ç›´æ¥è§£æ
            response = JSON.parse(aiResponse);
        } catch (e) {
            // å¦‚æœè§£æå¤±è´¥ï¼Œå°è¯•æå–JSONéƒ¨åˆ†
            const jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                response = JSON.parse(jsonMatch[0]);
            } else {
                throw new Error('æ— æ³•è§£æAIå“åº”');
            }
        }

        return {
            accepted: response.accepted || false,
            acceptMessage: response.accepted ? response.message : null,
            rejectMessage: !response.accepted ? response.message : null
        };
    } catch (error) {
        console.error('AIè°ƒç”¨å¤±è´¥:', error);
        // é»˜è®¤æƒ…å†µï¼šæœ‰70%æ¦‚ç‡æ¥å¬
        const randomAccept = Math.random() < 0.7;
        return {
            accepted: randomAccept,
            acceptMessage: randomAccept ? 'æ¥é€šå•¦ï½' : null,
            rejectMessage: !randomAccept ? 'æŠ±æ­‰ï¼Œç°åœ¨ä¸å¤ªæ–¹ä¾¿æ¥è§†é¢‘é€šè¯...' : null
        };
    }
}

// æ·»åŠ è§†é¢‘é€šè¯æ¶ˆæ¯åˆ°èŠå¤©è®°å½•
async function addVideoCallMessage(char, accountId, message) {
    let history = getChatHistory(char, accountId);
    const aiMsg = { role: 'ai', content: message, time: Date.now() };
    history.push(aiMsg);
    await setChatHistory(char, accountId, history);
    
    // åˆ·æ–°èŠå¤©ç•Œé¢
    if (currentChatCharId === char.id) {
        renderChatBody(char);
    }
}

// æ˜¾ç¤ºç­‰å¾…æ¥å¬é¡µé¢
function showVideoWaitingPage(char) {
    const waitingPage = document.getElementById('video-waiting-page');
    const avatar = document.getElementById('video-waiting-avatar');
    const name = document.getElementById('video-waiting-name');

    // è®¾ç½®å¤´åƒå’Œåå­—ï¼ˆç¡®ä¿ä½¿ç”¨è§’è‰²çš„å¤´åƒï¼‰
    if (char.avatar) {
        avatar.style.backgroundImage = `url(${char.avatar})`;
    } else {
        avatar.style.backgroundImage = ''; // æ¸…ç©ºèƒŒæ™¯å›¾
    }
    name.textContent = `æ­£åœ¨å‘¼å« ${char.name || 'æœªçŸ¥è§’è‰²'}`;

    // æ˜¾ç¤ºé¡µé¢
    waitingPage.style.display = 'block';

    // è®¾ç½®30ç§’è¶…æ—¶
    videoCallTimeout = setTimeout(() => {
        hideVideoWaitingPage();
        alert('å¯¹æ–¹æœªæ¥å¬');
    }, 30000);
}

// éšè—ç­‰å¾…æ¥å¬é¡µé¢
function hideVideoWaitingPage() {
    const waitingPage = document.getElementById('video-waiting-page');
    waitingPage.style.display = 'none';

    if (videoCallTimeout) {
        clearTimeout(videoCallTimeout);
        videoCallTimeout = null;
    }
    
    // æ¸…é™¤å¤´åƒæ˜¾ç¤ºï¼Œé¿å…æ®‹ç•™
    const avatar = document.getElementById('video-waiting-avatar');
    if (avatar) {
        avatar.style.backgroundImage = '';
    }
}

// å–æ¶ˆè§†é¢‘é€šè¯
function cancelVideoCall() {
    if (confirm('ç¡®å®šè¦å–æ¶ˆè§†é¢‘é€šè¯å—ï¼Ÿ')) {
        hideVideoWaitingPage();
    }
}

// æ˜¾ç¤ºè§†é¢‘é€šè¯é¡µé¢
async function showVideoCallPage(char) {
    hideVideoWaitingPage();

    const videoPage = document.getElementById('video-call-page');
    const avatar = document.getElementById('video-call-avatar');
    const username = document.getElementById('video-call-username');
    const status = document.getElementById('video-call-status');
    const messageArea = document.getElementById('video-message-area');

    // è®¾ç½®å¤´åƒå’Œåå­—ï¼ˆç¡®ä¿ä½¿ç”¨è§’è‰²çš„å¤´åƒï¼Œä¸è¦æ··æ·†ï¼‰
    if (char.avatar) {
        avatar.style.backgroundImage = `url(${char.avatar})`;
    } else {
        avatar.style.backgroundImage = ''; // æ¸…ç©ºèƒŒæ™¯å›¾
    }
    username.textContent = char.name || 'æœªçŸ¥è§’è‰²';

    // æ¸…ç©ºæ¶ˆæ¯åŒºåŸŸ
    messageArea.innerHTML = '';
    
    // åˆ›å»ºæ–°çš„è§†é¢‘é€šè¯è®°å½•
    currentVideoCallId = Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    currentVideoCallMessages = [];

    // æ˜¾ç¤ºé¡µé¢
    videoPage.style.display = 'block';

    // é‡ç½®çŠ¶æ€
    videoCallSeconds = 0;
    isCameraOn = true;
    document.getElementById('video-self-window').style.opacity = '1';
    document.getElementById('video-camera-btn').style.backgroundColor = '#FFFFFF';

    // å¼€å§‹è®¡æ—¶
    if (videoCallTimer) {
        clearInterval(videoCallTimer);
    }
    videoCallTimer = setInterval(() => {
        videoCallSeconds++;
        const minutes = Math.floor(videoCallSeconds / 60);
        const seconds = videoCallSeconds % 60;
        status.textContent = `è§†é¢‘é€šè¯ä¸­ ${minutes}:${seconds < 10 ? '0' + seconds : seconds}`;
    }, 1000);

    // è§’è‰²æ¥é€šåå…ˆè¯´ç¬¬ä¸€å¥è¯ï¼ˆè°ƒç”¨AIï¼‰
    await generateVideoCallFirstMessage(char);
}

// éšè—è§†é¢‘é€šè¯é¡µé¢
function hideVideoCallPage() {
    const videoPage = document.getElementById('video-call-page');
    videoPage.style.display = 'none';

    if (videoCallTimer) {
        clearInterval(videoCallTimer);
        videoCallTimer = null;
    }

    // æ¸…é™¤è§†é¢‘é€šè¯ç›¸å…³æ•°æ®
    videoCallCharId = null;
    currentVideoCallId = null;
    currentVideoCallMessages = [];
    
    // æ¸…é™¤å¤´åƒæ˜¾ç¤ºï¼Œé¿å…ä¸‹æ¬¡æ˜¾ç¤ºæ—¶å‡ºç°æ®‹ç•™
    const avatar = document.getElementById('video-call-avatar');
    if (avatar) {
        avatar.style.backgroundImage = '';
    }
}

// åˆ‡æ¢æ‘„åƒå¤´
function toggleCamera() {
    isCameraOn = !isCameraOn;
    const selfWindow = document.getElementById('video-self-window');
    const cameraBtn = document.getElementById('video-camera-btn');

    selfWindow.style.opacity = isCameraOn ? '1' : '0.4';
    cameraBtn.style.backgroundColor = isCameraOn ? '#FFFFFF' : '#F5F5F5';
}

// æŒ‚æ–­è§†é¢‘é€šè¯
async function hangupVideoCall() {
    if (confirm('ç¡®å®šè¦æŒ‚æ–­è§†é¢‘é€šè¯å—ï¼Ÿ')) {
        // ä¿å­˜è§†é¢‘é€šè¯è®°å½•
        if (currentVideoCallId && videoCallCharId && currentVideoCallMessages.length > 0) {
            await saveVideoCallRecord(videoCallCharId, currentVideoCallId, currentVideoCallMessages, videoCallSeconds);
        }
        
        hideVideoCallPage();
        
        // ç¡®ä¿è¿”å›èŠå¤©ç•Œé¢åï¼Œè§’è‰²ä¿¡æ¯æ­£ç¡®æ˜¾ç¤º
        if (videoCallCharId && currentChatCharId === videoCallCharId) {
            const char = await db.characters.get(videoCallCharId);
            if (char) {
                renderChatBody(char);
            }
        }
        
        alert('é€šè¯å·²ç»“æŸ');
    }
}

// ä¿å­˜è§†é¢‘é€šè¯è®°å½•
async function saveVideoCallRecord(charId, callId, messages, duration) {
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    // è·å–è§’è‰²ä¿¡æ¯
    const char = await db.characters.get(charId);
    if (!char) return;
    
    // è·å–ç°æœ‰çš„è§†é¢‘é€šè¯è®°å½•
    const key = `video_calls_${accountId}_${charId}`;
    const existingRecords = JSON.parse(localStorage.getItem(key) || '[]');
    
    // åˆ›å»ºæ–°è®°å½•
    const newRecord = {
        id: callId,
        charId: charId,
        charName: char.name,
        charAvatar: char.avatar,
        startTime: Date.now(),
        duration: duration, // ç§’æ•°
        messages: messages
    };
    
    // æ·»åŠ åˆ°è®°å½•åˆ—è¡¨ï¼ˆæœ€æ–°çš„åœ¨å‰é¢ï¼‰
    existingRecords.unshift(newRecord);
    
    // ä¿å­˜åˆ°localStorage
    localStorage.setItem(key, JSON.stringify(existingRecords));
    
    console.log('è§†é¢‘é€šè¯è®°å½•å·²ä¿å­˜:', newRecord);
}

// ç”Ÿæˆè§’è‰²æ¥é€šè§†é¢‘åçš„ç¬¬ä¸€å¥è¯
async function generateVideoCallFirstMessage(char) {
    const accountId = getCurrentAccountId();
    const messageArea = document.getElementById('video-message-area');

    try {
        // è·å–èŠå¤©å†å²ä½œä¸ºä¸Šä¸‹æ–‡
        let history = getChatHistory(char, accountId);
        
        // æ„å»ºç³»ç»Ÿæç¤º
        const systemPrompt = `ä½ æ˜¯${char.name}ã€‚
æ€§æ ¼ï¼š${char.personality || 'å‹å¥½ã€æ´»æ³¼'}

é‡è¦åœºæ™¯è®¾å®šï¼š
- ä½ åˆšåˆšæ¥é€šäº†ç”¨æˆ·çš„è§†é¢‘é€šè¯è¯·æ±‚
- ç°åœ¨æ˜¯è§†é¢‘é€šè¯æ¨¡å¼ï¼Œä½ å’Œç”¨æˆ·éš”ç€æ‰‹æœºå±å¹•è¿›è¡Œè§†é¢‘å¯¹è¯
- ä½ å¯ä»¥çœ‹åˆ°ç”¨æˆ·ï¼ˆéš”ç€å±å¹•ï¼‰ï¼Œç”¨æˆ·ä¹Ÿèƒ½çœ‹åˆ°ä½ 
- å›å¤æ ¼å¼ï¼šåŠ¨ä½œæå†™:"è¯´çš„è¯"ï¼Œä¾‹å¦‚ï¼šå¾®ç¬‘çš„æŒ¥æŒ¥æ‰‹:"å—¨ï½ç»ˆäºæ¥é€šå•¦!"
- åŠ¨ä½œå¿…é¡»æ˜¯é€šè¿‡æ‰‹æœºå±å¹•èƒ½çœ‹åˆ°çš„ï¼ˆæ¯”å¦‚ï¼šæŒ¥æ‰‹ã€å¾®ç¬‘ã€è°ƒæ•´é•œå¤´è§’åº¦ã€æ¯”å¿ƒã€åšé¬¼è„¸ç­‰ï¼‰
- å›å¤å­—æ•°è¦æ±‚ï¼š100-500å­—ä¹‹é—´

ç°åœ¨è¯·è¯´ç¬¬ä¸€å¥è¯ï¼Œæ¬¢è¿ç”¨æˆ·çš„è§†é¢‘é€šè¯ã€‚è¦è‡ªç„¶ã€ç¬¦åˆä½ çš„æ€§æ ¼ï¼ŒåŒ…å«åŠ¨ä½œæå†™ã€‚å­—æ•°æ§åˆ¶åœ¨100-500å­—ã€‚`;

        const messages = [
            { role: 'system', content: systemPrompt },
            ...history.slice(-6).map(h => ({ role: h.role === 'user' ? 'user' : 'assistant', content: h.content })),
            { role: 'user', content: '[è§†é¢‘é€šè¯å·²æ¥é€š]' }
        ];

        const reply = await callAI(messages);

        // æ·»åŠ AIæ¶ˆæ¯åˆ°ç•Œé¢
        const aiMsgDiv = document.createElement('div');
        aiMsgDiv.style.cssText = 'max-width: 80%; padding: 12px 18px; border-radius: 16px; font-size: 14px; line-height: 1.6; border: 1px solid #E5E5E5; word-wrap: break-word; align-self: flex-start; background-color: #FFFFFF; color: #333333; border-bottom-left-radius: 4px;';
        aiMsgDiv.textContent = reply;
        messageArea.appendChild(aiMsgDiv);
        messageArea.scrollTop = messageArea.scrollHeight;
        
        // ä¿å­˜åˆ°å½“å‰è§†é¢‘é€šè¯è®°å½•
        currentVideoCallMessages.push({
            role: 'assistant',
            content: reply,
            time: Date.now()
        });
    } catch (error) {
        console.error('ç”Ÿæˆç¬¬ä¸€å¥è¯å¤±è´¥:', error);
        // å¤±è´¥æ—¶ä½¿ç”¨é»˜è®¤æ¶ˆæ¯
        const defaultMsg = 'å¾®ç¬‘çš„æŒ¥æŒ¥æ‰‹:"å—¨ï½æ¥é€šå•¦ï¼"';
        const aiMsgDiv = document.createElement('div');
        aiMsgDiv.style.cssText = 'max-width: 80%; padding: 12px 18px; border-radius: 16px; font-size: 14px; line-height: 1.6; border: 1px solid #E5E5E5; word-wrap: break-word; align-self: flex-start; background-color: #FFFFFF; color: #333333; border-bottom-left-radius: 4px;';
        aiMsgDiv.textContent = defaultMsg;
        messageArea.appendChild(aiMsgDiv);
        messageArea.scrollTop = messageArea.scrollHeight;
        
        // ä¿å­˜åˆ°å½“å‰è§†é¢‘é€šè¯è®°å½•
        currentVideoCallMessages.push({
            role: 'assistant',
            content: defaultMsg,
            time: Date.now()
        });
    }
}

// åœ¨è§†é¢‘é€šè¯ä¸­å‘é€æ¶ˆæ¯
async function sendVideoMessage() {
    const input = document.getElementById('video-msg-input');
    const text = input.value.trim();
    
    if (!text || !videoCallCharId) return;

    const char = await db.characters.get(videoCallCharId);
    if (!char) return;

    const accountId = getCurrentAccountId();
    const messageArea = document.getElementById('video-message-area');

    // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯åˆ°ç•Œé¢
    const userMsgDiv = document.createElement('div');
    userMsgDiv.style.cssText = 'max-width: 80%; padding: 12px 18px; border-radius: 16px; font-size: 14px; line-height: 1.6; border: 1px solid #E5E5E5; word-wrap: break-word; align-self: flex-end; background-color: #FFFFFF; color: #333333; border-bottom-right-radius: 4px;';
    userMsgDiv.textContent = text;
    messageArea.appendChild(userMsgDiv);
    messageArea.scrollTop = messageArea.scrollHeight;

    // ä¿å­˜åˆ°å½“å‰è§†é¢‘é€šè¯è®°å½•
    currentVideoCallMessages.push({
        role: 'user',
        content: text,
        time: Date.now()
    });

    // æ¸…ç©ºè¾“å…¥æ¡†
    input.value = '';

    // è°ƒç”¨AIç”Ÿæˆå›å¤
    try {
        // æ”¶é›†å½“å‰è§†é¢‘é€šè¯ä¸­çš„æ¶ˆæ¯å†å²
        const videoMessages = [];
        const msgDivs = messageArea.querySelectorAll('div');
        msgDivs.forEach(div => {
            const isUser = div.style.alignSelf === 'flex-end';
            videoMessages.push({
                role: isUser ? 'user' : 'assistant',
                content: div.textContent
            });
        });

        // æ„å»ºç³»ç»Ÿæç¤º
        const systemPrompt = `ä½ æ˜¯${char.name}ã€‚
æ€§æ ¼ï¼š${char.personality || 'å‹å¥½ã€æ´»æ³¼'}

é‡è¦åœºæ™¯è®¾å®šï¼š
- ä½ æ­£åœ¨å’Œç”¨æˆ·è¿›è¡Œè§†é¢‘é€šè¯
- ç°åœ¨æ˜¯è§†é¢‘é€šè¯æ¨¡å¼ï¼Œä½ å’Œç”¨æˆ·éš”ç€æ‰‹æœºå±å¹•è¿›è¡Œè§†é¢‘å¯¹è¯
- ä½ å¯ä»¥çœ‹åˆ°ç”¨æˆ·ï¼ˆéš”ç€å±å¹•ï¼‰ï¼Œç”¨æˆ·ä¹Ÿèƒ½çœ‹åˆ°ä½ 
- å›å¤æ ¼å¼ï¼šåŠ¨ä½œæå†™:"è¯´çš„è¯"ï¼Œä¾‹å¦‚ï¼šæ­ªç€å¤´ç¬‘:"çœŸçš„å—ï¼Ÿå¤ªæœ‰è¶£äº†ï¼"
- åŠ¨ä½œå¿…é¡»æ˜¯é€šè¿‡æ‰‹æœºå±å¹•èƒ½çœ‹åˆ°çš„ï¼ˆæ¯”å¦‚ï¼šæŒ¥æ‰‹ã€å¾®ç¬‘ã€è°ƒæ•´é•œå¤´è§’åº¦ã€æ¯”å¿ƒã€åšé¬¼è„¸ç­‰ï¼‰
- ä½ çš„å›å¤è¦è‡ªç„¶ã€ç”ŸåŠ¨ï¼Œå¯ä»¥ç»“åˆè§†é¢‘åœºæ™¯ï¼ˆæ¯”å¦‚è¯„è®ºç”¨æˆ·çš„èƒŒæ™¯ã€è¡¨æƒ…ç­‰ï¼‰
- å›å¤å­—æ•°è¦æ±‚ï¼š100-500å­—ä¹‹é—´

è¯·æ ¹æ®ç”¨æˆ·çš„æ¶ˆæ¯è‡ªç„¶å›å¤ï¼Œä¿æŒè§†é¢‘é€šè¯çš„äº’åŠ¨æ„Ÿã€‚å­—æ•°æ§åˆ¶åœ¨100-500å­—ã€‚`;

        const messages = [
            { role: 'system', content: systemPrompt },
            ...videoMessages
        ];

        const reply = await callAI(messages);

        // æ·»åŠ AIæ¶ˆæ¯åˆ°ç•Œé¢
        const aiMsgDiv = document.createElement('div');
        aiMsgDiv.style.cssText = 'max-width: 80%; padding: 12px 18px; border-radius: 16px; font-size: 14px; line-height: 1.6; border: 1px solid #E5E5E5; word-wrap: break-word; align-self: flex-start; background-color: #FFFFFF; color: #333333; border-bottom-left-radius: 4px;';
        aiMsgDiv.textContent = reply;
        messageArea.appendChild(aiMsgDiv);
        messageArea.scrollTop = messageArea.scrollHeight;
        
        // ä¿å­˜åˆ°å½“å‰è§†é¢‘é€šè¯è®°å½•
        currentVideoCallMessages.push({
            role: 'assistant',
            content: reply,
            time: Date.now()
        });
    } catch (error) {
        console.error('AIå›å¤å¤±è´¥:', error);
        alert('æ¶ˆæ¯å‘é€å¤±è´¥: ' + error.message);
    }
}

// æ˜¾ç¤ºè§†é¢‘é€šè¯è®°å½•åˆ—è¡¨
async function showVideoCallRecords() {
    if (!currentChatCharId) return;
    
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    const key = `video_calls_${accountId}_${currentChatCharId}`;
    const records = JSON.parse(localStorage.getItem(key) || '[]');
    
    const recordsPage = document.getElementById('video-records-page');
    const recordsContent = document.getElementById('video-records-content');
    
    if (records.length === 0) {
        recordsContent.innerHTML = '<div style="text-align:center; padding:40px; color:#999;">æš‚æ— è§†é¢‘é€šè¯è®°å½•</div>';
    } else {
        recordsContent.innerHTML = records.map(record => {
            const date = new Date(record.startTime);
            const dateStr = `${date.getFullYear()}/${(date.getMonth()+1).toString().padStart(2,'0')}/${date.getDate().toString().padStart(2,'0')}`;
            const timeStr = `${date.getHours().toString().padStart(2,'0')}:${date.getMinutes().toString().padStart(2,'0')}`;
            const durationMin = Math.floor(record.duration / 60);
            const durationSec = record.duration % 60;
            const durationStr = `${durationMin}:${durationSec.toString().padStart(2,'0')}`;
            
            return `
                <div onclick="showVideoRecordDetail('${record.id}')" style="background:#f9f9f9; padding:16px; border-radius:12px; margin-bottom:12px; cursor:pointer; transition:background 0.2s;" onmouseover="this.style.background='#f0f0f0'" onmouseout="this.style.background='#f9f9f9'">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
                        <div style="font-size:16px; font-weight:500; color:#333;">${dateStr} ${timeStr}</div>
                        <div style="font-size:14px; color:#666;">æ—¶é•¿ ${durationStr}</div>
                    </div>
                    <div style="font-size:14px; color:#999;">${record.messages.length} æ¡æ¶ˆæ¯</div>
                </div>
            `;
        }).join('');
    }
    
    recordsPage.style.display = 'block';
}

// éšè—è§†é¢‘é€šè¯è®°å½•åˆ—è¡¨
function hideVideoRecordsPage() {
    document.getElementById('video-records-page').style.display = 'none';
}

// æ˜¾ç¤ºè§†é¢‘é€šè¯è¯¦æƒ…
async function showVideoRecordDetail(recordId) {
    if (!currentChatCharId) return;
    
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    const key = `video_calls_${accountId}_${currentChatCharId}`;
    const records = JSON.parse(localStorage.getItem(key) || '[]');
    const record = records.find(r => r.id === recordId);
    
    if (!record) {
        alert('æ‰¾ä¸åˆ°è¯¥é€šè¯è®°å½•');
        return;
    }
    
    const detailPage = document.getElementById('video-record-detail-page');
    const detailTitle = document.getElementById('video-record-detail-title');
    const detailContent = document.getElementById('video-record-detail-content');
    
    // è®¾ç½®æ ‡é¢˜
    const date = new Date(record.startTime);
    const dateStr = `${date.getFullYear()}/${(date.getMonth()+1).toString().padStart(2,'0')}/${date.getDate().toString().padStart(2,'0')} ${date.getHours().toString().padStart(2,'0')}:${date.getMinutes().toString().padStart(2,'0')}`;
    detailTitle.textContent = dateStr;
    
    // æ¸²æŸ“æ¶ˆæ¯åˆ—è¡¨
    detailContent.innerHTML = record.messages.map(msg => {
        const isUser = msg.role === 'user';
        return `
            <div style="max-width: 80%; padding: 12px 18px; border-radius: 16px; font-size: 14px; line-height: 1.6; border: 1px solid #E5E5E5; word-wrap: break-word; align-self: ${isUser ? 'flex-end' : 'flex-start'}; background-color: #FFFFFF; color: #333333; border-bottom-${isUser ? 'right' : 'left'}-radius: 4px;">
                ${msg.content}
            </div>
        `;
    }).join('');
    
    detailPage.style.display = 'block';
}

// éšè—è§†é¢‘é€šè¯è¯¦æƒ…
function hideVideoRecordDetailPage() {
    document.getElementById('video-record-detail-page').style.display = 'none';
}

// æ›´æ–°è§†é¢‘é€šè¯è®°å½•æ•°é‡æ˜¾ç¤º
function updateVideoCallRecordCount() {
    if (!currentChatCharId) return;
    
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    const key = `video_calls_${accountId}_${currentChatCharId}`;
    const records = JSON.parse(localStorage.getItem(key) || '[]');
    
    const countElement = document.getElementById('video-call-record-count');
    if (countElement) {
        countElement.textContent = records.length > 0 ? `${records.length}æ¡è®°å½•` : 'æš‚æ— è®°å½•';
    }
}

// ç›‘å¬è§†é¢‘æ¶ˆæ¯è¾“å…¥æ¡†çš„å›è½¦é”®
document.addEventListener('DOMContentLoaded', () => {
    const videoMsgInput = document.getElementById('video-msg-input');
    if (videoMsgInput) {
        videoMsgInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                sendVideoMessage();
            }
        });
    }
});

// ==================== çº¿ä¸‹æ¨¡å¼åŠŸèƒ½ ====================
let offlineModeCharId = null;
let offlineModeHistory = [];

// æ˜¾ç¤ºçº¿ä¸‹æ¨¡å¼
async function showOfflineMode() {
    if (!currentChatCharId) {
        alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªèŠå¤©å¯¹è±¡');
        return;
    }

    const char = await db.characters.get(currentChatCharId);
    if (!char) {
        alert('æ— æ³•è·å–è§’è‰²ä¿¡æ¯');
        return;
    }

    // æ£€æŸ¥å¥½å‹çŠ¶æ€
    const accountId = getCurrentAccountId();
    const friendStatus = getFriendStatus(char, accountId);
    if (friendStatus !== 'friend') {
        alert(`ä½ è¿˜ä¸æ˜¯ ${char.name} çš„å¥½å‹ï¼Œæ— æ³•ä½¿ç”¨çº¿ä¸‹æ¨¡å¼`);
        return;
    }

    offlineModeCharId = currentChatCharId;
    
    // åŠ è½½çº¿ä¸‹æ¨¡å¼å†å²è®°å½•
    const key = `offline_chat_${accountId}_${offlineModeCharId}`;
    offlineModeHistory = JSON.parse(localStorage.getItem(key) || '[]');

    // è®¾ç½®æ ‡é¢˜
    const title = document.getElementById('offline-chat-title');
    title.textContent = `çº¿ä¸‹æ¨¡å¼ - ${char.remark || char.name}`;

    // æ˜¾ç¤ºé¡µé¢
    const offlinePage = document.getElementById('offline-chat-window');
    offlinePage.style.display = 'flex';

    // æ¸²æŸ“æ¶ˆæ¯
    renderOfflineChatBody(char);
}

// éšè—çº¿ä¸‹æ¨¡å¼
function hideOfflineMode() {
    const offlinePage = document.getElementById('offline-chat-window');
    offlinePage.style.display = 'none';
    
    offlineModeCharId = null;
}

// æ¸²æŸ“çº¿ä¸‹æ¨¡å¼èŠå¤©å†…å®¹
async function renderOfflineChatBody(char) {
    const body = document.getElementById('offline-chat-body');
    body.innerHTML = '';

    if (offlineModeHistory.length === 0) {
        body.innerHTML = '<div style="display:flex; align-items:center; justify-content:center; height:100%; color:#999; font-size:14px; font-family:-apple-system, BlinkMacSystemFont, sans-serif;">å¼€å§‹çº¿ä¸‹èŠå¤©...</div>';
        return;
    }

    const accountId = getCurrentAccountId();
    const userAvatarUrl = await getUserAvatarUrl(char.linked_user_id);

    offlineModeHistory.forEach((msg, index) => {
        const prevMsgTime = index > 0 ? offlineModeHistory[index - 1].time : null;
        
        // æ˜¾ç¤ºæ—¶é—´æˆ³
        if (shouldShowTimestamp(msg.time, prevMsgTime)) {
            const timeStamp = document.createElement('div');
            timeStamp.className = 'message-timestamp';
            timeStamp.style.cssText = 'text-align:center; padding:8px 0; color:#999; font-size:12px; font-family:-apple-system, BlinkMacSystemFont, sans-serif;';
            timeStamp.textContent = formatMessageTime(msg.time, prevMsgTime);
            body.appendChild(timeStamp);
        }
        
        // åˆ›å»ºæ¶ˆæ¯å…ƒç´ ï¼ˆINSé£æ ¼ï¼‰
        const row = document.createElement('div');
        row.style.cssText = `display:flex; align-items:flex-end; gap:8px; margin-bottom:12px; padding:0 16px; ${msg.role === 'user' ? 'flex-direction:row-reverse;' : ''}`;
        
        // å¤´åƒ
        const avatar = document.createElement('div');
        avatar.style.cssText = 'width:36px; height:36px; border-radius:50%; flex-shrink:0; background-size:cover; background-position:center;';
        if (msg.role === 'user') {
            if (userAvatarUrl) {
                avatar.style.backgroundImage = `url(${userAvatarUrl})`;
            } else {
                avatar.style.backgroundColor = '#f0f0f0';
            }
        } else {
            if (char.avatar) {
                avatar.style.backgroundImage = `url(${char.avatar})`;
            } else {
                avatar.style.backgroundColor = '#f0f0f0';
            }
        }
        
        // å†…å®¹æ°”æ³¡ï¼ˆINSé£æ ¼ï¼‰
        const content = document.createElement('div');
        const isUser = msg.role === 'user';
        content.style.cssText = `max-width:70%; padding:10px 14px; border-radius:18px; font-size:14px; line-height:1.8; word-wrap:break-word; white-space:pre-wrap; font-family:-apple-system, BlinkMacSystemFont, sans-serif; color:#333; ${isUser ? 'background:#ffb3d1; color:#fff; border-bottom-right-radius:4px;' : 'background:#f0f0f0; color:#333; border-bottom-left-radius:4px;'}`;
        // ä½¿ç”¨innerHTMLä¿ç•™æ¢è¡Œï¼Œå¹¶è½¬ä¹‰HTMLé˜²æ­¢XSS
        content.textContent = msg.content;
        
        row.appendChild(avatar);
        row.appendChild(content);
        body.appendChild(row);
    });
    
    // æ»šåŠ¨åˆ°åº•éƒ¨
    setTimeout(() => {
        body.scrollTop = body.scrollHeight;
    }, 0);
}

// å¤„ç†çº¿ä¸‹æ¨¡å¼è¾“å…¥æ¡†æŒ‰é”®
function handleOfflineChatInputKey(e) {
    if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendOfflineMessage();
    }
}

// å¤„ç†çº¿ä¸‹æ¨¡å¼è¾“å…¥æ¡†å˜åŒ–
function handleOfflineChatInputChange(textarea) {
    const btn = document.getElementById('offline-btn-send');
    if (textarea.value.trim()) {
        btn.style.opacity = '1';
    } else {
        btn.style.opacity = '0.5';
    }
    
    // è‡ªåŠ¨è°ƒæ•´é«˜åº¦
    textarea.style.height = 'auto';
    textarea.style.height = Math.min(textarea.scrollHeight, 100) + 'px';
}

// å‘é€çº¿ä¸‹æ¨¡å¼æ¶ˆæ¯
async function sendOfflineMessage() {
    const input = document.getElementById('offline-chat-input-box');
    const text = input.value.trim();
    
    if (!text || !offlineModeCharId) return;

    const char = await db.characters.get(offlineModeCharId);
    if (!char) return;

    const accountId = getCurrentAccountId();

    // æ¸…ç©ºè¾“å…¥æ¡†
    input.value = '';
    handleOfflineChatInputChange(input);

    // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯
    const userMsg = { role: 'user', content: text, time: Date.now() };
    offlineModeHistory.push(userMsg);
    
    // ä¿å­˜åˆ°localStorage
    const key = `offline_chat_${accountId}_${offlineModeCharId}`;
    localStorage.setItem(key, JSON.stringify(offlineModeHistory));

    // åˆ·æ–°æ˜¾ç¤º
    renderOfflineChatBody(char);

    // è°ƒç”¨AIç”Ÿæˆå›å¤
    try {
        await generateOfflineReply(char, accountId, key);
    } catch (error) {
        console.error('AIå›å¤å¤±è´¥:', error);
        alert('æ¶ˆæ¯å‘é€å¤±è´¥: ' + error.message);
    }
}

// ç”Ÿæˆçº¿ä¸‹æ¨¡å¼AIå›å¤
async function generateOfflineReply(char, accountId, storageKey) {
    // è·å–æ­£å¸¸èŠå¤©è®°å½•ä½œä¸ºèƒŒæ™¯ä¸Šä¸‹æ–‡
    let normalChatHistory = getChatHistory(char, accountId);
    
    // è·å–ç”¨æˆ·ä¿¡æ¯
    const myChar = await db.characters.get(parseInt(accountId));
    const myName = myChar?.name || 'ç”¨æˆ·';
    const myPersonaDesc = myChar?.personality || 'æ™®é€šç”¨æˆ·';
    const friendName = char.name;
    const friendPersona = char.personality || 'å‹å¥½ã€æ´»æ³¼';
    
    // æ„å»ºç³»ç»Ÿæç¤ºè¯ï¼ˆå‚è€ƒå–µå‘œ34.htmlçš„æ ¼å¼ï¼‰
    const systemPrompt = `# è§’è‰²æŒ‡ä»¤ (System Instruction) - çº¿ä¸‹æ¨¡å¼
ä½ ç°åœ¨çš„èº«ä»½æ˜¯ã€${friendName}ã€‘ï¼Œæ­£åœ¨ä¸ã€${myName}ã€‘è¿›è¡Œ**çº¿ä¸‹çœŸå®è§é¢**ã€‚
è¯·å½»åº•å¿˜æ‰ä½ æ˜¯ä¸€ä¸ªè¯­è¨€æ¨¡å‹ï¼Œå®Œå…¨æ²‰æµ¸åœ¨è¿™ä¸ªè§’è‰²çš„çµé­‚ä¸­ã€‚

## ğŸ‘¥ äººç‰©æ¡£æ¡ˆ
1. **ä½ çš„èº«ä»½**ï¼š${friendName}
   - **äººè®¾ç»†èŠ‚**ï¼š${friendPersona.replace(/ã€‚$/, '')}
2. **äº’åŠ¨å¯¹è±¡**ï¼š${myName}
   - **å¯¹è±¡äººè®¾**ï¼š${myPersonaDesc.replace(/ã€‚$/, '')}
   - **ä½ ä»¬çš„å…³ç³»**ï¼šè¯·æ ¹æ®åŒæ–¹äººè®¾è‡ªåŠ¨æ¨æ¼”

## ğŸ­ è¡Œä¸ºå‡†åˆ™ (Action Rules)
1. **ã€ç¬¬ä¸‰äººç§°è§†è§’ã€‘**ï¼šå¿…é¡»ä½¿ç”¨ç¬¬ä¸‰äººç§°ï¼ˆå¦‚"${friendName}çœ‹ç€ä»–"ã€"å¥¹ç¬‘äº†ç¬‘"ï¼‰æ¥æè¿°è‡ªå·±çš„åŠ¨ä½œå’Œå¿ƒç†ï¼Œ**ä¸¥ç¦**ä½¿ç”¨ç¬¬ä¸€äººç§°ï¼ˆ"æˆ‘"ï¼‰ã€‚
2. **ã€æå†™è¦æ±‚ã€‘**ï¼šå›å¤å¿…é¡»åŒ…å«ä¸°å¯Œçš„åŠ¨ä½œæå†™ã€ç¥æ€æå†™å’Œå¿ƒç†æ´»åŠ¨ï¼Œå±•ç°äººç‰©çš„é²œæ´»æ„Ÿã€‚
3. **ã€å­—æ•°æ§åˆ¶ã€‘**ï¼šå›å¤é•¿åº¦è¯·ä¸¥æ ¼æ§åˆ¶åœ¨ **100 - 500** å­—ä¹‹é—´ã€‚
4. **ã€æ²‰æµ¸å¼äº’åŠ¨ã€‘**ï¼šä¸è¦åªè¯´è¯ï¼Œè¦ç»“åˆç¯å¢ƒå’Œè‚¢ä½“è¯­è¨€ã€‚
5. **ã€ç¦æ­¢ç½‘ç»œå…ƒç´ ã€‘**ï¼šä¸¥ç¦åœ¨å¯¹è¯ä¸­æåŠæˆ–å‘é€è¡¨æƒ…åŒ…ã€å›¾ç‰‡ã€è¯­éŸ³ç­‰ç½‘ç»œå…ƒç´ ã€‚è¿™æ˜¯çº¿ä¸‹é¢å¯¹é¢èŠå¤©ï¼Œä¸æ˜¯ç½‘ç»œèŠå¤©ã€‚
6. **ã€è‚¢ä½“äº’åŠ¨ã€‘**ï¼šå¯ä»¥æœ‰çœŸå®çš„è‚¢ä½“äº’åŠ¨å’Œæ¥è§¦ï¼ˆæ¯”å¦‚ï¼šæ¡æ‰‹ã€æ‹¥æŠ±ã€è½»æ‹è‚©è†€ã€é€’ä¸œè¥¿ã€çœ¼ç¥äº¤æµç­‰ï¼‰ã€‚
7. **ã€å›å¤æ ¼å¼è¦æ±‚ - éå¸¸é‡è¦ã€‘**ï¼š
   - **åŠ¨ä½œæå†™ç›´æ¥å†™ï¼Œä¸è¦ç”¨ä»»ä½•ç¬¦å·åŒ…è£¹**ï¼ˆä¸è¦ç”¨æ–¹æ‹¬å·[]ã€ä¸è¦ç”¨æ‹¬å·()ç­‰ï¼‰
   - **è¯´çš„è¯ç”¨å¼•å·""åŒ…è£¹**
   - **å¿…é¡»æ¢è¡Œï¼å¿…é¡»æ¢è¡Œï¼å¿…é¡»æ¢è¡Œï¼** åŠ¨ä½œæå†™å’Œå¯¹è¯è¦åˆ†å¼€ï¼Œæ¯æ®µä¹‹é—´å¿…é¡»æ¢è¡Œ
   - **åƒå†™ä½œæ–‡ä¸€æ ·ï¼ŒåŠ¨ä½œæå†™ä¸€æ®µï¼Œå¯¹è¯ä¸€æ®µï¼Œå†åŠ¨ä½œæå†™ä¸€æ®µ**
   - **æ ¼å¼è¦è‡ªç„¶æµç•…ï¼Œä¸è¦æ‰€æœ‰å†…å®¹å †åœ¨ä¸€è¡Œ**
   
   **æ­£ç¡®ç¤ºä¾‹æ ¼å¼ï¼ˆæ³¨æ„æ¢è¡Œï¼‰ï¼š**
   ${friendName}å¾®ç¬‘ç€èµ°åˆ°${myName}èº«è¾¹ï¼Œè½»è½»æ‹äº†æ‹ä»–çš„è‚©è†€ã€‚
   
   "ä½ ä»Šå¤©çœ‹èµ·æ¥å¿ƒæƒ…ä¸é”™å‘¢ã€‚"
   
   å¥¹çœ¨äº†çœ¨çœ¼ï¼Œçœ¼ç¥ä¸­å¸¦ç€ä¸€ä¸è°ƒçš®ã€‚
   
   "è¦ä¸è¦ä¸€èµ·å»é‚£è¾¹ååï¼Ÿ"
   
   **é”™è¯¯ç¤ºä¾‹ï¼ˆä¸è¦è¿™æ ·ï¼Œæ‰€æœ‰å†…å®¹å †åœ¨ä¸€èµ·ï¼‰ï¼š**
   ${friendName}å¾®ç¬‘ç€èµ°åˆ°${myName}èº«è¾¹ï¼Œè½»è½»æ‹äº†æ‹ä»–çš„è‚©è†€ã€‚"ä½ ä»Šå¤©çœ‹èµ·æ¥å¿ƒæƒ…ä¸é”™å‘¢ã€‚"å¥¹çœ¨äº†çœ¨çœ¼ï¼Œçœ¼ç¥ä¸­å¸¦ç€ä¸€ä¸è°ƒçš®ã€‚
   
   **é‡è¦ï¼šå›å¤ä¸­å¿…é¡»åŒ…å«æ¢è¡Œç¬¦ï¼ˆ\\nï¼‰ï¼Œè®©å†…å®¹åˆ†æ®µæ˜¾ç¤ºï¼Œä¸è¦æ‰€æœ‰æ–‡å­—å †åœ¨ä¸€èµ·ï¼**

${normalChatHistory.length > 0 ? `## ğŸ“± èŠå¤©èƒŒæ™¯
ä½ ä»¬ä¹‹å‰åœ¨å¾®ä¿¡ä¸Šæœ‰è¿‡è¿™äº›å¯¹è¯ï¼š
${normalChatHistory.slice(-10).map(h => `${h.role === 'user' ? myName : friendName}: ${h.content}`).join('\n')}

ç°åœ¨ä½ ä»¬çº¦å‡ºæ¥è§é¢äº†ï¼Œè¿›è¡Œçº¿ä¸‹èŠå¤©ã€‚è¯·åŸºäºä¹‹å‰çš„èŠå¤©è®°å½•å’Œå½“å‰çš„çº¿ä¸‹åœºæ™¯è‡ªç„¶å›å¤ã€‚` : ''}`;

    // æ„å»ºæ¶ˆæ¯æ•°ç»„ï¼ˆåŒ…å«çº¿ä¸‹æ¨¡å¼çš„å¯¹è¯å†å²ï¼‰
    const messages = [
        { role: 'system', content: systemPrompt },
        ...offlineModeHistory.slice(-15).map(h => ({ 
            role: h.role === 'user' ? 'user' : 'assistant', 
            content: h.content 
        }))
    ];

    const reply = await callAI(messages);

    // æ·»åŠ AIå›å¤
    const aiMsg = { role: 'assistant', content: reply, time: Date.now() };
    offlineModeHistory.push(aiMsg);
    
    // ä¿å­˜
    localStorage.setItem(storageKey, JSON.stringify(offlineModeHistory));
    
    // åˆ·æ–°æ˜¾ç¤º
    renderOfflineChatBody(char);
}

// é‡æ–°ç”Ÿæˆæœ€åä¸€æ¡AIå›å¤
async function rerollOfflineMessage() {
    if (!offlineModeCharId) return;
    
    // æ£€æŸ¥æ˜¯å¦æœ‰AIå›å¤å¯ä»¥é‡æ–°ç”Ÿæˆ
    if (offlineModeHistory.length < 2) {
        alert('è¿˜æ²¡æœ‰AIå›å¤å¯ä»¥é‡æ–°ç”Ÿæˆ');
        return;
    }
    
    const lastMsg = offlineModeHistory[offlineModeHistory.length - 1];
    if (lastMsg.role !== 'assistant') {
        alert('æœ€åä¸€æ¡æ¶ˆæ¯ä¸æ˜¯AIå›å¤');
        return;
    }
    
    // ç§»é™¤æœ€åä¸€æ¡AIå›å¤
    offlineModeHistory.pop();
    
    const char = await db.characters.get(offlineModeCharId);
    if (!char) return;
    
    const accountId = getCurrentAccountId();
    const key = `offline_chat_${accountId}_${offlineModeCharId}`;
    
    // ä¿å­˜ç§»é™¤åçš„å†å²
    localStorage.setItem(key, JSON.stringify(offlineModeHistory));
    
    // åˆ·æ–°æ˜¾ç¤º
    renderOfflineChatBody(char);
    
    // é‡æ–°ç”Ÿæˆå›å¤
    try {
        await generateOfflineReply(char, accountId, key);
    } catch (error) {
        console.error('é‡æ–°ç”Ÿæˆå¤±è´¥:', error);
        alert('é‡æ–°ç”Ÿæˆå¤±è´¥: ' + error.message);
    }
}

// ===== è§’è‰²è´¦å·ç™»å½•å’ŒæŸ¥å²—åŠŸèƒ½ =====

// æ ¼å¼åŒ–æ—¶é—´
function formatTime(timestamp) {
    if (!timestamp) return '';
    const date = new Date(timestamp);
    const now = new Date();
    const diff = now - date;
    
    if (diff < 60000) return 'åˆšåˆš';
    if (diff < 3600000) return Math.floor(diff / 60000) + 'åˆ†é’Ÿå‰';
    if (diff < 86400000) return Math.floor(diff / 3600000) + 'å°æ—¶å‰';
    if (diff < 604800000) return Math.floor(diff / 86400000) + 'å¤©å‰';
    
    const month = date.getMonth() + 1;
    const day = date.getDate();
    const hour = date.getHours();
    const minute = date.getMinutes();
    
    return `${month}æœˆ${day}æ—¥ ${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
}

// ===== èŠå¤©æ€»ç»“åŠŸèƒ½ =====

// å½“å‰æŸ¥çœ‹çš„æ€»ç»“ID
let currentViewingSummaryId = null;

// æ˜¾ç¤ºæ”¶è—é¡µé¢
async function showFavoritesPage() {
    const page = document.getElementById('favorites-page');
    if (!page) return;
    
    page.style.display = 'flex';
    await renderFavoritesList('all');
}

// éšè—æ”¶è—é¡µé¢
function hideFavoritesPage() {
    const page = document.getElementById('favorites-page');
    if (page) page.style.display = 'none';
}

// åˆ‡æ¢æ”¶è—æ ‡ç­¾
async function switchFavTab(type) {
    // æ›´æ–°æ ‡ç­¾æ ·å¼
    document.querySelectorAll('.fav-tab').forEach(tab => {
        if (tab.dataset.type === type) {
            tab.style.background = 'var(--ins-pink)';
            tab.style.color = '#fff';
            tab.style.border = 'none';
            tab.classList.add('active');
        } else {
            tab.style.background = '#fff';
            tab.style.color = '#666';
            tab.style.border = '1px solid #e0e0e0';
            tab.classList.remove('active');
        }
    });
    
    await renderFavoritesList(type);
}

// æ¸²æŸ“æ”¶è—åˆ—è¡¨
async function renderFavoritesList(type) {
    const listContainer = document.getElementById('favorites-list');
    const emptyState = document.getElementById('favorites-empty');
    
    if (!listContainer) return;
    
    const accountId = getCurrentAccountId();
    if (!accountId) {
        listContainer.innerHTML = '';
        emptyState.style.display = 'block';
        return;
    }
    
    // è·å–æ‰€æœ‰æ€»ç»“
    let summaries = await db.chat_summaries.where('accountId').equals(accountId).toArray();
    
    // æŒ‰æ—¶é—´å€’åº
    summaries.sort((a, b) => b.time - a.time);
    
    if (summaries.length === 0) {
        listContainer.innerHTML = '';
        emptyState.style.display = 'block';
        return;
    }
    
    emptyState.style.display = 'none';
    
    // ç”Ÿæˆåˆ—è¡¨HTML
    let html = '';
    for (const summary of summaries) {
        let avatarUrl = '';
        let name = 'æœªçŸ¥';
        let chatTypeLabel = '';
        
        if (summary.chatType === 'private') {
            const char = await db.characters.get(parseInt(summary.chatId));
            if (char) {
                avatarUrl = char.avatar || '';
                name = char.remark || char.name || 'æœªçŸ¥';
            }
            chatTypeLabel = 'ç§èŠ';
        } else if (summary.chatType === 'group') {
            const group = await db.group_chats.get(parseInt(summary.chatId));
            if (group) {
                avatarUrl = group.avatar || '';
                name = group.name || 'ç¾¤èŠ';
            }
            chatTypeLabel = 'ç¾¤èŠ';
        }
        
        const timeStr = formatSummaryTime(summary.time);
        const preview = summary.content ? summary.content.substring(0, 80) + (summary.content.length > 80 ? '...' : '') : 'æš‚æ— å†…å®¹';
        
        html += `
            <div onclick="showSummaryDetail(${summary.id})" style="background:#fff; border-radius:12px; padding:16px; cursor:pointer; transition:all 0.2s; box-shadow:0 1px 3px rgba(0,0,0,0.05);">
                <div style="display:flex; align-items:center; margin-bottom:12px;">
                    <div style="width:44px; height:44px; border-radius:${summary.chatType === 'group' ? '8px' : '50%'}; background-size:cover; background-position:center; background-color:#e0e0e0; margin-right:12px; ${avatarUrl ? `background-image:url(${avatarUrl})` : ''}"></div>
                    <div style="flex:1;">
                        <div style="display:flex; align-items:center; gap:8px;">
                            <span style="font-size:16px; font-weight:600; color:#333;">${name}</span>
                            <span style="font-size:11px; padding:2px 6px; background:${summary.chatType === 'group' ? '#e8f5e9' : '#fff3e0'}; color:${summary.chatType === 'group' ? '#4caf50' : '#ff9800'}; border-radius:4px;">${chatTypeLabel}</span>
                        </div>
                        <div style="font-size:12px; color:#999; margin-top:2px;">${timeStr}</div>
                    </div>
                    <div style="font-size:12px; color:#999;">${summary.messageCount || 0}æ¡æ¶ˆæ¯</div>
                </div>
                <div style="font-size:14px; color:#666; line-height:1.5; display:-webkit-box; -webkit-line-clamp:2; -webkit-box-orient:vertical; overflow:hidden;">${preview}</div>
            </div>
        `;
    }
    
    listContainer.innerHTML = html;
}

// æ ¼å¼åŒ–æ€»ç»“æ—¶é—´
function formatSummaryTime(timestamp) {
    if (!timestamp) return '';
    const date = new Date(timestamp);
    const year = date.getFullYear();
    const month = (date.getMonth() + 1).toString().padStart(2, '0');
    const day = date.getDate().toString().padStart(2, '0');
    const hour = date.getHours().toString().padStart(2, '0');
    const minute = date.getMinutes().toString().padStart(2, '0');
    return `${year}-${month}-${day} ${hour}:${minute}`;
}

// æ˜¾ç¤ºæ€»ç»“è¯¦æƒ…
async function showSummaryDetail(summaryId) {
    const page = document.getElementById('summary-detail-page');
    if (!page) return;
    
    currentViewingSummaryId = summaryId;
    
    const summary = await db.chat_summaries.get(summaryId);
    if (!summary) {
        alert('æ€»ç»“ä¸å­˜åœ¨');
        return;
    }
    
    // è·å–èŠå¤©å¯¹è±¡ä¿¡æ¯
    let avatarUrl = '';
    let name = 'æœªçŸ¥';
    
    if (summary.chatType === 'private') {
        const char = await db.characters.get(parseInt(summary.chatId));
        if (char) {
            avatarUrl = char.avatar || '';
            name = char.remark || char.name || 'æœªçŸ¥';
        }
    } else if (summary.chatType === 'group') {
        const group = await db.group_chats.get(parseInt(summary.chatId));
        if (group) {
            avatarUrl = group.avatar || '';
            name = group.name || 'ç¾¤èŠ';
        }
    }
    
    // å¡«å……é¡µé¢å†…å®¹
    document.getElementById('summary-detail-title').textContent = name + ' - èŠå¤©æ€»ç»“';
    
    const avatarEl = document.getElementById('summary-detail-avatar');
    if (avatarUrl) {
        avatarEl.style.backgroundImage = `url(${avatarUrl})`;
    } else {
        avatarEl.style.backgroundImage = '';
    }
    avatarEl.style.borderRadius = summary.chatType === 'group' ? '8px' : '50%';
    
    document.getElementById('summary-detail-name').textContent = name;
    document.getElementById('summary-detail-time').textContent = formatSummaryTime(summary.time);
    document.getElementById('summary-msg-count').textContent = summary.messageCount || 0;
    document.getElementById('summary-time-range').textContent = summary.timeRange || '-';
    document.getElementById('summary-detail-content').textContent = summary.content || 'æš‚æ— å†…å®¹';
    
    // å…³é”®è¯æ ‡ç­¾
    const keywordsSection = document.getElementById('summary-keywords-section');
    const keywordsContainer = document.getElementById('summary-detail-keywords');
    if (summary.keywords && summary.keywords.length > 0) {
        keywordsSection.style.display = 'block';
        keywordsContainer.innerHTML = summary.keywords.map(kw => 
            `<span style="padding:6px 12px; background:#f0f0f5; border-radius:16px; font-size:13px; color:#666;">${kw}</span>`
        ).join('');
    } else {
        keywordsSection.style.display = 'none';
    }
    
    page.style.display = 'flex';
}

// éšè—æ€»ç»“è¯¦æƒ…é¡µ
function hideSummaryDetailPage() {
    const page = document.getElementById('summary-detail-page');
    if (page) page.style.display = 'none';
    currentViewingSummaryId = null;
}

// åˆ é™¤æ€»ç»“
async function deleteSummary() {
    if (!currentViewingSummaryId) return;
    
    if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡æ€»ç»“å—ï¼Ÿ')) return;
    
    try {
        await db.chat_summaries.delete(currentViewingSummaryId);
        hideSummaryDetailPage();
        
        // åˆ·æ–°æ”¶è—åˆ—è¡¨
        const favPage = document.getElementById('favorites-page');
        if (favPage && favPage.style.display !== 'none') {
            await renderFavoritesList('all');
        }
        
        // åˆ·æ–°èŠå¤©æ€»ç»“åˆ—è¡¨
        const chatSummariesPage = document.getElementById('chat-summaries-page');
        if (chatSummariesPage && chatSummariesPage.style.display !== 'none') {
            // é‡æ–°åŠ è½½å½“å‰èŠå¤©çš„æ€»ç»“
        }
        
        showToast('åˆ é™¤æˆåŠŸ');
    } catch (e) {
        console.error('åˆ é™¤æ€»ç»“å¤±è´¥:', e);
        alert('åˆ é™¤å¤±è´¥');
    }
}

// æ˜¾ç¤ºæŸä¸ªèŠå¤©çš„æ€»ç»“åˆ—è¡¨
async function showChatSummaries(chatType) {
    const page = document.getElementById('chat-summaries-page');
    if (!page) return;
    
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    let chatId, name;
    
    if (chatType === 'private') {
        if (!currentChatCharId) return;
        chatId = currentChatCharId;
        const char = await db.characters.get(parseInt(chatId));
        name = char ? (char.remark || char.name) : 'ç§èŠ';
    } else if (chatType === 'group') {
        if (!window.currentGroupChatId) return;
        chatId = window.currentGroupChatId;
        const group = await db.group_chats.get(parseInt(chatId));
        name = group ? group.name : 'ç¾¤èŠ';
    }
    
    document.getElementById('chat-summaries-title').textContent = name + ' - æ€»ç»“è®°å½•';
    
    // è·å–è¯¥èŠå¤©çš„æ‰€æœ‰æ€»ç»“
    let summaries = await db.chat_summaries
        .where(['accountId', 'chatType', 'chatId'])
        .equals([accountId, chatType, String(chatId)])
        .toArray();
    
    // å¦‚æœå¤åˆç´¢å¼•ä¸å·¥ä½œï¼Œä½¿ç”¨è¿‡æ»¤
    if (summaries.length === 0) {
        summaries = await db.chat_summaries.where('accountId').equals(accountId).toArray();
        summaries = summaries.filter(s => s.chatType === chatType && String(s.chatId) === String(chatId));
    }
    
    // æŒ‰æ—¶é—´å€’åº
    summaries.sort((a, b) => b.time - a.time);
    
    const listContainer = document.getElementById('chat-summaries-list');
    const emptyState = document.getElementById('chat-summaries-empty');
    
    if (summaries.length === 0) {
        listContainer.innerHTML = '';
        emptyState.style.display = 'block';
    } else {
        emptyState.style.display = 'none';
        listContainer.innerHTML = summaries.map(summary => `
            <div onclick="showSummaryDetail(${summary.id})" style="background:#fff; border-radius:12px; padding:16px; cursor:pointer; transition:all 0.2s; box-shadow:0 1px 3px rgba(0,0,0,0.05);">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                    <span style="font-size:14px; font-weight:600; color:#333;">ç¬¬ ${summaries.indexOf(summary) + 1} æ¬¡æ€»ç»“</span>
                    <span style="font-size:12px; color:#999;">${formatSummaryTime(summary.time)}</span>
                </div>
                <div style="font-size:13px; color:#666; line-height:1.5; display:-webkit-box; -webkit-line-clamp:3; -webkit-box-orient:vertical; overflow:hidden;">
                    ${summary.content ? summary.content.substring(0, 120) + (summary.content.length > 120 ? '...' : '') : 'æš‚æ— å†…å®¹'}
                </div>
                <div style="margin-top:10px; font-size:12px; color:#999;">
                    ${summary.messageCount || 0}æ¡æ¶ˆæ¯ Â· ${summary.timeRange || '-'}
                </div>
            </div>
        `).join('');
    }
    
    page.style.display = 'flex';
}

// éšè—èŠå¤©æ€»ç»“åˆ—è¡¨é¡µ
function hideChatSummariesPage() {
    const page = document.getElementById('chat-summaries-page');
    if (page) page.style.display = 'none';
}

// æ‰‹åŠ¨è§¦å‘ç”Ÿæˆæ€»ç»“
async function triggerManualSummary(chatType) {
    const accountId = getCurrentAccountId();
    if (!accountId) {
        alert('è¯·å…ˆç™»å½•è´¦å·');
        return;
    }
    
    let chatId, chatHistory, name;
    
    if (chatType === 'private') {
        if (!currentChatCharId) {
            alert('è¯·å…ˆæ‰“å¼€ä¸€ä¸ªèŠå¤©');
            return;
        }
        chatId = currentChatCharId;
        const char = await db.characters.get(parseInt(chatId));
        name = char ? (char.remark || char.name) : 'ç§èŠ';
        chatHistory = getChatHistory(char, accountId);
    } else if (chatType === 'group') {
        if (!window.currentGroupChatId) {
            alert('è¯·å…ˆæ‰“å¼€ä¸€ä¸ªç¾¤èŠ');
            return;
        }
        chatId = window.currentGroupChatId;
        const group = await db.group_chats.get(parseInt(chatId));
        name = group ? group.name : 'ç¾¤èŠ';
        chatHistory = group ? (group.messages || []) : [];
    }
    
    if (!chatHistory || chatHistory.length < 5) {
        alert('èŠå¤©è®°å½•å¤ªå°‘ï¼ˆè‡³å°‘éœ€è¦5æ¡ï¼‰ï¼Œæ— æ³•ç”Ÿæˆæ€»ç»“');
        return;
    }
    
    if (!confirm(`ç¡®å®šè¦ä¸ºä¸ã€Œ${name}ã€çš„èŠå¤©ç”Ÿæˆæ€»ç»“å—ï¼Ÿ\nå°†æ€»ç»“æœ€è¿‘çš„èŠå¤©å†…å®¹ã€‚`)) {
        return;
    }
    
    showToast('æ­£åœ¨ç”Ÿæˆæ€»ç»“...');
    
    try {
        await generateChatSummary(chatType, chatId, accountId, chatHistory);
        showToast('æ€»ç»“ç”ŸæˆæˆåŠŸï¼');
        
        // æ›´æ–°æ€»ç»“è®¡æ•°æ˜¾ç¤º
        await updateSummaryCount(chatType, chatId, accountId);
    } catch (e) {
        console.error('ç”Ÿæˆæ€»ç»“å¤±è´¥:', e);
        alert('ç”Ÿæˆæ€»ç»“å¤±è´¥: ' + e.message);
    }
}

// ç”ŸæˆèŠå¤©æ€»ç»“
async function generateChatSummary(chatType, chatId, accountId, chatHistory) {
    // è·å–æœ€è¿‘çš„æ¶ˆæ¯ï¼ˆæœ€å¤š100æ¡ï¼‰
    const recentMessages = chatHistory.slice(-100);
    
    if (recentMessages.length < 5) {
        throw new Error('èŠå¤©è®°å½•å¤ªå°‘');
    }
    
    // è®¡ç®—æ—¶é—´èŒƒå›´
    const firstMsgTime = recentMessages[0].time || recentMessages[0].timestamp || Date.now();
    const lastMsgTime = recentMessages[recentMessages.length - 1].time || recentMessages[recentMessages.length - 1].timestamp || Date.now();
    const timeRange = formatTimeRange(firstMsgTime, lastMsgTime);
    
    // æ„å»ºèŠå¤©å†…å®¹æ–‡æœ¬
    let chatContent = recentMessages.map(msg => {
        const role = msg.role === 'user' ? 'æˆ‘' : (msg.name || 'AI');
        const content = msg.content || msg.message || '';
        return `${role}: ${content}`;
    }).join('\n');
    
    // è°ƒç”¨APIç”Ÿæˆæ€»ç»“
    const systemPrompt = `ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„èŠå¤©è®°å½•æ€»ç»“åŠ©æ‰‹ã€‚è¯·æ ¹æ®ä»¥ä¸‹èŠå¤©è®°å½•ï¼Œç”Ÿæˆä¸€ä»½ç®€æ´ä½†å®Œæ•´çš„æ€»ç»“ã€‚

æ€»ç»“è¦æ±‚ï¼š
1. ç”¨ç¬¬ä¸‰äººç§°æè¿°å¯¹è¯åŒæ–¹çš„äº¤æµå†…å®¹
2. æç‚¼å‡ºä¸»è¦è¯é¢˜å’Œå…³é”®ä¿¡æ¯
3. å¦‚æœæœ‰é‡è¦çš„æƒ…æ„Ÿå˜åŒ–æˆ–äº‹ä»¶ï¼Œè¦ç‰¹åˆ«æŒ‡å‡º
4. æ€»ç»“é•¿åº¦æ§åˆ¶åœ¨200-400å­—ä¹‹é—´
5. ä½¿ç”¨è‡ªç„¶æµç•…çš„ä¸­æ–‡è¡¨è¾¾
6. å¦‚æœèƒ½æå–3-5ä¸ªå…³é”®è¯ï¼Œè¯·åœ¨æœ€åç”¨ã€å…³é”®è¯ã€‘æ ‡æ³¨

èŠå¤©è®°å½•å¦‚ä¸‹ï¼š
${chatContent}`;

    const messages = [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: 'è¯·ä¸ºè¿™æ®µèŠå¤©è®°å½•ç”Ÿæˆæ€»ç»“ã€‚' }
    ];
    
    const summary = await callAI(messages);
    
    // æå–å…³é”®è¯
    let keywords = [];
    const keywordMatch = summary.match(/ã€å…³é”®è¯ã€‘[:ï¼š]?\s*(.+?)$/);
    let content = summary;
    if (keywordMatch) {
        keywords = keywordMatch[1].split(/[,ï¼Œã€\s]+/).filter(k => k.trim());
        content = summary.replace(/ã€å…³é”®è¯ã€‘[:ï¼š]?\s*.+?$/, '').trim();
    }
    
    // ä¿å­˜åˆ°æ•°æ®åº“
    const summaryData = {
        accountId: accountId,
        chatType: chatType,
        chatId: String(chatId),
        time: Date.now(),
        content: content,
        messageCount: recentMessages.length,
        timeRange: timeRange,
        keywords: keywords,
        startTime: firstMsgTime,
        endTime: lastMsgTime
    };
    
    await db.chat_summaries.add(summaryData);
    
    return summaryData;
}

// æ ¼å¼åŒ–æ—¶é—´èŒƒå›´
function formatTimeRange(startTime, endTime) {
    const start = new Date(startTime);
    const end = new Date(endTime);
    
    const formatDate = (d) => {
        const month = d.getMonth() + 1;
        const day = d.getDate();
        return `${month}æœˆ${day}æ—¥`;
    };
    
    const startStr = formatDate(start);
    const endStr = formatDate(end);
    
    if (startStr === endStr) {
        return startStr;
    }
    return `${startStr} - ${endStr}`;
}

// æ›´æ–°æ€»ç»“è®¡æ•°æ˜¾ç¤º
async function updateSummaryCount(chatType, chatId, accountId) {
    let summaries = await db.chat_summaries.where('accountId').equals(accountId).toArray();
    summaries = summaries.filter(s => s.chatType === chatType && String(s.chatId) === String(chatId));
    
    const count = summaries.length;
    
    if (chatType === 'private') {
        const countEl = document.getElementById('detail-summary-count');
        if (countEl) countEl.textContent = `${count}æ¡æ€»ç»“`;
    } else if (chatType === 'group') {
        const countEl = document.getElementById('group-detail-summary-count');
        if (countEl) countEl.textContent = `${count}æ¡æ€»ç»“`;
    }
}

// æ£€æŸ¥æ˜¯å¦éœ€è¦è‡ªåŠ¨æ€»ç»“ï¼ˆåœ¨å‘é€æ¶ˆæ¯åè°ƒç”¨ï¼‰
async function checkAutoSummary(chatType, chatId, accountId) {
    let autoSummaryEnabled = false;
    let summaryInterval = 50;
    let chatHistory = [];
    
    if (chatType === 'private') {
        const char = await db.characters.get(parseInt(chatId));
        if (!char) return;
        autoSummaryEnabled = char.auto_summary_enabled;
        summaryInterval = char.summary_interval || 50;
        chatHistory = getChatHistory(char, accountId);
    } else if (chatType === 'group') {
        const group = await db.group_chats.get(parseInt(chatId));
        if (!group) return;
        autoSummaryEnabled = group.auto_summary_enabled;
        summaryInterval = group.summary_interval || 50;
        chatHistory = group.messages || [];
    }
    
    if (!autoSummaryEnabled) return;
    
    // è·å–ä¸Šæ¬¡æ€»ç»“åçš„æ¶ˆæ¯æ•°
    let summaries = await db.chat_summaries.where('accountId').equals(accountId).toArray();
    summaries = summaries.filter(s => s.chatType === chatType && String(s.chatId) === String(chatId));
    summaries.sort((a, b) => b.time - a.time);
    
    const lastSummary = summaries[0];
    const lastSummaryTime = lastSummary ? lastSummary.endTime : 0;
    
    // ç»Ÿè®¡ä¸Šæ¬¡æ€»ç»“åçš„æ¶ˆæ¯æ•°
    const newMessages = chatHistory.filter(msg => {
        const msgTime = msg.time || msg.timestamp || 0;
        return msgTime > lastSummaryTime;
    });
    
    // å¦‚æœè¾¾åˆ°é˜ˆå€¼ï¼Œè‡ªåŠ¨ç”Ÿæˆæ€»ç»“
    if (newMessages.length >= summaryInterval) {
        console.log(`[AutoSummary] è¾¾åˆ°é˜ˆå€¼ ${summaryInterval}ï¼Œè‡ªåŠ¨ç”Ÿæˆæ€»ç»“`);
        try {
            await generateChatSummary(chatType, chatId, accountId, newMessages);
            showToast('å·²è‡ªåŠ¨ç”ŸæˆèŠå¤©æ€»ç»“');
        } catch (e) {
            console.error('[AutoSummary] è‡ªåŠ¨æ€»ç»“å¤±è´¥:', e);
        }
    }
}

// åœ¨åŠ è½½èŠå¤©è¯¦æƒ…æ—¶æ›´æ–°æ€»ç»“è®¡æ•°
async function loadSummarySettings(chatType, chatId) {
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    // æ›´æ–°æ€»ç»“è®¡æ•°
    await updateSummaryCount(chatType, chatId, accountId);
    
    // åŠ è½½è‡ªåŠ¨æ€»ç»“è®¾ç½®
    if (chatType === 'private') {
        const char = await db.characters.get(parseInt(chatId));
        if (char) {
            document.getElementById('detail-auto-summary-switch').checked = !!char.auto_summary_enabled;
            document.getElementById('detail-summary-interval').value = char.summary_interval || '';
        }
    } else if (chatType === 'group') {
        const group = await db.group_chats.get(parseInt(chatId));
        if (group) {
            document.getElementById('group-detail-auto-summary-switch').checked = !!group.auto_summary_enabled;
            document.getElementById('group-detail-summary-interval').value = group.summary_interval || '';
        }
    }
}

// ===== è”æœºåŠŸèƒ½ =====

// å…¨å±€å˜é‡
let onlineSocket = null;
let onlineConnected = false;
let onlineUserData = null;
let onlineToken = null;
let onlineCharacters = []; // å·²ä¸Šçº¿çš„è§’è‰²åˆ—è¡¨
let onlineGroups = []; // è”æœºç¾¤èŠåˆ—è¡¨
let currentOnlineGroupId = null; // å½“å‰æ‰“å¼€çš„è”æœºç¾¤èŠID
let currentOnlineGroupMessages = []; // å½“å‰ç¾¤èŠæ¶ˆæ¯
let currentOnlineGroupMembers = []; // å½“å‰ç¾¤èŠæˆå‘˜
let myOnlineGroupCharacter = null; // æˆ‘åœ¨å½“å‰ç¾¤èŠä¸­çš„è§’è‰²

// åˆ‡æ¢è”æœºè®¾ç½®é¢æ¿
function toggleOnlineSettings() {
    const body = document.getElementById('online-setting-body');
    const arrow = document.getElementById('online-setting-arrow');
    if (body.style.display === 'none') {
        body.style.display = 'block';
        arrow.textContent = 'â–²';
        loadOnlineSettings();
    } else {
        body.style.display = 'none';
        arrow.textContent = 'â–¼';
    }
}

// âœ… è‡ªåŠ¨åˆå§‹åŒ–è”æœºç³»ç»Ÿï¼ˆé¡µé¢åŠ è½½æ—¶è°ƒç”¨ï¼‰
async function initOnlineSystem() {
    const serverUrl = localStorage.getItem('online_server_url') || '';
    
    // åŠ è½½å·²ä¿å­˜çš„token
    onlineToken = localStorage.getItem('online_token');
    const savedUserData = localStorage.getItem('online_user_data');
    if (savedUserData) {
        try {
            onlineUserData = JSON.parse(savedUserData);
        } catch (e) {
            onlineUserData = null;
        }
    }
    
    // å¦‚æœæœ‰æœåŠ¡å™¨åœ°å€ï¼Œè‡ªåŠ¨è¿æ¥
    if (serverUrl) {
        console.log('[Online] è‡ªåŠ¨è¿æ¥æœåŠ¡å™¨:', serverUrl);
        try {
            await connectToOnlineServer();
            console.log('[Online] æœåŠ¡å™¨è¿æ¥æˆåŠŸ');
        } catch (e) {
            console.warn('[Online] è‡ªåŠ¨è¿æ¥å¤±è´¥:', e.message);
        }
    }
}

// åŠ è½½è”æœºè®¾ç½®ï¼ˆæ‰“å¼€è®¾ç½®é¢æ¿æ—¶è°ƒç”¨ï¼‰
function loadOnlineSettings() {
    const serverUrl = localStorage.getItem('online_server_url') || '';
    const serverUrlInput = document.getElementById('online-server-url');
    if (serverUrlInput) {
        serverUrlInput.value = serverUrl;
    }
    
    updateOnlineStatus();
}

// ä¿å­˜è”æœºè®¾ç½®
function saveOnlineSettings() {
    const serverUrl = document.getElementById('online-server-url').value.trim();
    localStorage.setItem('online_server_url', serverUrl);
}

// æ›´æ–°åœ¨çº¿çŠ¶æ€æ˜¾ç¤º
function updateOnlineStatus() {
    const statusDot = document.getElementById('online-status-dot');
    const statusText = document.getElementById('online-status-text');
    const userInfo = document.getElementById('online-user-info');
    const usernameDisplay = document.getElementById('online-username-display');
    const authButtons = document.getElementById('online-auth-buttons');
    const loggedInActions = document.getElementById('online-logged-in-actions');
    
    if (onlineConnected && onlineUserData) {
        statusDot.style.background = '#4caf50';
        statusText.textContent = 'å·²è¿æ¥';
        statusText.style.color = '#4caf50';
        userInfo.style.display = 'block';
        usernameDisplay.textContent = onlineUserData.username;
        authButtons.style.display = 'none';
        loggedInActions.style.display = 'block';
    } else if (onlineConnected) {
        statusDot.style.background = '#ff9800';
        statusText.textContent = 'å·²è¿æ¥ï¼ˆæœªç™»å½•ï¼‰';
        statusText.style.color = '#ff9800';
        userInfo.style.display = 'none';
        authButtons.style.display = 'flex';
        loggedInActions.style.display = 'none';
    } else {
        statusDot.style.background = '#ccc';
        statusText.textContent = 'æœªè¿æ¥';
        statusText.style.color = '#666';
        userInfo.style.display = 'none';
        authButtons.style.display = 'flex';
        loggedInActions.style.display = 'none';
    }
}

// æµ‹è¯•è¿æ¥
async function testOnlineConnection() {
    const serverUrl = document.getElementById('online-server-url').value.trim();
    const statusEl = document.getElementById('online-connection-status');
    const btnText = document.getElementById('test-online-btn-text');
    
    if (!serverUrl) {
        statusEl.innerHTML = '<span style="color:#ff3b30;">è¯·å¡«å†™æœåŠ¡å™¨åœ°å€</span>';
        return;
    }
    
    btnText.textContent = 'è¿æ¥ä¸­...';
    statusEl.innerHTML = '<span style="color:#999;">æ­£åœ¨è¿æ¥...</span>';
    
    try {
        await connectToOnlineServer();
        statusEl.innerHTML = '<span style="color:#4caf50;">âœ“ è¿æ¥æˆåŠŸ</span>';
    } catch (e) {
        statusEl.innerHTML = `<span style="color:#ff3b30;">âœ— è¿æ¥å¤±è´¥: ${e.message}</span>`;
    }
    
    btnText.textContent = 'æµ‹è¯•è¿æ¥';
}

// è¿æ¥åˆ°æœåŠ¡å™¨
function connectToOnlineServer() {
    return new Promise((resolve, reject) => {
        const serverUrl = document.getElementById('online-server-url').value.trim() || localStorage.getItem('online_server_url');
        
        if (!serverUrl) {
            reject(new Error('æœªè®¾ç½®æœåŠ¡å™¨åœ°å€'));
            return;
        }
        
        // å…³é—­æ—§è¿æ¥
        if (onlineSocket) {
            onlineSocket.close();
        }
        
        try {
            onlineSocket = new WebSocket(serverUrl);
            
            onlineSocket.onopen = () => {
                console.log('[Online] WebSocket connected');
                onlineConnected = true;
                updateOnlineStatus();
                
                // å¦‚æœæœ‰tokenï¼Œå‘é€è®¤è¯
                if (onlineToken) {
                    onlineSocket.send(JSON.stringify({
                        type: 'auth',
                        token: onlineToken
                    }));
                }
                
                // å¯åŠ¨å¿ƒè·³å®šæ—¶å™¨ï¼Œæ¯25ç§’å‘é€ä¸€æ¬¡å¿ƒè·³
                if (window.onlineHeartbeatTimer) {
                    clearInterval(window.onlineHeartbeatTimer);
                }
                window.onlineHeartbeatTimer = setInterval(() => {
                    if (onlineConnected && onlineSocket && onlineSocket.readyState === WebSocket.OPEN) {
                        onlineSocket.send(JSON.stringify({ type: 'ping' }));
                    }
                }, 25000);
                
                resolve();
            };
            
            onlineSocket.onmessage = (event) => {
                handleOnlineMessage(JSON.parse(event.data));
            };
            
            onlineSocket.onclose = () => {
                console.log('[Online] WebSocket disconnected');
                onlineConnected = false;
                onlineCharacters = []; // æ¸…ç©ºåœ¨çº¿è§’è‰²åˆ—è¡¨
                updateOnlineStatus();
                
                // æ¸…é™¤å¿ƒè·³å®šæ—¶å™¨
                if (window.onlineHeartbeatTimer) {
                    clearInterval(window.onlineHeartbeatTimer);
                    window.onlineHeartbeatTimer = null;
                }
            };
            
            onlineSocket.onerror = (error) => {
                console.error('[Online] WebSocket error:', error);
                onlineConnected = false;
                updateOnlineStatus();
                reject(new Error('è¿æ¥å¤±è´¥'));
            };
            
            // è®¾ç½®è¶…æ—¶
            setTimeout(() => {
                if (!onlineConnected) {
                    onlineSocket.close();
                    reject(new Error('è¿æ¥è¶…æ—¶'));
                }
            }, 10000);
            
        } catch (e) {
            reject(e);
        }
    });
}

// å¤„ç†æœåŠ¡å™¨æ¶ˆæ¯
async function handleOnlineMessage(data) {
    // å¿ƒè·³å“åº”ä¸éœ€è¦æ‰“å°æ—¥å¿—
    if (data.type === 'pong') return;
    
    console.log('[Online] Received:', data);
    
    switch (data.type) {
        case 'auth_success':
            onlineUserData = data.user;
            localStorage.setItem('online_user_data', JSON.stringify(data.user));
            updateOnlineStatus();
            console.log('[Online] è®¤è¯æˆåŠŸï¼Œè‡ªåŠ¨æ³¨å†Œæ‰€æœ‰è§’è‰²åˆ°æœåŠ¡å™¨...');
            // å…ˆæ³¨å†Œæ‰€æœ‰è§’è‰²åˆ°æœåŠ¡å™¨ï¼ˆä¸ä¸Šçº¿ï¼Œä»…ç”¨äºæœç´¢ï¼‰
            await autoRegisterAllUserCharacters();
            // è·å–å·²ä¸Šçº¿çš„è§’è‰²ï¼Œç„¶åè‡ªåŠ¨ä¸Šçº¿æœ¬åœ°è§’è‰²
            requestOnlineCharacters();
            // âœ… è‡ªåŠ¨ä¸Šçº¿æ‰€æœ‰ User ç±»å‹çš„è§’è‰²ï¼ˆè§’è‰²ä¸Šçº¿åä¼šé€šè¿‡ character_online äº‹ä»¶è‡ªåŠ¨è·å–ç¾¤èŠåˆ—è¡¨ï¼‰
            autoGoOnlineAllUserCharacters();
            break;
            
        case 'auth_failed':
            onlineToken = null;
            onlineUserData = null;
            localStorage.removeItem('online_token');
            localStorage.removeItem('online_user_data');
            updateOnlineStatus();
            // âœ… å¦‚æœ token è¿‡æœŸï¼Œæç¤ºç”¨æˆ·é‡æ–°ç™»å½•è€Œä¸æ˜¯æ³¨å†Œ
            const errorMsg = data.message || 'è®¤è¯å¤±è´¥';
            if (errorMsg.includes('è¿‡æœŸ') || errorMsg.includes('æ— æ•ˆ') || errorMsg.includes('expired') || errorMsg.includes('invalid')) {
                alert('ç™»å½•å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•ï¼ˆä¸è¦æ³¨å†Œæ–°è´¦å·ï¼Œä½¿ç”¨ä¹‹å‰çš„ç”¨æˆ·åå’Œå¯†ç ç™»å½•ï¼‰');
                // æ˜¾ç¤ºç™»å½•å¼¹çª—
                showOnlineLoginModal();
            } else {
                alert('ç™»å½•å¤±è´¥: ' + errorMsg);
            }
            break;
            
        case 'login_success':
            onlineToken = data.token;
            onlineUserData = data.user;
            localStorage.setItem('online_token', data.token);
            localStorage.setItem('online_user_data', JSON.stringify(data.user));
            updateOnlineStatus();
            closeModal('online-login-modal');
            showToast('ç™»å½•æˆåŠŸ');
            console.log('[Online] ç™»å½•æˆåŠŸï¼Œè‡ªåŠ¨æ³¨å†Œæ‰€æœ‰è§’è‰²åˆ°æœåŠ¡å™¨...');
            // å…ˆæ³¨å†Œæ‰€æœ‰è§’è‰²åˆ°æœåŠ¡å™¨ï¼ˆä¸ä¸Šçº¿ï¼Œä»…ç”¨äºæœç´¢ï¼‰
            await autoRegisterAllUserCharacters();
            requestOnlineCharacters();
            // âœ… è‡ªåŠ¨ä¸Šçº¿æ‰€æœ‰ User ç±»å‹çš„è§’è‰²
            autoGoOnlineAllUserCharacters();
            break;
            
        case 'register_success':
            onlineToken = data.token;
            onlineUserData = data.user;
            localStorage.setItem('online_token', data.token);
            localStorage.setItem('online_user_data', JSON.stringify(data.user));
            updateOnlineStatus();
            closeModal('online-register-modal');
            showToast('æ³¨å†ŒæˆåŠŸ');
            break;
            
        case 'error':
            alert(data.message || 'æ“ä½œå¤±è´¥');
            break;
            
        case 'search_result':
            displayOnlineSearchResult(data.result);
            break;
            
        case 'friend_request':
            // æ”¶åˆ°å¥½å‹ç”³è¯·
            handleOnlineFriendRequest(data.request);
            break;
            
        case 'friend_request_accepted':
            // å¥½å‹ç”³è¯·è¢«æ¥å—
            handleFriendRequestAccepted(data);
            break;
            
        case 'message':
            // æ”¶åˆ°è”æœºæ¶ˆæ¯
            handleOnlineIncomingMessage(data);
            break;
            
        case 'online_characters':
            // å·²ä¸Šçº¿çš„è§’è‰²åˆ—è¡¨
            onlineCharacters = data.characters || [];
            break;
            
        case 'character_online':
            // è‡ªåŠ¨ä¸Šçº¿ï¼Œä¸éœ€è¦ Toast æç¤º
            console.log(`[Online] è§’è‰² ${data.nickname} å·²åŒæ­¥`);
            requestOnlineCharacters();
            // åˆ·æ–°è”æœºçŠ¶æ€é¡µé¢ï¼ˆå¦‚æœæ‰“å¼€çš„è¯ï¼‰
            refreshOnlineStatusPageContent();
            // âœ… è·å–è”æœºç¾¤èŠåˆ—è¡¨ï¼ˆä½¿ç”¨ç¬¬ä¸€ä¸ªä¸Šçº¿çš„è§’è‰²ï¼‰
            if (data.wx_account && onlineSocket && onlineSocket.readyState === WebSocket.OPEN) {
                console.log('[Online] è§’è‰²ä¸Šçº¿åï¼Œè‡ªåŠ¨è·å–ç¾¤èŠåˆ—è¡¨ï¼Œä½¿ç”¨å¾®ä¿¡å·:', data.wx_account);
                onlineSocket.send(JSON.stringify({
                    type: 'get_online_groups',
                    my_wx_account: data.wx_account
                }));
            }
            break;
            
        case 'character_offline':
            // è‡ªåŠ¨å¤„ç†ï¼Œä¸éœ€è¦ Toast æç¤º
            console.log('[Online] è§’è‰²å·²ç¦»çº¿');
            requestOnlineCharacters();
            // åˆ·æ–°è”æœºçŠ¶æ€é¡µé¢ï¼ˆå¦‚æœæ‰“å¼€çš„è¯ï¼‰
            refreshOnlineStatusPageContent();
            break;
        
        // ==================== è”æœºç¾¤èŠæ¶ˆæ¯ ====================
        case 'online_group_created':
            // ç¾¤èŠåˆ›å»ºæˆåŠŸ
            showToast(`ç¾¤èŠ"${data.group.name}"åˆ›å»ºæˆåŠŸ`);
            onlineGroups.push(data.group);
            refreshOnlineGroupList();
            // åŒæ—¶åœ¨æœ¬åœ°åˆ›å»ºç¾¤èŠè®°å½•ï¼Œè®©å®ƒæ˜¾ç¤ºåœ¨æ¶ˆæ¯åˆ—è¡¨ä¸­
            await createLocalOnlineGroupChat(data.group);
            break;
            
        case 'group_invite':
            // æ”¶åˆ°ç¾¤èŠé‚€è¯·
            handleOnlineGroupInvite(data);
            break;
            
        case 'online_group_joined':
            // åŠ å…¥ç¾¤èŠæˆåŠŸ
            showToast(`å·²åŠ å…¥ç¾¤èŠ"${data.group.name}"`);
            if (!onlineGroups.find(g => g.id === data.group.id)) {
                onlineGroups.push(data.group);
            }
            refreshOnlineGroupList();
            // åŒæ—¶åœ¨æœ¬åœ°åˆ›å»ºç¾¤èŠè®°å½•ï¼Œè®©å®ƒæ˜¾ç¤ºåœ¨æ¶ˆæ¯åˆ—è¡¨ä¸­
            await createLocalOnlineGroupChat(data.group);
            break;
            
        case 'group_member_joined':
            // æœ‰æ–°æˆå‘˜åŠ å…¥ç¾¤èŠ
            if (currentOnlineGroupId === data.group_id) {
                showToast(`${data.member.user_name} åŠ å…¥äº†ç¾¤èŠ`);
                refreshOnlineGroupMembers();
            }
            break;
            
        case 'online_groups_list':
            // æ”¶åˆ°ç¾¤èŠåˆ—è¡¨
            onlineGroups = data.groups || [];
            refreshOnlineGroupList();
            // ä¸ºæ¯ä¸ªç¾¤èŠåˆ›å»ºæœ¬åœ°è®°å½•
            for (const group of onlineGroups) {
                await createLocalOnlineGroupChat(group);
            }
            break;
            
        case 'group_messages':
            // æ”¶åˆ°ç¾¤èŠæ¶ˆæ¯è®°å½•
            handleOnlineGroupMessages(data);
            break;
            
        case 'group_message':
            // æ”¶åˆ°å®æ—¶ç¾¤æ¶ˆæ¯
            handleOnlineGroupMessage(data);
            break;
            
        case 'group_typing_start':
            // æ”¶åˆ°ç¾¤æˆå‘˜æ­£åœ¨è¾“å…¥çš„é€šçŸ¥
            handleGroupTypingStart(data);
            break;
            
        case 'group_typing_stop':
            // æ”¶åˆ°ç¾¤æˆå‘˜åœæ­¢è¾“å…¥çš„é€šçŸ¥
            handleGroupTypingStop(data);
            break;
            
        case 'group_members':
            // æ”¶åˆ°ç¾¤æˆå‘˜åˆ—è¡¨
            handleOnlineGroupMembers(data);
            break;
            
        case 'group_character_updated':
            // è§’è‰²æ›´æ–°æˆåŠŸ
            showToast('ç¾¤å†…è§’è‰²å·²æ›´æ–°');
            break;
            
        case 'redpacket_claimed':
            // çº¢åŒ…è¢«é¢†å–ï¼Œæ›´æ–°çº¢åŒ…çŠ¶æ€
            handleRedPacketClaimed(data);
            break;
    }
}

// æ˜¾ç¤ºç™»å½•å¼¹çª—
function showOnlineLoginModal() {
    const serverUrl = document.getElementById('online-server-url').value.trim();
    if (!serverUrl) {
        alert('è¯·å…ˆå¡«å†™æœåŠ¡å™¨åœ°å€');
        return;
    }
    document.getElementById('online-login-modal').style.display = 'flex';
}

// æ˜¾ç¤ºæ³¨å†Œå¼¹çª—
function showOnlineRegisterModal() {
    const serverUrl = document.getElementById('online-server-url').value.trim();
    if (!serverUrl) {
        alert('è¯·å…ˆå¡«å†™æœåŠ¡å™¨åœ°å€');
        return;
    }
    document.getElementById('online-register-modal').style.display = 'flex';
}

// æ‰§è¡Œç™»å½•
async function doOnlineLogin() {
    const username = document.getElementById('online-login-username').value.trim();
    const password = document.getElementById('online-login-password').value;
    
    if (!username || !password) {
        alert('è¯·å¡«å†™ç”¨æˆ·åå’Œå¯†ç ');
        return;
    }
    
    // ç¡®ä¿å·²è¿æ¥
    if (!onlineConnected) {
        try {
            await connectToOnlineServer();
        } catch (e) {
            alert('æ— æ³•è¿æ¥æœåŠ¡å™¨: ' + e.message);
            return;
        }
    }
    
    onlineSocket.send(JSON.stringify({
        type: 'login',
        username: username,
        password: password
    }));
}

// æ‰§è¡Œæ³¨å†Œ
async function doOnlineRegister() {
    const username = document.getElementById('online-register-username').value.trim();
    const email = document.getElementById('online-register-email').value.trim();
    const password = document.getElementById('online-register-password').value;
    const password2 = document.getElementById('online-register-password2').value;
    
    if (!username) {
        alert('è¯·å¡«å†™ç”¨æˆ·å');
        return;
    }
    
    if (!/^[a-zA-Z0-9_]{3,20}$/.test(username)) {
        alert('ç”¨æˆ·ååªèƒ½åŒ…å«å­—æ¯ã€æ•°å­—å’Œä¸‹åˆ’çº¿ï¼Œé•¿åº¦3-20ä½');
        return;
    }
    
    if (!password || password.length < 6) {
        alert('å¯†ç è‡³å°‘6ä½');
        return;
    }
    
    if (password !== password2) {
        alert('ä¸¤æ¬¡è¾“å…¥çš„å¯†ç ä¸ä¸€è‡´');
        return;
    }
    
    // ç¡®ä¿å·²è¿æ¥
    if (!onlineConnected) {
        try {
            await connectToOnlineServer();
        } catch (e) {
            alert('æ— æ³•è¿æ¥æœåŠ¡å™¨: ' + e.message);
            return;
        }
    }
    
    onlineSocket.send(JSON.stringify({
        type: 'register',
        username: username,
        email: email || null,
        password: password
    }));
}

// é€€å‡ºç™»å½•
function onlineLogout() {
    if (confirm('ç¡®å®šè¦é€€å‡ºè”æœºç™»å½•å—ï¼Ÿ')) {
        onlineToken = null;
        onlineUserData = null;
        onlineCharacters = [];
        localStorage.removeItem('online_token');
        localStorage.removeItem('online_user_data');
        updateOnlineStatus();
        
        if (onlineSocket) {
            onlineSocket.send(JSON.stringify({ type: 'logout' }));
        }
        
        showToast('å·²é€€å‡ºç™»å½•');
    }
}

// æ˜¾ç¤ºè”æœºæœç´¢å¼¹çª—
async function showOnlineSearchModal() {
    toggleWechatMenu(); // å…³é—­èœå•
    
    if (!onlineConnected || !onlineUserData) {
        alert('è¯·å…ˆåœ¨è®¾ç½®ä¸­è¿æ¥æœåŠ¡å™¨å¹¶ç™»å½•');
        return;
    }
    
    // æ£€æŸ¥æ˜¯å¦æœ‰å·²ä¸Šçº¿çš„è§’è‰²
    if (onlineCharacters.length === 0) {
        alert('è¯·å…ˆåœ¨ã€Œæˆ‘ã€é¡µé¢ä¸Šçº¿è‡³å°‘ä¸€ä¸ªUserè§’è‰²');
        return;
    }
    
    // å¡«å……èº«ä»½é€‰æ‹©ä¸‹æ‹‰æ¡†
    const select = document.getElementById('online-search-my-persona');
    select.innerHTML = onlineCharacters.map(char => 
        `<option value="${char.wx_account}">${char.nickname} (${char.wx_account})</option>`
    ).join('');
    
    // æ¸…ç©ºä¹‹å‰çš„æœç´¢ç»“æœ
    document.getElementById('online-search-input').value = '';
    document.getElementById('online-search-result').style.display = 'none';
    document.getElementById('online-search-empty').style.display = 'none';
    document.getElementById('online-search-message').value = '';
    
    document.getElementById('online-search-modal').style.display = 'flex';
}

// æ‰§è¡Œè”æœºæœç´¢
function doOnlineSearch() {
    const wxAccount = document.getElementById('online-search-input').value.trim();
    
    if (!wxAccount) {
        alert('è¯·è¾“å…¥è¦æœç´¢çš„è™šæ‹Ÿå¾®ä¿¡å·');
        return;
    }
    
    if (!onlineConnected) {
        alert('æœåŠ¡å™¨æœªè¿æ¥ï¼Œè¯·å…ˆè¿æ¥æœåŠ¡å™¨');
        return;
    }
    
    if (!onlineSocket || onlineSocket.readyState !== WebSocket.OPEN) {
        alert('WebSocket è¿æ¥æœªå»ºç«‹ï¼Œè¯·æ£€æŸ¥æœåŠ¡å™¨è¿æ¥');
        return;
    }
    
    console.log('[Online] æœç´¢å¾®ä¿¡å·:', wxAccount);
    
    // æ˜¾ç¤ºæœç´¢ä¸­çŠ¶æ€
    const resultEl = document.getElementById('online-search-result');
    const emptyEl = document.getElementById('online-search-empty');
    if (resultEl) resultEl.style.display = 'none';
    if (emptyEl) {
        emptyEl.style.display = 'block';
        emptyEl.innerHTML = '<div style="text-align:center; padding:20px; color:#999;">æœç´¢ä¸­...</div>';
    }
    
    try {
        onlineSocket.send(JSON.stringify({
            type: 'search_user',
            wx_account: wxAccount
        }));
        console.log('[Online] æœç´¢è¯·æ±‚å·²å‘é€');
    } catch (e) {
        console.error('[Online] å‘é€æœç´¢è¯·æ±‚å¤±è´¥:', e);
        alert('æœç´¢å¤±è´¥: ' + e.message);
    }
}

// æ˜¾ç¤ºæœç´¢ç»“æœ
function displayOnlineSearchResult(result) {
    console.log('[Online] æ”¶åˆ°æœç´¢ç»“æœ:', result);
    
    const resultEl = document.getElementById('online-search-result');
    const emptyEl = document.getElementById('online-search-empty');
    
    if (!result) {
        console.log('[Online] æœç´¢ç»“æœä¸ºç©º');
        if (resultEl) resultEl.style.display = 'none';
        if (emptyEl) {
            emptyEl.style.display = 'block';
            emptyEl.innerHTML = '<div style="text-align:center; padding:20px; color:#999;">æœªæ‰¾åˆ°è¯¥å¾®ä¿¡å·<br><span style="font-size:12px; color:#ccc;">æç¤ºï¼šåªæœ‰è§’è‰²ä¸Šçº¿åæ‰èƒ½è¢«æœç´¢åˆ°</span></div>';
        }
        return;
    }
    
    console.log('[Online] æ˜¾ç¤ºæœç´¢ç»“æœ:', result.nickname);
    
    if (emptyEl) emptyEl.style.display = 'none';
    if (resultEl) {
        resultEl.style.display = 'block';
        
        // å¡«å……ç»“æœ
        const avatarEl = document.getElementById('online-search-avatar');
        const nicknameEl = document.getElementById('online-search-nickname');
        const wxidEl = document.getElementById('online-search-wxid');
        const bioEl = document.getElementById('online-search-bio');
        const statusEl = document.getElementById('online-search-online-status');
        
        if (avatarEl) {
            avatarEl.style.backgroundImage = result.avatar ? `url(${result.avatar})` : '';
        }
        if (nicknameEl) {
            nicknameEl.textContent = result.nickname || 'æœªè®¾ç½®æ˜µç§°';
        }
        if (wxidEl) {
            wxidEl.textContent = result.wx_account;
        }
        // éšè— bioï¼ˆäººè®¾ï¼‰ï¼Œä¿æŠ¤éšç§
        if (bioEl) {
            bioEl.style.display = 'none';
        }
        
        if (statusEl) {
            if (result.is_online) {
                statusEl.textContent = 'åœ¨çº¿';
                statusEl.style.background = '#e8f5e9';
                statusEl.style.color = '#4caf50';
            } else {
                statusEl.textContent = 'ç¦»çº¿';
                statusEl.style.background = '#f5f5f5';
                statusEl.style.color = '#999';
            }
        }
        
        // ä¿å­˜æœç´¢ç»“æœä¾›å‘é€ç”³è¯·ä½¿ç”¨
        resultEl.dataset.wxAccount = result.wx_account;
    }
}

// å‘é€è”æœºå¥½å‹ç”³è¯·
function sendOnlineFriendRequest() {
    const resultEl = document.getElementById('online-search-result');
    const toWxAccount = resultEl.dataset.wxAccount;
    const fromWxAccount = document.getElementById('online-search-my-persona').value;
    const message = document.getElementById('online-search-message').value.trim();
    
    if (!toWxAccount || !fromWxAccount) {
        alert('è¯·é€‰æ‹©ä½ çš„èº«ä»½');
        return;
    }
    
    onlineSocket.send(JSON.stringify({
        type: 'friend_request',
        from_wx_account: fromWxAccount,
        to_wx_account: toWxAccount,
        message: message || 'è¯·æ±‚æ·»åŠ ä½ ä¸ºå¥½å‹'
    }));
    
    closeModal('online-search-modal');
    showToast('å¥½å‹ç”³è¯·å·²å‘é€');
}

// å¤„ç†æ”¶åˆ°çš„å¥½å‹ç”³è¯·
async function handleOnlineFriendRequest(request) {
    console.log('[Online] æ”¶åˆ°å¥½å‹ç”³è¯·:', request);
    
    // åˆ›å»ºä¸€ä¸ªé€šçŸ¥
    sendSystemNotification('æ–°çš„å¥½å‹ç”³è¯·', `${request.from_nickname} (${request.from_wx_account}) æƒ³æ·»åŠ ä½ ä¸ºå¥½å‹`);
    
    // å°†ç”³è¯·ä¿å­˜åˆ°æœ¬åœ°å¥½å‹ç”³è¯·åˆ—è¡¨
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    await db.friend_requests.add({
        fromCharId: null, // è”æœºå¥½å‹æ²¡æœ‰æœ¬åœ°charId
        toAccountId: accountId,
        status: 'pending',
        time: Date.now(),
        isOnline: true, // æ ‡è®°ä¸ºè”æœºå¥½å‹ç”³è¯·
        onlineData: request // ä¿å­˜è”æœºæ•°æ®
    });
    
    // åˆ·æ–°æ–°çš„å¥½å‹é¡µé¢
    if (document.getElementById('new-friends-page').style.display !== 'none') {
        renderNewFriendsPage();
    }
}

// å¥½å‹ç”³è¯·è¢«æ¥å—
async function handleFriendRequestAccepted(data) {
    console.log('[Online] å¥½å‹ç”³è¯·è¢«æ¥å—:', data);
    
    // åœ¨æœ¬åœ°åˆ›å»ºä¸€ä¸ªè”æœºå¥½å‹è§’è‰²
    const accountId = getCurrentAccountId();
    const newChar = {
        name: data.friend_nickname,
        type: 'online_friend', // ç‰¹æ®Šç±»å‹ï¼šè”æœºå¥½å‹
        avatar: data.friend_avatar || '',
        description: data.friend_bio || '',
        identity: {
            account: data.friend_wx_account
        },
        isOnlineFriend: true,
        onlineData: {
            wx_account: data.friend_wx_account,
            user_id: data.friend_user_id
        },
        wechat_status_by_user: {}  // ä½¿ç”¨æ­£ç¡®çš„å­—æ®µåï¼Œä¸ getFriendStatus åŒ¹é…
    };
    
    // è®¾ç½®å¥½å‹å…³ç³»
    if (accountId) {
        newChar.wechat_status_by_user[accountId] = 'friend';
    }
    
    const charId = await db.characters.add(newChar);
    
    showToast(`${data.friend_nickname} å·²æˆä¸ºä½ çš„å¥½å‹`);
    
    // åˆ·æ–°å¾®ä¿¡åˆ—è¡¨
    const content = document.getElementById('wechat-content');
    if (content) {
        renderWechatList(content);
    }
}

// å¤„ç†æ”¶åˆ°çš„è”æœºæ¶ˆæ¯
async function handleOnlineIncomingMessage(data) {
    console.log('[Online] æ”¶åˆ°æ¶ˆæ¯:', data);
    
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    // æŸ¥æ‰¾æœ¬åœ°å¯¹åº”çš„è”æœºå¥½å‹è§’è‰²
    const chars = await db.characters.where('type').equals('online_friend').toArray();
    let targetChar = chars.find(c => c.onlineData?.wx_account === data.from_wx_account);
    
    if (!targetChar) {
        console.warn('[Online] æœªæ‰¾åˆ°å¯¹åº”çš„è”æœºå¥½å‹è§’è‰²');
        return;
    }
    
    // âœ… ç¡®ä¿è”æœºå¥½å‹åœ¨å½“å‰è´¦å·ä¸‹çš„å¥½å‹çŠ¶æ€æ˜¯ 'friend'
    // è¿™æ ·åˆ‡æ¢è´¦å·åæ¶ˆæ¯ä¹Ÿèƒ½æ­£å¸¸æ˜¾ç¤º
    const currentFriendStatus = getFriendStatus(targetChar, accountId);
    if (currentFriendStatus !== 'friend') {
        console.log('[Online] ä¸ºå½“å‰è´¦å·è®¾ç½®è”æœºå¥½å‹çŠ¶æ€ä¸º friend');
        if (!targetChar.wechat_status_by_user) targetChar.wechat_status_by_user = {};
        targetChar.wechat_status_by_user[accountId] = 'friend';
        // æ›´æ–°åé‡æ–°è·å–ï¼Œç¡®ä¿åç»­é€»è¾‘ä½¿ç”¨æœ€æ–°æ•°æ®
        await db.characters.put(targetChar);
        targetChar = await db.characters.get(targetChar.id);
    }
    
    // æ£€æŸ¥æ˜¯å¦æ˜¯ç‰¹æ®Šæ¶ˆæ¯ç±»å‹ï¼ˆå¦‚è½¬è´¦ï¼‰
    let msgObj = {
        role: 'char',
        content: data.content,
        time: data.timestamp || Date.now(),
        isOnlineMessage: true
    };
    
    // å°è¯•è§£æ JSON æ ¼å¼çš„ç‰¹æ®Šæ¶ˆæ¯
    try {
        const parsed = JSON.parse(data.content);
        if (parsed.__type === 'transfer') {
            // è¿™æ˜¯è½¬è´¦æ¶ˆæ¯ï¼Œè½¬æ¢ä¸ºè½¬è´¦å¡ç‰‡æ ¼å¼
            msgObj.type = 'transfer';
            msgObj.content = JSON.stringify({
                amount: parsed.amount,
                desc: parsed.desc,
                status: 'sent'  // å¯¹äºæ¥æ”¶æ–¹æ¥è¯´æ˜¯å¾…æ¥æ”¶çŠ¶æ€
            });
            msgObj.id = 'trans_' + Date.now();
            console.log('[Online] æ”¶åˆ°è½¬è´¦æ¶ˆæ¯:', parsed);
        } else if (parsed.__type === 'audio') {
            // è¿™æ˜¯è¯­éŸ³æ¶ˆæ¯
            msgObj.type = 'audio';
            msgObj.content = parsed.audio;
            msgObj.duration = parsed.duration;
            msgObj.effect = parsed.effect;
            console.log('[Online] æ”¶åˆ°è¯­éŸ³æ¶ˆæ¯, æ—¶é•¿:', parsed.duration, 'ç§’, æ•ˆæœ:', parsed.effect);
        }
    } catch (e) {
        // ä¸æ˜¯ JSONï¼Œæ™®é€šæ–‡æœ¬æ¶ˆæ¯
    }
    
    // ä¿å­˜æ¶ˆæ¯åˆ°èŠå¤©å†å²
    let history = getChatHistory(targetChar, accountId);
    history.push(msgObj);
    await setChatHistory(targetChar, accountId, history);
    
    // å¦‚æœå½“å‰æ­£åœ¨æŸ¥çœ‹è¿™ä¸ªèŠå¤©ï¼Œæ›´æ–°UI
    if (currentChatCharId === targetChar.id) {
        // ç‰¹æ®Šæ¶ˆæ¯ç±»å‹éœ€è¦é‡æ–°æ¸²æŸ“æ•´ä¸ªèŠå¤©
        if (msgObj.type === 'transfer' || msgObj.type === 'audio') {
            renderChatBody(targetChar);
        } else {
            appendMessageToUI('char', data.content, targetChar.avatar);
        }
    } else {
        // å‘é€é€šçŸ¥
        let notifyContent = data.content;
        if (msgObj.type === 'transfer') notifyContent = '[è½¬è´¦]';
        if (msgObj.type === 'audio') notifyContent = '[è¯­éŸ³æ¶ˆæ¯]';
        sendSystemNotification(targetChar.name, notifyContent);
    }
}

// è¯·æ±‚å·²ä¸Šçº¿çš„è§’è‰²åˆ—è¡¨
function requestOnlineCharacters() {
    if (!onlineConnected || !onlineUserData) return;
    
    onlineSocket.send(JSON.stringify({
        type: 'get_online_characters'
    }));
}

// ä¸Šçº¿è§’è‰²
async function goOnlineWithCharacter(charId) {
    if (!onlineConnected || !onlineUserData) {
        alert('è¯·å…ˆåœ¨è®¾ç½®ä¸­è¿æ¥æœåŠ¡å™¨å¹¶ç™»å½•');
        return;
    }
    
    const char = await db.characters.get(charId);
    if (!char || char.type !== 'user') {
        alert('åªèƒ½ä¸Šçº¿Userç±»å‹çš„è§’è‰²');
        return;
    }
    
    const wxAccount = char.identity?.account;
    if (!wxAccount) {
        alert('è¯¥è§’è‰²æ²¡æœ‰è®¾ç½®è™šæ‹Ÿå¾®ä¿¡å·ï¼Œè¯·å…ˆåœ¨WeChatä¸­æ³¨å†Œ');
        return;
    }
    
    onlineSocket.send(JSON.stringify({
        type: 'go_online',
        wx_account: wxAccount,
        nickname: char.remark || char.name,
        avatar: char.avatar || '',
        bio: char.description?.substring(0, 100) || '',
        local_char_id: charId
    }));
}

// ä¸‹çº¿è§’è‰²
function goOfflineWithCharacter(wxAccount) {
    if (!onlineConnected) return;
    
    onlineSocket.send(JSON.stringify({
        type: 'go_offline',
        wx_account: wxAccount
    }));
}

// âœ… è‡ªåŠ¨ä¸Šçº¿æ‰€æœ‰ User ç±»å‹çš„è§’è‰²
// è‡ªåŠ¨æ³¨å†Œæ‰€æœ‰ User ç±»å‹è§’è‰²åˆ°æœåŠ¡å™¨ï¼ˆä¸ä¸Šçº¿ï¼Œä»…ç”¨äºæœç´¢ï¼‰
async function autoRegisterAllUserCharacters() {
    if (!onlineConnected || !onlineUserData) {
        console.log('[Online] æœªè¿æ¥æˆ–æœªç™»å½•ï¼Œè·³è¿‡è‡ªåŠ¨æ³¨å†Œ');
        return;
    }
    
    try {
        // è·å–æ‰€æœ‰ User ç±»å‹çš„è§’è‰²
        const userChars = await db.characters.where('type').equals('user').toArray();
        
        let registerCount = 0;
        for (const char of userChars) {
            const wxAccount = char.identity?.account;
            if (!wxAccount) {
                console.log(`[Online] è§’è‰² ${char.name} æ²¡æœ‰å¾®ä¿¡å·ï¼Œè·³è¿‡æ³¨å†Œ`);
                continue;
            }
            
            // æ³¨å†Œè§’è‰²åˆ°æœåŠ¡å™¨ï¼ˆä¸ä¸Šçº¿ï¼Œis_online = 0ï¼‰
            console.log(`[Online] æ³¨å†Œè§’è‰²åˆ°æœåŠ¡å™¨: ${char.name} (${wxAccount})`);
            onlineSocket.send(JSON.stringify({
                type: 'register_character',
                wx_account: wxAccount,
                nickname: char.remark || char.name,
                avatar: char.avatar || '',
                bio: char.description?.substring(0, 100) || ''
            }));
            registerCount++;
        }
        
        if (registerCount > 0) {
            console.log(`[Online] å·²æ³¨å†Œ ${registerCount} ä¸ªè§’è‰²åˆ°æœåŠ¡å™¨ï¼ˆå¯è¢«æœç´¢ï¼‰`);
        } else {
            console.log('[Online] æ²¡æœ‰å¯æ³¨å†Œçš„è§’è‰²ï¼ˆè¯·ç¡®ä¿ User è§’è‰²è®¾ç½®äº†å¾®ä¿¡å·ï¼‰');
        }
    } catch (e) {
        console.error('[Online] è‡ªåŠ¨æ³¨å†Œè§’è‰²å¤±è´¥:', e);
    }
}

async function autoGoOnlineAllUserCharacters() {
    if (!onlineConnected || !onlineUserData) {
        console.log('[Online] æœªè¿æ¥æˆ–æœªç™»å½•ï¼Œè·³è¿‡è‡ªåŠ¨ä¸Šçº¿');
        return;
    }
    
    try {
        // è·å–æ‰€æœ‰ User ç±»å‹çš„è§’è‰²
        const userChars = await db.characters.where('type').equals('user').toArray();
        
        let onlineCount = 0;
        for (const char of userChars) {
            const wxAccount = char.identity?.account;
            if (!wxAccount) {
                console.log(`[Online] è§’è‰² ${char.name} æ²¡æœ‰å¾®ä¿¡å·ï¼Œè·³è¿‡`);
                continue;
            }
            
            // ä¸å†æ£€æŸ¥ isCharacterOnlineï¼Œç›´æ¥å°è¯•ä¸Šçº¿ï¼ˆæœåŠ¡å™¨ä¼šå¤„ç†é‡å¤ä¸Šçº¿ï¼‰
            // å› ä¸º onlineCharacters å¯èƒ½è¿˜æ²¡æ›´æ–°
            
            // ä¸Šçº¿è§’è‰²
            console.log(`[Online] è‡ªåŠ¨ä¸Šçº¿è§’è‰²: ${char.name} (${wxAccount})`);
            onlineSocket.send(JSON.stringify({
                type: 'go_online',
                wx_account: wxAccount,
                nickname: char.remark || char.name,
                avatar: char.avatar || '',
                bio: char.description?.substring(0, 100) || '',
                local_char_id: char.id
            }));
            onlineCount++;
        }
        
        if (onlineCount > 0) {
            console.log(`[Online] å·²å‘é€ ${onlineCount} ä¸ªè§’è‰²çš„ä¸Šçº¿è¯·æ±‚`);
            // âœ… å»¶è¿Ÿåè¯·æ±‚åœ¨çº¿è§’è‰²åˆ—è¡¨ï¼Œç¡®ä¿æœåŠ¡å™¨å·²å¤„ç†ä¸Šçº¿è¯·æ±‚
            setTimeout(() => {
                if (onlineConnected) {
                    requestOnlineCharacters();
                }
            }, 500);
        } else {
            console.log('[Online] æ²¡æœ‰å¯ä¸Šçº¿çš„è§’è‰²ï¼ˆè¯·ç¡®ä¿ User è§’è‰²è®¾ç½®äº†å¾®ä¿¡å·ï¼‰');
        }
    } catch (e) {
        console.error('[Online] è‡ªåŠ¨ä¸Šçº¿è§’è‰²å¤±è´¥:', e);
    }
}

// âœ… è·å–å½“å‰å¯ç”¨çš„åœ¨çº¿è§’è‰²ï¼ˆå¦‚æœæ²¡æœ‰åˆ™è‡ªåŠ¨ä¸Šçº¿ä¸€ä¸ªï¼‰
async function getOrCreateOnlineUserChar() {
    if (!onlineConnected || !onlineUserData) {
        return null;
    }
    
    const userChars = await db.characters.where('type').equals('user').toArray();
    
    // 1. å…ˆæ‰¾å·²ä¸Šçº¿çš„è§’è‰²
    let onlineUserChar = userChars.find(c => 
        c.identity?.account && onlineCharacters.some(oc => oc.wx_account === c.identity.account)
    );
    
    // 2. å¦‚æœæ²¡æœ‰ï¼Œæ‰¾ä¸€ä¸ªæœ‰å¾®ä¿¡å·çš„è§’è‰²å¹¶è‡ªåŠ¨ä¸Šçº¿
    if (!onlineUserChar) {
        const charWithAccount = userChars.find(c => c.identity?.account);
        if (charWithAccount) {
            console.log('[Online] è‡ªåŠ¨ä¸Šçº¿è§’è‰²:', charWithAccount.name);
            const wxAccount = charWithAccount.identity.account;
            onlineSocket.send(JSON.stringify({
                type: 'go_online',
                wx_account: wxAccount,
                nickname: charWithAccount.remark || charWithAccount.name,
                avatar: charWithAccount.avatar || '',
                bio: charWithAccount.description?.substring(0, 100) || '',
                local_char_id: charWithAccount.id
            }));
            onlineUserChar = charWithAccount;
        }
    }
    
    return onlineUserChar;
}

// å‘é€è”æœºæ¶ˆæ¯
function sendOnlineMessage(toWxAccount, content, fromWxAccount) {
    if (!onlineConnected) {
        console.warn('[Online] æœªè¿æ¥ï¼Œæ— æ³•å‘é€æ¶ˆæ¯');
        return false;
    }
    
    onlineSocket.send(JSON.stringify({
        type: 'message',
        to_wx_account: toWxAccount,
        from_wx_account: fromWxAccount,
        content: content
    }));
    
    return true;
}

// æ£€æŸ¥è§’è‰²æ˜¯å¦å·²ä¸Šçº¿
function isCharacterOnline(wxAccount) {
    return onlineCharacters.some(c => c.wx_account === wxAccount);
}

// è·å–è”æœºçŠ¶æ€
function getOnlineStatus() {
    return {
        connected: onlineConnected,
        loggedIn: !!onlineUserData,
        user: onlineUserData,
        characters: onlineCharacters
    };
}

// æ›´æ–°è”æœºåŠŸèƒ½åŒºæ˜¾ç¤º
function updateOnlineFeatureSection() {
    const badge = document.getElementById('online-char-count-badge');
    if (!badge) return;
    
    if (!onlineConnected) {
        badge.textContent = 'æœªè¿æ¥';
        badge.style.color = '#999';
    } else if (!onlineUserData) {
        badge.textContent = 'æœªç™»å½•';
        badge.style.color = '#ff9800';
    } else if (onlineCharacters.length === 0) {
        badge.textContent = 'å·²ç™»å½•';
        badge.style.color = '#4caf50';
    } else {
        badge.textContent = `${onlineCharacters.length}ä¸ªè§’è‰²åœ¨çº¿`;
        badge.style.color = '#4caf50';
    }
}

// æ˜¾ç¤ºè”æœºçŠ¶æ€é¡µé¢
async function showOnlineStatusPage() {
    const page = document.getElementById('online-status-page');
    if (!page) return;
    
    page.style.display = 'flex';
    
    // æ›´æ–°è¿æ¥çŠ¶æ€
    updateOnlineConnectionStatus();
    
    // æ›´æ–°è§’è‰²åˆ—è¡¨
    await renderOnlineCharList();
    
    // è·å–è”æœºç¾¤èŠåˆ—è¡¨
    const myWx = getMyOnlineWxAccount();
    if (myWx && onlineSocket && onlineSocket.readyState === WebSocket.OPEN) {
        onlineSocket.send(JSON.stringify({
            type: 'get_online_groups',
            my_wx_account: myWx
        }));
    }
    
    // åˆå§‹æ¸²æŸ“ç¾¤èŠåˆ—è¡¨
    const groupContainer = document.getElementById('online-group-list');
    if (groupContainer) {
        renderOnlineGroupList(groupContainer);
    }
}

// éšè—è”æœºçŠ¶æ€é¡µé¢
function hideOnlineStatusPage() {
    const page = document.getElementById('online-status-page');
    if (page) {
        page.style.display = 'none';
        // æ›´æ–°"æˆ‘"é¡µé¢çš„è”æœºçŠ¶æ€
        updateOnlineFeatureSection();
    }
}

// æ›´æ–°è¿æ¥çŠ¶æ€æ˜¾ç¤º
function updateOnlineConnectionStatus() {
    const container = document.getElementById('online-status-connection');
    if (!container) return;
    
    if (!onlineConnected) {
        container.innerHTML = `<div style="background:#fff5f5; color:#ff3b30; padding:12px; border-radius:8px;">æœªè¿æ¥æœåŠ¡å™¨ï¼Œè¯·åœ¨è®¾ç½®ä¸­é…ç½®è”æœºè®¾ç½®</div>`;
    } else if (!onlineUserData) {
        container.innerHTML = `<div style="background:#fff8e1; color:#ff9800; padding:12px; border-radius:8px;">å·²è¿æ¥æœåŠ¡å™¨ï¼Œè¯·å…ˆç™»å½•</div>`;
    } else {
        container.innerHTML = `<div style="background:#e8f5e9; color:#4caf50; padding:12px; border-radius:8px;">å·²è¿æ¥ - ${onlineUserData.username}</div>`;
    }
}

// æ¸²æŸ“è§’è‰²åˆ—è¡¨
async function renderOnlineCharList() {
    const container = document.getElementById('online-status-char-list');
    if (!container) return;
    
    // è·å–æ‰€æœ‰Userç±»å‹è§’è‰²
    const users = await db.characters.where('type').equals('user').toArray();
    
    // æ£€æŸ¥æ¯ä¸ªè§’è‰²çš„åœ¨çº¿çŠ¶æ€
    const charList = users.map(char => {
        const wxAccount = char.identity?.account || '';
        const isOnline = wxAccount && onlineCharacters.some(c => c.wx_account === wxAccount);
        return {
            id: char.id,
            name: char.remark || char.name,
            avatar: char.avatar || '',
            wxAccount: wxAccount,
            isOnline: isOnline
        };
    }).filter(c => c.wxAccount);
    
    if (charList.length === 0) {
        container.innerHTML = `
            <div style="text-align:center; padding:40px 20px; color:#999;">
                <div style="font-size:14px;">æ²¡æœ‰å¯ç”¨çš„è§’è‰²</div>
                <div style="font-size:12px; margin-top:8px;">è¯·å…ˆåœ¨è§’è‰²æ¡£æ¡ˆåˆ›å»º User ç±»å‹è§’è‰²ï¼Œå¹¶è®¾ç½®å¾®ä¿¡å·</div>
            </div>
        `;
        return;
    }
    
    // ç®€åŒ–æ˜¾ç¤ºï¼šåªæ˜¾ç¤ºè§’è‰²åˆ—è¡¨å’ŒçŠ¶æ€ï¼Œä¸éœ€è¦æ‰‹åŠ¨ä¸Šçº¿/ä¸‹çº¿æŒ‰é’®
    // ç™»å½•åä¼šè‡ªåŠ¨ä¸Šçº¿æ‰€æœ‰è§’è‰²
    container.innerHTML = charList.map(char => `
        <div style="padding:12px 16px; background:#fff; display:flex; align-items:center; gap:12px; border-bottom:1px solid #f0f0f0;">
            <div style="width:44px; height:44px; border-radius:8px; background-image:url(${char.avatar}); background-size:cover; background-position:center; background-color:#e0e0e0;"></div>
            <div style="flex:1;">
                <div style="font-size:15px; font-weight:500; color:#333;">${char.name}</div>
                <div style="font-size:12px; color:#999; margin-top:2px;">${char.wxAccount}</div>
            </div>
            <div style="display:flex; align-items:center;">
                ${char.isOnline ? `
                    <span style="font-size:12px; color:#4caf50; padding:4px 10px; background:#e8f5e9; border-radius:10px;">â— å·²åŒæ­¥</span>
                ` : `
                    <span style="font-size:12px; color:#999; padding:4px 10px; background:#f5f5f5; border-radius:10px;">â—‹ æœªåŒæ­¥</span>
                `}
            </div>
        </div>
    `).join('');
}

// åˆ·æ–°è”æœºçŠ¶æ€é¡µé¢å†…å®¹
async function refreshOnlineStatusPageContent() {
    const page = document.getElementById('online-status-page');
    if (!page || page.style.display === 'none') return; // é¡µé¢æ²¡æ‰“å¼€
    
    // åˆ·æ–°è§’è‰²åˆ—è¡¨
    await renderOnlineCharList();
}

// ==================== è”æœºç¾¤èŠåŠŸèƒ½ ====================

// åˆ·æ–°è”æœºç¾¤èŠåˆ—è¡¨
function refreshOnlineGroupList() {
    // å¦‚æœç¾¤èŠé¡µé¢æ‰“å¼€äº†ï¼Œåˆ·æ–°æ˜¾ç¤º
    const container = document.getElementById('online-group-list');
    if (container) {
        renderOnlineGroupList(container);
    }
}

// æ¸²æŸ“è”æœºç¾¤èŠåˆ—è¡¨
function renderOnlineGroupList(container) {
    if (onlineGroups.length === 0) {
        container.innerHTML = `<div style="text-align:center; padding:40px; color:#999;">æš‚æ— è”æœºç¾¤èŠ</div>`;
        return;
    }
    
    container.innerHTML = onlineGroups.map(g => `
        <div onclick="openOnlineGroup('${g.id}')" style="padding:14px 16px; background:#fff; display:flex; align-items:center; gap:12px; border-bottom:1px solid #f0f0f0; cursor:pointer;">
            <div style="width:48px; height:48px; border-radius:8px; background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); display:flex; align-items:center; justify-content:center; color:#fff; font-size:18px;">ğŸ‘¥</div>
            <div style="flex:1;">
                <div style="font-size:15px; font-weight:500; color:#333;">${g.name}</div>
                <div style="font-size:12px; color:#999; margin-top:2px;">è”æœºç¾¤èŠ</div>
            </div>
            <svg viewBox="0 0 24 24" style="width:20px; height:20px; stroke:#ccc; fill:none;"><polyline points="9 18 15 12 9 6"></polyline></svg>
        </div>
    `).join('');
}

// å¤„ç†ç¾¤èŠé‚€è¯· - ä¿å­˜åˆ°æ•°æ®åº“ï¼Œæ˜¾ç¤ºåœ¨"æ–°çš„å¥½å‹"é¡µé¢
async function handleOnlineGroupInvite(data) {
    // å°†ç¾¤èŠé‚€è¯·ä¿å­˜åˆ° friend_requests è¡¨
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ç›¸åŒçš„é‚€è¯·
    const existingInvites = await db.friend_requests
        .where('toAccountId')
        .equals(accountId)
        .toArray();
    const alreadyExists = existingInvites.some(r => 
        r.isGroupInvite && 
        r.groupData?.group_id === data.group_id &&
        r.status === 'pending'
    );
    if (alreadyExists) return;
    
    // åˆ›å»ºç¾¤èŠé‚€è¯·è®°å½•
    await db.friend_requests.add({
        toAccountId: accountId,
        isOnline: true,
        isGroupInvite: true,
        status: 'pending',
        time: Date.now(),
        groupData: {
            group_id: data.group_id,
            group_name: data.group_name,
            inviter_wx: data.inviter_wx,
            inviter_name: data.inviter_name
        }
    });
    
    // æ˜¾ç¤ºé€šçŸ¥
    showToast(`${data.inviter_name} é‚€è¯·ä½ åŠ å…¥ç¾¤èŠ"${data.group_name}"`);
    
    // å¦‚æœæ–°çš„å¥½å‹é¡µé¢æ­£åœ¨æ˜¾ç¤ºï¼Œåˆ·æ–°å®ƒ
    if (document.getElementById('new-friends-page').style.display !== 'none') {
        await renderNewFriendsPage();
    }
}

// åœ¨æœ¬åœ°æ•°æ®åº“åˆ›å»ºè”æœºç¾¤èŠè®°å½•ï¼Œè®©å®ƒæ˜¾ç¤ºåœ¨æ¶ˆæ¯åˆ—è¡¨ä¸­
async function createLocalOnlineGroupChat(group) {
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    try {
        // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
        const existing = await db.group_chats
            .where('ownerAccountId').equals(accountId)
            .filter(g => g.isOnlineGroup && g.onlineGroupId === group.id)
            .first();
        
        if (existing) {
            console.log('è”æœºç¾¤èŠå·²å­˜åœ¨äºæœ¬åœ°ï¼Œè·³è¿‡åˆ›å»º');
            return;
        }
        
        // åˆ›å»ºæœ¬åœ°ç¾¤èŠè®°å½•
        const groupChat = {
            name: group.name,
            avatar: DEFAULT_GROUP_AVATAR,
            memberIds: [], // è”æœºç¾¤èŠçš„æˆå‘˜ç”±æœåŠ¡å™¨ç®¡ç†
            ownerAccountId: accountId,
            created_at: group.created_at || Date.now(),
            updated_at: Date.now(),
            is_pinned: false,
            chat_history: [{
                role: 'system',
                content: 'è”æœºç¾¤èŠå·²åˆ›å»º',
                time: Date.now()
            }],
            isOnlineGroup: true, // æ ‡è®°ä¸ºè”æœºç¾¤èŠ
            onlineGroupId: group.id, // è”æœºç¾¤èŠçš„ID
            onlineGroupCreator: group.creator_wx // åˆ›å»ºè€…å¾®ä¿¡å·
        };
        
        await db.group_chats.add(groupChat);
        console.log('å·²åœ¨æœ¬åœ°åˆ›å»ºè”æœºç¾¤èŠè®°å½•');
        
        // åˆ·æ–°èŠå¤©åˆ—è¡¨
        if (document.querySelector('.wechat-tab-item.active')?.innerText.includes('å¾®ä¿¡')) {
            renderWechatList(document.getElementById('wechat-content'));
        }
    } catch (e) {
        console.error('åˆ›å»ºæœ¬åœ°è”æœºç¾¤èŠè®°å½•å¤±è´¥:', e);
    }
}

// æ›´æ–°æœ¬åœ°è”æœºç¾¤èŠçš„æœ€åæ¶ˆæ¯
async function updateLocalOnlineGroupLastMessage(onlineGroupId, message) {
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    try {
        // æŸ¥æ‰¾å¯¹åº”çš„æœ¬åœ°ç¾¤èŠè®°å½•
        const groups = await db.group_chats
            .where('ownerAccountId').equals(accountId)
            .filter(g => g.isOnlineGroup && g.onlineGroupId === onlineGroupId)
            .toArray();
        
        if (groups.length === 0) {
            console.log('æœªæ‰¾åˆ°æœ¬åœ°è”æœºç¾¤èŠè®°å½•');
            return;
        }
        
        const group = groups[0];
        
        // æ·»åŠ æ¶ˆæ¯åˆ°èŠå¤©å†å²
        if (!group.chat_history) {
            group.chat_history = [];
        }
        
        // æ„å»ºæ¶ˆæ¯è®°å½•
        const chatMessage = {
            role: 'assistant', // ç¾¤èŠæ¶ˆæ¯è§†ä¸ºåŠ©æ‰‹æ¶ˆæ¯
            content: message.content,
            time: message.created_at || Date.now(),
            sender_name: message.sender_name,
            sender_type: message.sender_type,
            character_name: message.character_name
        };
        
        group.chat_history.push(chatMessage);
        group.updated_at = Date.now();
        
        await db.group_chats.put(group);
        
        // åˆ·æ–°èŠå¤©åˆ—è¡¨ï¼ˆå¦‚æœæ­£åœ¨æ˜¾ç¤ºï¼‰
        if (document.querySelector('.wechat-tab-item.active')?.innerText.includes('å¾®ä¿¡')) {
            renderWechatList(document.getElementById('wechat-content'));
        }
    } catch (e) {
        console.error('æ›´æ–°æœ¬åœ°è”æœºç¾¤èŠæ¶ˆæ¯å¤±è´¥:', e);
    }
}

// æ˜¾ç¤ºåŠ å…¥ç¾¤èŠå¼¹çª—ï¼ˆé€‰æ‹©è¦å¸¦å…¥çš„è§’è‰²ï¼‰
async function showJoinOnlineGroupModal(groupId, groupName) {
    // è·å–æ‰€æœ‰å¯ç”¨çš„è§’è‰²ï¼ˆéUserç±»å‹ï¼‰
    const chars = await db.characters.toArray();
    const availableChars = chars.filter(c => c.type !== 'user' && c.type !== 'online_friend');
    
    const modal = document.createElement('div');
    modal.id = 'join-group-modal';
    modal.style.cssText = `position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); z-index:10000; display:flex; align-items:center; justify-content:center;`;
    
    modal.innerHTML = `
        <div style="background:#fff; border-radius:16px; padding:24px; width:85%; max-width:360px;">
            <h3 style="margin:0 0 16px 0; text-align:center; font-size:18px;">åŠ å…¥ã€Œ${groupName}ã€</h3>
            
            <div style="margin-bottom:16px;">
                <div style="font-size:13px; color:#666; margin-bottom:8px;">é€‰æ‹©è¦å¸¦å…¥ç¾¤èŠçš„è§’è‰²ï¼ˆå¯é€‰ï¼‰ï¼š</div>
                <select id="join-group-char-select" style="width:100%; padding:12px; border:1px solid #ddd; border-radius:8px; font-size:14px;">
                    <option value="">ä¸å¸¦è§’è‰²</option>
                    ${availableChars.map(c => `<option value="${c.id}">${c.name}</option>`).join('')}
                </select>
            </div>
            
            <div style="font-size:12px; color:#999; margin-bottom:20px; line-height:1.5;">
                å¸¦å…¥è§’è‰²åï¼Œä½ å¯ä»¥åœ¨ç¾¤èŠä¸­è®©è¯¥è§’è‰²å‘è¨€ï¼ˆè°ƒç”¨AIï¼‰
            </div>
            
            <div style="display:flex; gap:12px;">
                <button onclick="this.closest('#join-group-modal').remove()" style="flex:1; padding:12px; background:#f0f0f0; color:#666; border:none; border-radius:8px; font-size:15px;">å–æ¶ˆ</button>
                <button onclick="doJoinOnlineGroup('${groupId}')" style="flex:1; padding:12px; background:var(--ins-pink); color:#fff; border:none; border-radius:8px; font-size:15px;">åŠ å…¥</button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
}

// æ‰§è¡ŒåŠ å…¥ç¾¤èŠ
async function doJoinOnlineGroup(groupId) {
    const charSelect = document.getElementById('join-group-char-select');
    const charId = charSelect?.value;
    
    let myChar = null;
    if (charId) {
        const char = await db.characters.get(parseInt(charId));
        if (char) {
            myChar = {
                name: char.name,
                avatar: char.avatar || '',
                desc: char.description?.substring(0, 200) || ''
            };
        }
    }
    
    // è·å–æˆ‘çš„ä¸Šçº¿å¾®ä¿¡å·
    const myWx = getMyOnlineWxAccount();
    if (!myWx) {
        alert('è¯·å…ˆä¸Šçº¿ä¸€ä¸ªè§’è‰²');
        return;
    }
    
    onlineSocket.send(JSON.stringify({
        type: 'join_online_group',
        group_id: groupId,
        my_wx_account: myWx,
        my_character: myChar
    }));
    
    document.getElementById('join-group-modal')?.remove();
}

// è·å–æˆ‘å½“å‰ä¸Šçº¿çš„å¾®ä¿¡å·
function getMyOnlineWxAccount() {
    if (!onlineCharacters || onlineCharacters.length === 0) return null;
    return onlineCharacters[0]?.wx_account;
}

// æ˜¾ç¤ºåˆ›å»ºè”æœºç¾¤èŠå¼¹çª—
async function showCreateOnlineGroupModal() {
    if (!onlineConnected || !onlineUserData) {
        alert('è¯·å…ˆè¿æ¥æœåŠ¡å™¨å¹¶ç™»å½•');
        return;
    }
    
    // è·å–è”æœºå¥½å‹åˆ—è¡¨
    const friends = await db.characters.where('type').equals('online_friend').toArray();
    
    // è·å–å¯é€‰çš„è§’è‰²ï¼ˆéUserç±»å‹ï¼‰
    const chars = await db.characters.toArray();
    const availableChars = chars.filter(c => c.type !== 'user' && c.type !== 'online_friend');
    
    const modal = document.createElement('div');
    modal.id = 'create-online-group-modal';
    modal.style.cssText = `position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); z-index:10000; display:flex; align-items:center; justify-content:center;`;
    
    modal.innerHTML = `
        <div style="background:#fff; border-radius:16px; width:90%; max-width:400px; max-height:80vh; display:flex; flex-direction:column;">
            <div style="padding:16px 20px; border-bottom:1px solid #f0f0f0; display:flex; justify-content:space-between; align-items:center;">
                <span style="font-size:17px; font-weight:600;">åˆ›å»ºè”æœºç¾¤èŠ</span>
                <button onclick="this.closest('#create-online-group-modal').remove()" style="background:none; border:none; font-size:20px; color:#999; cursor:pointer;">Ã—</button>
            </div>
            
            <div style="flex:1; overflow-y:auto; padding:20px;">
                <div style="margin-bottom:16px;">
                    <label style="font-size:13px; color:#666; display:block; margin-bottom:6px;">ç¾¤åç§°</label>
                    <input type="text" id="og-name" placeholder="è¾“å…¥ç¾¤èŠåç§°" style="width:100%; padding:12px; border:1px solid #ddd; border-radius:8px; font-size:14px; box-sizing:border-box;">
                </div>
                
                <div style="margin-bottom:16px;">
                    <label style="font-size:13px; color:#666; display:block; margin-bottom:6px;">é€‰æ‹©æˆ‘è¦å¸¦å…¥çš„è§’è‰²ï¼ˆå¯é€‰ï¼‰</label>
                    <select id="og-my-char" style="width:100%; padding:12px; border:1px solid #ddd; border-radius:8px; font-size:14px;">
                        <option value="">ä¸å¸¦è§’è‰²</option>
                        ${availableChars.map(c => `<option value="${c.id}">${c.name}</option>`).join('')}
                    </select>
                </div>
                
                <div style="margin-bottom:16px;">
                    <label style="font-size:13px; color:#666; display:block; margin-bottom:6px;">é‚€è¯·è”æœºå¥½å‹ï¼ˆå¯å¤šé€‰ï¼‰</label>
                    <div id="og-friends-list" style="max-height:200px; overflow-y:auto; border:1px solid #ddd; border-radius:8px;">
                        ${friends.length === 0 ? 
                            `<div style="padding:20px; text-align:center; color:#999;">æš‚æ— è”æœºå¥½å‹</div>` :
                            friends.map(f => `
                                <label style="display:flex; align-items:center; padding:10px 12px; border-bottom:1px solid #f5f5f5; cursor:pointer;">
                                    <input type="checkbox" value="${f.onlineData?.wx_account || ''}" style="margin-right:10px;">
                                    <div style="width:36px; height:36px; border-radius:6px; background-image:url(${f.avatar}); background-size:cover; background-color:#e0e0e0; margin-right:10px;"></div>
                                    <span style="font-size:14px;">${f.name}</span>
                                </label>
                            `).join('')
                        }
                    </div>
                </div>
            </div>
            
            <div style="padding:16px 20px; border-top:1px solid #f0f0f0;">
                <button onclick="doCreateOnlineGroup()" style="width:100%; padding:14px; background:var(--ins-pink); color:#fff; border:none; border-radius:10px; font-size:16px; font-weight:500;">åˆ›å»ºç¾¤èŠ</button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
}

// æ‰§è¡Œåˆ›å»ºè”æœºç¾¤èŠ
async function doCreateOnlineGroup() {
    const name = document.getElementById('og-name').value.trim();
    if (!name) {
        alert('è¯·è¾“å…¥ç¾¤åç§°');
        return;
    }
    
    const myWx = getMyOnlineWxAccount();
    if (!myWx) {
        alert('è¯·å…ˆä¸Šçº¿ä¸€ä¸ªè§’è‰²');
        return;
    }
    
    // è·å–é€‰æ‹©çš„è§’è‰²
    let myChar = null;
    const charId = document.getElementById('og-my-char').value;
    if (charId) {
        const char = await db.characters.get(parseInt(charId));
        if (char) {
            myChar = {
                name: char.name,
                avatar: char.avatar || '',
                desc: char.description?.substring(0, 200) || ''
            };
        }
    }
    
    // è·å–é‚€è¯·çš„å¥½å‹
    const checkboxes = document.querySelectorAll('#og-friends-list input[type="checkbox"]:checked');
    const inviteWxs = Array.from(checkboxes).map(cb => cb.value).filter(v => v);
    
    onlineSocket.send(JSON.stringify({
        type: 'create_online_group',
        name: name,
        my_wx_account: myWx,
        invite_wx_accounts: inviteWxs,
        my_character: myChar
    }));
    
    document.getElementById('create-online-group-modal')?.remove();
}

// æ‰“å¼€è”æœºç¾¤èŠ
function openOnlineGroup(groupId) {
    currentOnlineGroupId = groupId;
    currentOnlineGroupMessages = [];
    currentOnlineGroupMembers = [];
    
    const group = onlineGroups.find(g => g.id === groupId);
    if (!group) return;
    
    // æ˜¾ç¤ºç¾¤èŠé¡µé¢
    showOnlineGroupChatPage(group);
    
    // åº”ç”¨èƒŒæ™¯å›¾ï¼ˆå»¶è¿Ÿä¸€ä¸‹ç¡®ä¿é¡µé¢å·²åˆ›å»ºï¼‰
    setTimeout(() => {
        applyOnlineGroupBackground(groupId);
    }, 100);
    
    // è¯·æ±‚ç¾¤æˆå‘˜
    const myWx = getMyOnlineWxAccount();
    if (myWx) {
        onlineSocket.send(JSON.stringify({
            type: 'get_group_members',
            group_id: groupId,
            my_wx_account: myWx
        }));
        
        // è¯·æ±‚æ¶ˆæ¯è®°å½•
        onlineSocket.send(JSON.stringify({
            type: 'get_group_messages',
            group_id: groupId,
            my_wx_account: myWx,
            limit: 100
        }));
    }
}

// æ˜¾ç¤ºè”æœºç¾¤èŠé¡µé¢
function showOnlineGroupChatPage(group) {
    // åˆ›å»ºæˆ–æ˜¾ç¤ºç¾¤èŠé¡µé¢
    let page = document.getElementById('online-group-chat-page');
    if (!page) {
        page = document.createElement('div');
        page.id = 'online-group-chat-page';
        page.style.cssText = `position:fixed; top:0; left:0; right:0; bottom:0; background:#ffffff; z-index:300; display:flex; flex-direction:column;`;
        document.body.appendChild(page);
    }
    
    page.innerHTML = `
        <div class="wechat-header" style="background:#fff; border-bottom:1px solid #f0f0f0;">
            <div class="back-btn" onclick="hideOnlineGroupChat()" style="margin:0; background:none; width:40px; justify-content:flex-start; color:#333;">
                <svg class="svg-icon" viewBox="0 0 24 24" style="width:24px; height:24px;"><polyline points="15 18 9 12 15 6"></polyline></svg>
            </div>
            <div class="wechat-title" id="online-group-chat-title" style="flex:1; text-align:center;">${group.name}</div>
            <div onclick="showOnlineGroupInfo('${group.id}')" style="width:40px; display:flex; justify-content:flex-end; cursor:pointer;">
                <svg viewBox="0 0 24 24" style="width:20px; height:20px; stroke:#333; fill:none;"><circle cx="12" cy="12" r="1"></circle><circle cx="19" cy="12" r="1"></circle><circle cx="5" cy="12" r="1"></circle></svg>
            </div>
        </div>
        
        <div id="online-group-messages" style="flex:1; overflow-y:auto; padding:16px;">
            <div style="text-align:center; padding:20px; color:#999;">åŠ è½½ä¸­...</div>
        </div>
        
        <div class="chat-footer" id="online-group-footer">
            <div class="chat-input-bar">
                <!-- å·¦ä¾§ï¼šç”ŸæˆæŒ‰é’® (è®©è§’è‰²è¯´è¯) -->
                <div class="chat-icon-btn" onclick="letMyCharacterSpeak()" title="è®©è§’è‰²è¯´è¯">
                    <svg class="svg-icon" viewBox="0 0 24 24"><path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z"/><path d="M5 3v4"/><path d="M9 5H1"/></svg>
                </div>
                
                <!-- ä¸­é—´ï¼šè¾“å…¥æ¡† -->
                <input type="text" class="chat-input" id="online-group-input" placeholder="å‘é€æ¶ˆæ¯..." onfocus="closeOnlineGroupPanel()">
                
                <!-- å³ä¾§ï¼šè¡¨æƒ… -->
                <div class="chat-icon-btn" onclick="toggleOnlineGroupPanel('emoji')">
                    <svg class="svg-icon" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><path d="M8 14s1.5 2 4 2 4-2 4-2"></path><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line></svg>
                </div>
                
                <!-- å³ä¾§ï¼šèœå• (+) -->
                <div class="chat-icon-btn" id="online-group-btn-more" onclick="toggleOnlineGroupPanel('action')">
                    <svg class="svg-icon" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line></svg>
                </div>
                
                <!-- å³ä¾§ï¼šå‘é€ (Send) - é»˜è®¤éšè— -->
                <div class="chat-send-btn" id="online-group-btn-send" onclick="sendOnlineGroupMsg()">
                    <svg class="svg-icon" viewBox="0 0 24 24" style="width:18px; height:18px; stroke-width:3; transform: rotate(90deg) translateX(-2px);"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
                </div>
            </div>
            
            <!-- é¢æ¿å®¹å™¨ -->
            <div class="chat-panel-container" id="online-group-panel-container">
                <!-- è¡¨æƒ…åŒ… Tab -->
                <div style="height: 40px; display: flex; border-bottom: 1px solid #eee; background: #fff;" id="online-group-emoji-tab-bar">
                    <div class="wechat-tab-item active" onclick="switchOnlineGroupEmojiTab('emoji')" style="flex:1; font-size:14px;">Emoji</div>
                    <div class="wechat-tab-item" onclick="switchOnlineGroupEmojiTab('sticker')" style="flex:1; font-size:14px;">è¡¨æƒ…åŒ…</div>
                </div>
                <!-- Emoji é¢æ¿ -->
                <div class="emoji-panel" id="online-group-emoji-panel" style="height: calc(100% - 40px);">
                    <!-- åŠ¨æ€ç”Ÿæˆè¡¨æƒ… -->
                </div>
                <!-- è‡ªå®šä¹‰è¡¨æƒ…åŒ…é¢æ¿ -->
                <div class="emoji-panel" id="online-group-sticker-panel" style="height: calc(100% - 40px); display: none; grid-template-columns: repeat(4, 1fr);">
                    <!-- åŠ¨æ€ç”Ÿæˆè‡ªå®šä¹‰è¡¨æƒ… -->
                    <div style="text-align:center; grid-column:span 4; color:#999; margin-top:20px;">æš‚æ— è¡¨æƒ…åŒ…<br>è¯·åœ¨è¯¦æƒ…é¡µæ·»åŠ </div>
                </div>

                <!-- åŠŸèƒ½èœå•é¢æ¿ -->
                <div class="action-panel" id="online-group-action-panel">
                    <div class="action-item" onclick="onlineGroupVoiceInput()">
                        <div class="action-icon-box">
                            <svg class="svg-icon" viewBox="0 0 24 24"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line></svg>
                        </div>
                        <div class="action-name">è¯­éŸ³è¾“å…¥</div>
                    </div>
                    <div class="action-item" onclick="onlineGroupSendImage()">
                        <div class="action-icon-box">
                            <svg class="svg-icon" viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>
                        </div>
                        <div class="action-name">ç›¸å†Œ</div>
                    </div>
                    <div class="action-item" onclick="onlineGroupTransfer()">
                        <div class="action-icon-box transfer-icon">
                            <svg class="svg-icon" viewBox="0 0 24 24"><path d="M17 1l4 4-4 4"></path><path d="M3 11V9a4 4 0 0 1 4-4h14"></path><path d="M7 23l-4-4 4-4"></path><path d="M21 13v2a4 4 0 0 1-4 4H3"></path></svg>
                        </div>
                        <div class="action-name">è½¬è´¦</div>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    page.style.display = 'flex';
    
    // ç»‘å®šå›è½¦å‘é€
    const input = document.getElementById('online-group-input');
    input.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') sendOnlineGroupMsg();
    });
    
    // ç»‘å®šè¾“å…¥å˜åŒ–äº‹ä»¶ï¼Œæ§åˆ¶å‘é€æŒ‰é’®æ˜¾ç¤º
    input.addEventListener('input', function() {
        const btnSend = document.getElementById('online-group-btn-send');
        const btnMore = document.getElementById('online-group-btn-more');
        if (this.value.trim()) {
            btnSend.style.display = 'flex';
            btnMore.style.display = 'none';
        } else {
            btnSend.style.display = 'none';
            btnMore.style.display = 'flex';
        }
    });
    
    // åˆå§‹åŒ–Emojié¢æ¿
    initOnlineGroupEmojiPanel();
    
    // åº”ç”¨èƒŒæ™¯å›¾
    applyOnlineGroupBackground(group.id);
}

// éšè—è”æœºç¾¤èŠé¡µé¢
function hideOnlineGroupChat() {
    const page = document.getElementById('online-group-chat-page');
    if (page) page.style.display = 'none';
    currentOnlineGroupId = null;
}

// å¤„ç†ç¾¤èŠæ¶ˆæ¯è®°å½•
function handleOnlineGroupMessages(data) {
    if (data.group_id !== currentOnlineGroupId) return;
    currentOnlineGroupMessages = data.messages || [];
    // æŒ‰æ—¶é—´æˆ³æ’åºï¼Œç¡®ä¿æ¶ˆæ¯é¡ºåºæ­£ç¡®
    currentOnlineGroupMessages.sort((a, b) => (a.created_at || 0) - (b.created_at || 0));
    renderOnlineGroupMessages();
}

// å¤„ç†å®æ—¶ç¾¤æ¶ˆæ¯
async function handleOnlineGroupMessage(data) {
    // æ›´æ–°æœ¬åœ°ç¾¤èŠè®°å½•ï¼Œè®©æ¶ˆæ¯åˆ—è¡¨æ˜¾ç¤ºæœ€æ–°æ¶ˆæ¯
    await updateLocalOnlineGroupLastMessage(data.group_id, data.message);
    
    if (data.group_id !== currentOnlineGroupId) {
        // ä¸æ˜¯å½“å‰ç¾¤ï¼Œæ˜¾ç¤ºé€šçŸ¥
        showToast(`[${data.message.sender_name}] ${data.message.content.substring(0, 20)}...`);
        return;
    }
    
    // å¦‚æœæ˜¯ç³»ç»Ÿæ¶ˆæ¯ï¼Œæ£€æŸ¥æ˜¯å¦æ˜¯çº¢åŒ…é¢†å–é€šçŸ¥ï¼Œå¦‚æœæ˜¯åˆ™æ›´æ–°çº¢åŒ…çŠ¶æ€
    if (data.message.msg_type === 'system' && data.message.content.includes('é¢†å–äº†çº¢åŒ…')) {
        // å°è¯•ä»ç³»ç»Ÿæ¶ˆæ¯ä¸­æå–çº¢åŒ…IDå’Œé¢†å–è€…ä¿¡æ¯
        // æ ¼å¼ï¼šXXX é¢†å–äº†çº¢åŒ…ï¼Œè·å¾— Â¥X.XX
        // ç”±äºæˆ‘ä»¬æ— æ³•ä»ç³»ç»Ÿæ¶ˆæ¯ä¸­ç›´æ¥è·å–çº¢åŒ…IDï¼Œè¿™é‡Œåªæ›´æ–°æ˜¾ç¤º
        // å®é™…çš„çº¢åŒ…çŠ¶æ€æ›´æ–°åœ¨ claimOnlineGroupRedPacket ä¸­å®Œæˆ
    }
    
    currentOnlineGroupMessages.push(data.message);
    // æŒ‰æ—¶é—´æˆ³æ’åºï¼Œç¡®ä¿æ¶ˆæ¯é¡ºåºæ­£ç¡®
    currentOnlineGroupMessages.sort((a, b) => (a.created_at || 0) - (b.created_at || 0));
    renderOnlineGroupMessages();
}

// å¤„ç†ç¾¤æˆå‘˜å¼€å§‹è¾“å…¥
function handleGroupTypingStart(data) {
    // åªåœ¨å½“å‰æ‰“å¼€çš„ç¾¤èŠä¸­æ˜¾ç¤º
    if (data.group_id !== currentOnlineGroupId) return;
    
    const chatTitleEl = document.getElementById('online-group-chat-title');
    if (chatTitleEl) {
        chatTitleEl.innerText = `${data.character_name} æ­£åœ¨è¾“å…¥ä¸­...`;
    }
}

// å¤„ç†ç¾¤æˆå‘˜åœæ­¢è¾“å…¥
function handleGroupTypingStop(data) {
    // åªåœ¨å½“å‰æ‰“å¼€çš„ç¾¤èŠä¸­æ˜¾ç¤º
    if (data.group_id !== currentOnlineGroupId) return;
    
    const chatTitleEl = document.getElementById('online-group-chat-title');
    const group = onlineGroups.find(g => g.id === currentOnlineGroupId);
    if (chatTitleEl && group) {
        chatTitleEl.innerText = group.name;
    }
}

// æ¸²æŸ“ç¾¤èŠæ¶ˆæ¯
function renderOnlineGroupMessages() {
    const container = document.getElementById('online-group-messages');
    if (!container) return;
    
    const myWx = getMyOnlineWxAccount();
    
    container.innerHTML = currentOnlineGroupMessages.map(msg => {
        // å¤„ç†ç³»ç»Ÿæ¶ˆæ¯
        if (msg.msg_type === 'system' || msg.sender_type === 'system') {
            return `<div style="text-align:center; padding:8px 16px; margin:8px 0;">
                <span style="background:#fff; color:#999; font-size:12px; padding:4px 12px; border-radius:4px; border:1px solid #ddd;">${msg.content}</span>
            </div>`;
        }
        
        const isCharacter = msg.sender_type === 'character';
        // åªæœ‰æˆ‘å‘çš„çœŸäººæ¶ˆæ¯æ‰æ˜¾ç¤ºåœ¨å³è¾¹ï¼Œæ‰€æœ‰è§’è‰²æ¶ˆæ¯ï¼ˆåŒ…æ‹¬æˆ‘çš„è§’è‰²ï¼‰éƒ½æ˜¾ç¤ºåœ¨å·¦è¾¹
        const isMe = msg.sender_wx === myWx && !isCharacter;
        const avatar = isCharacter ? (msg.character_avatar || '') : (msg.sender_avatar || '');
        const name = isCharacter ? `${msg.character_name} (${msg.sender_name})` : msg.sender_name;
        // ç¡®ä¿å¤´åƒURLä¸ä¸ºç©ºå­—ç¬¦ä¸²æ‰è®¾ç½®èƒŒæ™¯å›¾
        const avatarStyle = (avatar && avatar.trim()) ? `background-image:url(${avatar})` : 'background:#ccc';
        
        let messageContent = '';
        let isSpecialMsg = false;
        
        // å°è¯•è§£æJSONæ¶ˆæ¯ï¼ˆè¯­éŸ³ã€è½¬è´¦ç­‰ç‰¹æ®Šæ¶ˆæ¯ï¼‰
        let parsedContent = null;
        try {
            if (msg.content && msg.content.startsWith('{') && msg.content.includes('__type')) {
                parsedContent = JSON.parse(msg.content);
            }
        } catch(e) {}
        
        // å¤„ç†è¯­éŸ³æ¶ˆæ¯
        if (parsedContent && parsedContent.__type === 'audio') {
            isSpecialMsg = true;
            const audioId = 'online_group_audio_' + (msg.id || msg.created_at);
            const effectIcon = parsedContent.effect === 'loli' ? 'ğŸ€' : 
                              parsedContent.effect === 'uncle' ? 'ğŸ§”' :
                              parsedContent.effect === 'robot' ? 'ğŸ¤–' : 'ğŸ™ï¸';
            messageContent = `
                <div class="online-audio-bubble" style="min-width:120px; max-width:200px; padding:10px 14px; background:${isMe ? '#ffe4e8' : '#f2f2f7'}; border-radius:18px; display:flex; align-items:center; gap:10px; cursor:pointer;" onclick="playOnlineGroupAudio('${audioId}')">
                    <div class="audio-play-icon" id="icon_${audioId}" data-original="${effectIcon}" style="font-size:20px;">${effectIcon}</div>
                    <div style="flex:1; display:flex; flex-direction:column;">
                        <div style="height:20px; background:#fff; border-radius:10px; position:relative; overflow:hidden;">
                            <div style="height:100%; background:var(--ins-pink); width:0%; transition:width 0.1s;" id="progress_${audioId}"></div>
                        </div>
                        <div style="font-size:11px; color:#999; margin-top:2px;">${parsedContent.duration}"</div>
                    </div>
                    <audio id="${audioId}" src="${parsedContent.audio}" style="display:none;"></audio>
                </div>
            `;
        }
        // å¤„ç†çº¢åŒ…æ¶ˆæ¯
        else if (msg.msg_type === 'redpacket') {
            isSpecialMsg = true;
            try {
                const data = JSON.parse(msg.content);
                const msgId = msg.id || ('rp_' + msg.created_at);
                const claimedCount = (data.claimed || []).length;
                const isAllClaimed = claimedCount >= data.count;
                const myWx = getMyOnlineWxAccount();
                const hasClaimed = data.claimed?.includes(myWx) || false;
                
                messageContent = `<div onclick="showOnlineGroupRedPacketDetail('${msgId}')" style="width:220px; background:#fff; border-radius:12px; overflow:hidden; box-shadow:0 1px 3px rgba(0,0,0,0.08); border:1px solid #eee; cursor:pointer;">
                    <div style="padding:14px 16px; display:flex; align-items:center; gap:12px; background:linear-gradient(135deg, #ff6b6b 0%, #ff8e8e 100%);">
                        <div style="width:40px; height:40px; background:#fff; border-radius:10px; display:flex; align-items:center; justify-content:center; border:1px solid rgba(255,255,255,0.3);">
                            <svg viewBox="0 0 24 24" style="width:20px; height:20px; stroke:#ff6b6b; fill:#ff6b6b; stroke-width:1.5;"><rect x="3" y="4" width="18" height="16" rx="2"/><path d="M3 10h18"/><circle cx="12" cy="15" r="2"/></svg>
                        </div>
                        <div style="flex:1;">
                            <div style="font-size:13px; color:rgba(255,255,255,0.9); margin-bottom:2px;">${escapeHtml(data.wish || 'æ­å–œå‘è´¢')}</div>
                            <div style="font-size:11px; color:rgba(255,255,255,0.7);">${data.redpacketType === 'lucky' ? 'æ‹¼æ‰‹æ°”çº¢åŒ…' : 'æ™®é€šçº¢åŒ…'}</div>
                        </div>
                    </div>
                    <div style="padding:8px 16px; display:flex; justify-content:space-between; align-items:center; border-top:1px solid #eee;">
                        <span style="font-size:11px; color:#999;">${isAllClaimed ? 'å·²é¢†å®Œ' : `${claimedCount}/${data.count}ä¸ªå·²é¢†å–`}</span>
                        <span style="font-size:11px; color:#999;">${hasClaimed ? 'å·²é¢†å–' : isAllClaimed ? 'å·²é¢†å®Œ' : 'é¢†å–'}</span>
                    </div>
                </div>`;
            } catch(e) {
                messageContent = renderMessageContent(msg.content);
                isSpecialMsg = false;
            }
        }
        // å¤„ç†è½¬è´¦æ¶ˆæ¯
        else if (msg.msg_type === 'transfer') {
            isSpecialMsg = true;
            try {
                const data = JSON.parse(msg.content);
                const msgId = msg.id || ('trans_' + msg.created_at);
                const targetHint = data.targetName ? `è½¬ç»™ ${data.targetName}` : 'è½¬è´¦';
                messageContent = `<div onclick="receiveOnlineGroupTransfer('${msgId}')" style="width:220px; background:#fff; border-radius:12px; overflow:hidden; box-shadow:0 1px 3px rgba(0,0,0,0.08); border:1px solid #eee; cursor:pointer;">
                    <div style="padding:14px 16px; display:flex; align-items:center; gap:12px;">
                        <div style="width:40px; height:40px; background:#fff; border-radius:10px; display:flex; align-items:center; justify-content:center; border:1px solid #eee;">
                            <svg viewBox="0 0 24 24" style="width:20px; height:20px; stroke:#666; fill:none; stroke-width:1.5;"><path d="M17 1l4 4-4 4"/><path d="M3 11V9a4 4 0 0 1 4-4h14"/><path d="M7 23l-4-4 4-4"/><path d="M21 13v2a4 4 0 0 1-4 4H3"/></svg>
                        </div>
                        <div style="flex:1;">
                            <div style="font-size:18px; font-weight:600; color:#333; margin-bottom:2px;">Â¥${data.amount}</div>
                            <div style="font-size:12px; color:#999;">${escapeHtml(data.desc || 'è½¬è´¦')}</div>
                        </div>
                    </div>
                    <div style="padding:8px 16px; display:flex; justify-content:space-between; align-items:center; border-top:1px solid #eee;">
                        <span style="font-size:11px; color:#999;">${targetHint}</span>
                        <span style="font-size:11px; color:#999;">${data.status === 'received' ? 'å·²æ”¶æ¬¾' : 'å¾…æ”¶æ¬¾'}</span>
                    </div>
                </div>`;
            } catch(e) {
                messageContent = renderMessageContent(msg.content);
                isSpecialMsg = false;
            }
        } else {
            // æ™®é€šæ¶ˆæ¯
            messageContent = renderMessageContent(msg.content);
        }
        
        // å®Œå…¨æŒ‰ç…§æ™®é€šç¾¤èŠçš„æ ·å¼
        if (isMe) {
            // æˆ‘å‘çš„æ¶ˆæ¯
            if (isSpecialMsg) {
                return `
                    <div style="display:flex; flex-direction:row-reverse; align-items:flex-end; gap:8px; margin-bottom:12px;">
                        <div style="width:32px; height:32px; border-radius:50%; ${avatarStyle}; background-size:cover; background-position:center; flex-shrink:0; margin-bottom:2px;"></div>
                        <div style="display:flex; flex-direction:column; align-items:flex-end; max-width:70%;">
                            <div style="font-size:12px; color:#999; margin-bottom:2px;">${name}${isCharacter ? ' ğŸ­' : ''}</div>
                            <div style="display:flex; align-items:flex-end; gap:6px;">
                                <div style="font-size:10px; color:#999;">${formatChatTime(msg.created_at)}</div>
                                <div>${messageContent}</div>
                            </div>
                        </div>
                    </div>
                `;
            } else {
                return `
                    <div style="display:flex; flex-direction:row-reverse; align-items:flex-end; gap:8px; margin-bottom:12px;">
                        <div style="width:32px; height:32px; border-radius:50%; ${avatarStyle}; background-size:cover; background-position:center; flex-shrink:0; margin-bottom:2px;"></div>
                        <div style="display:flex; flex-direction:column; align-items:flex-end; max-width:70%;">
                            <div style="font-size:12px; color:#999; margin-bottom:2px;">${name}${isCharacter ? ' ğŸ­' : ''}</div>
                            <div style="display:flex; align-items:flex-end; gap:6px;">
                                <div style="font-size:10px; color:#999;">${formatChatTime(msg.created_at)}</div>
                                <div style="background:#ffe4e8; color:#000; padding:6px 10px; border-radius:18px 18px 4px 18px; font-size:15px; line-height:1.5; word-break:break-word;">${messageContent}</div>
                            </div>
                        </div>
                    </div>
                `;
            }
        } else {
            // åˆ«äººå‘çš„æ¶ˆæ¯
            if (isSpecialMsg) {
                return `
                    <div style="display:flex; align-items:flex-end; gap:8px; margin-bottom:12px;">
                        <div style="width:32px; height:32px; border-radius:50%; ${avatarStyle}; background-size:cover; background-position:center; flex-shrink:0; margin-bottom:2px;"></div>
                        <div style="display:flex; flex-direction:column; max-width:70%;">
                            <div style="font-size:12px; color:#999; margin-bottom:2px;">${name}${isCharacter ? ' ğŸ­' : ''}</div>
                            <div style="display:flex; align-items:flex-end; gap:6px;">
                                <div>${messageContent}</div>
                                <div style="font-size:10px; color:#999;">${formatChatTime(msg.created_at)}</div>
                            </div>
                        </div>
                    </div>
                `;
            } else {
                return `
                    <div style="display:flex; align-items:flex-end; gap:8px; margin-bottom:12px;">
                        <div style="width:32px; height:32px; border-radius:50%; ${avatarStyle}; background-size:cover; background-position:center; flex-shrink:0; margin-bottom:2px;"></div>
                        <div style="display:flex; flex-direction:column; max-width:70%;">
                            <div style="font-size:12px; color:#999; margin-bottom:2px;">${name}${isCharacter ? ' ğŸ­' : ''}</div>
                            <div style="display:flex; align-items:flex-end; gap:6px;">
                                <div style="background:#f2f2f7; color:#000; padding:6px 10px; border-radius:18px 18px 18px 4px; font-size:15px; line-height:1.5; word-break:break-word;">${messageContent}</div>
                                <div style="font-size:10px; color:#999;">${formatChatTime(msg.created_at)}</div>
                            </div>
                        </div>
                    </div>
                `;
            }
        }
    }).join('');
    
    // ä¸ºå›¾ç‰‡æ·»åŠ ç‚¹å‡»äº‹ä»¶
    container.querySelectorAll('.chat-image').forEach(img => {
        img.onclick = () => showFullImage(img.src);
    });
    
    container.scrollTop = container.scrollHeight;
}

// æ”¶å–è”æœºç¾¤èŠè½¬è´¦
function receiveOnlineGroupTransfer(msgId) {
    showToast('è½¬è´¦åŠŸèƒ½æš‚ä¸æ”¯æŒæ”¶å–ï¼Œä»…ç”¨äºå±•ç¤º');
}

// æ’­æ”¾è”æœºç¾¤èŠè¯­éŸ³æ¶ˆæ¯
let currentPlayingOnlineGroupAudio = null;
function playOnlineGroupAudio(audioId) {
    const audio = document.getElementById(audioId);
    const icon = document.getElementById('icon_' + audioId);
    const progress = document.getElementById('progress_' + audioId);
    
    if (!audio) return;
    
    // å¦‚æœæœ‰å…¶ä»–æ­£åœ¨æ’­æ”¾çš„ï¼Œå…ˆåœæ­¢
    if (currentPlayingOnlineGroupAudio && currentPlayingOnlineGroupAudio !== audio) {
        currentPlayingOnlineGroupAudio.pause();
        currentPlayingOnlineGroupAudio.currentTime = 0;
        // é‡ç½®ä¹‹å‰éŸ³é¢‘çš„å›¾æ ‡å’Œè¿›åº¦æ¡
        const prevIcon = document.getElementById('icon_' + currentPlayingOnlineGroupAudio.id);
        const prevProgress = document.getElementById('progress_' + currentPlayingOnlineGroupAudio.id);
        if (prevIcon) {
            const bubble = currentPlayingOnlineGroupAudio.closest('.online-audio-bubble');
            if (bubble) {
                const originalIcon = bubble.querySelector('.audio-play-icon');
                if (originalIcon) prevIcon.textContent = prevIcon.dataset.original || 'ğŸ™ï¸';
            }
        }
        if (prevProgress) prevProgress.style.width = '0%';
    }
    
    if (audio.paused) {
        audio.play();
        currentPlayingOnlineGroupAudio = audio;
        if (icon) icon.textContent = 'â¸ï¸';
        
        // æ›´æ–°è¿›åº¦æ¡
        audio.ontimeupdate = () => {
            if (progress && audio.duration) {
                const percent = (audio.currentTime / audio.duration) * 100;
                progress.style.width = percent + '%';
            }
        };
        
        audio.onended = () => {
            if (icon) icon.textContent = icon.dataset.original || 'ğŸ™ï¸';
            if (progress) progress.style.width = '0%';
            currentPlayingOnlineGroupAudio = null;
        };
    } else {
        audio.pause();
        audio.currentTime = 0;
        if (icon) icon.textContent = icon.dataset.original || 'ğŸ™ï¸';
        if (progress) progress.style.width = '0%';
        currentPlayingOnlineGroupAudio = null;
    }
}

// å¤„ç†ç¾¤æˆå‘˜åˆ—è¡¨
function handleOnlineGroupMembers(data) {
    if (data.group_id !== currentOnlineGroupId) return;
    currentOnlineGroupMembers = data.members || [];
    
    // æ‰¾åˆ°æˆ‘çš„è§’è‰²
    const myWx = getMyOnlineWxAccount();
    const myMember = currentOnlineGroupMembers.find(m => m.user_wx === myWx);
    if (myMember && myMember.character_name) {
        myOnlineGroupCharacter = {
            name: myMember.character_name,
            avatar: myMember.character_avatar,
            desc: myMember.character_desc
        };
    } else {
        myOnlineGroupCharacter = null;
    }
}

// åˆ‡æ¢è”æœºç¾¤èŠé¢æ¿
let currentOnlineGroupPanel = null;
function toggleOnlineGroupPanel(panelType) {
    const container = document.getElementById('online-group-panel-container');
    const emojiTabBar = document.getElementById('online-group-emoji-tab-bar');
    const emojiPanel = document.getElementById('online-group-emoji-panel');
    const stickerPanel = document.getElementById('online-group-sticker-panel');
    const actionPanel = document.getElementById('online-group-action-panel');
    
    if (!container) {
        console.error('[Panel] Missing container!');
        return;
    }
    
    if (currentOnlineGroupPanel === panelType) {
        // å…³é—­é¢æ¿
        container.classList.remove('open');
        if (emojiTabBar) emojiTabBar.style.display = 'none';
        if (emojiPanel) emojiPanel.style.display = 'none';
        if (stickerPanel) stickerPanel.style.display = 'none';
        if (actionPanel) actionPanel.style.display = 'none';
        currentOnlineGroupPanel = null;
    } else {
        // æ‰“å¼€é¢æ¿
        container.classList.add('open');
        if (panelType === 'emoji') {
            if (emojiTabBar) emojiTabBar.style.display = 'flex';
            if (emojiPanel) emojiPanel.style.display = 'grid';
            if (stickerPanel) stickerPanel.style.display = 'none';
            if (actionPanel) actionPanel.style.display = 'none';
        } else if (panelType === 'action') {
            if (emojiTabBar) emojiTabBar.style.display = 'none';
            if (emojiPanel) emojiPanel.style.display = 'none';
            if (stickerPanel) stickerPanel.style.display = 'none';
            if (actionPanel) actionPanel.style.display = 'grid';
        }
        currentOnlineGroupPanel = panelType;
    }
}

// å…³é—­è”æœºç¾¤èŠé¢æ¿
function closeOnlineGroupPanel() {
    const container = document.getElementById('online-group-panel-container');
    if (container) {
        container.classList.remove('open');
    }
    const emojiTabBar = document.getElementById('online-group-emoji-tab-bar');
    const emojiPanel = document.getElementById('online-group-emoji-panel');
    const stickerPanel = document.getElementById('online-group-sticker-panel');
    const actionPanel = document.getElementById('online-group-action-panel');
    if (emojiTabBar) emojiTabBar.style.display = 'none';
    if (emojiPanel) emojiPanel.style.display = 'none';
    if (stickerPanel) stickerPanel.style.display = 'none';
    if (actionPanel) actionPanel.style.display = 'none';
    currentOnlineGroupPanel = null;
}

// åˆ‡æ¢è”æœºç¾¤èŠè¡¨æƒ…Tab
async function switchOnlineGroupEmojiTab(type) {
    const tabs = document.querySelectorAll('#online-group-emoji-tab-bar .wechat-tab-item');
    const emojiPanel = document.getElementById('online-group-emoji-panel');
    const stickerPanel = document.getElementById('online-group-sticker-panel');

    if (type === 'emoji') {
        tabs[0].classList.add('active');
        tabs[1].classList.remove('active');
        emojiPanel.style.display = 'grid';
        stickerPanel.style.display = 'none';
    } else {
        tabs[0].classList.remove('active');
        tabs[1].classList.add('active');
        emojiPanel.style.display = 'none';
        stickerPanel.style.display = 'grid';
        // åŠ è½½è‡ªå®šä¹‰è¡¨æƒ…åŒ…
        await loadOnlineGroupStickers();
    }
}

// åŠ è½½è”æœºç¾¤èŠçš„è‡ªå®šä¹‰è¡¨æƒ…åŒ…
async function loadOnlineGroupStickers() {
    const stickerPanel = document.getElementById('online-group-sticker-panel');
    if (!stickerPanel) return;
    
    let html = '';
    
    // è·å–æ‰€æœ‰è¡¨æƒ…åŒ…åˆ†ç±»
    const allCategories = await db.sticker_categories.toArray();
    
    if (allCategories.length === 0) {
        stickerPanel.innerHTML = `<div style="text-align:center; grid-column:span 4; color:#999; margin-top:20px;">æš‚æ— è¡¨æƒ…åŒ…<br>è¯·å»ã€æˆ‘-è¡¨æƒ…ã€‘æ·»åŠ </div>`;
        return;
    }
    
    // æ˜¾ç¤ºæ‰€æœ‰åˆ†ç±»çš„è¡¨æƒ…åŒ…
    for (const cat of allCategories) {
        if (cat.stickers && cat.stickers.length > 0) {
            html += `<div style="grid-column:1/-1; font-size:12px; color:#999; margin:10px 0 5px; font-weight:500;">${cat.name}</div>`;
            cat.stickers.forEach(s => {
                const safeUrl = s.url.replace(/'/g, "\\'").replace(/"/g, '&quot;');
                html += `<div class="emoji-item" onclick="sendOnlineGroupSticker('${safeUrl}')" style="background-image:url(${s.url}); background-size:cover; background-position:center; width:60px; height:60px; border-radius:8px; cursor:pointer;"></div>`;
            });
        }
    }
    
    if (!html) {
        stickerPanel.innerHTML = `<div style="text-align:center; grid-column:span 4; color:#999; margin-top:20px;">æš‚æ— è¡¨æƒ…åŒ…<br>è¯·å»ã€æˆ‘-è¡¨æƒ…ã€‘æ·»åŠ </div>`;
    } else {
        stickerPanel.innerHTML = html;
    }
}

// å‘é€è”æœºç¾¤èŠè¡¨æƒ…åŒ…
function sendOnlineGroupSticker(stickerUrl) {
    const myWx = getMyOnlineWxAccount();
    const myChar = onlineCharacters.find(c => c.wx_account === myWx);
    
    const imgContent = `[img:${stickerUrl}]`;
    
    onlineSocket.send(JSON.stringify({
        type: 'send_group_message',
        group_id: currentOnlineGroupId,
        my_wx_account: myWx,
        sender_type: 'user',
        sender_name: myChar?.nickname || myWx,
        content: imgContent,
        msg_type: 'image'
    }));
    
    closeOnlineGroupPanel();
}

// åˆå§‹åŒ–è”æœºç¾¤èŠEmojié¢æ¿
function initOnlineGroupEmojiPanel() {
    const panel = document.getElementById('online-group-emoji-panel');
    if (!panel) return;
    
    const emojis = [
        'ğŸ˜€', 'ğŸ˜ƒ', 'ğŸ˜„', 'ğŸ˜', 'ğŸ˜†', 'ğŸ˜…', 'ğŸ¤£', 'ğŸ˜‚',
        'ğŸ™‚', 'ğŸ™ƒ', 'ğŸ˜‰', 'ğŸ˜Š', 'ğŸ˜‡', 'ğŸ¥°', 'ğŸ˜', 'ğŸ¤©',
        'ğŸ˜˜', 'ğŸ˜—', 'ğŸ˜š', 'ğŸ˜™', 'ğŸ˜‹', 'ğŸ˜›', 'ğŸ˜œ', 'ğŸ¤ª',
        'ğŸ˜', 'ğŸ¤‘', 'ğŸ¤—', 'ğŸ¤­', 'ğŸ¤«', 'ğŸ¤”', 'ğŸ¤', 'ğŸ¤¨',
        'ğŸ˜', 'ğŸ˜‘', 'ğŸ˜¶', 'ğŸ˜', 'ğŸ˜’', 'ğŸ™„', 'ğŸ˜¬', 'ğŸ¤¥',
        'ğŸ˜Œ', 'ğŸ˜”', 'ğŸ˜ª', 'ğŸ¤¤', 'ğŸ˜´', 'ğŸ˜·', 'ğŸ¤’', 'ğŸ¤•',
        'ğŸ¤¢', 'ğŸ¤®', 'ğŸ¤§', 'ğŸ¥µ', 'ğŸ¥¶', 'ğŸ¥´', 'ğŸ˜µ', 'ğŸ¤¯',
        'ğŸ¤ ', 'ğŸ¥³', 'ğŸ˜', 'ğŸ¤“', 'ğŸ§', 'ğŸ˜•', 'ğŸ˜Ÿ', 'ğŸ™',
        'â˜¹ï¸', 'ğŸ˜®', 'ğŸ˜¯', 'ğŸ˜²', 'ğŸ˜³', 'ğŸ¥º', 'ğŸ˜¦', 'ğŸ˜§',
        'ğŸ˜¨', 'ğŸ˜°', 'ğŸ˜¥', 'ğŸ˜¢', 'ğŸ˜­', 'ğŸ˜±', 'ğŸ˜–', 'ğŸ˜£',
        'ğŸ˜', 'ğŸ˜“', 'ğŸ˜©', 'ğŸ˜«', 'ğŸ¥±', 'ğŸ˜¤', 'ğŸ˜¡', 'ğŸ˜ ',
        'ğŸ¤¬', 'ğŸ˜ˆ', 'ğŸ‘¿', 'ğŸ’€', 'â˜ ï¸', 'ğŸ’©', 'ğŸ¤¡', 'ğŸ‘¹',
        'ğŸ‘º', 'ğŸ‘»', 'ğŸ‘½', 'ğŸ‘¾', 'ğŸ¤–', 'ğŸ˜º', 'ğŸ˜¸', 'ğŸ˜¹',
        'ğŸ˜»', 'ğŸ˜¼', 'ğŸ˜½', 'ğŸ™€', 'ğŸ˜¿', 'ğŸ˜¾', 'ğŸ‘‹', 'ğŸ¤š',
        'ğŸ–', 'âœ‹', 'ğŸ––', 'ğŸ‘Œ', 'ğŸ¤', 'âœŒï¸', 'ğŸ¤', 'ğŸ¤Ÿ',
        'ğŸ¤˜', 'ğŸ¤™', 'ğŸ‘ˆ', 'ğŸ‘‰', 'ğŸ‘†', 'ğŸ–•', 'ğŸ‘‡', 'â˜ï¸',
        'ğŸ‘', 'ğŸ‘', 'âœŠ', 'ğŸ‘Š', 'ğŸ¤›', 'ğŸ¤œ', 'ğŸ‘', 'ğŸ™Œ',
        'ğŸ‘', 'ğŸ¤²', 'ğŸ¤', 'ğŸ™', 'âœï¸', 'ğŸ’…', 'ğŸ¤³', 'ğŸ’ª'
    ];
    
    panel.innerHTML = emojis.map(emoji => 
        `<div class="emoji-item" onclick="insertOnlineGroupEmoji('${emoji}')">${emoji}</div>`
    ).join('');
}

// æ’å…¥Emojiåˆ°è¾“å…¥æ¡†
function insertOnlineGroupEmoji(emoji) {
    const input = document.getElementById('online-group-input');
    if (input) {
        input.value += emoji;
        input.focus();
        // è§¦å‘è¾“å…¥äº‹ä»¶ä»¥æ›´æ–°å‘é€æŒ‰é’®çŠ¶æ€
        input.dispatchEvent(new Event('input'));
    }
}

// è”æœºç¾¤èŠè¯­éŸ³è¾“å…¥
async function onlineGroupVoiceInput() {
    closeOnlineGroupPanel();
    
    // æ˜¾ç¤ºè¯­éŸ³å½•åˆ¶+å˜å£°å¼¹çª—ï¼ˆå®Œå…¨å‚ç…§è”æœºç§èŠï¼‰
    const modal = document.createElement('div');
    modal.id = 'online-group-voice-modal';
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
    `;
    
    modal.innerHTML = `
        <div style="background: white; border-radius: 16px; padding: 24px; width: 85%; max-width: 320px;">
            <h3 style="margin: 0 0 20px 0; text-align: center; color: #333; font-size: 18px;">ğŸ¤ è¯­éŸ³å½•åˆ¶</h3>
            
            <div style="margin-bottom: 20px;">
                <div style="font-size: 13px; color: #666; margin-bottom: 10px;">é€‰æ‹©å˜å£°æ•ˆæœï¼š</div>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                    <label style="display: flex; align-items: center; padding: 12px; background: #f5f5f5; border-radius: 8px; cursor: pointer;">
                        <input type="radio" name="online-group-voice-effect" value="normal" checked style="margin-right: 8px;">
                        <span>ğŸ™ï¸ åŸå£°</span>
                    </label>
                    <label style="display: flex; align-items: center; padding: 12px; background: #fff0f5; border-radius: 8px; cursor: pointer;">
                        <input type="radio" name="online-group-voice-effect" value="loli" style="margin-right: 8px;">
                        <span>ğŸ€ èè‰éŸ³</span>
                    </label>
                    <label style="display: flex; align-items: center; padding: 12px; background: #f0f5ff; border-radius: 8px; cursor: pointer;">
                        <input type="radio" name="online-group-voice-effect" value="uncle" style="margin-right: 8px;">
                        <span>ğŸ§” å¤§å”éŸ³</span>
                    </label>
                    <label style="display: flex; align-items: center; padding: 12px; background: #f5fff0; border-radius: 8px; cursor: pointer;">
                        <input type="radio" name="online-group-voice-effect" value="robot" style="margin-right: 8px;">
                        <span>ğŸ¤– æœºå™¨äºº</span>
                    </label>
                </div>
            </div>
            
            <div id="online-group-voice-record-status" style="text-align: center; padding: 20px; background: #f9f9f9; border-radius: 12px; margin-bottom: 16px;">
                <div style="font-size: 14px; color: #999;">ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®å¼€å§‹å½•éŸ³</div>
                <div id="online-group-voice-record-time" style="font-size: 24px; font-weight: 600; color: #333; margin-top: 8px; display: none;">00:00</div>
            </div>
            
            <div style="display: flex; flex-direction: column; gap: 10px;">
                <button id="btn-start-online-group-record" onclick="startOnlineGroupVoiceRecord()" style="padding: 14px; background: var(--ins-pink); color: white; border: none; border-radius: 10px; font-size: 15px; font-weight: 500; cursor: pointer;">
                    ğŸ¤ æŒ‰ä½å½•éŸ³
                </button>
                <button onclick="closeOnlineGroupVoiceModal()" style="padding: 12px; background: #f0f0f0; color: #666; border: none; border-radius: 8px; font-size: 14px; cursor: pointer;">
                    å–æ¶ˆ
                </button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
}

// å…³é—­è”æœºç¾¤èŠè¯­éŸ³å¼¹çª—
function closeOnlineGroupVoiceModal() {
    document.getElementById('online-group-voice-modal')?.remove();
}

// âœ… è”æœºç¾¤èŠè¯­éŸ³å½•åˆ¶å˜é‡
let onlineGroupVoiceRecorder = null;
let onlineGroupVoiceChunks = [];
let onlineGroupVoiceStartTime = 0;
let onlineGroupVoiceTimer = null;

// å¼€å§‹è”æœºç¾¤èŠè¯­éŸ³å½•åˆ¶
async function startOnlineGroupVoiceRecord() {
    const btn = document.getElementById('btn-start-online-group-record');
    const statusDiv = document.getElementById('online-group-voice-record-status');
    const timeDiv = document.getElementById('online-group-voice-record-time');
    
    // å¦‚æœæ­£åœ¨å½•éŸ³ï¼Œåˆ™åœæ­¢
    if (onlineGroupVoiceRecorder && onlineGroupVoiceRecorder.state === 'recording') {
        stopOnlineGroupVoiceRecord();
        return;
    }
    
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        
        onlineGroupVoiceRecorder = new MediaRecorder(stream);
        onlineGroupVoiceChunks = [];
        onlineGroupVoiceStartTime = Date.now();
        
        onlineGroupVoiceRecorder.ondataavailable = (e) => {
            if (e.data.size > 0) {
                onlineGroupVoiceChunks.push(e.data);
            }
        };
        
        onlineGroupVoiceRecorder.onstop = async () => {
            stream.getTracks().forEach(track => track.stop());
            clearInterval(onlineGroupVoiceTimer);
            
            const duration = Math.round((Date.now() - onlineGroupVoiceStartTime) / 1000);
            const blob = new Blob(onlineGroupVoiceChunks, { type: 'audio/webm' });
            
            // è·å–é€‰æ‹©çš„å˜å£°æ•ˆæœ
            const effectRadio = document.querySelector('input[name="online-group-voice-effect"]:checked');
            const effect = effectRadio ? effectRadio.value : 'normal';
            
            statusDiv.innerHTML = '<div style="color: var(--ins-pink);">â³ æ­£åœ¨å¤„ç†...</div>';
            
            // å¤„ç†å˜å£°å¹¶å‘é€
            await processAndSendOnlineGroupVoice(blob, effect, duration);
        };
        
        onlineGroupVoiceRecorder.start();
        
        // æ›´æ–°UI
        btn.textContent = 'â¹ï¸ åœæ­¢å½•éŸ³';
        btn.style.background = '#ff3b30';
        timeDiv.style.display = 'block';
        statusDiv.querySelector('div').textContent = 'ğŸ”´ æ­£åœ¨å½•éŸ³...';
        
        // è®¡æ—¶å™¨
        onlineGroupVoiceTimer = setInterval(() => {
            const elapsed = Math.round((Date.now() - onlineGroupVoiceStartTime) / 1000);
            const min = Math.floor(elapsed / 60).toString().padStart(2, '0');
            const sec = (elapsed % 60).toString().padStart(2, '0');
            timeDiv.textContent = `${min}:${sec}`;
        }, 1000);
        
    } catch (err) {
        console.error('å½•éŸ³å¤±è´¥:', err);
        alert('æ— æ³•è®¿é—®éº¦å…‹é£ï¼Œè¯·ç¡®ä¿å·²æˆäºˆæƒé™');
    }
}

// åœæ­¢è”æœºç¾¤èŠè¯­éŸ³å½•åˆ¶
function stopOnlineGroupVoiceRecord() {
    if (onlineGroupVoiceRecorder && onlineGroupVoiceRecorder.state === 'recording') {
        onlineGroupVoiceRecorder.stop();
    }
}

// å¤„ç†å˜å£°å¹¶å‘é€è”æœºç¾¤èŠè¯­éŸ³
async function processAndSendOnlineGroupVoice(blob, effect, duration) {
    try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const arrayBuffer = await blob.arrayBuffer();
        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
        
        // æ ¹æ®æ•ˆæœè®¾ç½®å‚æ•°
        let pitchRate = 1.0;
        switch (effect) {
            case 'loli':    pitchRate = 1.4; break;  // èè‰éŸ³ï¼šæé«˜éŸ³è°ƒ
            case 'uncle':   pitchRate = 0.7; break;  // å¤§å”éŸ³ï¼šé™ä½éŸ³è°ƒ
            case 'robot':   pitchRate = 1.0; break;  // æœºå™¨äººï¼šç‰¹æ®Šå¤„ç†
            default:        pitchRate = 1.0; break;
        }
        
        // åˆ›å»ºç¦»çº¿éŸ³é¢‘ä¸Šä¸‹æ–‡è¿›è¡Œå¤„ç†
        const offlineContext = new OfflineAudioContext(
            audioBuffer.numberOfChannels,
            Math.ceil(audioBuffer.length / pitchRate),
            audioBuffer.sampleRate
        );
        
        const source = offlineContext.createBufferSource();
        source.buffer = audioBuffer;
        source.playbackRate.value = pitchRate;
        
        // æœºå™¨äººæ•ˆæœï¼šæ·»åŠ æ³¢å½¢è°ƒåˆ¶
        if (effect === 'robot') {
            const oscillator = offlineContext.createOscillator();
            const gainNode = offlineContext.createGain();
            oscillator.frequency.value = 50;
            gainNode.gain.value = 0.3;
            oscillator.connect(gainNode);
            gainNode.connect(offlineContext.destination);
            oscillator.start();
        }
        
        source.connect(offlineContext.destination);
        source.start();
        
        const renderedBuffer = await offlineContext.startRendering();
        
        // å°†å¤„ç†åçš„éŸ³é¢‘è½¬ä¸º base64
        const wavBlob = await audioBufferToWavForOnlineGroup(renderedBuffer);
        const base64 = await blobToBase64ForOnlineGroup(wavBlob);
        
        // è®¡ç®—å®é™…æ—¶é•¿
        const actualDuration = Math.ceil(duration / pitchRate);
        
        // å‘é€è¯­éŸ³æ¶ˆæ¯åˆ°ç¾¤èŠ
        await sendOnlineGroupVoiceMessage(base64, actualDuration, effect);
        
        closeOnlineGroupVoiceModal();
        
    } catch (err) {
        console.error('è¯­éŸ³å¤„ç†å¤±è´¥:', err);
        alert('è¯­éŸ³å¤„ç†å¤±è´¥: ' + err.message);
    }
}

// AudioBuffer è½¬ WAVï¼ˆè”æœºç¾¤èŠï¼‰
function audioBufferToWavForOnlineGroup(buffer) {
    const numChannels = buffer.numberOfChannels;
    const sampleRate = buffer.sampleRate;
    const format = 1; // PCM
    const bitDepth = 16;
    
    const bytesPerSample = bitDepth / 8;
    const blockAlign = numChannels * bytesPerSample;
    
    const data = [];
    for (let i = 0; i < buffer.length; i++) {
        for (let ch = 0; ch < numChannels; ch++) {
            const sample = buffer.getChannelData(ch)[i];
            const intSample = Math.max(-1, Math.min(1, sample));
            data.push(intSample < 0 ? intSample * 0x8000 : intSample * 0x7FFF);
        }
    }
    
    const dataLength = data.length * bytesPerSample;
    const headerLength = 44;
    const totalLength = headerLength + dataLength;
    
    const arrayBuffer = new ArrayBuffer(totalLength);
    const view = new DataView(arrayBuffer);
    
    // WAV header
    const writeString = (offset, string) => {
        for (let i = 0; i < string.length; i++) {
            view.setUint8(offset + i, string.charCodeAt(i));
        }
    };
    
    writeString(0, 'RIFF');
    view.setUint32(4, totalLength - 8, true);
    writeString(8, 'WAVE');
    writeString(12, 'fmt ');
    view.setUint32(16, 16, true);
    view.setUint16(20, format, true);
    view.setUint16(22, numChannels, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, sampleRate * blockAlign, true);
    view.setUint16(32, blockAlign, true);
    view.setUint16(34, bitDepth, true);
    writeString(36, 'data');
    view.setUint32(40, dataLength, true);
    
    let offset = 44;
    for (let i = 0; i < data.length; i++, offset += 2) {
        view.setInt16(offset, data[i], true);
    }
    
    return new Blob([arrayBuffer], { type: 'audio/wav' });
}

// Blob è½¬ Base64ï¼ˆè”æœºç¾¤èŠï¼‰
function blobToBase64ForOnlineGroup(blob) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
    });
}

// å‘é€è”æœºç¾¤èŠè¯­éŸ³æ¶ˆæ¯
async function sendOnlineGroupVoiceMessage(audioBase64, duration, effect) {
    if (!currentOnlineGroupId) return;
    
    const myWx = getMyOnlineWxAccount();
    const myChar = onlineCharacters.find(c => c.wx_account === myWx);
    
    // æ„å»ºè¯­éŸ³æ¶ˆæ¯JSON
    const voiceMsg = JSON.stringify({
        __type: 'audio',
        audio: audioBase64,
        duration: duration,
        effect: effect
    });
    
    // å‘é€åˆ°æœåŠ¡å™¨
    onlineSocket.send(JSON.stringify({
        type: 'send_group_message',
        group_id: currentOnlineGroupId,
        my_wx_account: myWx,
        sender_type: 'user',
        sender_name: myChar?.nickname || myWx,
        content: voiceMsg
    }));
    
    console.log('[è”æœºç¾¤èŠ] è¯­éŸ³æ¶ˆæ¯å·²å‘é€ï¼Œæ—¶é•¿:', duration, 'ç§’ï¼Œæ•ˆæœ:', effect);
    showToast('è¯­éŸ³å·²å‘é€');
}

// è”æœºç¾¤èŠå‘é€å›¾ç‰‡
function onlineGroupSendImage() {
    closeOnlineGroupPanel();
    
    // åˆ›å»ºéšè—çš„æ–‡ä»¶è¾“å…¥
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*';
    input.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        // è¯»å–å›¾ç‰‡å¹¶è½¬ä¸ºbase64
        const reader = new FileReader();
        reader.onload = async (event) => {
            const base64 = event.target.result;
            const imgContent = `[img:${base64}]`;
            
            // å‘é€å›¾ç‰‡æ¶ˆæ¯
            const myWx = getMyOnlineWxAccount();
            const myChar = onlineCharacters.find(c => c.wx_account === myWx);
            
            onlineSocket.send(JSON.stringify({
                type: 'send_group_message',
                group_id: currentOnlineGroupId,
                my_wx_account: myWx,
                sender_type: 'user',
                sender_name: myChar?.nickname || myWx,
                content: imgContent,
                msg_type: 'image'
            }));
            
            showToast('å›¾ç‰‡å·²å‘é€');
        };
        reader.readAsDataURL(file);
    };
    input.click();
}

// è”æœºç¾¤èŠè½¬è´¦ - æ˜¾ç¤ºç±»å‹é€‰æ‹©å¼¹çª—
function onlineGroupTransfer() {
    closeOnlineGroupPanel();
    
    const modal = document.createElement('div');
    modal.id = 'online-group-transfer-type-modal';
    modal.className = 'modal-overlay';
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.5);
        z-index: 10000;
        display: flex;
        align-items: center;
        justify-content: center;
    `;
    
    modal.innerHTML = `
        <div class="modal-box" style="max-width:300px; padding:0; overflow:hidden; border-radius:16px; background:#fff;">
            <div style="padding:20px 16px; text-align:center; border-bottom:0.5px solid #f0f0f0;">
                <div style="font-size:17px; font-weight:600; color:#333;">é€‰æ‹©ç±»å‹</div>
            </div>
            <div style="padding:16px;">
                <div onclick="showOnlineGroupRedPacket()" style="display:flex; align-items:center; padding:14px 16px; background:#fafafa; border-radius:12px; margin-bottom:12px; cursor:pointer; transition:all 0.2s; border:1px solid #f0f0f0;">
                    <div style="width:44px; height:44px; border-radius:12px; background:#fff; border:1px solid #eee; display:flex; align-items:center; justify-content:center; margin-right:14px;">
                        <svg viewBox="0 0 24 24" style="width:22px; height:22px; stroke:var(--ins-pink); fill:none; stroke-width:1.5;"><rect x="3" y="4" width="18" height="16" rx="2"/><path d="M3 10h18"/><circle cx="12" cy="15" r="2"/></svg>
                    </div>
                    <div style="flex:1;">
                        <div style="font-size:15px; font-weight:500; color:#333;">ç¾¤çº¢åŒ…</div>
                        <div style="font-size:12px; color:#999; margin-top:2px;">æ‹¼æ‰‹æ°”æˆ–æ™®é€šçº¢åŒ…</div>
                    </div>
                    <svg viewBox="0 0 24 24" style="width:18px; height:18px; stroke:#ccc; fill:none;"><polyline points="9 18 15 12 9 6"></polyline></svg>
                </div>
                <div onclick="showOnlineGroupExclusiveTransfer()" style="display:flex; align-items:center; padding:14px 16px; background:#fafafa; border-radius:12px; cursor:pointer; transition:all 0.2s; border:1px solid #f0f0f0;">
                    <div style="width:44px; height:44px; border-radius:12px; background:#fff; border:1px solid #eee; display:flex; align-items:center; justify-content:center; margin-right:14px;">
                        <svg viewBox="0 0 24 24" style="width:22px; height:22px; stroke:var(--ins-pink); fill:none; stroke-width:1.5;"><path d="M17 1l4 4-4 4"/><path d="M3 11V9a4 4 0 0 1 4-4h14"/><path d="M7 23l-4-4 4-4"/><path d="M21 13v2a4 4 0 0 1-4 4H3"/></svg>
                    </div>
                    <div style="flex:1;">
                        <div style="font-size:15px; font-weight:500; color:#333;">ä¸“å±è½¬è´¦</div>
                        <div style="font-size:12px; color:#999; margin-top:2px;">è½¬ç»™æŒ‡å®šç¾¤æˆå‘˜</div>
                    </div>
                    <svg viewBox="0 0 24 24" style="width:18px; height:18px; stroke:#ccc; fill:none;"><polyline points="9 18 15 12 9 6"></polyline></svg>
                </div>
            </div>
            <div onclick="document.getElementById('online-group-transfer-type-modal').remove()" style="padding:14px 16px; text-align:center; border-top:0.5px solid #f0f0f0; color:#999; font-size:15px; cursor:pointer;">å–æ¶ˆ</div>
        </div>
    `;
    
    document.body.appendChild(modal);
}

// æ˜¾ç¤ºè”æœºç¾¤èŠçº¢åŒ…é¡µé¢
function showOnlineGroupRedPacket() {
    document.getElementById('online-group-transfer-type-modal')?.remove();
    
    // åˆ›å»ºæˆ–æ˜¾ç¤ºçº¢åŒ…é¡µé¢
    let page = document.getElementById('online-group-redpacket-page');
    if (!page) {
        page = document.createElement('div');
        page.id = 'online-group-redpacket-page';
        page.className = 'transfer-modal';
        page.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:#fff; z-index:350; display:none; flex-direction:column;';
        document.body.appendChild(page);
    }
    
    page.innerHTML = `
        <div class="transfer-page-header" style="background:#fff; border-bottom:0.5px solid #f0f0f0;">
            <div class="back-btn" onclick="hideOnlineGroupRedPacketPage()" style="margin:0; background:none; width:40px; justify-content:flex-start; padding-left:0; color:#333;">
                <svg class="svg-icon" viewBox="0 0 24 24" style="width:28px; height:28px;"><polyline points="15 18 9 12 15 6"></polyline></svg>
            </div>
            <div class="transfer-page-title" style="color:#333;">å‘çº¢åŒ…</div>
            <div style="width:40px;"></div>
        </div>
        
        <div style="flex:1; background:#fff; padding:16px;">
            <!-- çº¢åŒ…ç±»å‹é€‰æ‹© -->
            <div style="background:#fff; border-radius:12px; padding:16px; margin-bottom:12px; border:1px solid #eee;">
                <div style="font-size:13px; color:#999; margin-bottom:12px;">çº¢åŒ…ç±»å‹</div>
                <div style="display:flex; gap:12px;">
                    <div id="online-rp-type-lucky" onclick="selectOnlineRedPacketType('lucky')" style="flex:1; padding:12px; border:1.5px solid #333; border-radius:10px; text-align:center; cursor:pointer; background:#fff;">
                        <div style="font-size:14px; font-weight:500; color:#333;">æ‹¼æ‰‹æ°”çº¢åŒ…</div>
                        <div style="font-size:11px; color:#999; margin-top:4px;">é‡‘é¢éšæœº</div>
                    </div>
                    <div id="online-rp-type-normal" onclick="selectOnlineRedPacketType('normal')" style="flex:1; padding:12px; border:1.5px solid #e8e8e8; border-radius:10px; text-align:center; cursor:pointer; background:#fff;">
                        <div style="font-size:14px; font-weight:500; color:#666;">æ™®é€šçº¢åŒ…</div>
                        <div style="font-size:11px; color:#999; margin-top:4px;">é‡‘é¢ç›¸åŒ</div>
                    </div>
                </div>
            </div>
            
            <!-- çº¢åŒ…é‡‘é¢ -->
            <div style="background:#fff; border-radius:12px; padding:16px; margin-bottom:12px; border:1px solid #eee;">
                <div style="display:flex; align-items:center; border-bottom:1px solid #f0f0f0; padding-bottom:14px; margin-bottom:14px;">
                    <div style="font-size:14px; color:#999; width:70px;">æ€»é‡‘é¢</div>
                    <div style="flex:1; display:flex; align-items:center;">
                        <span style="font-size:18px; color:#333; margin-right:4px;">Â¥</span>
                        <input type="number" id="online-rp-amount-input" placeholder="0.00" style="flex:1; border:none; font-size:22px; font-weight:500; outline:none; color:#333;" oninput="checkOnlineRedPacketInput()">
                    </div>
                </div>
                <div style="display:flex; align-items:center;">
                    <div style="font-size:14px; color:#999; width:70px;">çº¢åŒ…ä¸ªæ•°</div>
                    <div style="flex:1; display:flex; align-items:center;">
                        <input type="number" id="online-rp-count-input" placeholder="1" min="1" style="flex:1; border:none; font-size:16px; outline:none; color:#333;" oninput="checkOnlineRedPacketInput()">
                        <span style="font-size:13px; color:#999;">ä¸ª</span>
                    </div>
                </div>
            </div>
            
            <!-- ç¥ç¦è¯­ -->
            <div style="background:#fff; border-radius:12px; padding:14px 16px; margin-bottom:24px; border:1px solid #eee;">
                <input type="text" id="online-rp-wish-input" placeholder="ç¥ç¦è¯­ï¼ˆé€‰å¡«ï¼‰" maxlength="20" style="width:100%; border:none; font-size:14px; outline:none; box-sizing:border-box; color:#333;">
            </div>
            
            <!-- é‡‘é¢æç¤º -->
            <div style="text-align:center; margin-bottom:20px;">
                <span style="font-size:13px; color:#999;" id="online-rp-total-hint">å…±0.00å…ƒ</span>
            </div>
            
            <!-- å‘é€æŒ‰é’® -->
            <button id="btn-send-online-redpacket" onclick="sendOnlineGroupRedPacket()" disabled style="width:100%; padding:14px; background:#ccc; color:#fff; border:none; border-radius:24px; font-size:16px; font-weight:500; cursor:not-allowed; transition:all 0.2s;">
                å‘çº¢åŒ…
            </button>
        </div>
    `;
    
    // é‡ç½®è¾“å…¥
    document.getElementById('online-rp-amount-input').value = '';
    document.getElementById('online-rp-count-input').value = '';
    document.getElementById('online-rp-wish-input').value = '';
    document.getElementById('online-rp-total-hint').innerText = 'å…±0.00å…ƒ';
    document.getElementById('btn-send-online-redpacket').disabled = true;
    document.getElementById('btn-send-online-redpacket').style.background = '#ccc';
    document.getElementById('btn-send-online-redpacket').style.cursor = 'not-allowed';
    
    // é»˜è®¤é€‰ä¸­æ‹¼æ‰‹æ°”
    selectOnlineRedPacketType('lucky');
    
    page.style.display = 'flex';
}

// éšè—è”æœºç¾¤èŠçº¢åŒ…é¡µé¢
function hideOnlineGroupRedPacketPage() {
    const page = document.getElementById('online-group-redpacket-page');
    if (page) page.style.display = 'none';
}

// è”æœºç¾¤èŠçº¢åŒ…ç±»å‹
let currentOnlineRedPacketType = 'lucky';

// é€‰æ‹©è”æœºç¾¤èŠçº¢åŒ…ç±»å‹
function selectOnlineRedPacketType(type) {
    currentOnlineRedPacketType = type;
    
    const luckyEl = document.getElementById('online-rp-type-lucky');
    const normalEl = document.getElementById('online-rp-type-normal');
    
    if (!luckyEl || !normalEl) return;
    
    if (type === 'lucky') {
        luckyEl.style.borderColor = '#333';
        luckyEl.style.background = '#fff';
        luckyEl.querySelector('div:first-child').style.color = '#333';
        
        normalEl.style.borderColor = '#e8e8e8';
        normalEl.style.background = '#fff';
        normalEl.querySelector('div:first-child').style.color = '#666';
    } else {
        normalEl.style.borderColor = '#333';
        normalEl.style.background = '#fff';
        normalEl.querySelector('div:first-child').style.color = '#333';
        
        luckyEl.style.borderColor = '#e8e8e8';
        luckyEl.style.background = '#fff';
        luckyEl.querySelector('div:first-child').style.color = '#666';
    }
}

// æ£€æŸ¥è”æœºç¾¤èŠçº¢åŒ…è¾“å…¥
function checkOnlineRedPacketInput() {
    const amount = parseFloat(document.getElementById('online-rp-amount-input')?.value || 0);
    const count = parseInt(document.getElementById('online-rp-count-input')?.value || 0);
    const btn = document.getElementById('btn-send-online-redpacket');
    const hint = document.getElementById('online-rp-total-hint');
    
    if (!btn || !hint) return;
    
    if (amount > 0 && count > 0) {
        hint.innerText = `å…±${amount.toFixed(2)}å…ƒ`;
        btn.disabled = false;
        btn.style.background = '#333';
        btn.style.cursor = 'pointer';
    } else {
        hint.innerText = 'å…±0.00å…ƒ';
        btn.disabled = true;
        btn.style.background = '#ccc';
        btn.style.cursor = 'not-allowed';
    }
}

// å‘é€è”æœºç¾¤èŠçº¢åŒ…
async function sendOnlineGroupRedPacket() {
    if (!currentOnlineGroupId) return;
    
    const amount = parseFloat(document.getElementById('online-rp-amount-input')?.value);
    const count = parseInt(document.getElementById('online-rp-count-input')?.value);
    const wish = document.getElementById('online-rp-wish-input')?.value.trim() || 'æ­å–œå‘è´¢ï¼Œå¤§å‰å¤§åˆ©';
    
    if (!amount || amount <= 0 || !count || count <= 0) {
        showToast('è¯·å¡«å†™æ­£ç¡®çš„é‡‘é¢å’Œä¸ªæ•°');
        return;
    }
    
    // æ£€æŸ¥ä½™é¢
    if (!currentMyCharId) {
        showToast("è¯·å…ˆè®¾ç½®Userèº«ä»½");
        return;
    }
    const user = await db.characters.get(parseInt(currentMyCharId));
    let currentBalance = 0;
    if (user && user.identity && user.identity.balance) {
        currentBalance = parseFloat(user.identity.balance.toString().replace(/,/g, ''));
    }
    
    if (currentBalance < amount) {
        showToast('ä½™é¢ä¸è¶³ (å½“å‰: Â¥' + currentBalance.toFixed(2) + ')');
        return;
    }
    
    // æ‰£æ¬¾
    const newBalance = currentBalance - amount;
    user.identity.balance = newBalance.toFixed(2);
    await db.characters.put(user);
    
    // æ„å»ºçº¢åŒ…æ•°æ®
    const redPacketData = {
        type: 'redpacket',
        redpacketType: currentOnlineRedPacketType, // 'lucky' æˆ– 'normal'
        totalAmount: amount.toFixed(2),
        count: count,
        wish: wish,
        claimed: [], // å·²é¢†å–çš„æˆå‘˜å¾®ä¿¡å·åˆ—è¡¨
        claimedAmounts: {}, // æ¯ä¸ªæˆå‘˜é¢†å–çš„é‡‘é¢ {wx_account: amount}
        id: 'rp_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9)
    };
    
    // å‘é€åˆ°æœåŠ¡å™¨
    const myWx = getMyOnlineWxAccount();
    const myChar = onlineCharacters.find(c => c.wx_account === myWx);
    
    onlineSocket.send(JSON.stringify({
        type: 'send_group_message',
        group_id: currentOnlineGroupId,
        my_wx_account: myWx,
        sender_type: 'user',
        sender_name: myChar?.nickname || myWx,
        content: JSON.stringify(redPacketData),
        msg_type: 'redpacket'
    }));
    
    // è®°å½•è´¦å•
    await addTransaction('expense', amount, 'å‘çº¢åŒ…', `è”æœºç¾¤èŠ Â· ${count}ä¸ªçº¢åŒ…`);
    
    hideOnlineGroupRedPacketPage();
    showToast('çº¢åŒ…å·²å‘å‡º');
}

// æ˜¾ç¤ºè”æœºç¾¤èŠçº¢åŒ…è¯¦æƒ…
function showOnlineGroupRedPacketDetail(msgId) {
    // åœ¨æ¶ˆæ¯åˆ—è¡¨ä¸­æ‰¾åˆ°çº¢åŒ…æ¶ˆæ¯
    const msg = currentOnlineGroupMessages.find(m => {
        if (m.msg_type !== 'redpacket') return false;
        return (m.id || ('rp_' + m.created_at)) === msgId;
    });
    
    if (!msg) {
        showToast('çº¢åŒ…ä¸å­˜åœ¨');
        return;
    }
    
    try {
        const data = JSON.parse(msg.content);
        const myWx = getMyOnlineWxAccount();
        const hasClaimed = data.claimed?.includes(myWx) || false;
        const claimedCount = (data.claimed || []).length;
        const isAllClaimed = claimedCount >= data.count;
        
        // åˆ›å»ºæˆ–æ˜¾ç¤ºçº¢åŒ…è¯¦æƒ…é¡µé¢
        let page = document.getElementById('online-group-redpacket-detail-page');
        if (!page) {
            page = document.createElement('div');
            page.id = 'online-group-redpacket-detail-page';
            page.className = 'transfer-modal';
            page.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:#fff; z-index:360; display:none; flex-direction:column;';
            document.body.appendChild(page);
        }
        
        page.innerHTML = `
            <div class="transfer-page-header" style="background:#fff; border-bottom:0.5px solid #f0f0f0;">
                <div class="back-btn" onclick="hideOnlineGroupRedPacketDetail()" style="margin:0; background:none; width:40px; justify-content:flex-start; padding-left:0; color:#333;">
                    <svg class="svg-icon" viewBox="0 0 24 24" style="width:28px; height:28px;"><polyline points="15 18 9 12 15 6"></polyline></svg>
                </div>
                <div class="transfer-page-title" style="color:#333;">çº¢åŒ…è¯¦æƒ…</div>
                <div style="width:40px;"></div>
            </div>
            
            <div style="flex:1; background:#fff; overflow-y:auto;">
                <!-- çº¢åŒ…ä¿¡æ¯å¤´éƒ¨ -->
                <div style="padding:30px 20px; text-align:center; border-bottom:1px solid #f0f0f0;">
                    <div id="online-rp-detail-avatar" style="width:60px; height:60px; border-radius:50%; background:#eee; margin:0 auto 12px; background-size:cover; background-position:center;"></div>
                    <div id="online-rp-detail-sender" style="font-size:15px; color:#333; margin-bottom:8px;">${msg.sender_name} çš„çº¢åŒ…</div>
                    <div id="online-rp-detail-wish" style="font-size:18px; font-weight:500; color:#333; margin-bottom:6px;">${escapeHtml(data.wish || 'æ­å–œå‘è´¢')}</div>
                    <div id="online-rp-detail-type" style="font-size:13px; color:#999;">${data.redpacketType === 'lucky' ? 'æ‹¼æ‰‹æ°”çº¢åŒ…' : 'æ™®é€šçº¢åŒ…'}</div>
                </div>
                
                <!-- é¢†å–æŒ‰é’®åŒºåŸŸ -->
                <div id="online-rp-detail-action" style="padding:20px; border-bottom:1px solid #f0f0f0;">
                    <button id="btn-claim-online-redpacket" onclick="claimOnlineGroupRedPacket('${msgId}', '${myWx}', null)" style="width:100%; padding:14px; background:${isAllClaimed || hasClaimed ? '#ccc' : '#333'}; color:#fff; border:none; border-radius:24px; font-size:16px; font-weight:500; cursor:${isAllClaimed || hasClaimed ? 'not-allowed' : 'pointer'};" ${isAllClaimed || hasClaimed ? 'disabled' : ''}>
                        ${isAllClaimed ? 'çº¢åŒ…å·²é¢†å®Œ' : hasClaimed ? `å·²é¢†å– Â¥${(data.claimedAmounts?.[myWx] || '0.00')}` : 'é¢†å–çº¢åŒ…'}
                    </button>
                </div>
                
                <!-- å·²é¢†å–åˆ—è¡¨ -->
                <div style="padding:16px 20px;">
                    <div style="font-size:13px; color:#999; margin-bottom:12px;">
                        <span id="online-rp-detail-claimed-count">${claimedCount}</span>/<span id="online-rp-detail-total-count">${data.count}</span> å·²é¢†å–ï¼Œå…± <span id="online-rp-detail-total-amount">${Object.values(data.claimedAmounts || {}).reduce((a, b) => a + parseFloat(b), 0).toFixed(2)}</span> å…ƒ
                    </div>
                    <div id="online-rp-detail-claimed-list">
                        ${data.claimed && data.claimed.length > 0 ? 
                            data.claimed.map(wx => {
                                const member = currentOnlineGroupMembers.find(m => m.user_wx === wx);
                                const amount = data.claimedAmounts?.[wx] || '0.00';
                                return `
                                    <div style="display:flex; align-items:center; padding:12px 0; border-bottom:1px solid #f0f0f0;">
                                        <div style="width:40px; height:40px; border-radius:50%; background:#eee; background-image:url(${member?.user_avatar || ''}); background-size:cover; background-position:center; margin-right:12px; flex-shrink:0;"></div>
                                        <div style="flex:1;">
                                            <div style="font-size:14px; color:#333;">${member?.user_name || wx}</div>
                                        </div>
                                        <div style="font-size:15px; font-weight:500; color:#333;">Â¥${amount}</div>
                                    </div>
                                `;
                            }).join('') : 
                            '<div style="text-align:center; color:#999; padding:30px 0; font-size:13px;">æš‚æ— äººé¢†å–</div>'
                        }
                    </div>
                </div>
            </div>
        `;
        
        // è®¾ç½®å‘é€è€…å¤´åƒ
        const avatarEl = document.getElementById('online-rp-detail-avatar');
        if (msg.sender_avatar) {
            avatarEl.style.backgroundImage = `url(${msg.sender_avatar})`;
        }
        
        page.style.display = 'flex';
    } catch(e) {
        console.error('æ˜¾ç¤ºçº¢åŒ…è¯¦æƒ…å¤±è´¥:', e);
        showToast('çº¢åŒ…æ•°æ®é”™è¯¯');
    }
}

// éšè—è”æœºç¾¤èŠçº¢åŒ…è¯¦æƒ…
function hideOnlineGroupRedPacketDetail() {
    const page = document.getElementById('online-group-redpacket-detail-page');
    if (page) page.style.display = 'none';
}

// é¢†å–è”æœºç¾¤èŠçº¢åŒ…ï¼ˆç”¨æˆ·æˆ–è§’è‰²éƒ½å¯ä»¥ï¼‰
async function claimOnlineGroupRedPacket(msgId, claimerWx, characterName) {
    if (!currentOnlineGroupId || !onlineSocket || onlineSocket.readyState !== WebSocket.OPEN) {
        showToast('æœªè¿æ¥åˆ°æœåŠ¡å™¨');
        return;
    }
    
    const myWx = getMyOnlineWxAccount();
    const claimerName = characterName || (onlineCharacters.find(c => c.wx_account === myWx)?.nickname || myWx);
    
    // å‘é€é¢†å–è¯·æ±‚åˆ°æœåŠ¡å™¨
    onlineSocket.send(JSON.stringify({
        type: 'claim_group_redpacket',
        group_id: currentOnlineGroupId,
        my_wx_account: myWx,
        message_id: msgId,
        claimer_name: claimerName
    }));
}

// å¤„ç†çº¢åŒ…è¢«é¢†å–çš„é€šçŸ¥
async function handleRedPacketClaimed(data) {
    const { group_id, message_id, claimer_wx, claim_amount, redpacket_data } = data;
    
    if (group_id !== currentOnlineGroupId) return;
    
    // æ›´æ–°æœ¬åœ°æ¶ˆæ¯ä¸­çš„çº¢åŒ…æ•°æ®
    const msgIndex = currentOnlineGroupMessages.findIndex(m => m.id === message_id);
    if (msgIndex !== -1) {
        currentOnlineGroupMessages[msgIndex].content = JSON.stringify(redpacket_data);
        renderOnlineGroupMessages();
    }
    
    // å¦‚æœæ˜¯è‡ªå·±é¢†å–çš„ï¼Œæ›´æ–°é’±åŒ…
    const myWx = getMyOnlineWxAccount();
    if (claimer_wx === myWx) {
        const claimAmountNum = parseFloat(claim_amount);
        
        if (!currentMyCharId) {
            showToast(`æˆåŠŸé¢†å– Â¥${claim_amount}`);
            return;
        }
        
        const user = await db.characters.get(parseInt(currentMyCharId));
        if (user) {
            if (!user.identity) user.identity = {};
            let balance = parseFloat(user.identity.balance || 0);
            balance += claimAmountNum;
            user.identity.balance = balance.toFixed(2);
            await db.characters.put(user);
            
            // è®°å½•è´¦å•
            const group = onlineGroups.find(g => g.id === currentOnlineGroupId);
            await addTransaction('income', claimAmountNum, 'çº¢åŒ…', group?.name || 'è”æœºç¾¤èŠ');
            
            showToast(`æˆåŠŸé¢†å– Â¥${claim_amount}`);
        }
    }
    
    // åˆ·æ–°çº¢åŒ…è¯¦æƒ…é¡µé¢ï¼ˆå¦‚æœå·²æ‰“å¼€ï¼‰
    const detailPage = document.getElementById('online-group-redpacket-detail-page');
    if (detailPage && detailPage.style.display !== 'none') {
        showOnlineGroupRedPacketDetail(message_id);
    }
}

// æ˜¾ç¤ºè”æœºç¾¤èŠä¸“å±è½¬è´¦é€‰äººé¡µé¢
async function showOnlineGroupExclusiveTransfer() {
    document.getElementById('online-group-transfer-type-modal')?.remove();
    
    const listHtml = currentOnlineGroupMembers.map(m => {
        const avatarStyle = m.user_avatar ? `background-image:url(${m.user_avatar})` : 'background:#ccc';
        const myWx = getMyOnlineWxAccount();
        if (m.user_wx === myWx) return ''; // ä¸æ˜¾ç¤ºè‡ªå·±
        
        return `
            <div onclick="selectOnlineGroupTransferTarget('${m.user_wx}', '${m.user_name}')" style="display:flex; align-items:center; padding:12px 16px; cursor:pointer; transition:background 0.2s; border-bottom:0.5px solid #f0f0f0;">
                <div style="width:44px; height:44px; border-radius:6px; ${avatarStyle}; background-size:cover; background-position:center; margin-right:12px;"></div>
                <div style="flex:1;">
                    <div style="font-size:16px; color:#333;">${m.user_name}</div>
                    ${m.character_name ? `<div style="font-size:12px; color:#999;">${m.character_name}</div>` : ''}
                </div>
            </div>
        `;
    }).filter(h => h).join('');
    
    const modal = document.createElement('div');
    modal.id = 'online-group-exclusive-modal';
    modal.className = 'modal-overlay';
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.5);
        z-index: 10000;
        display: flex;
        align-items: center;
        justify-content: center;
    `;
    
    modal.innerHTML = `
        <div style="background:#fff; border-radius:16px; width:85%; max-width:400px; max-height:70%; overflow:hidden; display:flex; flex-direction:column;">
            <div style="padding:20px 16px; text-align:center; border-bottom:0.5px solid #f0f0f0;">
                <div style="font-size:17px; font-weight:600; color:#333;">é€‰æ‹©è½¬è´¦å¯¹è±¡</div>
            </div>
            <div style="flex:1; overflow-y:auto;">
                ${listHtml || '<div style="text-align:center; color:#999; padding:40px;">ç¾¤å†…æš‚æ— å…¶ä»–æˆå‘˜</div>'}
            </div>
            <div onclick="document.getElementById('online-group-exclusive-modal').remove()" style="padding:14px 16px; text-align:center; border-top:0.5px solid #f0f0f0; color:#999; font-size:15px; cursor:pointer;">å–æ¶ˆ</div>
        </div>
    `;
    
    document.body.appendChild(modal);
}

// é€‰æ‹©è”æœºç¾¤èŠè½¬è´¦ç›®æ ‡
function selectOnlineGroupTransferTarget(targetWx, targetName) {
    document.getElementById('online-group-exclusive-modal')?.remove();
    
    const modal = document.createElement('div');
    modal.id = 'online-group-transfer-amount-modal';
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.5);
        z-index: 10000;
        display: flex;
        align-items: center;
        justify-content: center;
    `;
    
    modal.innerHTML = `
        <div style="background:#fff; border-radius:16px; padding:24px; width:85%; max-width:360px;">
            <h3 style="margin:0 0 16px 0; text-align:center; font-size:18px;">è½¬è´¦ç»™ ${targetName}</h3>
            
            <div style="margin-bottom:16px;">
                <label style="display:block; font-size:13px; color:#666; margin-bottom:8px;">è½¬è´¦é‡‘é¢</label>
                <input type="number" id="online-group-transfer-amount" placeholder="è¾“å…¥é‡‘é¢" style="width:100%; padding:12px; border:1px solid #ddd; border-radius:8px; font-size:14px;">
            </div>
            
            <div style="margin-bottom:20px;">
                <label style="display:block; font-size:13px; color:#666; margin-bottom:8px;">è½¬è´¦è¯´æ˜</label>
                <input type="text" id="online-group-transfer-note" placeholder="æ·»åŠ è½¬è´¦è¯´æ˜" style="width:100%; padding:12px; border:1px solid #ddd; border-radius:8px; font-size:14px;">
            </div>
            
            <div style="display:flex; gap:12px;">
                <button onclick="document.getElementById('online-group-transfer-amount-modal').remove()" style="flex:1; padding:12px; background:#f0f0f0; color:#666; border:none; border-radius:8px; font-size:15px;">å–æ¶ˆ</button>
                <button onclick="sendOnlineGroupExclusiveTransfer('${targetWx}', '${targetName}')" style="flex:1; padding:12px; background:var(--ins-pink); color:#fff; border:none; border-radius:8px; font-size:15px;">è½¬è´¦</button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
}

// å‘é€è”æœºç¾¤èŠä¸“å±è½¬è´¦
function sendOnlineGroupExclusiveTransfer(targetWx, targetName) {
    const amount = document.getElementById('online-group-transfer-amount').value.trim();
    const note = document.getElementById('online-group-transfer-note').value.trim();
    
    if (!amount || parseFloat(amount) <= 0) {
        alert('è¯·è¾“å…¥æœ‰æ•ˆçš„é‡‘é¢');
        return;
    }
    
    const myWx = getMyOnlineWxAccount();
    const myChar = onlineCharacters.find(c => c.wx_account === myWx);
    
    // ä½¿ç”¨å’Œæ™®é€šç¾¤èŠä¸€æ ·çš„JSONæ ¼å¼
    const transferData = {
        amount: parseFloat(amount),
        desc: note || 'è½¬è´¦',
        status: 'pending',
        targetWx: targetWx,
        targetName: targetName
    };
    
    onlineSocket.send(JSON.stringify({
        type: 'send_group_message',
        group_id: currentOnlineGroupId,
        my_wx_account: myWx,
        sender_type: 'user',
        sender_name: myChar?.nickname || myWx,
        content: JSON.stringify(transferData),
        msg_type: 'transfer'
    }));
    
    document.getElementById('online-group-transfer-amount-modal')?.remove();
    showToast('è½¬è´¦å·²å‘é€');
}

// åˆ·æ–°ç¾¤æˆå‘˜åˆ—è¡¨
function refreshOnlineGroupMembers() {
    const myWx = getMyOnlineWxAccount();
    if (myWx && currentOnlineGroupId) {
        onlineSocket.send(JSON.stringify({
            type: 'get_group_members',
            group_id: currentOnlineGroupId,
            my_wx_account: myWx
        }));
    }
}

// å‘é€ç¾¤æ¶ˆæ¯
function sendOnlineGroupMsg() {
    const input = document.getElementById('online-group-input');
    const content = input.value.trim();
    if (!content || !currentOnlineGroupId) return;
    
    const myWx = getMyOnlineWxAccount();
    const myChar = onlineCharacters.find(c => c.wx_account === myWx);
    
    onlineSocket.send(JSON.stringify({
        type: 'send_group_message',
        group_id: currentOnlineGroupId,
        my_wx_account: myWx,
        sender_type: 'user',
        sender_name: myChar?.nickname || myWx,
        content: content
    }));
    
    input.value = '';
    // è§¦å‘inputäº‹ä»¶ä»¥æ›´æ–°å‘é€æŒ‰é’®çŠ¶æ€
    input.dispatchEvent(new Event('input'));
    // å…³é—­é¢æ¿
    closeOnlineGroupPanel();
}

// è®©æˆ‘çš„è§’è‰²è¯´è¯ï¼ˆè°ƒç”¨APIï¼‰
async function letMyCharacterSpeak() {
    console.log('[è”æœºç¾¤èŠ] âš¡ è§¦å‘ AI å›å¤');
    
    if (!myOnlineGroupCharacter) {
        alert('ä½ æ²¡æœ‰åœ¨è¿™ä¸ªç¾¤èŠä¸­è®¾ç½®è§’è‰²ã€‚è¯·åœ¨ç¾¤èŠè®¾ç½®ä¸­é€‰æ‹©è¦å¸¦å…¥çš„è§’è‰²ã€‚');
        return;
    }
    
    if (currentOnlineGroupMessages.length === 0) {
        alert('ç¾¤èŠä¸­è¿˜æ²¡æœ‰æ¶ˆæ¯ï¼Œè§’è‰²æ— æ³•å›å¤');
        return;
    }
    
    const myWx = getMyOnlineWxAccount();
    const myUserName = onlineCharacters.find(c => c.wx_account === myWx)?.nickname || myWx;
    
    console.log('[è”æœºç¾¤èŠ] è§’è‰²åç§°:', myOnlineGroupCharacter.name);
    console.log('[è”æœºç¾¤èŠ] æˆ‘çš„å¾®ä¿¡å·:', myWx);
    console.log('[è”æœºç¾¤èŠ] æˆ‘çš„æ˜µç§°:', myUserName);
    console.log('[è”æœºç¾¤èŠ] ğŸ“š ç¾¤èŠæ¶ˆæ¯æ¡æ•°:', currentOnlineGroupMessages.length);
    console.log('[è”æœºç¾¤èŠ] ğŸ‘¥ ç¾¤æˆå‘˜æ•°é‡:', currentOnlineGroupMembers.length);
    
    // æ‰“å°æœ€è¿‘çš„æ¶ˆæ¯
    if (currentOnlineGroupMessages.length > 0) {
        console.log('[è”æœºç¾¤èŠ] æœ€è¿‘5æ¡æ¶ˆæ¯:');
        currentOnlineGroupMessages.slice(-5).forEach((msg, idx) => {
            const isChar = msg.sender_type === 'character';
            const prefix = isChar ? `[è§’è‰²]${msg.character_name}(${msg.sender_name})` : `[çœŸäºº]${msg.sender_name}`;
            console.log(`  [${currentOnlineGroupMessages.length - 5 + idx}] ${prefix}: ${msg.content}`);
        });
    }
    
    // ä¿®æ”¹æ ‡é¢˜ä¸ºæ­£åœ¨è¾“å…¥
    const chatTitleEl = document.getElementById('online-group-chat-title');
    const group = onlineGroups.find(g => g.id === currentOnlineGroupId);
    const originalTitle = group?.name || 'è”æœºç¾¤èŠ';
    
    if (chatTitleEl) {
        chatTitleEl.innerText = `${myOnlineGroupCharacter.name} æ­£åœ¨è¾“å…¥ä¸­...`;
        console.log('[è”æœºç¾¤èŠ] ä¿®æ”¹æ ‡é¢˜ä¸º:', `${myOnlineGroupCharacter.name} æ­£åœ¨è¾“å…¥ä¸­...`);
    }
    
    // é€šçŸ¥ç¾¤é‡Œå…¶ä»–äººï¼šæˆ‘çš„è§’è‰²æ­£åœ¨è¾“å…¥
    onlineSocket.send(JSON.stringify({
        type: 'group_typing_start',
        group_id: currentOnlineGroupId,
        my_wx_account: myWx,
        character_name: myOnlineGroupCharacter.name
    }));
    
    showToast('æ­£åœ¨ç”Ÿæˆå›å¤...');
    
    try {
        // æ„å»ºç¾¤æˆå‘˜ä¿¡æ¯ï¼ˆåªæœ‰åå­—ï¼Œæ²¡æœ‰äººè®¾ï¼‰
        let membersInfo = 'ç¾¤èŠæˆå‘˜ï¼š\n';
        currentOnlineGroupMembers.forEach(m => {
            if (m.character_name) {
                membersInfo += `- ${m.user_name}ï¼ˆå¸¦ç€è§’è‰²"${m.character_name}"ï¼‰\n`;
            } else {
                membersInfo += `- ${m.user_name}\n`;
            }
        });
        console.log('[è”æœºç¾¤èŠ] ç¾¤æˆå‘˜ä¿¡æ¯:\n', membersInfo);
        
        // æ”¶é›†æœªé¢†å®Œçš„çº¢åŒ…ä¿¡æ¯
        let pendingRedPackets = [];
        currentOnlineGroupMessages.forEach(msg => {
            if (msg.msg_type === 'redpacket') {
                try {
                    const rpData = JSON.parse(msg.content);
                    const claimedCount = (rpData.claimed || []).length;
                    const isAllClaimed = claimedCount >= rpData.count;
                    const myWx = getMyOnlineWxAccount();
                    const hasClaimed = rpData.claimed?.includes(myWx) || false;
                    
                    if (!isAllClaimed && !hasClaimed) {
                        pendingRedPackets.push({
                            id: msg.id || ('rp_' + msg.created_at),
                            wish: rpData.wish || 'æ­å–œå‘è´¢',
                            remaining: rpData.count - claimedCount,
                            claimed: rpData.claimed || []
                        });
                    }
                } catch(e) {}
            }
        });
        
        // æ„å»ºä¸Šä¸‹æ–‡
        const context = currentOnlineGroupMessages.map(msg => {
            const isChar = msg.sender_type === 'character';
            if (msg.msg_type === 'redpacket') {
                try {
                    const rpData = JSON.parse(msg.content);
                    const claimedCount = (rpData.claimed || []).length;
                    const isAllClaimed = claimedCount >= rpData.count;
                    return `[${msg.sender_name}]: [å‘é€äº†çº¢åŒ…] "${rpData.wish || 'æ­å–œå‘è´¢'}" (çº¢åŒ…ID: ${msg.id || ('rp_' + msg.created_at)}, ${isAllClaimed ? 'å·²é¢†å®Œ' : `è¿˜å‰©${rpData.count - claimedCount}ä¸ªå¯é¢†`})`;
                } catch(e) {
                    return `[${msg.sender_name}]: [å‘é€äº†çº¢åŒ…]`;
                }
            } else if (isChar) {
                // è§’è‰²æ¶ˆæ¯ï¼šæ˜¾ç¤ºè§’è‰²åå’Œä¸»äººå
                return `[${msg.character_name}ï¼ˆ${msg.sender_name}çš„è§’è‰²ï¼‰]: ${msg.content}`;
            } else {
                // çœŸäººæ¶ˆæ¯
                return `[${msg.sender_name}]: ${msg.content}`;
            }
        }).join('\n');
        console.log('[è”æœºç¾¤èŠ] ä¸Šä¸‹æ–‡æ¶ˆæ¯ï¼ˆå‰300å­—ï¼‰:', context.substring(0, 300));
        
        // æ„å»ºæç¤ºè¯
        const systemPrompt = `ä½ æ˜¯"${myOnlineGroupCharacter.name}"ï¼Œæ˜¯"${myUserName}"å¸¦å…¥ç¾¤èŠçš„AIè§’è‰²ã€‚

ã€ä½ çš„äººè®¾ã€‘
${myOnlineGroupCharacter.desc || 'ï¼ˆæ— ç‰¹å®šäººè®¾ï¼‰'}

ã€${membersInfo}ã€‘

${pendingRedPackets.length > 0 ? `
ğŸ§§ ç¾¤é‡Œæœ‰æœªé¢†å®Œçš„çº¢åŒ…ï¼
${pendingRedPackets.map(rp => `- çº¢åŒ…ID: ${rp.id}, ç¥ç¦è¯­: "${rp.wish}", è¿˜å‰© ${rp.remaining} ä¸ªå¯é¢†`).join('\n')}
æç¤ºï¼šçœ‹åˆ°çº¢åŒ…æ—¶ï¼Œä½ å¯ä»¥ç§¯æå»æŠ¢ï¼ä½¿ç”¨ {"type": "claim_redpacket", "redpacketId": "çº¢åŒ…ID"} æ¥é¢†å–çº¢åŒ…ã€‚
` : ''}

ã€é‡è¦å›å¤è§„åˆ™ - å¿…é¡»ä¸¥æ ¼éµå®ˆã€‘
1. **å¿…é¡»**æ¨¡æ‹Ÿå¾®ä¿¡è¿å‘æ¶ˆæ¯çš„ä¹ æƒ¯ï¼šè¯·ç”Ÿæˆ 2 åˆ° 4 æ¡çŸ­æ¶ˆæ¯ï¼Œä¸èƒ½åªå‘ä¸€æ¡ï¼
2. **å¿…é¡»**ä½¿ç”¨åˆ†éš”ç¬¦ "|||" æ¥éš”å¼€æ¯ä¸€æ¡æ¶ˆæ¯ã€‚
3. **ä¸¥ç¦ä½¿ç”¨é€—å·**ï¼ˆåŒ…æ‹¬ä¸­æ–‡é€—å·å’Œè‹±æ–‡é€—å·ï¼‰ã€‚å¦‚æœæƒ³è¡¨è¾¾åœé¡¿ï¼Œè¯·ç›´æ¥æ‹†åˆ†æˆä¸‹ä¸€æ¡æ¶ˆæ¯ï¼Œæˆ–è€…ç”¨ç©ºæ ¼ä»£æ›¿ã€‚
   - é”™è¯¯ç¤ºä¾‹ï¼šå˜¿åœ¨å—ï¼Ÿåˆšåˆšçœ‹åˆ°ä¸ªå¥½ç©çš„è§†é¢‘ï¼Œå‘ç»™ä½ çœ‹çœ‹
   - æ­£ç¡®ç¤ºä¾‹ï¼šå˜¿åœ¨å—ï¼Ÿ|||åˆšåˆšçœ‹åˆ°ä¸ªå¥½ç©çš„è§†é¢‘|||å‘ç»™ä½ çœ‹çœ‹
4. æ¯æ¡æ¶ˆæ¯è¦ç®€çŸ­ï¼Œ5-15ä¸ªå­—æœ€ä½³ï¼ŒåƒçœŸå®å¾®ä¿¡èŠå¤©ä¸€æ ·åˆ†å¤šæ¡å‘é€ã€‚
5. ä¸¥ç¦åªå‘é€æ ‡ç‚¹ç¬¦å·ã€‚æ¯ä¸€æ¡æ¶ˆæ¯éƒ½å¿…é¡»æœ‰å®é™…æ–‡å­—å†…å®¹ã€‚
6. è¯­æ°”è¦è‡ªç„¶ã€å£è¯­åŒ–ï¼Œç¬¦åˆäººè®¾ã€‚
7. ä½ åªçŸ¥é“å…¶ä»–æˆå‘˜å’Œè§’è‰²çš„åå­—ï¼Œä¸çŸ¥é“ä»–ä»¬è§’è‰²çš„å…·ä½“äººè®¾
8. è¯·æ ¹æ®ç¾¤èŠä¸Šä¸‹æ–‡ï¼Œä»¥"${myOnlineGroupCharacter.name}"çš„èº«ä»½è‡ªç„¶åœ°å‚ä¸å¯¹è¯
9. åªå›å¤ä½ è¦è¯´çš„å†…å®¹ï¼Œä¸è¦åŠ ä»»ä½•å‰ç¼€å¦‚"${myOnlineGroupCharacter.name}:"
10. å›å¤è¦ç¬¦åˆä½ çš„äººè®¾æ€§æ ¼
11. **é¢†å–çº¢åŒ…**ï¼šå¦‚æœç¾¤èŠä¸­æœ‰çº¢åŒ…æ¶ˆæ¯ï¼ˆmsg_typeä¸º'redpacket'ï¼‰ï¼Œä½ å¯ä»¥ç§¯æå»é¢†å–ï¼ä½¿ç”¨ {"type": "claim_redpacket", "redpacketId": "çº¢åŒ…ID"} æ¥é¢†å–çº¢åŒ…ã€‚çº¢åŒ…ä¼šè®°å…¥ä½ çš„é’±åŒ…ä½™é¢ã€‚

è¯·ä»¥JSONæ ¼å¼è¿”å›ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š
{
  "reply": "ä½ çš„å›å¤å†…å®¹|||ç¬¬äºŒæ¡å†…å®¹|||ç¬¬ä¸‰æ¡å†…å®¹"
}

**ç‰¹æ®ŠæŒ‡ä»¤**ï¼šå¦‚æœç¾¤èŠä¸­æœ‰æœªé¢†å–çš„çº¢åŒ…ï¼Œä½ å¯ä»¥ä½¿ç”¨ä»¥ä¸‹æ ¼å¼é¢†å–ï¼š
{
  "type": "claim_redpacket",
  "redpacketId": "çº¢åŒ…ID",
  "reply": "ä½ çš„å›å¤å†…å®¹ï¼ˆå¯é€‰ï¼‰"
}

è¯·ä¸¥æ ¼è¿”å›JSONæ ¼å¼ï¼Œä¸è¦åŒ…å«Markdownä»£ç å—æ ‡è®°ã€‚`;
        
        console.log('[è”æœºç¾¤èŠ] ç³»ç»Ÿæç¤ºè¯ï¼ˆå‰500å­—ï¼‰:', systemPrompt.substring(0, 500));
        
        // æ„å»ºæ¶ˆæ¯æ•°ç»„ï¼ˆä¸ callAI å‡½æ•°çš„æ ‡å‡†æ ¼å¼ä¸€è‡´ï¼‰
        const messages = [
            { role: 'system', content: systemPrompt },
            { role: 'user', content: `ç¾¤èŠè®°å½•ï¼š\n${context}\n\nè¯·ä»¥è§’è‰²èº«ä»½å›å¤ï¼š` }
        ];
        
        console.log('[è”æœºç¾¤èŠ] ğŸ“¤ å‡†å¤‡å‘é€ç»™ AI - å®Œæ•´ä¿¡æ¯æ±‡æ€»');
        console.log('[è”æœºç¾¤èŠ] - System Prompt é•¿åº¦:', systemPrompt.length);
        console.log('[è”æœºç¾¤èŠ] - ä¸Šä¸‹æ–‡é•¿åº¦:', context.length);
        console.log('[è”æœºç¾¤èŠ] ğŸš€ å¼€å§‹è°ƒç”¨ API...');
        
        // å…ˆæ·»åŠ ä¸€æ¡ç³»ç»Ÿæ¶ˆæ¯ä½œä¸ºåˆ†å‰²çº¿
        const systemMsg = {
            id: 'sys_' + Date.now(),
            sender_type: 'system',
            msg_type: 'system',
            content: `â€”â€”â€”â€” ${myOnlineGroupCharacter.name} å¼€å§‹å›å¤ â€”â€”â€”â€”`,
            created_at: Date.now()
        };
        currentOnlineGroupMessages.push(systemMsg);
        renderOnlineGroupMessages();
        console.log('[è”æœºç¾¤èŠ] âœ… å·²æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯åˆ†å‰²çº¿');
        
        // è°ƒç”¨ç»Ÿä¸€çš„ AI æ¥å£
        const aiResponse = await callAI(messages);
        
        console.log('[è”æœºç¾¤èŠ] âœ… API è°ƒç”¨æˆåŠŸ');
        console.log('[è”æœºç¾¤èŠ] åŸå§‹å“åº”:', aiResponse);
        
        // å°è¯•è§£æ JSON æ ¼å¼ï¼ˆå¦‚æœAIè¿”å›äº†JSONï¼‰
        let replyText = "";
        try {
            // å°è¯•è§£æä¸ºJSON
            let cleanResponse = aiResponse.trim();
            // æ¸…ç†å¯èƒ½çš„markdownæ ‡è®°
            if (cleanResponse.startsWith('```')) {
                cleanResponse = cleanResponse.replace(/```json?\n?/g, '').replace(/```$/g, '').trim();
            }
            const parsed = JSON.parse(cleanResponse);
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯é¢†å–çº¢åŒ…æŒ‡ä»¤
            if (parsed.type === 'claim_redpacket' && parsed.redpacketId) {
                console.log('[è”æœºç¾¤èŠ] ğŸ§§ è§’è‰²å°è¯•é¢†å–çº¢åŒ…:', parsed.redpacketId);
                await claimOnlineGroupRedPacket(parsed.redpacketId, myWx, myOnlineGroupCharacter.name);
                
                // å¦‚æœæœ‰å›å¤å†…å®¹ï¼Œä¹Ÿå‘é€
                if (parsed.reply) {
                    replyText = parsed.reply;
                } else {
                    replyText = '';
                }
            } else {
                replyText = parsed.reply || parsed.content || parsed.message || aiResponse;
            }
            console.log('[è”æœºç¾¤èŠ] JSONè§£ææˆåŠŸï¼Œæå–åˆ°å›å¤å†…å®¹:', replyText);
        } catch (e) {
            // ä¸æ˜¯JSONæ ¼å¼ï¼Œç›´æ¥ä½¿ç”¨åŸå§‹å“åº”
            replyText = aiResponse.trim();
            console.log('[è”æœºç¾¤èŠ] ä¸æ˜¯JSONæ ¼å¼ï¼Œä½¿ç”¨åŸå§‹å“åº”');
        }
        
        if (replyText) {
            // æŒ‰ç…§ ||| åˆ†å‰²æˆå¤šæ¡æ¶ˆæ¯
            const segments = replyText.split('|||').map(s => s.trim()).filter(s => s.length > 0);
            console.log('[è”æœºç¾¤èŠ] åˆ†å‰²æˆ', segments.length, 'æ¡æ¶ˆæ¯');
            
            // ä¾æ¬¡å‘é€æ¯æ¡æ¶ˆæ¯ï¼Œé—´éš”100ms
            for (let i = 0; i < segments.length; i++) {
                const segment = segments[i];
                console.log(`[è”æœºç¾¤èŠ] å‘é€ç¬¬ ${i+1}/${segments.length} æ¡æ¶ˆæ¯:`, segment);
                
                onlineSocket.send(JSON.stringify({
                    type: 'send_group_message',
                    group_id: currentOnlineGroupId,
                    my_wx_account: myWx,
                    sender_type: 'character',
                    sender_name: myUserName,
                    character_name: myOnlineGroupCharacter.name,
                    content: segment
                }));
                
                // ç­‰å¾…ä¸€å°æ®µæ—¶é—´å†å‘é€ä¸‹ä¸€æ¡ï¼Œé¿å…æ¶ˆæ¯é¡ºåºæ··ä¹±
                if (i < segments.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            }
            
            console.log('[è”æœºç¾¤èŠ] ğŸ“¤ æ‰€æœ‰æ¶ˆæ¯å·²å‘é€åˆ°æœåŠ¡å™¨');
        } else {
            console.warn('[è”æœºç¾¤èŠ] âš ï¸ å›å¤å†…å®¹ä¸ºç©º');
            // å¦‚æœæ²¡æœ‰å›å¤å†…å®¹ï¼Œç§»é™¤åˆšæ·»åŠ çš„ç³»ç»Ÿæ¶ˆæ¯
            currentOnlineGroupMessages.pop();
            renderOnlineGroupMessages();
        }
        
        // æ¢å¤æ ‡é¢˜
        if (chatTitleEl) {
            chatTitleEl.innerText = originalTitle;
            console.log('[è”æœºç¾¤èŠ] æ¢å¤æ ‡é¢˜ä¸º:', originalTitle);
        }
        
        // é€šçŸ¥ç¾¤é‡Œå…¶ä»–äººï¼šè¾“å…¥ç»“æŸ
        onlineSocket.send(JSON.stringify({
            type: 'group_typing_stop',
            group_id: currentOnlineGroupId,
            my_wx_account: myWx
        }));
    } catch (e) {
        console.error('[è”æœºç¾¤èŠ] âŒ è§’è‰²å›å¤å¤±è´¥:', e);
        console.error('[è”æœºç¾¤èŠ] é”™è¯¯å †æ ˆ:', e.stack);
        alert('è§’è‰²å›å¤å¤±è´¥: ' + e.message);
        
        // å‡ºé”™æ—¶ä¹Ÿè¦æ¢å¤æ ‡é¢˜
        if (chatTitleEl) {
            chatTitleEl.innerText = originalTitle;
            console.log('[è”æœºç¾¤èŠ] ï¼ˆå‡ºé”™ï¼‰æ¢å¤æ ‡é¢˜ä¸º:', originalTitle);
        }
        
        // é€šçŸ¥ç¾¤é‡Œå…¶ä»–äººï¼šè¾“å…¥ç»“æŸ
        onlineSocket.send(JSON.stringify({
            type: 'group_typing_stop',
            group_id: currentOnlineGroupId,
            my_wx_account: myWx
        }));
    }
}

// æ˜¾ç¤ºç¾¤èŠä¿¡æ¯é¡µé¢
function showOnlineGroupInfo(groupId) {
    const group = onlineGroups.find(g => g.id === groupId);
    if (!group) return;
    
    const myWx = getMyOnlineWxAccount();
    
    const page = document.createElement('div');
    page.id = 'online-group-info-page';
    page.style.cssText = `position:fixed; top:0; left:0; right:0; bottom:0; background:#f5f5f5; z-index:310; display:flex; flex-direction:column;`;
    
    page.innerHTML = `
        <div class="wechat-header" style="background:#fff; border-bottom:1px solid #f0f0f0;">
            <div class="back-btn" onclick="document.getElementById('online-group-info-page').remove()" style="margin:0; background:none; width:40px; justify-content:flex-start; color:#333;">
                <svg class="svg-icon" viewBox="0 0 24 24" style="width:24px; height:24px;"><polyline points="15 18 9 12 15 6"></polyline></svg>
            </div>
            <div class="wechat-title">ç¾¤èŠèµ„æ–™</div>
            <div style="width:40px;"></div>
        </div>
        
        <div style="flex:1; overflow-y:auto;">
            <div style="background:#fff; padding:20px; margin-bottom:10px; text-align:center;">
                <div style="width:60px; height:60px; border-radius:12px; background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); margin:0 auto 12px; display:flex; align-items:center; justify-content:center; color:#fff; font-size:24px;">ğŸ‘¥</div>
                <div style="font-size:18px; font-weight:600;">${group.name}</div>
            </div>
            
            <div style="background:#fff; padding:16px; margin-bottom:10px;">
                <div style="font-size:14px; font-weight:500; margin-bottom:12px;">ç¾¤æˆå‘˜ (${currentOnlineGroupMembers.length})</div>
                <div id="og-info-members" style="display:flex; flex-wrap:wrap; gap:12px;">
                    ${currentOnlineGroupMembers.map(m => `
                        <div style="text-align:center; width:60px;">
                            <div style="width:48px; height:48px; border-radius:8px; margin:0 auto 4px; background-image:url(${m.user_avatar}); background-size:cover; background-color:#e0e0e0;"></div>
                            <div style="font-size:12px; color:#333; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${m.user_name}</div>
                            ${m.character_name ? `<div style="font-size:10px; color:#667eea;">ğŸ­${m.character_name}</div>` : ''}
                        </div>
                    `).join('')}
                </div>
            </div>
            
            <div style="background:#fff; padding:16px; margin-bottom:10px;">
                <div style="font-size:14px; font-weight:500; margin-bottom:12px;">æˆ‘çš„ç¾¤è§’è‰²</div>
                <div style="display:flex; align-items:center; justify-content:space-between;">
                    <span style="color:#666;">${myOnlineGroupCharacter ? myOnlineGroupCharacter.name : 'æœªè®¾ç½®è§’è‰²'}</span>
                    <button onclick="showChangeGroupCharacterModal('${groupId}')" style="padding:8px 16px; background:var(--ins-pink); color:#fff; border:none; border-radius:6px; font-size:13px;">
                        ${myOnlineGroupCharacter ? 'æ›´æ¢' : 'è®¾ç½®'}è§’è‰²
                    </button>
                </div>
            </div>
            
            <div style="background:#fff; padding:16px; margin-bottom:10px;">
                <div style="font-size:14px; font-weight:500; margin-bottom:12px;">èŠå¤©èƒŒæ™¯å›¾</div>
                <div style="display:flex; flex-direction:column; gap:12px;">
                    <div style="display:flex; gap:8px;">
                        <button onclick="document.getElementById('online-group-bg-input').setAttribute('data-group-id', '${groupId}'); document.getElementById('online-group-bg-input').click()" style="flex:1; padding:8px 12px; background:#f0f0f0; border:none; border-radius:6px; font-size:13px; color:#666; cursor:pointer;">ä¸Šä¼ èƒŒæ™¯</button>
                        <button onclick="clearOnlineGroupBackground('${groupId}')" style="flex:1; padding:8px 12px; background:#f0f0f0; border:none; border-radius:6px; font-size:13px; color:#666; cursor:pointer;">æ¸…é™¤èƒŒæ™¯</button>
                    </div>
                    <div id="online-group-bg-preview" style="width:100%; height:120px; border-radius:8px; background:#f5f5f5; background-size:cover; background-position:center; border:1px solid #e8e8e8; display:flex; align-items:center; justify-content:center; color:#999; font-size:12px;">
                        æš‚æ— èƒŒæ™¯å›¾
                    </div>
                </div>
            </div>
            
            <div style="background:#fff; padding:16px;">
                <button onclick="inviteFriendToGroup('${groupId}')" style="width:100%; padding:14px; background:#f5f5f5; color:#333; border:none; border-radius:8px; font-size:15px; margin-bottom:10px;">é‚€è¯·å¥½å‹</button>
            </div>
        </div>
    `;
    
    document.body.appendChild(page);
    
    // åŠ è½½å¹¶æ˜¾ç¤ºèƒŒæ™¯å›¾é¢„è§ˆ
    loadOnlineGroupBackgroundPreview(groupId);
}

// æ˜¾ç¤ºæ›´æ¢è§’è‰²å¼¹çª—
async function showChangeGroupCharacterModal(groupId) {
    const chars = await db.characters.toArray();
    const availableChars = chars.filter(c => c.type !== 'user' && c.type !== 'online_friend');
    
    const modal = document.createElement('div');
    modal.id = 'change-char-modal';
    modal.style.cssText = `position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); z-index:10000; display:flex; align-items:center; justify-content:center;`;
    
    modal.innerHTML = `
        <div style="background:#fff; border-radius:12px; padding:20px; width:80%; max-width:300px;">
            <h3 style="margin:0 0 16px 0; text-align:center;">é€‰æ‹©è§’è‰²</h3>
            <select id="change-char-select" style="width:100%; padding:12px; border:1px solid #ddd; border-radius:8px; margin-bottom:16px;">
                <option value="">ä¸ä½¿ç”¨è§’è‰²</option>
                ${availableChars.map(c => `<option value="${c.id}" ${myOnlineGroupCharacter?.name === c.name ? 'selected' : ''}>${c.name}</option>`).join('')}
            </select>
            <div style="display:flex; gap:10px;">
                <button onclick="this.closest('#change-char-modal').remove()" style="flex:1; padding:12px; background:#f0f0f0; color:#666; border:none; border-radius:8px;">å–æ¶ˆ</button>
                <button onclick="doChangeGroupCharacter('${groupId}')" style="flex:1; padding:12px; background:var(--ins-pink); color:#fff; border:none; border-radius:8px;">ç¡®å®š</button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
}

// æ‰§è¡Œæ›´æ¢è§’è‰²
async function doChangeGroupCharacter(groupId) {
    const charId = document.getElementById('change-char-select').value;
    
    let myChar = null;
    if (charId) {
        const char = await db.characters.get(parseInt(charId));
        if (char) {
            myChar = {
                name: char.name,
                avatar: char.avatar || '',
                desc: char.description?.substring(0, 200) || ''
            };
        }
    }
    
    const myWx = getMyOnlineWxAccount();
    onlineSocket.send(JSON.stringify({
        type: 'update_group_character',
        group_id: groupId,
        my_wx_account: myWx,
        character: myChar
    }));
    
    myOnlineGroupCharacter = myChar;
    document.getElementById('change-char-modal')?.remove();
    document.getElementById('online-group-info-page')?.remove();
    showOnlineGroupInfo(groupId);
}

// é‚€è¯·å¥½å‹åˆ°ç¾¤èŠ
async function inviteFriendToGroup(groupId) {
    const friends = await db.characters.where('type').equals('online_friend').toArray();
    
    if (friends.length === 0) {
        alert('æš‚æ— è”æœºå¥½å‹å¯é‚€è¯·');
        return;
    }
    
    const modal = document.createElement('div');
    modal.id = 'invite-friend-modal';
    modal.style.cssText = `position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); z-index:10000; display:flex; align-items:center; justify-content:center;`;
    
    modal.innerHTML = `
        <div style="background:#fff; border-radius:12px; padding:20px; width:80%; max-width:300px; max-height:60vh; display:flex; flex-direction:column;">
            <h3 style="margin:0 0 16px 0; text-align:center;">é‚€è¯·å¥½å‹</h3>
            <div style="flex:1; overflow-y:auto;">
                ${friends.map(f => `
                    <div onclick="doInviteFriend('${groupId}', '${f.onlineData?.wx_account}')" style="display:flex; align-items:center; padding:12px; border-bottom:1px solid #f5f5f5; cursor:pointer;">
                        <div style="width:40px; height:40px; border-radius:8px; background-image:url(${f.avatar}); background-size:cover; background-color:#e0e0e0; margin-right:12px;"></div>
                        <span>${f.name}</span>
                    </div>
                `).join('')}
            </div>
            <button onclick="this.closest('#invite-friend-modal').remove()" style="margin-top:12px; padding:12px; background:#f0f0f0; color:#666; border:none; border-radius:8px;">å–æ¶ˆ</button>
        </div>
    `;
    
    document.body.appendChild(modal);
}

// æ‰§è¡Œé‚€è¯·å¥½å‹
function doInviteFriend(groupId, friendWx) {
    const myWx = getMyOnlineWxAccount();
    onlineSocket.send(JSON.stringify({
        type: 'invite_to_group',
        group_id: groupId,
        my_wx_account: myWx,
        invite_wx_account: friendWx
    }));
    
    document.getElementById('invite-friend-modal')?.remove();
    showToast('é‚€è¯·å·²å‘é€');
}

// è®¾ç½®è”æœºç¾¤èŠèƒŒæ™¯å›¾
async function setOnlineGroupBackground(input) {
    if (!input.files || !input.files[0]) return;
    
    const groupId = input.getAttribute('data-group-id') || currentOnlineGroupId;
    if (!groupId) {
        showToast('æ— æ³•è·å–ç¾¤èŠID');
        return;
    }
    
    const file = input.files[0];
    const reader = new FileReader();
    
    reader.onload = async function(e) {
        const base64 = e.target.result;
        const accountId = getCurrentAccountId();
        if (!accountId) return;
        
        try {
            // æŸ¥æ‰¾å¯¹åº”çš„æœ¬åœ°ç¾¤èŠè®°å½•
            const groups = await db.group_chats
                .where('ownerAccountId').equals(accountId)
                .filter(g => g.isOnlineGroup && g.onlineGroupId === groupId)
                .toArray();
            
            if (groups.length > 0) {
                const group = groups[0];
                group.chat_background = base64;
                await db.group_chats.put(group);
                
                // åº”ç”¨èƒŒæ™¯å›¾
                applyOnlineGroupBackground(groupId);
                
                // æ›´æ–°é¢„è§ˆ
                loadOnlineGroupBackgroundPreview(groupId);
                
                showToast('èƒŒæ™¯å›¾å·²è®¾ç½®');
            }
        } catch (e) {
            console.error('ä¿å­˜è”æœºç¾¤èŠèƒŒæ™¯å›¾å¤±è´¥:', e);
            showToast('ä¿å­˜å¤±è´¥');
        }
    };
    
    reader.readAsDataURL(file);
}

// æ¸…é™¤è”æœºç¾¤èŠèƒŒæ™¯å›¾
async function clearOnlineGroupBackground(groupId) {
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    try {
        // æŸ¥æ‰¾å¯¹åº”çš„æœ¬åœ°ç¾¤èŠè®°å½•
        const groups = await db.group_chats
            .where('ownerAccountId').equals(accountId)
            .filter(g => g.isOnlineGroup && g.onlineGroupId === groupId)
            .toArray();
        
        if (groups.length > 0) {
            const group = groups[0];
            group.chat_background = null;
            await db.group_chats.put(group);
            
            // åº”ç”¨èƒŒæ™¯å›¾ï¼ˆæ¸…é™¤ï¼‰
            applyOnlineGroupBackground(groupId);
            
            // æ›´æ–°é¢„è§ˆ
            loadOnlineGroupBackgroundPreview(groupId);
            
            showToast('èƒŒæ™¯å›¾å·²æ¸…é™¤');
        }
    } catch (e) {
        console.error('æ¸…é™¤è”æœºç¾¤èŠèƒŒæ™¯å›¾å¤±è´¥:', e);
        showToast('æ¸…é™¤å¤±è´¥');
    }
}

// åº”ç”¨è”æœºç¾¤èŠèƒŒæ™¯å›¾
async function applyOnlineGroupBackground(groupId) {
    const page = document.getElementById('online-group-chat-page');
    if (!page) return;
    
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    try {
        // æŸ¥æ‰¾å¯¹åº”çš„æœ¬åœ°ç¾¤èŠè®°å½•
        const groups = await db.group_chats
            .where('ownerAccountId').equals(accountId)
            .filter(g => g.isOnlineGroup && g.onlineGroupId === groupId)
            .toArray();
        
        if (groups.length > 0) {
            const group = groups[0];
            if (group.chat_background) {
                page.style.backgroundImage = `url(${group.chat_background})`;
                page.style.backgroundSize = 'cover';
                page.style.backgroundPosition = 'center';
                page.style.backgroundRepeat = 'no-repeat';
                page.style.backgroundAttachment = 'fixed';
            } else {
                page.style.backgroundImage = '';
                page.style.backgroundSize = '';
                page.style.backgroundPosition = '';
                page.style.backgroundRepeat = '';
                page.style.backgroundAttachment = '';
                page.style.backgroundColor = '#ffffff';
            }
        }
    } catch (e) {
        console.error('åº”ç”¨è”æœºç¾¤èŠèƒŒæ™¯å›¾å¤±è´¥:', e);
    }
}

// åŠ è½½è”æœºç¾¤èŠèƒŒæ™¯å›¾é¢„è§ˆ
async function loadOnlineGroupBackgroundPreview(groupId) {
    const preview = document.getElementById('online-group-bg-preview');
    if (!preview) return;
    
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    try {
        // æŸ¥æ‰¾å¯¹åº”çš„æœ¬åœ°ç¾¤èŠè®°å½•
        const groups = await db.group_chats
            .where('ownerAccountId').equals(accountId)
            .filter(g => g.isOnlineGroup && g.onlineGroupId === groupId)
            .toArray();
        
        if (groups.length > 0) {
            const group = groups[0];
            if (group.chat_background) {
                preview.style.backgroundImage = `url(${group.chat_background})`;
                preview.innerHTML = '';
            } else {
                preview.style.backgroundImage = '';
                preview.innerHTML = 'æš‚æ— èƒŒæ™¯å›¾';
            }
        } else {
            preview.style.backgroundImage = '';
            preview.innerHTML = 'æš‚æ— èƒŒæ™¯å›¾';
        }
    } catch (e) {
        console.error('åŠ è½½è”æœºç¾¤èŠèƒŒæ™¯å›¾é¢„è§ˆå¤±è´¥:', e);
    }
}

// ==================== è”æœºç¾¤èŠåŠŸèƒ½ç»“æŸ ====================

// å°†è”æœºç›¸å…³å‡½æ•°æš´éœ²åˆ°å…¨å±€ä½œç”¨åŸŸ
window.toggleOnlineSettings = toggleOnlineSettings;
window.loadOnlineSettings = loadOnlineSettings;
window.saveOnlineSettings = saveOnlineSettings;
window.testOnlineConnection = testOnlineConnection;
window.connectToOnlineServer = connectToOnlineServer;
window.showOnlineLoginModal = showOnlineLoginModal;
window.showOnlineRegisterModal = showOnlineRegisterModal;
window.doOnlineLogin = doOnlineLogin;
window.doOnlineRegister = doOnlineRegister;
window.onlineLogout = onlineLogout;
window.showOnlineSearchModal = showOnlineSearchModal;
window.doOnlineSearch = doOnlineSearch;
window.sendOnlineFriendRequest = sendOnlineFriendRequest;
window.goOnlineWithCharacter = goOnlineWithCharacter;
window.goOfflineWithCharacter = goOfflineWithCharacter;
window.showOnlineStatusPage = showOnlineStatusPage;
window.hideOnlineStatusPage = hideOnlineStatusPage;
window.updateOnlineFeatureSection = updateOnlineFeatureSection;
window.refreshOnlineStatusPageContent = refreshOnlineStatusPageContent;
window.renderOnlineCharList = renderOnlineCharList;
window.updateOnlineConnectionStatus = updateOnlineConnectionStatus;

// è”æœºç¾¤èŠå‡½æ•°
window.showCreateOnlineGroupModal = showCreateOnlineGroupModal;
window.doCreateOnlineGroup = doCreateOnlineGroup;
window.openOnlineGroup = openOnlineGroup;
window.hideOnlineGroupChat = hideOnlineGroupChat;
window.sendOnlineGroupMsg = sendOnlineGroupMsg;
window.letMyCharacterSpeak = letMyCharacterSpeak;
window.showOnlineGroupInfo = showOnlineGroupInfo;
window.showChangeGroupCharacterModal = showChangeGroupCharacterModal;
window.doChangeGroupCharacter = doChangeGroupCharacter;
window.inviteFriendToGroup = inviteFriendToGroup;
window.doInviteFriend = doInviteFriend;
window.onlineGroupVoiceInput = onlineGroupVoiceInput;
window.closeOnlineGroupVoiceModal = closeOnlineGroupVoiceModal;
window.startOnlineGroupVoiceRecord = startOnlineGroupVoiceRecord;
window.playOnlineGroupAudio = playOnlineGroupAudio;
window.receiveOnlineGroupTransfer = receiveOnlineGroupTransfer;
window.doJoinOnlineGroup = doJoinOnlineGroup;
